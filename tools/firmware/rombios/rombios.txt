00001                                           ! 1 
00002                                           ! 1 # 1 "_rombios_.c"
00003                                           ! 1 struct rombios_info {
00004                                           ! 2     unsigned long bios32_entry;
00005                                           !BCC_EOS
00006                                           ! 3 };
00007                                           !BCC_EOS
00008                                           ! 4 #asm
00009                                           !BCC_ASM
00010 0000                                      .rom
00011 0000                                      .org 0x0000
00012                                           use16 386
00013                                           MACRO HALT
00014                                             ;; the HALT macro is called with the line number of the HALT call.
00015                                             ;; The line number is then sent to the 0x400, causing Bochs/Plex
00016                                             ;; to print a BX_PANIC message. This will normally halt the simulation
00017                                             ;; with a message such as "BIOS panic at rombios.c, line 4091".
00018                                             ;; However, users can choose to make panics non-fatal and continue.
00019                                             mov dx,#0x400
00020                                             mov ax,#?1
00021                                             out dx,ax
00022                                           MEND
00023                                           MACRO JMP_AP
00024                                             db 0xea
00025                                             dw ?2
00026                                             dw ?1
00027                                           MEND
00028                                           MACRO SET_INT_VECTOR
00029                                             mov ax, ?3
00030                                             mov ?1*4, ax
00031                                             mov ax, ?2
00032                                             mov ?1*4+2, ax
00033                                           MEND
00034                                           ! 29 endasm
00035                                           !BCC_ENDASM
00036                                           ! 30 typedef unsigned char Bit8u;
00037                                           !BCC_EOS
00038                                           ! 31 typedef unsigned short Bit16u;
00039                                           !BCC_EOS
00040                                           ! 32 typedef unsigned short bx_bool;
00041                                           !BCC_EOS
00042                                           ! 33 typedef unsigned long Bit32u;
00043                                           !BCC_EOS
00044                                           ! 34   void memsetb(seg,offset,value,count);
00045                                           !BCC_EOS
00046                                           ! 35   void memcpyb(dseg,doffset,sseg,soffset,count);
00047                                           !BCC_EOS
00048                                           ! 36   void memcpyd(dseg,doffset,sseg,soffset,count);
00049                                           !BCC_EOS
00050                                           ! 37     void
00051                                           ! 38   memsetb(seg,offset,value,count)
00052                                           ! 39     Bit16u seg;
00053                                           export	_memsetb
00054                       00000000            _memsetb:
00055                                           !BCC_EOS
00056                                           ! 40     Bit16u offset;
00057                                           !BCC_EOS
00058                                           ! 41     Bit16u value;
00059                                           !BCC_EOS
00060                                           ! 42     Bit16u count;
00061                                           !BCC_EOS
00062                                           ! 43   {
00063                                           ! 44 #asm
00064                                           !BCC_ASM
00065                       00000008            _memsetb.count	set	8
00066                       00000002            _memsetb.seg	set	2
00067                       00000006            _memsetb.value	set	6
00068                       00000004            _memsetb.offset	set	4
00069 0000           55                             push bp
00070 0001           89E5                           mov bp, sp
00071 0003           50                               push ax
00072 0004           51                               push cx
00073 0005           06                               push es
00074 0006           57                               push di
00075 0007           8B4E         0A                  mov cx, 10[bp] ; count
00076 000A           85C9                             test cx, cx
00077 000C           74           10                  je memsetb_end
00078 000E           8B46         04                  mov ax, 4[bp] ; segment
00079 0011           8EC0                             mov es, ax
00080 0013           8B46         06                  mov ax, 6[bp] ; offset
00081 0016           89C7                             mov di, ax
00082 0018           8A46         08                  mov al, 8[bp] ; value
00083 001B           FC                               cld
00084 001C           F3                               rep
00085 001D           AA                                stosb
00086                       0000001E              memsetb_end:
00087 001E           5F                               pop di
00088 001F           07                               pop es
00089 0020           59                               pop cx
00090 0021           58                               pop ax
00091 0022           5D                             pop bp
00092                                           ! 68 endasm
00093                                           !BCC_ENDASM
00094                                           ! 69   }
00095 0023           C3                         ret
00096                                           ! 70     void
00097                                           ! 71   memcpyb(dseg,doffset,sseg,soffset,count)
00098                                           ! 72     Bit16u dseg;
00099                                           export	_memcpyb
00100                       00000024            _memcpyb:
00101                                           !BCC_EOS
00102                                           ! 73     Bit16u doffset;
00103                                           !BCC_EOS
00104                                           ! 74     Bit16u sseg;
00105                                           !BCC_EOS
00106                                           ! 75     Bit16u soffset;
00107                                           !BCC_EOS
00108                                           ! 76     Bit16u count;
00109                                           !BCC_EOS
00110                                           ! 77   {
00111                                           ! 78 #asm
00112                                           !BCC_ASM
00113                       0000000A            _memcpyb.count	set	$A
00114                       00000006            _memcpyb.sseg	set	6
00115                       00000008            _memcpyb.soffset	set	8
00116                       00000002            _memcpyb.dseg	set	2
00117                       00000004            _memcpyb.doffset	set	4
00118 0024           55                             push bp
00119 0025           89E5                           mov bp, sp
00120 0027           50                               push ax
00121 0028           51                               push cx
00122 0029           06                               push es
00123 002A           57                               push di
00124 002B           1E                               push ds
00125 002C           56                               push si
00126 002D           8B4E         0C                  mov cx, 12[bp] ; count
00127 0030           85C9                             test cx, cx
00128 0032           74           17                  je memcpyb_end
00129 0034           8B46         04                  mov ax, 4[bp] ; dsegment
00130 0037           8EC0                             mov es, ax
00131 0039           8B46         06                  mov ax, 6[bp] ; doffset
00132 003C           89C7                             mov di, ax
00133 003E           8B46         08                  mov ax, 8[bp] ; ssegment
00134 0041           8ED8                             mov ds, ax
00135 0043           8B46         0A                  mov ax, 10[bp] ; soffset
00136 0046           89C6                             mov si, ax
00137 0048           FC                               cld
00138 0049           F3                               rep
00139 004A           A4                                movsb
00140                       0000004B              memcpyb_end:
00141 004B           5E                               pop si
00142 004C           1F                               pop ds
00143 004D           5F                               pop di
00144 004E           07                               pop es
00145 004F           59                               pop cx
00146 0050           58                               pop ax
00147 0051           5D                             pop bp
00148                                           ! 109 endasm
00149                                           !BCC_ENDASM
00150                                           ! 110   }
00151 0052           C3                         ret
00152                                           ! 111     void
00153                                           ! 112   memcpyd(dseg,doffset,sseg,soffset,count)
00154                                           ! 113     Bit16u dseg;
00155                                           export	_memcpyd
00156                       00000053            _memcpyd:
00157                                           !BCC_EOS
00158                                           ! 114     Bit16u doffset;
00159                                           !BCC_EOS
00160                                           ! 115     Bit16u sseg;
00161                                           !BCC_EOS
00162                                           ! 116     Bit16u soffset;
00163                                           !BCC_EOS
00164                                           ! 117     Bit16u count;
00165                                           !BCC_EOS
00166                                           ! 118   {
00167                                           ! 119 #asm
00168                                           !BCC_ASM
00169                       0000000A            _memcpyd.count	set	$A
00170                       00000006            _memcpyd.sseg	set	6
00171                       00000008            _memcpyd.soffset	set	8
00172                       00000002            _memcpyd.dseg	set	2
00173                       00000004            _memcpyd.doffset	set	4
00174 0053           55                             push bp
00175 0054           89E5                           mov bp, sp
00176 0056           50                               push ax
00177 0057           51                               push cx
00178 0058           06                               push es
00179 0059           57                               push di
00180 005A           1E                               push ds
00181 005B           56                               push si
00182 005C           8B4E         0C                  mov cx, 12[bp] ; count
00183 005F           85C9                             test cx, cx
00184 0061           74           18                  je memcpyd_end
00185 0063           8B46         04                  mov ax, 4[bp] ; dsegment
00186 0066           8EC0                             mov es, ax
00187 0068           8B46         06                  mov ax, 6[bp] ; doffset
00188 006B           89C7                             mov di, ax
00189 006D           8B46         08                  mov ax, 8[bp] ; ssegment
00190 0070           8ED8                             mov ds, ax
00191 0072           8B46         0A                  mov ax, 10[bp] ; soffset
00192 0075           89C6                             mov si, ax
00193 0077           FC                               cld
00194 0078           F3                               rep
00195 0079     66    A5                                movsd
00196                       0000007B              memcpyd_end:
00197 007B           5E                               pop si
00198 007C           1F                               pop ds
00199 007D           5F                               pop di
00200 007E           07                               pop es
00201 007F           59                               pop cx
00202 0080           58                               pop ax
00203 0081           5D                             pop bp
00204                                           ! 150 endasm
00205                                           !BCC_ENDASM
00206                                           ! 151   }
00207 0082           C3                         ret
00208                                           ! 152   static Bit32u read_dword();
00209                                           !BCC_EOS
00210                                           ! 153   static void write_dword();
00211                                           !BCC_EOS
00212                                           ! 154     Bit32u
00213                                           ! 155   read_dword(seg, offset)
00214                                           ! 156     Bit16u seg;
00215                                           export	_read_dword
00216                       00000083            _read_dword:
00217                                           !BCC_EOS
00218                                           ! 157     Bit16u offset;
00219                                           !BCC_EOS
00220                                           ! 158   {
00221                                           ! 159 #asm
00222                                           !BCC_ASM
00223                       00000002            _read_dword.seg	set	2
00224                       00000004            _read_dword.offset	set	4
00225 0083           55                             push bp
00226 0084           89E5                           mov bp, sp
00227 0086           53                               push bx
00228 0087           1E                               push ds
00229 0088           8B46         04                  mov ax, 4[bp] ; segment
00230 008B           8ED8                             mov ds, ax
00231 008D           8B5E         06                  mov bx, 6[bp] ; offset
00232 0090           8B07                             mov ax, [bx]
00233 0092           83C3                   02        add bx, #2
00234 0095           8B17                             mov dx, [bx]
00235                                                 ;; ax = return value (word)
00236                                                 ;; dx = return value (word)
00237 0097           1F                               pop ds
00238 0098           5B                               pop bx
00239 0099           5D                             pop bp
00240                                           ! 175 endasm
00241                                           !BCC_ENDASM
00242                                           ! 176   }
00243 009A           C3                         ret
00244                                           ! 177     void
00245                                           ! 178   write_dword(seg, offset, data)
00246                                           ! 179     Bit16u seg;
00247                                           export	_write_dword
00248                       0000009B            _write_dword:
00249                                           !BCC_EOS
00250                                           ! 180     Bit16u offset;
00251                                           !BCC_EOS
00252                                           ! 181     Bit32u data;
00253                                           !BCC_EOS
00254                                           ! 182   {
00255                                           ! 183 #asm
00256                                           !BCC_ASM
00257                       00000002            _write_dword.seg	set	2
00258                       00000006            _write_dword.data	set	6
00259                       00000004            _write_dword.offset	set	4
00260 009B           55                             push bp
00261 009C           89E5                           mov bp, sp
00262 009E           50                               push ax
00263 009F           53                               push bx
00264 00A0           1E                               push ds
00265 00A1           8B46         04                  mov ax, 4[bp] ; segment
00266 00A4           8ED8                             mov ds, ax
00267 00A6           8B5E         06                  mov bx, 6[bp] ; offset
00268 00A9           8B46         08                  mov ax, 8[bp] ; data word
00269 00AC           8907                             mov [bx], ax ; write data word
00270 00AE           83C3                   02        add bx, #2
00271 00B1           8B46         0A                  mov ax, 10[bp] ; data word
00272 00B4           8907                             mov [bx], ax ; write data word
00273 00B6           1F                               pop ds
00274 00B7           5B                               pop bx
00275 00B8           58                               pop ax
00276 00B9           5D                             pop bp
00277                                           ! 201 endasm
00278                                           !BCC_ENDASM
00279                                           ! 202   }
00280 00BA           C3                         ret
00281                                           ! 203 #asm
00282                                           !BCC_ASM
00283                       00000002            _write_dword.seg	set	2
00284                       00000006            _write_dword.data	set	6
00285                       00000004            _write_dword.offset	set	4
00286                                             ;; and function
00287                       000000BB              landl:
00288                       000000BB              landul:
00289 00BB           36                             SEG SS
00290 00BC           2305                             and ax,[di]
00291 00BE           36                             SEG SS
00292 00BF           235D         02                  and bx,2[di]
00293 00C2           C3                             ret
00294                                             ;; add function
00295                       000000C3              laddl:
00296                       000000C3              laddul:
00297 00C3           36                             SEG SS
00298 00C4           0305                             add ax,[di]
00299 00C6           36                             SEG SS
00300 00C7           135D         02                  adc bx,2[di]
00301 00CA           C3                             ret
00302                                             ;; cmp function
00303                       000000CB              lcmpl:
00304                       000000CB              lcmpul:
00305 00CB     66    25               0000FFFF      and eax, #0x0000FFFF
00306 00D1     66    C1E3                   10      shl ebx, #16
00307 00D5     66    09D8                           or eax, ebx
00308 00D8     66    C1EB                   10      shr ebx, #16
00309 00DC           36                             SEG SS
00310 00DD     66    3B05                             cmp eax, dword ptr [di]
00311 00E0           C3                             ret
00312                                             ;; sub function
00313                       000000E1              lsubl:
00314                       000000E1              lsubul:
00315 00E1           36                             SEG SS
00316 00E2           2B05                           sub ax,[di]
00317 00E4           36                             SEG SS
00318 00E5           1B5D         02                sbb bx,2[di]
00319 00E8           C3                             ret
00320                                             ;; mul function
00321                       000000E9              lmull:
00322                       000000E9              lmulul:
00323 00E9     66    25               0000FFFF      and eax, #0x0000FFFF
00324 00EF     66    C1E3                   10      shl ebx, #16
00325 00F3     66    09D8                           or eax, ebx
00326 00F6           36                             SEG SS
00327 00F7     66    F725                           mul eax, dword ptr [di]
00328 00FA     66    89C3                           mov ebx, eax
00329 00FD     66    C1EB                   10      shr ebx, #16
00330 0101           C3                             ret
00331                                             ;; dec function
00332                       00000102              ldecl:
00333                       00000102              ldecul:
00334 0102           36                             SEG SS
00335 0103     66    FF0F                           dec dword ptr [bx]
00336 0106           C3                             ret
00337                                             ;; or function
00338                       00000107              lorl:
00339                       00000107              lorul:
00340 0107           36                             SEG SS
00341 0108           0B05                           or ax,[di]
00342 010A           36                             SEG SS
00343 010B           0B5D         02                or bx,2[di]
00344 010E           C3                             ret
00345                                             ;; inc function
00346                       0000010F              lincl:
00347                       0000010F              lincul:
00348 010F           36                             SEG SS
00349 0110     66    FF07                           inc dword ptr [bx]
00350 0113           C3                             ret
00351                                             ;; tst function
00352                       00000114              ltstl:
00353                       00000114              ltstul:
00354 0114     66    25               0000FFFF      and eax, #0x0000FFFF
00355 011A     66    C1E3                   10      shl ebx, #16
00356 011E     66    09D8                           or eax, ebx
00357 0121     66    C1EB                   10      shr ebx, #16
00358 0125     66    85C0                           test eax, eax
00359 0128           C3                             ret
00360                                             ;; sr function
00361                       00000129              lsrul:
00362 0129           89F9                           mov cx,di
00363 012B           E3           19                jcxz lsr_exit
00364 012D     66    25               0000FFFF      and eax, #0x0000FFFF
00365 0133     66    C1E3                   10      shl ebx, #16
00366 0137     66    09D8                           or eax, ebx
00367                       0000013A              lsr_loop:
00368 013A     66    D1E8                           shr eax, #1
00369 013D           E2           FB                loop lsr_loop
00370 013F     66    89C3                           mov ebx, eax
00371 0142     66    C1EB                   10      shr ebx, #16
00372                       00000146              lsr_exit:
00373 0146           C3                             ret
00374                                             ;; sl function
00375                       00000147              lsll:
00376                       00000147              lslul:
00377 0147           89F9                           mov cx,di
00378 0149           E3           19                jcxz lsl_exit
00379 014B     66    25               0000FFFF      and eax, #0x0000FFFF
00380 0151     66    C1E3                   10      shl ebx, #16
00381 0155     66    09D8                           or eax, ebx
00382                       00000158              lsl_loop:
00383 0158     66    D1E0                           shl eax, #1
00384 015B           E2           FB                loop lsl_loop
00385 015D     66    89C3                           mov ebx, eax
00386 0160     66    C1EB                   10      shr ebx, #16
00387                       00000164              lsl_exit:
00388 0164           C3                             ret
00389                       00000165              idiv_:
00390 0165           99                             cwd
00391 0166           F7FB                           idiv bx
00392 0168           C3                             ret
00393                       00000169              idiv_u:
00394 0169           31D2                           xor dx,dx
00395 016B           F7F3                           div bx
00396 016D           C3                             ret
00397                       0000016E              ldivul:
00398 016E     66    25               0000FFFF      and eax, #0x0000FFFF
00399 0174     66    C1E3                   10      shl ebx, #16
00400 0178     66    09D8                           or eax, ebx
00401 017B     66    31D2                           xor edx, edx
00402 017E           36                             SEG SS
00403 017F           8B5D         02                mov bx, 2[di]
00404 0182     66    C1E3                   10      shl ebx, #16
00405 0186           36                             SEG SS
00406 0187           8B1D                           mov bx, [di]
00407 0189     66    F7F3                           div ebx
00408 018C     66    89C3                           mov ebx, eax
00409 018F     66    C1EB                   10      shr ebx, #16
00410 0193           C3                             ret
00411                                           ! 329 endasm
00412                                           !BCC_ENDASM
00413                                           ! 330 typedef struct {
00414                                           ! 331   unsigned char filler1[0x400];
00415                                           !BCC_EOS
00416                                           ! 332   unsigned char filler2[0x6c];
00417                                           !BCC_EOS
00418                                           ! 333   Bit16u ticks_low;
00419                                           !BCC_EOS
00420                                           ! 334   Bit16u ticks_high;
00421                                           !BCC_EOS
00422                                           ! 335   Bit8u midnight_flag;
00423                                           !BCC_EOS
00424                                           ! 336   } bios_data_t;
00425                                           !BCC_EOS
00426                                           ! 337   typedef struct {
00427                                           ! 338     Bit16u heads;
00428                                           !BCC_EOS
00429                                           ! 339     Bit16u cylinders;
00430                                           !BCC_EOS
00431                                           ! 340     Bit16u spt;
00432                                           !BCC_EOS
00433                                           ! 341     } chs_t;
00434                                           !BCC_EOS
00435                                           ! 342   typedef struct {
00436                                           ! 343     Bit16u iobase1;
00437                                           !BCC_EOS
00438                                           ! 344     Bit16u iobase2;
00439                                           !BCC_EOS
00440                                           ! 345     Bit8u prefix;
00441                                           !BCC_EOS
00442                                           ! 346     Bit8u unused;
00443                                           !BCC_EOS
00444                                           ! 347     Bit8u irq;
00445                                           !BCC_EOS
00446                                           ! 348     Bit8u blkcount;
00447                                           !BCC_EOS
00448                                           ! 349     Bit8u dma;
00449                                           !BCC_EOS
00450                                           ! 350     Bit8u pio;
00451                                           !BCC_EOS
00452                                           ! 351     Bit16u options;
00453                                           !BCC_EOS
00454                                           ! 352     Bit16u reserved;
00455                                           !BCC_EOS
00456                                           ! 353     Bit8u revision;
00457                                           !BCC_EOS
00458                                           ! 354     Bit8u checksum;
00459                                           !BCC_EOS
00460                                           ! 355     } dpte_t;
00461                                           !BCC_EOS
00462                                           ! 356   typedef struct {
00463                                           ! 357     Bit8u iface;
00464                                           !BCC_EOS
00465                                           ! 358     Bit16u iobase1;
00466                                           !BCC_EOS
00467                                           ! 359     Bit16u iobase2;
00468                                           !BCC_EOS
00469                                           ! 360     Bit8u irq;
00470                                           !BCC_EOS
00471                                           ! 361     } ata_channel_t;
00472                                           !BCC_EOS
00473                                           ! 362   typedef struct {
00474                                           ! 363     Bit8u type;
00475                                           !BCC_EOS
00476                                           ! 364     Bit8u device;
00477                                           !BCC_EOS
00478                                           ! 365     Bit8u removab
00479                                           ! 365 le;
00480                                           !BCC_EOS
00481                                           ! 366     Bit8u lock;
00482                                           !BCC_EOS
00483                                           ! 367     Bit8u mode;
00484                                           !BCC_EOS
00485                                           ! 368     Bit16u blksize;
00486                                           !BCC_EOS
00487                                           ! 369     Bit8u translation;
00488                                           !BCC_EOS
00489                                           ! 370     chs_t lchs;
00490                                           !BCC_EOS
00491                                           ! 371     chs_t pchs;
00492                                           !BCC_EOS
00493                                           ! 372     Bit32u sectors_low;
00494                                           !BCC_EOS
00495                                           ! 373     Bit32u sectors_high;
00496                                           !BCC_EOS
00497                                           ! 374     } ata_device_t;
00498                                           !BCC_EOS
00499                                           ! 375   typedef struct {
00500                                           ! 376     ata_channel_t channels[4];
00501                                           !BCC_EOS
00502                                           ! 377     ata_device_t devices[(4*2)];
00503                                           !BCC_EOS
00504                                           ! 378     Bit8u hdcount, hdidmap[(4*2)];
00505                                           !BCC_EOS
00506                                           ! 379     Bit8u cdcount, cdidmap[(4*2)];
00507                                           !BCC_EOS
00508                                           ! 380     dpte_t dpte;
00509                                           !BCC_EOS
00510                                           ! 381     Bit16u trsfsectors;
00511                                           !BCC_EOS
00512                                           ! 382     Bit32u trsfbytes;
00513                                           !BCC_EOS
00514                                           ! 383     } ata_t;
00515                                           !BCC_EOS
00516                                           ! 384   typedef struct {
00517                                           ! 385     Bit8u active;
00518                                           !BCC_EOS
00519                                           ! 386     Bit8u media;
00520                                           !BCC_EOS
00521                                           ! 387     Bit8u emulated_drive;
00522                                           !BCC_EOS
00523                                           ! 388     Bit8u controller_index;
00524                                           !BCC_EOS
00525                                           ! 389     Bit16u device_spec;
00526                                           !BCC_EOS
00527                                           ! 390     Bit32u ilba;
00528                                           !BCC_EOS
00529                                           ! 391     Bit16u buffer_segment;
00530                                           !BCC_EOS
00531                                           ! 392     Bit16u load_segment;
00532                                           !BCC_EOS
00533                                           ! 393     Bit16u sector_count;
00534                                           !BCC_EOS
00535                                           ! 394     chs_t vdevice;
00536                                           !BCC_EOS
00537                                           ! 395     } cdemu_t;
00538                                           !BCC_EOS
00539                                           ! 396 Bit32u TCGInterruptHandler ();
00540                                           !BCC_EOS
00541                                           ! 397 void tcpa_acpi_init ();
00542                                           !BCC_EOS
00543                                           ! 398 Bit32u tcpa_extend_acpi_log ();
00544                                           !BCC_EOS
00545                                           ! 399 void tcpa_calling_int19h ();
00546                                           !BCC_EOS
00547                                           ! 400 void tcpa_returned_int19h ();
00548                                           !BCC_EOS
00549                                           ! 401 void tcpa_add_event_separators ();
00550                                           !BCC_EOS
00551                                           ! 402 void tcpa_wake_event ();
00552                                           !BCC_EOS
00553                                           ! 403 void tcpa_add_bootdevice ();
00554                                           !BCC_EOS
00555                                           ! 404 void tcpa_start_option_rom_scan ();
00556                                           !BCC_EOS
00557                                           ! 405 void tcpa_option_rom ();
00558                                           !BCC_EOS
00559                                           ! 406 void tcpa_ipl ();
00560                                           !BCC_EOS
00561                                           ! 407 void tcpa_measure_post ();
00562                                           !BCC_EOS
00563                                           ! 408 Bit32u tcpa_initialize_tpm ();
00564                                           !BCC_EOS
00565                                           ! 409 Bit32u get_s3_waking_vector ();
00566                                           !BCC_EOS
00567                                           ! 410 Bit32u pmm ();
00568                                           !BCC_EOS
00569                                           ! 411   typedef struct {
00570                                           ! 412     unsigned char ebda_size;
00571                                           !BCC_EOS
00572                                           ! 413     unsigned char cmos_shutdown_status;
00573                                           !BCC_EOS
00574                                           ! 414     unsigned char filler1[0x3B];
00575                                           !BCC_EOS
00576                                           ! 415     unsigned char fdpt0[0x10];
00577                                           !BCC_EOS
00578                                           ! 416     unsigned char fdpt1[0x10];
00579                                           !BCC_EOS
00580                                           ! 417     unsigned char filler2[0xC4];
00581                                           !BCC_EOS
00582                                           ! 418     ata_t ata;
00583                                           !BCC_EOS
00584                                           ! 419     cdemu_t cdemu;
00585                                           !BCC_EOS
00586                                           ! 420     } ebda_data_t;
00587                                           !BCC_EOS
00588                                           ! 421   typedef struct {
00589                                           ! 422     Bit8u size;
00590                                           !BCC_EOS
00591                                           ! 423     Bit8u reserved;
00592                                           !BCC_EOS
00593                                           ! 424     Bit16u count;
00594                                           !BCC_EOS
00595                                           ! 425     Bit16u offset;
00596                                           !BCC_EOS
00597                                           ! 426     Bit16u segment;
00598                                           !BCC_EOS
00599                                           ! 427     Bit32u lba1;
00600                                           !BCC_EOS
00601                                           ! 428     Bit32u lba2;
00602                                           !BCC_EOS
00603                                           ! 429     } int13ext_t;
00604                                           !BCC_EOS
00605                                           ! 430   typedef struct {
00606                                           ! 431     Bit16u size;
00607                                           !BCC_EOS
00608                                           ! 432     Bit16u infos;
00609                                           !BCC_EOS
00610                                           ! 433     Bit32u cylinders;
00611                                           !BCC_EOS
00612                                           ! 434     Bit32u heads;
00613                                           !BCC_EOS
00614                                           ! 435     Bit32u spt;
00615                                           !BCC_EOS
00616                                           ! 436     Bit32u sector_count1;
00617                                           !BCC_EOS
00618                                           ! 437     Bit32u sector_count2;
00619                                           !BCC_EOS
00620                                           ! 438     Bit16u blksize;
00621                                           !BCC_EOS
00622                                           ! 439     Bit16u dpte_offset;
00623                                           !BCC_EOS
00624                                           ! 440     Bit16u dpte_segment;
00625                                           !BCC_EOS
00626                                           ! 441     Bit16u key;
00627                                           !BCC_EOS
00628                                           ! 442     Bit8u dpi_length;
00629                                           !BCC_EOS
00630                                           ! 443     Bit8u reserved1;
00631                                           !BCC_EOS
00632                                           ! 444     Bit16u reserved2;
00633                                           !BCC_EOS
00634                                           ! 445     Bit8u host_bus[4];
00635                                           !BCC_EOS
00636                                           ! 446     Bit8u iface_type[8];
00637                                           !BCC_EOS
00638                                           ! 447     Bit8u iface_path[8];
00639                                           !BCC_EOS
00640                                           ! 448     Bit8u device_path[8];
00641                                           !BCC_EOS
00642                                           ! 449     Bit8u reserved3;
00643                                           !BCC_EOS
00644                                           ! 450     Bit8u checksum;
00645                                           !BCC_EOS
00646                                           ! 451     } dpt_t;
00647                                           !BCC_EOS
00648                                           ! 452 typedef struct {
00649                                           ! 453   union {
00650                                           ! 454     struct {
00651                                           ! 455       Bit16u di, si, b
00652                                           ! 455 p, sp;
00653                                           !BCC_EOS
00654                                           ! 456       Bit16u bx, dx, cx, ax;
00655                                           !BCC_EOS
00656                                           ! 457       } r16;
00657                                           !BCC_EOS
00658                                           ! 458     struct {
00659                                           ! 459       Bit16u filler[4];
00660                                           !BCC_EOS
00661                                           ! 460       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
00662                                           !BCC_EOS
00663                                           ! 461       } r8;
00664                                           !BCC_EOS
00665                                           ! 462     } u;
00666                                           !BCC_EOS
00667                                           ! 463   } pusha_regs_t;
00668                                           !BCC_EOS
00669                                           ! 464 typedef struct {
00670                                           ! 465  union {
00671                                           ! 466   struct {
00672                                           ! 467     Bit32u edi, esi, ebp, esp;
00673                                           !BCC_EOS
00674                                           ! 468     Bit32u ebx, edx, ecx, eax;
00675                                           !BCC_EOS
00676                                           ! 469     } r32;
00677                                           !BCC_EOS
00678                                           ! 470   struct {
00679                                           ! 471     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
00680                                           !BCC_EOS
00681                                           ! 472     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
00682                                           !BCC_EOS
00683                                           ! 473     } r16;
00684                                           !BCC_EOS
00685                                           ! 474   struct {
00686                                           ! 475     Bit32u filler[4];
00687                                           !BCC_EOS
00688                                           ! 476     Bit8u bl, bh;
00689                                           !BCC_EOS
00690                                           ! 477     Bit16u filler1;
00691                                           !BCC_EOS
00692                                           ! 478     Bit8u dl, dh;
00693                                           !BCC_EOS
00694                                           ! 479     Bit16u filler2;
00695                                           !BCC_EOS
00696                                           ! 480     Bit8u cl, ch;
00697                                           !BCC_EOS
00698                                           ! 481     Bit16u filler3;
00699                                           !BCC_EOS
00700                                           ! 482     Bit8u al, ah;
00701                                           !BCC_EOS
00702                                           ! 483     Bit16u filler4;
00703                                           !BCC_EOS
00704                                           ! 484     } r8;
00705                                           !BCC_EOS
00706                                           ! 485   } u;
00707                                           !BCC_EOS
00708                                           ! 486 } pushad_regs_t;
00709                                           !BCC_EOS
00710                                           ! 487 typedef struct {
00711                                           ! 488   union {
00712                                           ! 489     struct {
00713                                           ! 490       Bit16u flags;
00714                                           !BCC_EOS
00715                                           ! 491       } r16;
00716                                           !BCC_EOS
00717                                           ! 492     struct {
00718                                           ! 493       Bit8u flagsl;
00719                                           !BCC_EOS
00720                                           ! 494       Bit8u flagsh;
00721                                           !BCC_EOS
00722                                           ! 495       } r8;
00723                                           !BCC_EOS
00724                                           ! 496     } u;
00725                                           !BCC_EOS
00726                                           ! 497   } flags_t;
00727                                           !BCC_EOS
00728                                           ! 498 typedef struct {
00729                                           ! 499   Bit16u ip;
00730                                           !BCC_EOS
00731                                           ! 500   Bit16u cs;
00732                                           !BCC_EOS
00733                                           ! 501   flags_t flags;
00734                                           !BCC_EOS
00735                                           ! 502   } iret_addr_t;
00736                                           !BCC_EOS
00737                                           ! 503 typedef struct {
00738                                           ! 504   Bit16u type;
00739                                           !BCC_EOS
00740                                           ! 505   Bit16u flags;
00741                                           !BCC_EOS
00742                                           ! 506   Bit32u vector;
00743                                           !BCC_EOS
00744                                           ! 507   Bit32u description;
00745                                           !BCC_EOS
00746                                           ! 508   Bit32u reserved;
00747                                           !BCC_EOS
00748                                           ! 509   } ipl_entry_t;
00749                                           !BCC_EOS
00750                                           ! 510 static Bit8u inb();
00751                                           !BCC_EOS
00752                                           ! 511 static Bit8u inb_cmos();
00753                                           !BCC_EOS
00754                                           ! 512 static void outb();
00755                                           !BCC_EOS
00756                                           ! 513 static void outb_cmos();
00757                                           !BCC_EOS
00758                                           ! 514 static Bit16u inw();
00759                                           !BCC_EOS
00760                                           ! 515 static void outw();
00761                                           !BCC_EOS
00762                                           ! 516 static void init_rtc();
00763                                           !BCC_EOS
00764                                           ! 517 static bx_bool rtc_updating();
00765                                           !BCC_EOS
00766                                           ! 518 static Bit8u read_byte();
00767                                           !BCC_EOS
00768                                           ! 519 static Bit16u read_word();
00769                                           !BCC_EOS
00770                                           ! 520 static void write_byte();
00771                                           !BCC_EOS
00772                                           ! 521 static void write_word();
00773                                           !BCC_EOS
00774                                           ! 522 static void bios_printf();
00775                                           !BCC_EOS
00776                                           ! 523 static Bit8u inhibit_mouse_int_and_events();
00777                                           !BCC_EOS
00778                                           ! 524 static void enable_mouse_int_and_events();
00779                                           !BCC_EOS
00780                                           ! 525 static Bit8u send_to_mouse_ctrl();
00781                                           !BCC_EOS
00782                                           ! 526 static Bit8u get_mouse_data();
00783                                           !BCC_EOS
00784                                           ! 527 static void set_kbd_command_byte();
00785                                           !BCC_EOS
00786                                           ! 528 static void int09_function();
00787                                           !BCC_EOS
00788                                           ! 529 static void int13_harddisk();
00789                                           !BCC_EOS
00790                                           ! 530 static void int13_cdrom();
00791                                           !BCC_EOS
00792                                           ! 531 static void int13_cdemu();
00793                                           !BCC_EOS
00794                                           ! 532 static void int13_eltorito();
00795                                           !BCC_EOS
00796                                           ! 533 static void int13_diskette_function();
00797                                           !BCC_EOS
00798                                           ! 534 static void int14_function();
00799                                           !BCC_EOS
00800                                           ! 535 static void int15_function();
00801                                           !BCC_EOS
00802                                           ! 536 static void int16_function();
00803                                           !BCC_EOS
00804                                           ! 537 static void int17_function();
00805                                           !BCC_EOS
00806                                           ! 538 static void int18_function();
00807                                           !BCC_EOS
00808                                           ! 539 static void int1a_function();
00809                                           !BCC_EOS
00810                                           ! 540 static void int70_function();
00811                                           !BCC_EOS
00812                                           ! 541 static void int74_function();
00813                                           !BCC_EOS
00814                                           ! 542 static Bit16u get_CS();
00815                                           !BCC_EOS
00816                                           ! 543 static Bit16u get_SS();
00817                                           !BCC_EOS
00818                                           ! 544 static unsigned int enqueue_key();
00819                                           !BCC_EOS
00820                                           ! 545 static unsigned int dequeue_
00821                                           ! 545 key();
00822                                           !BCC_EOS
00823                                           ! 546 static void get_hd_geometry();
00824                                           !BCC_EOS
00825                                           ! 547 static void set_diskette_ret_status();
00826                                           !BCC_EOS
00827                                           ! 548 static void set_diskette_current_cyl();
00828                                           !BCC_EOS
00829                                           ! 549 static void determine_floppy_media();
00830                                           !BCC_EOS
00831                                           ! 550 static bx_bool floppy_drive_exists();
00832                                           !BCC_EOS
00833                                           ! 551 static bx_bool floppy_drive_recal();
00834                                           !BCC_EOS
00835                                           ! 552 static bx_bool floppy_media_known();
00836                                           !BCC_EOS
00837                                           ! 553 static bx_bool floppy_media_sense();
00838                                           !BCC_EOS
00839                                           ! 554 static bx_bool set_enable_a20();
00840                                           !BCC_EOS
00841                                           ! 555 static void debugger_on();
00842                                           !BCC_EOS
00843                                           ! 556 static void debugger_off();
00844                                           !BCC_EOS
00845                                           ! 557 static void keyboard_init();
00846                                           !BCC_EOS
00847                                           ! 558 static void keyboard_panic();
00848                                           !BCC_EOS
00849                                           ! 559 static void shutdown_status_panic();
00850                                           !BCC_EOS
00851                                           ! 560 static void nmi_handler_msg();
00852                                           !BCC_EOS
00853                                           ! 561 static void delay_ticks();
00854                                           !BCC_EOS
00855                                           ! 562 static void delay_ticks_and_check_for_keystroke();
00856                                           !BCC_EOS
00857                                           ! 563 static void interactive_bootkey();
00858                                           !BCC_EOS
00859                                           ! 564 static void print_bios_banner();
00860                                           !BCC_EOS
00861                                           ! 565 static void print_boot_device();
00862                                           !BCC_EOS
00863                                           ! 566 static void print_boot_failure();
00864                                           !BCC_EOS
00865                                           ! 567 static void print_cdromboot_failure();
00866                                           !BCC_EOS
00867                                           ! 568 void ata_init();
00868                                           !BCC_EOS
00869                                           ! 569 void ata_detect();
00870                                           !BCC_EOS
00871                                           ! 570 void ata_reset();
00872                                           !BCC_EOS
00873                                           ! 571 Bit16u ata_cmd_non_data();
00874                                           !BCC_EOS
00875                                           ! 572 Bit16u ata_cmd_data_in();
00876                                           !BCC_EOS
00877                                           ! 573 Bit16u ata_cmd_data_out();
00878                                           !BCC_EOS
00879                                           ! 574 Bit16u ata_cmd_packet();
00880                                           !BCC_EOS
00881                                           ! 575 Bit16u atapi_get_sense();
00882                                           !BCC_EOS
00883                                           ! 576 Bit16u atapi_is_ready();
00884                                           !BCC_EOS
00885                                           ! 577 Bit16u atapi_is_cdrom();
00886                                           !BCC_EOS
00887                                           ! 578 void cdemu_init();
00888                                           !BCC_EOS
00889                                           ! 579 Bit8u cdemu_isactive();
00890                                           !BCC_EOS
00891                                           ! 580 Bit8u cdemu_emulated_drive();
00892                                           !BCC_EOS
00893                                           ! 581 Bit16u cdrom_boot();
00894                                           !BCC_EOS
00895                                           ! 582 static char bios_cvs_version_string[] = "$Revision: 1.221 $ $Date: 2008/12/07 17:32:29 $";
00896                                           
00897                       00000194            _bios_cvs_version_string:
00898                       00000194            .1:
00899 0194                        24            .ascii	"$Revision: 1.221 $ $Date: 2008/12/07 17:"
00900 01BC                        33            .ascii	"32:29 $"
00901 01C3                        00            .byte	0
00902                                           !BCC_EOS
00903                                           ! 583 static struct {
00904                                           ! 584   Bit16u normal;
00905                                           !BCC_EOS
00906                                           ! 585   Bit16u shift;
00907                                           !BCC_EOS
00908                                           ! 586   Bit16u control;
00909                                           !BCC_EOS
00910                                           ! 587   Bit16u alt;
00911                                           !BCC_EOS
00912                                           ! 588   Bit8u lock_flags;
00913                                           !BCC_EOS
00914                                           ! 589   } scan_to_scanascii[0x58 + 1] = {
00915                       000001C4            _scan_to_scanascii:
00916                                           ! 590       { 0, 0, 0, 0, 0 },
00917 01C4                      0000            .word	0
00918 01C6                      0000            .word	0
00919 01C8                      0000            .word	0
00920 01CA                      0000            .word	0
00921 01CC                        00            .byte	0
00922 01CD                  00000001            .blkb	1
00923                                           ! 591       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
00924 01CE                      011B            .word	$11B
00925 01D0                      011B            .word	$11B
00926 01D2                      011B            .word	$11B
00927 01D4                      0100            .word	$100
00928 01D6                        00            .byte	0
00929 01D7                  00000001            .blkb	1
00930                                           ! 592       { 0x0231, 0x0221, 0, 0x7800, 0 },
00931 01D8                      0231            .word	$231
00932 01DA                      0221            .word	$221
00933 01DC                      0000            .word	0
00934 01DE                      7800            .word	$7800
00935 01E0                        00            .byte	0
00936 01E1                  00000001            .blkb	1
00937                                           ! 593       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
00938 01E2                      0332            .word	$332
00939 01E4                      0340            .word	$340
00940 01E6                      0300            .word	$300
00941 01E8                      7900            .word	$7900
00942 01EA                        00            .byte	0
00943 01EB                  00000001            .blkb	1
00944                                           ! 594       { 0x0433, 0x0423, 0, 0x7a00, 0 },
00945 01EC                      0433            .word	$433
00946 01EE                      0423            .word	$423
00947 01F0                      0000            .word	0
00948 01F2                      7A00            .word	$7A00
00949 01F4                        00            .byte	0
00950 01F5                  00000001            .blkb	1
00951                                           ! 595       { 0x0534, 0x0524, 0, 0x7b00, 0 },
00952 01F6                      0534            .word	$534
00953 01F8                      0524            .word	$524
00954 01FA                      0000            .word	0
00955 01FC                      7B00            .word	$7B00
00956 01FE                        00            .byte	0
00957 01FF                  00000001            .blkb	1
00958                                           ! 596       { 0x0635, 0x0625, 0, 0x7c00, 0 },
00959 0200                      0635            .word	$635
00960 0202                      0625            .word	$625
00961 0204                      0000            .word	0
00962 0206                      7C00            .word	$7C00
00963 0208                        00            .byte	0
00964 0209                  00000001            .blkb	1
00965                                           ! 597       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
00966 020A                      0736            .word	$736
00967 020C                      075E            .word	$75E
00968 020E                      071E            .word	$71E
00969 0210                      7D00            .word	$7D00
00970 0212                        00            .byte	0
00971 0213                  00000001            .blkb	1
00972                                           ! 598       { 0x0837, 0x0826, 0, 0x7e00, 0 },
00973 0214                      0837            .word	$837
00974 0216                      0826            .word	$826
00975 0218                      0000            .word	0
00976 021A                      7E00            .word	$7E00
00977 021C                        00            .byte	0
00978 021D                  00000001            .blkb	1
00979                                           ! 599       { 0x0938, 0x092a, 0, 0x7f00, 0 },
00980 021E                      0938            .word	$938
00981 0220                      092A            .word	$92A
00982 0222                      0000            .word	0
00983 0224                      7F00            .word	$7F00
00984 0226                        00            .byte	0
00985 0227                  00000001            .blkb	1
00986                                           ! 600       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
00987 0228                      0A39            .word	$A39
00988 022A                      0A28            .word	$A28
00989 022C                      0000            .word	0
00990 022E                      8000            .word	$8000
00991 0230                        00            .byte	0
00992 0231                  00000001            .blkb	1
00993                                           ! 601       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
00994 0232                      0B30            .word	$B30
00995 0234                      0B29            .word	$B29
00996 0236                      0000            .word	0
00997 0238                      8100            .word	$8100
00998 023A                        00            .byte	0
00999 023B                  00000001            .blkb	1
01000                                           ! 602       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
01001 023C                      0C2D            .word	$C2D
01002 023E                      0C5F            .word	$C5F
01003 0240                      0C1F            .word	$C1F
01004 0242                      8200            .word	$8200
01005 0244                        00            .byte	0
01006 0245                  00000001            .blkb	1
01007                                           ! 603       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
01008 0246                      0D3D            .word	$D3D
01009 0248                      0D2B            .word	$D2B
01010 024A                      0000            .word	0
01011 024C                      8300            .word	$8300
01012 024E                        00            .byte	0
01013 024F                  00000001            .blkb	1
01014                                           ! 604       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
01015 0250                      0E08            .word	$E08
01016 0252                      0E08            .word	$E08
01017 0254                      0E7F            .word	$E7F
01018 0256                      0000            .word	0
01019 0258                        00            .byte	0
01020 0259                  00000001            .blkb	1
01021                                           ! 605       { 0x0f09, 0x0f00, 0, 0, 0 },
01022 025A                      0F09            .word	$F09
01023 025C                      0F00            .word	$F00
01024 025E                      0000            .word	0
01025 0260                      0000            .word	0
01026 0262                        00            .byte	0
01027 0263                  00000001            .blkb	1
01028                                           ! 606       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
01029 0264                      1071            .word	$1071
01030 0266                      1051            .word	$1051
01031 0268                      1011            .word	$1011
01032 026A                      1000            .word	$1000
01033 026C                        40            .byte	$40
01034 026D                  00000001            .blkb	1
01035                                           ! 607       { 0x1177, 0x1157, 0x1117, 
01036 026E                      1177            .word	$1177
01037 0270                      1157            .word	$1157
01038 0272                      1117            .word	$1117
01039                                           ! 607 0x1100, 0x40 },
01040 0274                      1100            .word	$1100
01041 0276                        40            .byte	$40
01042 0277                  00000001            .blkb	1
01043                                           ! 608       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
01044 0278                      1265            .word	$1265
01045 027A                      1245            .word	$1245
01046 027C                      1205            .word	$1205
01047 027E                      1200            .word	$1200
01048 0280                        40            .byte	$40
01049 0281                  00000001            .blkb	1
01050                                           ! 609       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
01051 0282                      1372            .word	$1372
01052 0284                      1352            .word	$1352
01053 0286                      1312            .word	$1312
01054 0288                      1300            .word	$1300
01055 028A                        40            .byte	$40
01056 028B                  00000001            .blkb	1
01057                                           ! 610       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
01058 028C                      1474            .word	$1474
01059 028E                      1454            .word	$1454
01060 0290                      1414            .word	$1414
01061 0292                      1400            .word	$1400
01062 0294                        40            .byte	$40
01063 0295                  00000001            .blkb	1
01064                                           ! 611       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
01065 0296                      1579            .word	$1579
01066 0298                      1559            .word	$1559
01067 029A                      1519            .word	$1519
01068 029C                      1500            .word	$1500
01069 029E                        40            .byte	$40
01070 029F                  00000001            .blkb	1
01071                                           ! 612       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
01072 02A0                      1675            .word	$1675
01073 02A2                      1655            .word	$1655
01074 02A4                      1615            .word	$1615
01075 02A6                      1600            .word	$1600
01076 02A8                        40            .byte	$40
01077 02A9                  00000001            .blkb	1
01078                                           ! 613       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
01079 02AA                      1769            .word	$1769
01080 02AC                      1749            .word	$1749
01081 02AE                      1709            .word	$1709
01082 02B0                      1700            .word	$1700
01083 02B2                        40            .byte	$40
01084 02B3                  00000001            .blkb	1
01085                                           ! 614       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
01086 02B4                      186F            .word	$186F
01087 02B6                      184F            .word	$184F
01088 02B8                      180F            .word	$180F
01089 02BA                      1800            .word	$1800
01090 02BC                        40            .byte	$40
01091 02BD                  00000001            .blkb	1
01092                                           ! 615       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
01093 02BE                      1970            .word	$1970
01094 02C0                      1950            .word	$1950
01095 02C2                      1910            .word	$1910
01096 02C4                      1900            .word	$1900
01097 02C6                        40            .byte	$40
01098 02C7                  00000001            .blkb	1
01099                                           ! 616       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
01100 02C8                      1A5B            .word	$1A5B
01101 02CA                      1A7B            .word	$1A7B
01102 02CC                      1A1B            .word	$1A1B
01103 02CE                      0000            .word	0
01104 02D0                        00            .byte	0
01105 02D1                  00000001            .blkb	1
01106                                           ! 617       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
01107 02D2                      1B5D            .word	$1B5D
01108 02D4                      1B7D            .word	$1B7D
01109 02D6                      1B1D            .word	$1B1D
01110 02D8                      0000            .word	0
01111 02DA                        00            .byte	0
01112 02DB                  00000001            .blkb	1
01113                                           ! 618       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
01114 02DC                      1C0D            .word	$1C0D
01115 02DE                      1C0D            .word	$1C0D
01116 02E0                      1C0A            .word	$1C0A
01117 02E2                      0000            .word	0
01118 02E4                        00            .byte	0
01119 02E5                  00000001            .blkb	1
01120                                           ! 619       { 0, 0, 0, 0, 0 },
01121 02E6                      0000            .word	0
01122 02E8                      0000            .word	0
01123 02EA                      0000            .word	0
01124 02EC                      0000            .word	0
01125 02EE                        00            .byte	0
01126 02EF                  00000001            .blkb	1
01127                                           ! 620       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
01128 02F0                      1E61            .word	$1E61
01129 02F2                      1E41            .word	$1E41
01130 02F4                      1E01            .word	$1E01
01131 02F6                      1E00            .word	$1E00
01132 02F8                        40            .byte	$40
01133 02F9                  00000001            .blkb	1
01134                                           ! 621       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
01135 02FA                      1F73            .word	$1F73
01136 02FC                      1F53            .word	$1F53
01137 02FE                      1F13            .word	$1F13
01138 0300                      1F00            .word	$1F00
01139 0302                        40            .byte	$40
01140 0303                  00000001            .blkb	1
01141                                           ! 622       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
01142 0304                      2064            .word	$2064
01143 0306                      2044            .word	$2044
01144 0308                      2004            .word	$2004
01145 030A                      2000            .word	$2000
01146 030C                        40            .byte	$40
01147 030D                  00000001            .blkb	1
01148                                           ! 623       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
01149 030E                      2166            .word	$2166
01150 0310                      2146            .word	$2146
01151 0312                      2106            .word	$2106
01152 0314                      2100            .word	$2100
01153 0316                        40            .byte	$40
01154 0317                  00000001            .blkb	1
01155                                           ! 624       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
01156 0318                      2267            .word	$2267
01157 031A                      2247            .word	$2247
01158 031C                      2207            .word	$2207
01159 031E                      2200            .word	$2200
01160 0320                        40            .byte	$40
01161 0321                  00000001            .blkb	1
01162                                           ! 625       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
01163 0322                      2368            .word	$2368
01164 0324                      2348            .word	$2348
01165 0326                      2308            .word	$2308
01166 0328                      2300            .word	$2300
01167 032A                        40            .byte	$40
01168 032B                  00000001            .blkb	1
01169                                           ! 626       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
01170 032C                      246A            .word	$246A
01171 032E                      244A            .word	$244A
01172 0330                      240A            .word	$240A
01173 0332                      2400            .word	$2400
01174 0334                        40            .byte	$40
01175 0335                  00000001            .blkb	1
01176                                           ! 627       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
01177 0336                      256B            .word	$256B
01178 0338                      254B            .word	$254B
01179 033A                      250B            .word	$250B
01180 033C                      2500            .word	$2500
01181 033E                        40            .byte	$40
01182 033F                  00000001            .blkb	1
01183                                           ! 628       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
01184 0340                      266C            .word	$266C
01185 0342                      264C            .word	$264C
01186 0344                      260C            .word	$260C
01187 0346                      2600            .word	$2600
01188 0348                        40            .byte	$40
01189 0349                  00000001            .blkb	1
01190                                           ! 629       { 0x273b, 0x273a, 0, 0, 0 },
01191 034A                      273B            .word	$273B
01192 034C                      273A            .word	$273A
01193 034E                      0000            .word	0
01194 0350                      0000            .word	0
01195 0352                        00            .byte	0
01196 0353                  00000001            .blkb	1
01197                                           ! 630       { 0x2827, 0x2822, 0, 0, 0 },
01198 0354                      2827            .word	$2827
01199 0356                      2822            .word	$2822
01200 0358                      0000            .word	0
01201 035A                      0000            .word	0
01202 035C                        00            .byte	0
01203 035D                  00000001            .blkb	1
01204                                           ! 631       { 0x2960, 0x297e, 0, 0, 0 },
01205 035E                      2960            .word	$2960
01206 0360                      297E            .word	$297E
01207 0362                      0000            .word	0
01208 0364                      0000            .word	0
01209 0366                        00            .byte	0
01210 0367                  00000001            .blkb	1
01211                                           ! 632       { 0, 0, 0, 0, 0 },
01212 0368                      0000            .word	0
01213 036A                      0000            .word	0
01214 036C                      0000            .word	0
01215 036E                      0000            .word	0
01216 0370                        00            .byte	0
01217 0371                  00000001            .blkb	1
01218                                           ! 633       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
01219 0372                      2B5C            .word	$2B5C
01220 0374                      2B7C            .word	$2B7C
01221 0376                      2B1C            .word	$2B1C
01222 0378                      0000            .word	0
01223 037A                        00            .byte	0
01224 037B                  00000001            .blkb	1
01225                                           ! 634       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
01226 037C                      2C7A            .word	$2C7A
01227 037E                      2C5A            .word	$2C5A
01228 0380                      2C1A            .word	$2C1A
01229 0382                      2C00            .word	$2C00
01230 0384                        40            .byte	$40
01231 0385                  00000001            .blkb	1
01232                                           ! 635       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
01233 0386                      2D78            .word	$2D78
01234 0388                      2D58            .word	$2D58
01235 038A                      2D18            .word	$2D18
01236 038C                      2D00            .word	$2D00
01237 038E                        40            .byte	$40
01238 038F                  00000001            .blkb	1
01239                                           ! 636       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
01240 0390                      2E63            .word	$2E63
01241 0392                      2E43            .word	$2E43
01242 0394                      2E03            .word	$2E03
01243 0396                      2E00            .word	$2E00
01244 0398                        40            .byte	$40
01245 0399                  00000001            .blkb	1
01246                                           ! 637       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
01247 039A                      2F76            .word	$2F76
01248 039C                      2F56            .word	$2F56
01249 039E                      2F16            .word	$2F16
01250 03A0                      2F00            .word	$2F00
01251 03A2                        40            .byte	$40
01252 03A3                  00000001            .blkb	1
01253                                           ! 638       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
01254 03A4                      3062            .word	$3062
01255 03A6                      3042            .word	$3042
01256 03A8                      3002            .word	$3002
01257 03AA                      3000            .word	$3000
01258 03AC                        40            .byte	$40
01259 03AD                  00000001            .blkb	1
01260                                           ! 639       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
01261 03AE                      316E            .word	$316E
01262 03B0                      314E            .word	$314E
01263 03B2                      310E            .word	$310E
01264 03B4                      3100            .word	$3100
01265 03B6                        40            .byte	$40
01266 03B7                  00000001            .blkb	1
01267                                           ! 640       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
01268 03B8                      326D            .word	$326D
01269 03BA                      324D            .word	$324D
01270 03BC                      320D            .word	$320D
01271 03BE                      3200            .word	$3200
01272 03C0                        40            .byte	$40
01273 03C1                  00000001            .blkb	1
01274                                           ! 641       { 0x332c, 0x333c, 0, 0, 0 },
01275 03C2                      332C            .word	$332C
01276 03C4                      333C            .word	$333C
01277 03C6                      0000            .word	0
01278 03C8                      0000            .word	0
01279 03CA                        00            .byte	0
01280 03CB                  00000001            .blkb	1
01281                                           ! 642       { 0x342e, 0x343e, 0, 0, 0 },
01282 03CC                      342E            .word	$342E
01283 03CE                      343E            .word	$343E
01284 03D0                      0000            .word	0
01285 03D2                      0000            .word	0
01286 03D4                        00            .byte	0
01287 03D5                  00000001            .blkb	1
01288                                           ! 643       { 0x352f, 0x353f, 0, 0, 0 },
01289 03D6                      352F            .word	$352F
01290 03D8                      353F            .word	$353F
01291 03DA                      0000            .word	0
01292 03DC                      0000            .word	0
01293 03DE                        00            .byte	0
01294 03DF                  00000001            .blkb	1
01295                                           ! 644       { 0, 0, 0, 0, 0 },
01296 03E0                      0000            .word	0
01297 03E2                      0000            .word	0
01298 03E4                      0000            .word	0
01299 03E6                      0000            .word	0
01300 03E8                        00            .byte	0
01301 03E9                  00000001            .blkb	1
01302                                           ! 645       { 0x372a, 0x372a, 0, 0, 0 },
01303 03EA                      372A            .word	$372A
01304 03EC                      372A            .word	$372A
01305 03EE                      0000            .word	0
01306 03F0                      0000            .word	0
01307 03F2                        00            .byte	0
01308 03F3                  00000001            .blkb	1
01309                                           ! 646       { 0, 0, 0, 0, 0 },
01310 03F4                      0000            .word	0
01311 03F6                      0000            .word	0
01312 03F8                      0000            .word	0
01313 03FA                      0000            .word	0
01314 03FC                        00            .byte	0
01315 03FD                  00000001            .blkb	1
01316                                           ! 647       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
01317 03FE                      3920            .word	$3920
01318 0400                      3920            .word	$3920
01319 0402                      3920            .word	$3920
01320 0404                      3920            .word	$3920
01321 0406                        00            .byte	0
01322 0407                  00000001            .blkb	1
01323                                           ! 648       { 0, 0, 0, 0, 0 },
01324 0408                      0000            .word	0
01325 040A                      0000            .word	0
01326 040C                      0000            .word	0
01327 040E                      0000            .word	0
01328 0410                        00            .byte	0
01329 0411                  00000001            .blkb	1
01330                                           ! 649       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
01331 0412                      3B00            .word	$3B00
01332 0414                      5400            .word	$5400
01333 0416                      5E00            .word	$5E00
01334 0418                      6800            .word	$6800
01335 041A                        00            .byte	0
01336 041B                  00000001            .blkb	1
01337                                           ! 650       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
01338 041C                      3C00            .word	$3C00
01339 041E                      5500            .word	$5500
01340 0420                      5F00            .word	$5F00
01341 0422                      6900            .word	$6900
01342 0424                        00            .byte	0
01343 0425                  00000001            .blkb	1
01344                                           ! 651       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
01345 0426                      3D00            .word	$3D00
01346 0428                      5600            .word	$5600
01347 042A                      6000            .word	$6000
01348 042C                      6A00            .word	$6A00
01349 042E                        00            .byte	0
01350 042F                  00000001            .blkb	1
01351                                           ! 652       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
01352 0430                      3E00            .word	$3E00
01353 0432                      5700            .word	$5700
01354 0434                      6100            .word	$6100
01355 0436                      6B00            .word	$6B00
01356 0438                        00            .byte	0
01357 0439                  00000001            .blkb	1
01358                                           ! 653       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
01359 043A                      3F00            .word	$3F00
01360 043C                      5800            .word	$5800
01361 043E                      6200            .word	$6200
01362 0440                      6C00            .word	$6C00
01363 0442                        00            .byte	0
01364 0443                  00000001            .blkb	1
01365                                           ! 654       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
01366 0444                      4000            .word	$4000
01367 0446                      5900            .word	$5900
01368 0448                      6300            .word	$6300
01369 044A                      6D00            .word	$6D00
01370 044C                        00            .byte	0
01371 044D                  00000001            .blkb	1
01372                                           ! 655       { 0x4100, 0x5a00, 0x6400, 0x6
01373 044E                      4100            .word	$4100
01374 0450                      5A00            .word	$5A00
01375 0452                      6400            .word	$6400
01376                                           ! 655 e00, 0 },
01377 0454                      6E00            .word	$6E00
01378 0456                        00            .byte	0
01379 0457                  00000001            .blkb	1
01380                                           ! 656       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
01381 0458                      4200            .word	$4200
01382 045A                      5B00            .word	$5B00
01383 045C                      6500            .word	$6500
01384 045E                      6F00            .word	$6F00
01385 0460                        00            .byte	0
01386 0461                  00000001            .blkb	1
01387                                           ! 657       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
01388 0462                      4300            .word	$4300
01389 0464                      5C00            .word	$5C00
01390 0466                      6600            .word	$6600
01391 0468                      7000            .word	$7000
01392 046A                        00            .byte	0
01393 046B                  00000001            .blkb	1
01394                                           ! 658       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
01395 046C                      4400            .word	$4400
01396 046E                      5D00            .word	$5D00
01397 0470                      6700            .word	$6700
01398 0472                      7100            .word	$7100
01399 0474                        00            .byte	0
01400 0475                  00000001            .blkb	1
01401                                           ! 659       { 0, 0, 0, 0, 0 },
01402 0476                      0000            .word	0
01403 0478                      0000            .word	0
01404 047A                      0000            .word	0
01405 047C                      0000            .word	0
01406 047E                        00            .byte	0
01407 047F                  00000001            .blkb	1
01408                                           ! 660       { 0, 0, 0, 0, 0 },
01409 0480                      0000            .word	0
01410 0482                      0000            .word	0
01411 0484                      0000            .word	0
01412 0486                      0000            .word	0
01413 0488                        00            .byte	0
01414 0489                  00000001            .blkb	1
01415                                           ! 661       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
01416 048A                      4700            .word	$4700
01417 048C                      4737            .word	$4737
01418 048E                      7700            .word	$7700
01419 0490                      0000            .word	0
01420 0492                        20            .byte	$20
01421 0493                  00000001            .blkb	1
01422                                           ! 662       { 0x4800, 0x4838, 0, 0, 0x20 },
01423 0494                      4800            .word	$4800
01424 0496                      4838            .word	$4838
01425 0498                      0000            .word	0
01426 049A                      0000            .word	0
01427 049C                        20            .byte	$20
01428 049D                  00000001            .blkb	1
01429                                           ! 663       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
01430 049E                      4900            .word	$4900
01431 04A0                      4939            .word	$4939
01432 04A2                      8400            .word	$8400
01433 04A4                      0000            .word	0
01434 04A6                        20            .byte	$20
01435 04A7                  00000001            .blkb	1
01436                                           ! 664       { 0x4a2d, 0x4a2d, 0, 0, 0 },
01437 04A8                      4A2D            .word	$4A2D
01438 04AA                      4A2D            .word	$4A2D
01439 04AC                      0000            .word	0
01440 04AE                      0000            .word	0
01441 04B0                        00            .byte	0
01442 04B1                  00000001            .blkb	1
01443                                           ! 665       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
01444 04B2                      4B00            .word	$4B00
01445 04B4                      4B34            .word	$4B34
01446 04B6                      7300            .word	$7300
01447 04B8                      0000            .word	0
01448 04BA                        20            .byte	$20
01449 04BB                  00000001            .blkb	1
01450                                           ! 666       { 0x4c00, 0x4c35, 0, 0, 0x20 },
01451 04BC                      4C00            .word	$4C00
01452 04BE                      4C35            .word	$4C35
01453 04C0                      0000            .word	0
01454 04C2                      0000            .word	0
01455 04C4                        20            .byte	$20
01456 04C5                  00000001            .blkb	1
01457                                           ! 667       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
01458 04C6                      4D00            .word	$4D00
01459 04C8                      4D36            .word	$4D36
01460 04CA                      7400            .word	$7400
01461 04CC                      0000            .word	0
01462 04CE                        20            .byte	$20
01463 04CF                  00000001            .blkb	1
01464                                           ! 668       { 0x4e2b, 0x4e2b, 0, 0, 0 },
01465 04D0                      4E2B            .word	$4E2B
01466 04D2                      4E2B            .word	$4E2B
01467 04D4                      0000            .word	0
01468 04D6                      0000            .word	0
01469 04D8                        00            .byte	0
01470 04D9                  00000001            .blkb	1
01471                                           ! 669       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
01472 04DA                      4F00            .word	$4F00
01473 04DC                      4F31            .word	$4F31
01474 04DE                      7500            .word	$7500
01475 04E0                      0000            .word	0
01476 04E2                        20            .byte	$20
01477 04E3                  00000001            .blkb	1
01478                                           ! 670       { 0x5000, 0x5032, 0, 0, 0x20 },
01479 04E4                      5000            .word	$5000
01480 04E6                      5032            .word	$5032
01481 04E8                      0000            .word	0
01482 04EA                      0000            .word	0
01483 04EC                        20            .byte	$20
01484 04ED                  00000001            .blkb	1
01485                                           ! 671       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
01486 04EE                      5100            .word	$5100
01487 04F0                      5133            .word	$5133
01488 04F2                      7600            .word	$7600
01489 04F4                      0000            .word	0
01490 04F6                        20            .byte	$20
01491 04F7                  00000001            .blkb	1
01492                                           ! 672       { 0x5200, 0x5230, 0, 0, 0x20 },
01493 04F8                      5200            .word	$5200
01494 04FA                      5230            .word	$5230
01495 04FC                      0000            .word	0
01496 04FE                      0000            .word	0
01497 0500                        20            .byte	$20
01498 0501                  00000001            .blkb	1
01499                                           ! 673       { 0x5300, 0x532e, 0, 0, 0x20 },
01500 0502                      5300            .word	$5300
01501 0504                      532E            .word	$532E
01502 0506                      0000            .word	0
01503 0508                      0000            .word	0
01504 050A                        20            .byte	$20
01505 050B                  00000001            .blkb	1
01506                                           ! 674       { 0, 0, 0, 0, 0 },
01507 050C                      0000            .word	0
01508 050E                      0000            .word	0
01509 0510                      0000            .word	0
01510 0512                      0000            .word	0
01511 0514                        00            .byte	0
01512 0515                  00000001            .blkb	1
01513                                           ! 675       { 0, 0, 0, 0, 0 },
01514 0516                      0000            .word	0
01515 0518                      0000            .word	0
01516 051A                      0000            .word	0
01517 051C                      0000            .word	0
01518 051E                        00            .byte	0
01519 051F                  00000001            .blkb	1
01520                                           ! 676       { 0x565c, 0x567c, 0, 0, 0 },
01521 0520                      565C            .word	$565C
01522 0522                      567C            .word	$567C
01523 0524                      0000            .word	0
01524 0526                      0000            .word	0
01525 0528                        00            .byte	0
01526 0529                  00000001            .blkb	1
01527                                           ! 677       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
01528 052A                      8500            .word	$8500
01529 052C                      8700            .word	$8700
01530 052E                      8900            .word	$8900
01531 0530                      8B00            .word	$8B00
01532 0532                        00            .byte	0
01533 0533                  00000001            .blkb	1
01534                                           ! 678       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
01535 0534                      8600            .word	$8600
01536 0536                      8800            .word	$8800
01537 0538                      8A00            .word	$8A00
01538 053A                      8C00            .word	$8C00
01539 053C                        00            .byte	0
01540 053D                  00000001            .blkb	1
01541                                           ! 679       };
01542                                           !BCC_EOS
01543                                           ! 680   Bit8u
01544                                           ! 681 inb(port)
01545                                           ! 682   Bit16u port;
01546                                           
01547                                           export	_inb
01548                       0000053E            _inb:
01549                                           !BCC_EOS
01550                                           ! 683 {
01551                                           ! 684 #asm
01552                                           !BCC_ASM
01553                       00000002            _inb.port	set	2
01554 053E           55                           push bp
01555 053F           89E5                         mov bp, sp
01556 0541           52                             push dx
01557 0542           8B56         04                mov dx, 4[bp]
01558 0545           EC                             in al, dx
01559 0546           5A                             pop dx
01560 0547           5D                           pop bp
01561                                           ! 692 endasm
01562                                           !BCC_ENDASM
01563                                           ! 693 }
01564 0548           C3                         ret
01565                                           ! 694   Bit16u
01566                                           ! 695 inw(port)
01567                                           ! 696   Bit16u port;
01568                                           export	_inw
01569                       00000549            _inw:
01570                                           !BCC_EOS
01571                                           ! 697 {
01572                                           ! 698 #asm
01573                                           !BCC_ASM
01574                       00000002            _inw.port	set	2
01575 0549           55                           push bp
01576 054A           89E5                         mov bp, sp
01577 054C           52                             push dx
01578 054D           8B56         04                mov dx, 4[bp]
01579 0550           ED                             in ax, dx
01580 0551           5A                             pop dx
01581 0552           5D                           pop bp
01582                                           ! 706 endasm
01583                                           !BCC_ENDASM
01584                                           ! 707 }
01585 0553           C3                         ret
01586                                           ! 708   void
01587                                           ! 709 outb(port, val)
01588                                           ! 710   Bit16u port;
01589                                           export	_outb
01590                       00000554            _outb:
01591                                           !BCC_EOS
01592                                           ! 711   Bit8u val;
01593                                           !BCC_EOS
01594                                           ! 712 {
01595                                           ! 713 #asm
01596                                           !BCC_ASM
01597                       00000004            _outb.val	set	4
01598                       00000002            _outb.port	set	2
01599 0554           55                           push bp
01600 0555           89E5                         mov bp, sp
01601 0557           50                             push ax
01602 0558           52                             push dx
01603 0559           8B56         04                mov dx, 4[bp]
01604 055C           8A46         06                mov al, 6[bp]
01605 055F           EE                             out dx, al
01606 0560           5A                             pop dx
01607 0561           58                             pop ax
01608 0562           5D                           pop bp
01609                                           ! 724 endasm
01610                                           !BCC_ENDASM
01611                                           ! 725 }
01612 0563           C3                         ret
01613                                           ! 726   void
01614                                           ! 727 outw(port, val)
01615                                           ! 728   Bit16u port;
01616                                           export	_outw
01617                       00000564            _outw:
01618                                           !BCC_EOS
01619                                           ! 729   Bit16u val;
01620                                           !BCC_EOS
01621                                           ! 730 {
01622                                           ! 731 #asm
01623                                           !BCC_ASM
01624                       00000004            _outw.val	set	4
01625                       00000002            _outw.port	set	2
01626 0564           55                           push bp
01627 0565           89E5                         mov bp, sp
01628 0567           50                             push ax
01629 0568           52                             push dx
01630 0569           8B56         04                mov dx, 4[bp]
01631 056C           8B46         06                mov ax, 6[bp]
01632 056F           EF                             out dx, ax
01633 0570           5A                             pop dx
01634 0571           58                             pop ax
01635 0572           5D                           pop bp
01636                                           ! 742 endasm
01637                                           !BCC_ENDASM
01638                                           ! 743 }
01639 0573           C3                         ret
01640                                           ! 744   void
01641                                           ! 745 outb_cmos(cmos_reg, val)
01642                                           ! 746   Bit8u cmos_reg;
01643                                           export	_outb_cmos
01644                       00000574            _outb_cmos:
01645                                           !BCC_EOS
01646                                           ! 747   Bit8u val;
01647                                           !BCC_EOS
01648                                           ! 748 {
01649                                           ! 749 #asm
01650                                           !BCC_ASM
01651                       00000002            _outb_cmos.cmos_reg	set	2
01652                       00000004            _outb_cmos.val	set	4
01653 0574           55                           push bp
01654 0575           89E5                         mov bp, sp
01655 0577           8A46         04                mov al, 4[bp] ;; cmos_reg
01656 057A           E6                     70      out 0x70, al
01657 057C           8A46         06                mov al, 6[bp] ;; val
01658 057F           E6                     71      out 0x71, al
01659 0581           5D                           pop bp
01660                                           ! 757 endasm
01661                                           !BCC_ENDASM
01662                                           ! 758 }
01663 0582           C3                         ret
01664                                           ! 759   Bit8u
01665                                           ! 760 inb_cmos(cmos_reg)
01666                                           ! 761   Bit8u cmos_reg;
01667                                           export	_inb_cmos
01668                       00000583            _inb_cmos:
01669                                           !BCC_EOS
01670                                           ! 762 {
01671                                           ! 763 #asm
01672                                           !BCC_ASM
01673                       00000002            _inb_cmos.cmos_reg	set	2
01674 0583           55                           push bp
01675 0584           89E5                         mov bp, sp
01676 0586           8A46         04                mov al, 4[bp] ;; cmos_reg
01677 0589           E6                     70      out 0x70, al
01678 058B           E4                     71      in al, 0x71
01679 058D           5D                           pop bp
01680                                           ! 770 endasm
01681                                           !BCC_ENDASM
01682                                           ! 771 }
01683 058E           C3                         ret
01684                                           ! 772   void
01685                                           ! 773 init_rtc()
01686                                           ! 774 {
01687                                           export	_init_rtc
01688                       0000058F            _init_rtc:
01689                                           ! 775   outb_cmos(0x0a, 0x26);
01690 058F           55                         push	bp
01691 0590           89E5                       mov	bp,sp
01692                                           ! Debug: list int = const $26 (used reg = )
01693 0592           B8                   0026  mov	ax,*$26
01694 0595           50                         push	ax
01695                                           ! Debug: list int = const $A (used reg = )
01696 0596           B8                   000A  mov	ax,*$A
01697 0599           50                         push	ax
01698                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01699 059A           E8         FFD7            call	_outb_cmos
01700 059D           89EC                       mov	sp,bp
01701                                           !BCC_EOS
01702                                           ! 776   outb_cmos(0x0b, 0x02);
01703                                           ! Debug: list int = const 2 (used reg = )
01704 059F           B8                   0002  mov	ax,*2
01705 05A2           50                         push	ax
01706                                           ! Debug: list int = const $B (used reg = )
01707 05A3           B8                   000B  mov	ax,*$B
01708 05A6           50                         push	ax
01709                                           ! Debug: func () void = outb_cmos+0 (used reg = )
01710 05A7           E8         FFCA            call	_outb_cmos
01711 05AA           89EC                       mov	sp,bp
01712                                           !BCC_EOS
01713                                           ! 777   inb_cmos(0x0c);
01714                                           ! Debug: list int = const $C (used reg = )
01715 05AC           B8                   000C  mov	ax,*$C
01716 05AF           50                         push	ax
01717                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01718 05B0           E8         FFD0            call	_inb_cmos
01719 05B3           89EC                       mov	sp,bp
01720                                           !BCC_EOS
01721                                           ! 778   inb_cmos(0x0d);
01722                                           ! Debug: list int = const $D (used reg = )
01723 05B5           B8                   000D  mov	ax,*$D
01724 05B8           50                         push	ax
01725                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01726 05B9           E8         FFC7            call	_inb_cmos
01727 05BC           89EC                       mov	sp,bp
01728                                           !BCC_EOS
01729                                           ! 779 }
01730 05BE           5D                         pop	bp
01731 05BF           C3                         ret
01732                                           ! 780   bx_bool
01733                                           ! 781 rtc_u
01734                                           ! 781 pdating()
01735                                           ! 782 {
01736                                           export	_rtc_updating
01737                       000005C0            _rtc_updating:
01738                                           ! 783   Bit16u count;
01739                                           !BCC_EOS
01740                                           ! 784   count = 25000;
01741 05C0           55                         push	bp
01742 05C1           89E5                       mov	bp,sp
01743 05C3           4C                         dec	sp
01744 05C4           4C                         dec	sp
01745                                           ! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
01746 05C5           B8                   61A8  mov	ax,#$61A8
01747 05C8           8946         FE            mov	-2[bp],ax
01748                                           !BCC_EOS
01749                                           ! 785   while (--count != 0) {
01750 05CB           EB           15            jmp .3
01751                       000005CD            .4:
01752                                           ! 786     if ( (inb_cmos(0x0a) & 0x80) == 0 )
01753                                           ! Debug: list int = const $A (used reg = )
01754 05CD           B8                   000A  mov	ax,*$A
01755 05D0           50                         push	ax
01756                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
01757 05D1           E8         FFAF            call	_inb_cmos
01758 05D4           44                         inc	sp
01759 05D5           44                         inc	sp
01760                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
01761 05D6           24                     80  and	al,#$80
01762                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
01763 05D8           84C0                       test	al,al
01764 05DA           75           06            jne 	.5
01765                       000005DC            .6:
01766                                           ! 787       return(0);
01767 05DC           31C0                       xor	ax,ax
01768 05DE           89EC                       mov	sp,bp
01769 05E0           5D                         pop	bp
01770 05E1           C3                         ret
01771                                           !BCC_EOS
01772                                           ! 788     }
01773                       000005E2            .5:
01774                                           ! 789   return(1);
01775                       000005E2            .3:
01776                                           ! Debug: predec unsigned short count = [S+4-4] (used reg = )
01777 05E2           8B46         FE            mov	ax,-2[bp]
01778 05E5           48                         dec	ax
01779 05E6           8946         FE            mov	-2[bp],ax
01780                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
01781 05E9           85C0                       test	ax,ax
01782 05EB           75           E0            jne	.4
01783                       000005ED            .7:
01784                       000005ED            .2:
01785 05ED           B8                   0001  mov	ax,*1
01786 05F0           89EC                       mov	sp,bp
01787 05F2           5D                         pop	bp
01788 05F3           C3                         ret
01789                                           !BCC_EOS
01790                                           ! 790 }
01791                                           ! 791   Bit8u
01792                                           ! 792 read_byte(seg, offset)
01793                                           ! 793   Bit16u seg;
01794                                           export	_read_byte
01795                       000005F4            _read_byte:
01796                                           !BCC_EOS
01797                                           ! 794   Bit16u offset;
01798                                           !BCC_EOS
01799                                           ! 795 {
01800                                           ! 796 #asm
01801                                           !BCC_ASM
01802                       00000002            _read_byte.seg	set	2
01803                       00000004            _read_byte.offset	set	4
01804 05F4           55                           push bp
01805 05F5           89E5                         mov bp, sp
01806 05F7           53                             push bx
01807 05F8           1E                             push ds
01808 05F9           8B46         04                mov ax, 4[bp] ; segment
01809 05FC           8ED8                           mov ds, ax
01810 05FE           8B5E         06                mov bx, 6[bp] ; offset
01811 0601           8A07                           mov al, [bx]
01812                                               ;; al = return value (byte)
01813 0603           1F                             pop ds
01814 0604           5B                             pop bx
01815 0605           5D                           pop bp
01816                                           ! 809 endasm
01817                                           !BCC_ENDASM
01818                                           ! 810 }
01819 0606           C3                         ret
01820                                           ! 811   Bit16u
01821                                           ! 812 read_word(seg, offset)
01822                                           ! 813   Bit16u seg;
01823                                           export	_read_word
01824                       00000607            _read_word:
01825                                           !BCC_EOS
01826                                           ! 814   Bit16u offset;
01827                                           !BCC_EOS
01828                                           ! 815 {
01829                                           ! 816 #asm
01830                                           !BCC_ASM
01831                       00000002            _read_word.seg	set	2
01832                       00000004            _read_word.offset	set	4
01833 0607           55                           push bp
01834 0608           89E5                         mov bp, sp
01835 060A           53                             push bx
01836 060B           1E                             push ds
01837 060C           8B46         04                mov ax, 4[bp] ; segment
01838 060F           8ED8                           mov ds, ax
01839 0611           8B5E         06                mov bx, 6[bp] ; offset
01840 0614           8B07                           mov ax, [bx]
01841                                               ;; ax = return value (word)
01842 0616           1F                             pop ds
01843 0617           5B                             pop bx
01844 0618           5D                           pop bp
01845                                           ! 829 endasm
01846                                           !BCC_ENDASM
01847                                           ! 830 }
01848 0619           C3                         ret
01849                                           ! 831   void
01850                                           ! 832 write_byte(seg, offset, data)
01851                                           ! 833   Bit16u seg;
01852                                           export	_write_byte
01853                       0000061A            _write_byte:
01854                                           !BCC_EOS
01855                                           ! 834   Bit16u offset;
01856                                           !BCC_EOS
01857                                           ! 835   Bit8u data;
01858                                           !BCC_EOS
01859                                           ! 836 {
01860                                           ! 837 #asm
01861                                           !BCC_ASM
01862                       00000002            _write_byte.seg	set	2
01863                       00000006            _write_byte.data	set	6
01864                       00000004            _write_byte.offset	set	4
01865 061A           55                           push bp
01866 061B           89E5                         mov bp, sp
01867 061D           50                             push ax
01868 061E           53                             push bx
01869 061F           1E                             push ds
01870 0620           8B46         04                mov ax, 4[bp] ; segment
01871 0623           8ED8                           mov ds, ax
01872 0625           8B5E         06                mov bx, 6[bp] ; offset
01873 0628           8A46         08                mov al, 8[bp] ; data byte
01874 062B           8807                           mov [bx], al ; write data byte
01875 062D           1F                             pop ds
01876 062E           5B                             pop bx
01877 062F           58                             pop ax
01878 0630           5D                           pop bp
01879                                           ! 852 endasm
01880                                           !BCC_ENDASM
01881                                           ! 853 }
01882 0631           C3                         ret
01883                                           ! 854   void
01884                                           ! 855 write_word(seg, offset, data)
01885                                           ! 856   Bit16u seg;
01886                                           export	_write_word
01887                       00000632            _write_word:
01888                                           !BCC_EOS
01889                                           ! 857   Bit16u offset;
01890                                           !BCC_EOS
01891                                           ! 858   Bit16u data;
01892                                           !BCC_EOS
01893                                           ! 859 {
01894                                           ! 860 #asm
01895                                           !BCC_ASM
01896                       00000002            _write_word.seg	set	2
01897                       00000006            _write_word.data	set	6
01898                       00000004            _write_word.offset	set	4
01899 0632           55                           push bp
01900 0633           89E5                         mov bp, sp
01901 0635           50                             push ax
01902 0636           53                             push bx
01903 0637           1E                             push ds
01904 0638           8B46         04                mov ax, 4[bp] ; segment
01905 063B           8ED8                           mov ds, ax
01906 063D           8B5E         06                mov bx, 6[bp] ; offset
01907 0640           8B46         08                mov ax, 8[bp] ; data word
01908 0643           8907                           mov [bx], ax ; write data word
01909 0645           1F                             pop ds
01910 0646           5B                             pop bx
01911 0647           58                             pop ax
01912 0648           5D                           pop bp
01913                                           ! 875 endasm
01914                                           !BCC_ENDASM
01915                                           ! 876 }
01916 0649           C3                         ret
01917                                           ! 877   Bit16u
01918                                           ! 878 get_CS()
01919                                           ! 879 {
01920                                           export	_get_CS
01921                       0000064A            _get_CS:
01922                                           ! 880 #asm
01923                                           !BCC_ASM
01924 064A           8CC8                         mov ax, cs
01925                                           ! 882 endasm
01926                                           !BCC_ENDASM
01927                                           ! 883 }
01928 064C           C3                         ret
01929                                           ! 884   Bit16u
01930                                           ! 885 get_SS()
01931                                           ! 886 {
01932                                           export	_get_SS
01933                       0000064D            _get_SS:
01934                                           ! 887 #asm
01935                                           !BCC_ASM
01936 064D           8CD0                         mov ax, ss
01937                                           ! 889 endasm
01938                                           !BCC_ENDASM
01939                                           ! 890 }
01940 064F           C3                         ret
01941                                           ! 891 void
01942                                           ! 892 fixup_base_mem_in_k()
01943                                           ! 893 {
01944                                           export	_fixup_base_mem_in_k
01945                       00000650            _fixup_base_mem_in_k:
01946                                           ! 894   Bit32u base_mem = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 8);
01947 0650           55                         push	bp
01948 0651           89E5                       mov	bp,sp
01949 0653           83C4                   FC  add	sp,*-4
01950                                           ! Debug: list int = const $10 (used reg = )
01951 0656           B8                   0010  mov	ax,*$10
01952 0659           50                         push	ax
01953                                           ! Debug: list unsigned short = const $EA10 (used reg = )
01954 065A           B8                   EA10  mov	ax,#$EA10
01955 065D           50                         push	ax
01956                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
01957 065E           E8         FA22            call	_read_dword
01958 0661           89D3                       mov	bx,dx
01959 0663           83C4                   04  add	sp,*4
01960                                           ! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+6-6] (used reg = )
01961 0666           8946         FC            mov	-4[bp],ax
01962 0669           895E         FE            mov	-2[bp],bx
01963                                           !BCC_EOS
01964                                           ! 895   write_word(0x40, 0x13, base_mem >> 10);
01965                                           ! Debug: sr int = const $A to unsigned long base_mem = [S+6-6] (used reg = )
01966 066C           8B46         FC            mov	ax,-4[bp]
01967 066F           8B5E         FE            mov	bx,-2[bp]
01968 0672           88E0                       mov	al,ah
01969 0674           88DC                       mov	ah,bl
01970 0676           88FB                       mov	bl,bh
01971 0678           28FF                       sub	bh,bh
01972 067A           BF                   0002  mov	di,*2
01973 067D           E8         FAA9            call	lsrul
01974                                           ! Debug: list unsigned long = bx+0 (used reg = )
01975 0680           53                         push	bx
01976 0681           50                         push	ax
01977                                           ! Debug: list int = const $13 (used reg = )
01978 0682           B8                   0013  mov	ax,*$13
01979 0685           50                         push	ax
01980                                           ! Debug: list int = const $40 (used reg = )
01981 0686           B8                   0040  mov	ax,*$40
01982 0689           50                         push	ax
01983                                           ! Debug: func () void = write_word+0 (used reg = )
01984 068A           E8         FFA5            call	_write_word
01985 068D           83C4                   08  add	sp,*8
01986                                           !BCC_EOS
01987                                           ! 896 }
01988 0690           89EC                       mov	sp,bp
01989 0692           5D                         pop	bp
01990 0693           C3                         ret
01991                                           ! 897 void enable_rom_write_access()
01992                                           ! Register BX used in function fixup_base_mem_in_k
01993                                           ! 898 {
01994                                           export	_enable_rom_write_access
01995                       00000694            _enable_rom_write_access:
01996                                           ! 899     outb(0x10, 0);
01997 0694           55                         push	bp
01998 0695           89E5                       mov	bp,sp
01999                                           ! Debug: list int = const 0 (used reg = )
02000 0697           31C0                       xor	ax,ax
02001 0699           50                         push	ax
02002                                           ! Debug: list int = const $10 (used reg = )
02003 069A           B8                   0010  mov	ax,*$10
02004 069D           50                         push	ax
02005                                           ! Debug: func () void = outb+0 (used reg = )
02006 069E           E8         FEB3            call	_outb
02007 06A1           89EC                       mov	sp,bp
02008                                           !BCC_EOS
02009                                           ! 900 }
02010 06A3           5D                         pop	bp
02011 06A4           C3                         ret
02012                                           ! 901 void disable_rom_write_access()
02013                                           ! 902 {
02014                                           export	_disable_rom_write_access
02015                       000006A5            _disable_rom_write_access:
02016                                           ! 903     outb(0x10, 1);
02017 06A5           55                         push	bp
02018 06A6           89E5                       mov	bp,sp
02019                                           ! Debug: list int = const 1 (used reg = )
02020 06A8           B8                   0001  mov	ax,*1
02021 06AB           50                         push	ax
02022                                           ! Debug: list int = const $10 (used reg = )
02023 06AC           B8                   0010  mov	ax,*$10
02024 06AF           50                         push	ax
02025                                           ! Debug: func () void = outb+0 (used reg = )
02026 06B0           E8         FEA1            call	_outb
02027 06B3           89EC                       mov	sp,bp
02028                                           !BCC_EOS
02029                                           ! 904 }
02030 06B5           5D                         pop	bp
02031 06B6           C3                         ret
02032                                           ! 905   void
02033                                           ! 906 wrch(c)
02034                                           ! 907   Bit8u c;
02035                                           export	_wrch
02036                       000006B7            _wrch:
02037                                           !BCC_EOS
02038                                           ! 908 {
02039                                           ! 909 #asm
02040                                           !BCC_ASM
02041                       00000002            _wrch.c	set	2
02042 06B7           55                           push bp
02043 06B8           89E5                         mov bp, sp
02044 06BA           53                           push bx
02045 06BB           B4                     0E    mov ah, #0x0e
02046 06BD           8A46         04              mov al, 4[bp]
02047 06C0           31DB                         xor bx,bx
02048 06C2           CD                     10    int #0x10
02049 06C4           5B                           pop bx
02050 06C5           5D                           pop bp
02051                                           ! 919 endasm
02052                                           !BCC_ENDASM
02053                                           ! 920 }
02054 06C6           C3                         ret
02055                                           ! 921   void
02056                                           ! 922 send(action, c)
02057                                           ! 923   Bit16u action;
02058                                           export	_send
02059                       000006C7            _send:
02060                                           !BCC_EOS
02061                                           ! 924   Bit8u c;
02062                                           !BCC_EOS
02063                                           ! 925 {
02064                                           ! 926   outb(0xE9, c);
02065 06C7           55                         push	bp
02066 06C8           89E5                       mov	bp,sp
02067                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02068 06CA           8A46         06            mov	al,6[bp]
02069 06CD           30E4                       xor	ah,ah
02070 06CF           50                         push	ax
02071                                           ! Debug: list int = const $E9 (used reg = )
02072 06D0           B8                   00E9  mov	ax,#$E9
02073 06D3           50                         push	ax
02074                                           ! Debug: func () void = outb+0 (used reg = )
02075 06D4           E8         FE7D            call	_outb
02076 06D7           89EC                       mov	sp,bp
02077                                           !BCC_EOS
02078                                           ! 927   if (action & 8) outb(0x403, c);
02079                                           ! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
02080 06D9           8A46         04            mov	al,4[bp]
02081 06DC           24                     08  and	al,*8
02082 06DE           84C0                       test	al,al
02083 06E0           74           0F            je  	.8
02084                       000006E2            .9:
02085                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02086 06E2           8A46         06            mov	al,6[bp]
02087 06E5           30E4                       xor	ah,ah
02088 06E7           50                         push	ax
02089                                           ! Debug: list int = const $403 (used reg = )
02090 06E8           B8                   0403  mov	ax,#$403
02091 06EB           50                         push	ax
02092                                           ! Debug: func () void = outb+0 (used reg = )
02093 06EC           E8         FE65            call	_outb
02094 06EF           89EC                       mov	sp,bp
02095                                           !BCC_EOS
02096                                           ! 928   if (action & 4) outb(0x402, c);
02097                       000006F1            .8:
02098                                           ! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
02099 06F1           8A46         04            mov	al,4[bp]
02100 06F4           24                     04  and	al,*4
02101 06F6           84C0                       test	al,al
02102 06F8           74           0F            je  	.A
02103                       000006FA            .B:
02104                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02105 06FA           8A46         06            mov	al,6[bp]
02106 06FD           30E4                       xor	ah,ah
02107 06FF           50                         push	ax
02108                                           ! Debug: list int = const $402 (used reg = )
02109 0700           B8                   0402  mov	ax,#$402
02110 0703           50                         push	ax
02111                                           ! Debug: func () void = outb+0 (used reg = )
02112 0704           E8         FE4D            call	_outb
02113 0707           89EC                       mov	sp,bp
02114                                           !BCC_EOS
02115                                           ! 929   if (action & 2) {
02116                       00000709            .A:
02117                                           ! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
02118 0709           8A46         04            mov	al,4[bp]
02119 070C           24                     02  and	al,*2
02120 070E           84C0                       test	al,al
02121 0710           74           1B            je  	.C
02122                       00000712            .D:
02123                                           ! 930     if (c == '\n') wrc
02124                                           ! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
02125 0712           8A46         06            mov	al,6[bp]
02126 0715           3C                     0A  cmp	al,*$A
02127 0717           75           09            jne 	.E
02128                       00000719            .F:
02129                                           ! 930 h('\r');
02130                                           ! Debug: list int = const $D (used reg = )
02131 0719           B8                   000D  mov	ax,*$D
02132 071C           50                         push	ax
02133                                           ! Debug: func () void = wrch+0 (used reg = )
02134 071D           E8         FF97            call	_wrch
02135 0720           89EC                       mov	sp,bp
02136                                           !BCC_EOS
02137                                           ! 931     wrch(c);
02138                       00000722            .E:
02139                                           ! Debug: list unsigned char c = [S+2+4] (used reg = )
02140 0722           8A46         06            mov	al,6[bp]
02141 0725           30E4                       xor	ah,ah
02142 0727           50                         push	ax
02143                                           ! Debug: func () void = wrch+0 (used reg = )
02144 0728           E8         FF8C            call	_wrch
02145 072B           89EC                       mov	sp,bp
02146                                           !BCC_EOS
02147                                           ! 932   }
02148                                           ! 933 }
02149                       0000072D            .C:
02150 072D           5D                         pop	bp
02151 072E           C3                         ret
02152                                           ! 934   void
02153                                           ! 935 put_int(action, val, width, neg)
02154                                           ! 936   Bit16u action;
02155                                           export	_put_int
02156                       0000072F            _put_int:
02157                                           !BCC_EOS
02158                                           ! 937   short val, width;
02159                                           !BCC_EOS
02160                                           ! 938   bx_bool neg;
02161                                           !BCC_EOS
02162                                           ! 939 {
02163                                           ! 940   short nval = val / 10;
02164 072F           55                         push	bp
02165 0730           89E5                       mov	bp,sp
02166 0732           4C                         dec	sp
02167 0733           4C                         dec	sp
02168                                           ! Debug: div int = const $A to short val = [S+4+4] (used reg = )
02169 0734           8B46         06            mov	ax,6[bp]
02170 0737           BB                   000A  mov	bx,*$A
02171 073A           99                         cwd
02172 073B           F7FB                       idiv	bx
02173                                           ! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
02174 073D           8946         FE            mov	-2[bp],ax
02175                                           !BCC_EOS
02176                                           ! 941   if (nval)
02177 0740           8B46         FE            mov	ax,-2[bp]
02178 0743           85C0                       test	ax,ax
02179 0745         0F84         0016            beq 	.10
02180                       00000749            .11:
02181                                           ! 942     put_int(action, nval, width - 1, neg);
02182                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02183 0749           FF76         0A            push	$A[bp]
02184                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02185 074C           8B46         08            mov	ax,8[bp]
02186                                           ! Debug: list int = ax-1 (used reg = )
02187 074F           48                         dec	ax
02188 0750           50                         push	ax
02189                                           ! Debug: list short nval = [S+8-4] (used reg = )
02190 0751           FF76         FE            push	-2[bp]
02191                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02192 0754           FF76         04            push	4[bp]
02193                                           ! Debug: func () void = put_int+0 (used reg = )
02194 0757           E8         FFD5            call	_put_int
02195 075A           83C4                   08  add	sp,*8
02196                                           !BCC_EOS
02197                                           ! 943   else {
02198 075D           EB           2E            jmp .12
02199                       0000075F            .10:
02200                                           ! 944     while (--width > 0) send(action, ' ');
02201 075F           EB           0D            jmp .14
02202                       00000761            .15:
02203                                           ! Debug: list int = const $20 (used reg = )
02204 0761           B8                   0020  mov	ax,*$20
02205 0764           50                         push	ax
02206                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02207 0765           FF76         04            push	4[bp]
02208                                           ! Debug: func () void = send+0 (used reg = )
02209 0768           E8         FF5C            call	_send
02210 076B           83C4                   04  add	sp,*4
02211                                           !BCC_EOS
02212                                           ! 945     if (neg) send(action, '-');
02213                       0000076E            .14:
02214                                           ! Debug: predec short width = [S+4+6] (used reg = )
02215 076E           8B46         08            mov	ax,8[bp]
02216 0771           48                         dec	ax
02217 0772           8946         08            mov	8[bp],ax
02218                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02219 0775           85C0                       test	ax,ax
02220 0777           7F           E8            jg 	.15
02221                       00000779            .16:
02222                       00000779            .13:
02223 0779           8B46         0A            mov	ax,$A[bp]
02224 077C           85C0                       test	ax,ax
02225 077E           74           0D            je  	.17
02226                       00000780            .18:
02227                                           ! Debug: list int = const $2D (used reg = )
02228 0780           B8                   002D  mov	ax,*$2D
02229 0783           50                         push	ax
02230                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02231 0784           FF76         04            push	4[bp]
02232                                           ! Debug: func () void = send+0 (used reg = )
02233 0787           E8         FF3D            call	_send
02234 078A           83C4                   04  add	sp,*4
02235                                           !BCC_EOS
02236                                           ! 946   }
02237                       0000078D            .17:
02238                                           ! 947   send(action, val - (nval * 10) + '0');
02239                       0000078D            .12:
02240                                           ! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
02241 078D           8B46         FE            mov	ax,-2[bp]
02242 0790           89C2                       mov	dx,ax
02243 0792           D1E0                       shl	ax,*1
02244 0794           D1E0                       shl	ax,*1
02245 0796           01D0                       add	ax,dx
02246 0798           D1E0                       shl	ax,*1
02247                                           ! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
02248 079A           50                         push	ax
02249 079B           8B46         06            mov	ax,6[bp]
02250 079E           2B46         FC            sub	ax,-4[bp]
02251 07A1           44                         inc	sp
02252 07A2           44                         inc	sp
02253                                           ! Debug: add int = const $30 to int = ax+0 (used reg = )
02254                                           ! Debug: list int = ax+$30 (used reg = )
02255 07A3           05                   0030  add	ax,*$30
02256 07A6           50                         push	ax
02257                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02258 07A7           FF76         04            push	4[bp]
02259                                           ! Debug: func () void = send+0 (used reg = )
02260 07AA           E8         FF1A            call	_send
02261 07AD           83C4                   04  add	sp,*4
02262                                           !BCC_EOS
02263                                           ! 948 }
02264 07B0           89EC                       mov	sp,bp
02265 07B2           5D                         pop	bp
02266 07B3           C3                         ret
02267                                           ! 949   void
02268                                           ! Register BX used in function put_int
02269                                           ! 950 put_uint(action, val, width, neg)
02270                                           ! 951   Bit16u action;
02271                                           export	_put_uint
02272                       000007B4            _put_uint:
02273                                           !BCC_EOS
02274                                           ! 952   unsigned short val;
02275                                           !BCC_EOS
02276                                           ! 953   short width;
02277                                           !BCC_EOS
02278                                           ! 954   bx_bool neg;
02279                                           !BCC_EOS
02280                                           ! 955 {
02281                                           ! 956   unsigned short nval = val / 10;
02282 07B4           55                         push	bp
02283 07B5           89E5                       mov	bp,sp
02284 07B7           4C                         dec	sp
02285 07B8           4C                         dec	sp
02286                                           ! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
02287 07B9           8B46         06            mov	ax,6[bp]
02288 07BC           BB                   000A  mov	bx,*$A
02289 07BF           E8         F9A7            call	idiv_u
02290                                           ! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
02291 07C2           8946         FE            mov	-2[bp],ax
02292                                           !BCC_EOS
02293                                           ! 957   if (nval)
02294 07C5           8B46         FE            mov	ax,-2[bp]
02295 07C8           85C0                       test	ax,ax
02296 07CA           74           16            je  	.19
02297                       000007CC            .1A:
02298                                           ! 958     put_uint(action, nval, width - 1, neg);
02299                                           ! Debug: list unsigned short neg = [S+4+8] (used reg = )
02300 07CC           FF76         0A            push	$A[bp]
02301                                           ! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
02302 07CF           8B46         08            mov	ax,8[bp]
02303                                           ! Debug: list int = ax-1 (used reg = )
02304 07D2           48                         dec	ax
02305 07D3           50                         push	ax
02306                                           ! Debug: list unsigned short nval = [S+8-4] (used reg = )
02307 07D4           FF76         FE            push	-2[bp]
02308                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02309 07D7           FF76         04            push	4[bp]
02310                                           ! Debug: func () void = put_uint+0 (used reg = )
02311 07DA           E8         FFD7            call	_put_uint
02312 07DD           83C4                   08  add	sp,*8
02313                                           !BCC_EOS
02314                                           ! 959   else {
02315 07E0           EB           2E            jmp .1B
02316                       000007E2            .19:
02317                                           ! 960     while (--width > 0) send(action, ' ');
02318 07E2           EB           0D            jmp .1D
02319                       000007E4            .1E:
02320                                           ! Debug: list int = const $20 (used reg = )
02321 07E4           B8                   0020  mov	ax,*$20
02322 07E7           50                         push	ax
02323                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02324 07E8           FF76         04            push	4[bp]
02325                                           ! Debug: func () void = send+0 (used reg = )
02326 07EB           E8         FED9            call	_send
02327 07EE           83C4                   04  add	sp,*4
02328                                           !BCC_EOS
02329                                           ! 961     if (neg) send(action, '-');
02330                       000007F1            .1D:
02331                                           ! Debug: predec short width = [S+4+6] (used reg = )
02332 07F1           8B46         08            mov	ax,8[bp]
02333 07F4           48                         dec	ax
02334 07F5           8946         08            mov	8[bp],ax
02335                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02336 07F8           85C0                       test	ax,ax
02337 07FA           7F           E8            jg 	.1E
02338                       000007FC            .1F:
02339                       000007FC            .1C:
02340 07FC           8B46         0A            mov	ax,$A[bp]
02341 07FF           85C0                       test	ax,ax
02342 0801           74           0D            je  	.20
02343                       00000803            .21:
02344                                           ! Debug: list int = const $2D (used reg = )
02345 0803           B8                   002D  mov	ax,*$2D
02346 0806           50                         push	ax
02347                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02348 0807           FF76         04            push	4[bp]
02349                                           ! Debug: func () void = send+0 (used reg = )
02350 080A           E8         FEBA            call	_send
02351 080D           83C4                   04  add	sp,*4
02352                                           !BCC_EOS
02353                                           ! 962   }
02354                       00000810            .20:
02355                                           ! 963   send(action, val - (nval * 10) + '0');
02356                       00000810            .1B:
02357                                           ! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
02358 0810           8B46         FE            mov	ax,-2[bp]
02359 0813           89C2                       mov	dx,ax
02360 0815           D1E0                       shl	ax,*1
02361 0817           D1E0                       shl	ax,*1
02362 0819           01D0                       add	ax,dx
02363 081B           D1E0                       shl	ax,*1
02364                                           ! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
02365 081D           50                         push	ax
02366 081E           8B46         06            mov	ax,6[bp]
02367 0821           2B46         FC            sub	ax,-4[bp]
02368 0824           44                         inc	sp
02369 0825           44                         inc	sp
02370                                           ! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
02371                                           ! Debug: list unsigned int = ax+$30 (used reg = )
02372 0826           05                   0030  add	ax,*$30
02373 0829           50                         push	ax
02374                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02375 082A           FF76         04            push	4[bp]
02376                                           ! Debug: func () void = send+0 (used reg = )
02377 082D           E8         FE97            call	_send
02378 0830           83C4                   04  add	sp,*4
02379                                           !BCC_EOS
02380                                           ! 964 }
02381 0833           89EC                       mov	sp,bp
02382 0835           5D                         pop	bp
02383 0836           C3                         ret
02384                                           ! 965   void
02385                                           ! Register BX used in function put_uint
02386                                           ! 966 put_luint(action, val, width, neg)
02387                                           ! 967   Bit16u action;
02388                                           export	_put_luint
02389                       00000837            _put_luint:
02390                                           !BCC_EOS
02391                                           ! 968   unsigned long val;
02392                                           !BCC_EOS
02393                                           ! 969   short width;
02394                                           !BCC_EOS
02395                                           ! 970   bx_bool neg;
02396                                           !BCC_EOS
02397                                           ! 971 {
02398                                           ! 972   unsigned long nval = val / 10;
02399 0837           55                         push	bp
02400 0838           89E5                       mov	bp,sp
02401 083A           83C4                   FC  add	sp,*-4
02402                                           ! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
02403 083D           B8                   000A  mov	ax,*$A
02404 0840           31DB                       xor	bx,bx
02405 0842           53                         push	bx
02406 0843           50                         push	ax
02407 0844           8B46         06            mov	ax,6[bp]
02408 0847           8B5E         08            mov	bx,8[bp]
02409 084A           8D7E         F8            lea	di,-8[bp]
02410 084D           E8         F91E            call	ldivul
02411 0850           83C4                   04  add	sp,*4
02412                                           ! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
02413 0853           8946         FC            mov	-4[bp],ax
02414 0856           895E         FE            mov	-2[bp],bx
02415                                           !BCC_EOS
02416                                           ! 973   if (nval)
02417 0859           8B46         FC            mov	ax,-4[bp]
02418 085C           8B5E         FE            mov	bx,-2[bp]
02419 085F           E8         F8B2            call	ltstl
02420 0862           74           19            je  	.22
02421                       00000864            .23:
02422                                           ! 974     put_luint(action, nval, width - 1, neg);
02423                                           ! Debug: list unsigned short neg = [S+6+$A] (used reg = )
02424 0864           FF76         0C            push	$C[bp]
02425                                           ! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
02426 0867           8B46         0A            mov	ax,$A[bp]
02427                                           ! Debug: list int = ax-1 (used reg = )
02428 086A           48                         dec	ax
02429 086B           50                         push	ax
02430                                           ! Debug: list unsigned long nval = [S+$A-6] (used reg = )
02431 086C           FF76         FE            push	-2[bp]
02432 086F           FF76         FC            push	-4[bp]
02433                                           ! Debug: list unsigned short action = [S+$E+2] (used reg = )
02434 0872           FF76         04            push	4[bp]
02435                                           ! Debug: func () void = put_luint+0 (used reg = )
02436 0875           E8         FFBF            call	_put_luint
02437 0878           83C4                   0A  add	sp,*$A
02438                                           !BCC_EOS
02439                                           ! 975   else {
02440 087B           EB           2E            jmp .24
02441                       0000087D            .22:
02442                                           ! 976     while (--width > 0) send(action, ' ');
02443 087D           EB           0D            jmp .26
02444                       0000087F            .27:
02445                                           ! Debug: list int = const $20 (used reg = )
02446 087F           B8                   0020  mov	ax,*$20
02447 0882           50                         push	ax
02448                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02449 0883           FF76         04            push	4[bp]
02450                                           ! Debug: func () void = send+0 (used reg = )
02451 0886           E8         FE3E            call	_send
02452 0889           83C4                   04  add	sp,*4
02453                                           !BCC_EOS
02454                                           ! 977     if (neg) send(action, '-');
02455                       0000088C            .26:
02456                                           ! Debug: predec short width = [S+6+8] (used reg = )
02457 088C           8B46         0A            mov	ax,$A[bp]
02458 088F           48                         dec	ax
02459 0890           8946         0A            mov	$A[bp],ax
02460                                           ! Debug: gt int = const 0 to short = ax+0 (used reg = )
02461 0893           85C0                       test	ax,ax
02462 0895           7F           E8            jg 	.27
02463                       00000897            .28:
02464                       00000897            .25:
02465 0897           8B46         0C            mov	ax,$C[bp]
02466 089A           85C0                       test	ax,ax
02467 089C           74           0D            je  	.29
02468                       0000089E            .2A:
02469                                           ! Debug: list int = const $2D (used reg = )
02470 089E           B8                   002D  mov	ax,*$2D
02471 08A1           50                         push	ax
02472                                           ! Debug: list unsigned short action = [S+8+2] (used reg = )
02473 08A2           FF76         04            push	4[bp]
02474                                           ! Debug: func () void = send+0 (used reg = )
02475 08A5           E8         FE1F            call	_send
02476 08A8           83C4                   04  add	sp,*4
02477                                           !BCC_EOS
02478                                           ! 978   }
02479                       000008AB            .29:
02480                                           ! 979   send(action, val - (nval * 10) + '0');
02481                       000008AB            .24:
02482                                           ! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
02483                                           ! Debug: expression subtree swapping
02484 08AB           B8                   000A  mov	ax,*$A
02485 08AE           31DB                       xor	bx,bx
02486 08B0           8D7E         FC            lea	di,-4[bp]
02487 08B3           E8         F833            call	lmulul
02488                                           ! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
02489 08B6           53                         push	bx
02490 08B7           50                         push	ax
02491 08B8           8B46         06            mov	ax,6[bp]
02492 08BB           8B5E         08            mov	bx,8[bp]
02493 08BE           8D7E         F8            lea	di,-8[bp]
02494 08C1           E8         F81D            call	lsubul
02495 08C4           83C4                   04  add	sp,*4
02496                                           ! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
02497 08C7           53                         push	bx
02498 08C8           50                         push	ax
02499 08C9           B8                   0030  mov	ax,*$30
02500 08CC           31DB                       xor	bx,bx
02501 08CE           53                         push	bx
02502 08CF           50                         push	ax
02503 08D0           8B46         F8            mov	ax,-8[bp]
02504 08D3           8B5E         FA            mov	bx,-6[bp]
02505 08D6           8D7E         F4            lea	di,-$C[bp]
02506 08D9           E8         F7E7            call	laddul
02507 08DC           83C4                   08  add	sp,*8
02508                                           ! Debug: list unsigned long = bx+0 (used reg = )
02509 08DF           53                         push	bx
02510 08E0           50                         push	ax
02511                                           ! Debug: list unsigned short action = [S+$A+2] (used reg = )
02512 08E1           FF76         04            push	4[bp]
02513                                           ! Debug: func () void = send+0 (used reg = )
02514 08E4           E8         FDE0            call	_send
02515 08E7           83C4                   06  add	sp,*6
02516                                           !BCC_EOS
02517                                           ! 980 }
02518 08EA           89EC                       mov	sp,bp
02519 08EC           5D                         pop	bp
02520 08ED           C3                         ret
02521                                           ! 981 void put_str(action, segment, offset)
02522                                           ! Register BX used in function put_luint
02523                                           ! 982   Bit16u action;
02524                                           export	_put_str
02525                       000008EE            _put_str:
02526                                           !BCC_EOS
02527                                           ! 983   Bit16u segment;
02528                                           !BCC_EOS
02529                                           ! 984   Bit16u offset;
02530                                           !BCC_EOS
02531                                           ! 985 {
02532                                           ! 986   Bit8u c;
02533                                           !BCC_EOS
02534                                           ! 987   while (c = read_byte(segment, offset)) {
02535 08EE           55                         push	bp
02536 08EF           89E5                       mov	bp,sp
02537 08F1           4C                         dec	sp
02538 08F2           4C                         dec	sp
02539 08F3           EB           16            jmp .2C
02540                       000008F5            .2D:
02541                                           ! 988     send(action, c);
02542                                           ! Debug: list unsigned char c = [S+4-3] (used reg = )
02543 08F5           8A46         FF            mov	al,-1[bp]
02544 08F8           30E4                       xor	ah,ah
02545 08FA           50                         push	ax
02546                                           ! Debug: list unsigned short action = [S+6+2] (used reg = )
02547 08FB           FF76         04            push	4[bp]
02548                                           ! Debug: func () void = send+0 (used reg = )
02549 08FE           E8         FDC6            call	_send
02550 0901           83C4                   04  add	sp,*4
02551                                           !BCC_EOS
02552                                           ! 989     offset++;
02553                                           ! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
02554 0904           8B46         08            mov	ax,8[bp]
02555 0907           40                         inc	ax
02556 0908           8946         08            mov	8[bp],ax
02557                                           !BCC_EOS
02558                                           ! 990   }
02559                                           ! 991 }
02560                       0000090B            .2C:
02561                                           ! Debug: list unsigned short offset = [S+4+6] (used reg = )
02562 090B           FF76         08            push	8[bp]
02563                                           ! Debug: list unsigned short segment = [S+6+4] (used reg = )
02564 090E           FF76         06            push	6[bp]
02565                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
02566 0911           E8         FCE0            call	_read_byte
02567 0914           83C4                   04  add	sp,*4
02568                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
02569 0917           8846         FF            mov	-1[bp],al
02570 091A           84C0                       test	al,al
02571 091C           75           D7            jne	.2D
02572                       0000091E            .2E:
02573                       0000091E            .2B:
02574 091E           89EC                       mov	sp,bp
02575 0920           5D                         pop	bp
02576 0921           C3                         ret
02577                                           ! 992   void
02578                                           ! 993 delay_ticks(ticks)
02579                                           ! 994   Bit16u ticks;
02580                                           export	_delay_ticks
02581                       00000922            _delay_ticks:
02582                                           !BCC_EOS
02583                                           ! 995 {
02584                                           ! 996   long ticks_to_wait, delta;
02585                                           !BCC_EOS
02586                                           ! 997   Bit32u prev_ticks, t;
02587                                           !BCC_EOS
02588                                           ! 998 #asm
02589 0922           55                         push	bp
02590 0923           89E5                       mov	bp,sp
02591 0925           83C4                   F0  add	sp,*-$10
02592                                           !BCC_EOS
02593                                           !BCC_ASM
02594                       00000014            _delay_ticks.ticks	set	$14
02595                       00000004            .delay_ticks.ticks	set	4
02596                       00000000            _delay_ticks.t	set	0
02597                       FFFFFFF0            .delay_ticks.t	set	-$10
02598                       00000004            _delay_ticks.prev_ticks	set	4
02599                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02600                       00000008            _delay_ticks.delta	set	8
02601                       FFFFFFF8            .delay_ticks.delta	set	-8
02602                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02603                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02604 0928           9C                           pushf
02605 0929           FB                           sti
02606                                           ! 1001 endasm
02607                                           !BCC_ENDASM
02608                                           !BCC_EOS
02609                                           ! 1002   ticks_to_wait = ticks;
02610                                           ! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
02611 092A           8B46         04            mov	ax,4[bp]
02612 092D           31DB                       xor	bx,bx
02613 092F           8946         FC            mov	-4[bp],ax
02614 0932           895E         FE            mov	-2[bp],bx
02615                                           !BCC_EOS
02616                                           ! 1003   prev_ticks = read_dword(0x0, 0x46c);
02617                                           ! Debug: list int = const $46C (used reg = )
02618 0935           B8                   046C  mov	ax,#$46C
02619 0938           50                         push	ax
02620                                           ! Debug: list int = const 0 (used reg = )
02621 0939           31C0                       xor	ax,ax
02622 093B           50                         push	ax
02623                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02624 093C           E8         F744            call	_read_dword
02625 093F           89D3                       mov	bx,dx
02626 0941           83C4                   04  add	sp,*4
02627                                           ! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02628 0944           8946         F4            mov	-$C[bp],ax
02629 0947           895E         F6            mov	-$A[bp],bx
02630                                           !BCC_EOS
02631                                           ! 1004   do
02632                                           ! 1005   {
02633                       0000094A            .31:
02634                                           ! 1006 #asm
02635                                           !BCC_EOS
02636                                           !BCC_ASM
02637                       00000014            _delay_ticks.ticks	set	$14
02638                       00000004            .delay_ticks.ticks	set	4
02639                       00000000            _delay_ticks.t	set	0
02640                       FFFFFFF0            .delay_ticks.t	set	-$10
02641                       00000004            _delay_ticks.prev_ticks	set	4
02642                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02643                       00000008            _delay_ticks.delta	set	8
02644                       FFFFFFF8            .delay_ticks.delta	set	-8
02645                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02646                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02647 094A           F4                             hlt
02648                                           ! 1008 endasm
02649                                           !BCC_ENDASM
02650                                           !BCC_EOS
02651                                           ! 1009     t = read_dword(0x0, 0x46c);
02652                                           ! Debug: list int = const $46C (used reg = )
02653 094B           B8                   046C  mov	ax,#$46C
02654 094E           50                         push	ax
02655                                           ! Debug: list int = const 0 (used reg = )
02656 094F           31C0                       xor	ax,ax
02657 0951           50                         push	ax
02658                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
02659 0952           E8         F72E            call	_read_dword
02660 0955           89D3                       mov	bx,dx
02661 0957           83C4                   04  add	sp,*4
02662                                           ! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
02663 095A           8946         F0            mov	-$10[bp],ax
02664 095D           895E         F2            mov	-$E[bp],bx
02665                                           !BCC_EOS
02666                                           ! 1010     if (t > prev_ticks)
02667                                           ! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02668 0960           8B46         F4            mov	ax,-$C[bp]
02669 0963           8B5E         F6            mov	bx,-$A[bp]
02670 0966           8D7E         F0            lea	di,-$10[bp]
02671 0969           E8         F75F            call	lcmpul
02672 096C           73           26            jae 	.32
02673                       0000096E            .33:
02674                                           ! 1011     {
02675                                           ! 1012       delta = t - prev_ticks;
02676                                           ! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02677 096E           8B46         F0            mov	ax,-$10[bp]
02678 0971           8B5E         F2            mov	bx,-$E[bp]
02679 0974           8D7E         F4            lea	di,-$C[bp]
02680 0977           E8         F767            call	lsubul
02681                                           ! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
02682 097A           8946         F8            mov	-8[bp],ax
02683 097D           895E         FA            mov	-6[bp],bx
02684                                           !BCC_EOS
02685                                           ! 1013       ticks_to_wait -= delta;
02686                                           ! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
02687 0980           8B46         FC            mov	ax,-4[bp]
02688 0983           8B5E         FE            mov	bx,-2[bp]
02689 0986           8D7E         F8            lea	di,-8[bp]
02690 0989           E8         F755            call	lsubl
02691 098C           8946         FC            mov	-4[bp],ax
02692 098F           895E         FE            mov	-2[bp],bx
02693                                           !BCC_EOS
02694                                           ! 1014     }
02695                                           ! 1015     else if (t < prev_ticks)
02696 0992           EB           20            jmp .34
02697                       00000994            .32:
02698                                           ! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
02699 0994           8B46         F4            mov	ax,-$C[bp]
02700 0997           8B5E         F6            mov	bx,-$A[bp]
02701 099A           8D7E         F0            lea	di,-$10[bp]
02702 099D           E8         F72B            call	lcmpul
02703 09A0           76           12            jbe 	.35
02704                       000009A2            .36:
02705                                           ! 1016     {
02706                                           ! 1017       ticks_to_wait -= t;
02707                                           ! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
02708 09A2           8B46         FC            mov	ax,-4[bp]
02709 09A5           8B5E         FE            mov	bx,-2[bp]
02710 09A8           8D7E         F0            lea	di,-$10[bp]
02711 09AB           E8         F733            call	lsubul
02712 09AE           8946         FC            mov	-4[bp],ax
02713 09B1           895E         FE            mov	-2[bp],bx
02714                                           !BCC_EOS
02715                                           ! 1018     }
02716                                           ! 1019     prev_ticks = t;
02717                       000009B4            .35:
02718                       000009B4            .34:
02719                                           ! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
02720 09B4           8B46         F0            mov	ax,-$10[bp]
02721 09B7           8B5E         F2            mov	bx,-$E[bp]
02722 09BA           8946         F4            mov	-$C[bp],ax
02723 09BD           895E         F6            mov	-$A[bp],bx
02724                                           !BCC_EOS
02725                                           ! 1020   } while (ticks_to_wait > 0);
02726                       000009C0            .30:
02727                                           ! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
02728 09C0           31C0                       xor	ax,ax
02729 09C2           31DB                       xor	bx,bx
02730 09C4           8D7E         FC            lea	di,-4[bp]
02731 09C7           E8         F701            call	lcmpl
02732 09CA         0F8C         FF7C            blt 	.31
02733                       000009CE            .37:
02734                                           !BCC_EOS
02735                                           ! 1021 #asm
02736                       000009CE            .2F:
02737                                           !BCC_EOS
02738                                           !BCC_ASM
02739                       00000014            _delay_ticks.ticks	set	$14
02740                       00000004            .delay_ticks.ticks	set	4
02741                       00000000            _delay_ticks.t	set	0
02742                       FFFFFFF0            .delay_ticks.t	set	-$10
02743                       00000004            _delay_ticks.prev_ticks	set	4
02744                       FFFFFFF4            .delay_ticks.prev_ticks	set	-$C
02745                       00000008            _delay_ticks.delta	set	8
02746                       FFFFFFF8            .delay_ticks.delta	set	-8
02747                       0000000C            _delay_ticks.ticks_to_wait	set	$C
02748                       FFFFFFFC            .delay_ticks.ticks_to_wait	set	-4
02749 09CE           FA                           cli
02750 09CF           9D                           popf
02751                                           ! 1024 endasm
02752                                           !BCC_ENDASM
02753                                           !BCC_EOS
02754                                           ! 1025 }
02755 09D0           89EC                       mov	sp,bp
02756 09D2           5D                         pop	bp
02757 09D3           C3                         ret
02758                                           ! 1026   Bit8u
02759                                           ! Register BX used in function delay_ticks
02760                                           ! 1027 check_for_keystroke()
02761                                           ! 1028 {
02762                                           export	_check_for_keystroke
02763                       000009D4            _check_for_keystroke:
02764                                           ! 1029 #asm
02765                                           !BCC_ASM
02766 09D4           B8                   0100    mov ax, #0x100
02767 09D7           CD                     16    int #0x16
02768 09D9           74           04              jz no_key
02769 09DB           B0                     01    mov al, #1
02770 09DD           EB           02              jmp done
02771                       000009DF            no_key:
02772 09DF           30C0                         xor al, al
02773                       000009E1            done:
02774                                           ! 1038 endasm
02775                                           !BCC_ENDASM
02776                                           ! 1039 }
02777 09E1           C3                         ret
02778                                           ! 1040   Bit8u
02779                                           ! 1041 get_keystroke()
02780                                           ! 1042 {
02781                                           export	_get_keystroke
02782                       000009E2            _get_keystroke:
02783                                           ! 1043 #asm
02784                                           !BCC_ASM
02785 09E2           B8                   0000    mov ax, #0x0
02786 09E5           CD                     16    int #0x16
02787 09E7           86C4                         xchg ah, al
02788                                           ! 1047 endasm
02789                                           !BCC_ENDASM
02790                                           ! 1048 }
02791 09E9           C3                         ret
02792                                           ! 1049   void
02793                                           ! 1050 delay_ticks_and_check_for_keystroke(ticks, count)
02794                                           ! 1051   Bit16u ticks, count;
02795                                           export	_delay_ticks_and_check_for_keystroke
02796                       000009EA            _delay_ticks_and_check_for_keystroke:
02797                                           !BCC_EOS
02798                                           ! 1052 {
02799                                           ! 1053   Bit16u i;
02800                                           !BCC_EOS
02801                                           ! 1054   for (i = 1; i <= count; i++) {
02802 09EA           55                         push	bp
02803 09EB           89E5                       mov	bp,sp
02804 09ED           4C                         dec	sp
02805 09EE           4C                         dec	sp
02806                                           ! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
02807 09EF           B8                   0001  mov	ax,*1
02808 09F2           8946         FE            mov	-2[bp],ax
02809                                           !BCC_EOS
02810                                           !BCC_EOS
02811 09F5           EB           18            jmp .3A
02812                       000009F7            .3B:
02813                                           ! 1055     delay_ticks(ticks)
02814                                           ! 1055 ;
02815                                           ! Debug: list unsigned short ticks = [S+4+2] (used reg = )
02816 09F7           FF76         04            push	4[bp]
02817                                           ! Debug: func () void = delay_ticks+0 (used reg = )
02818 09FA           E8         FF25            call	_delay_ticks
02819 09FD           44                         inc	sp
02820 09FE           44                         inc	sp
02821                                           !BCC_EOS
02822                                           ! 1056     if (check_for_keystroke())
02823                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
02824 09FF           E8         FFD2            call	_check_for_keystroke
02825 0A02           84C0                       test	al,al
02826 0A04           74           02            je  	.3C
02827                       00000A06            .3D:
02828                                           ! 1057       break;
02829 0A06           EB           0F            jmp .38
02830                                           !BCC_EOS
02831                                           ! 1058   }
02832                       00000A08            .3C:
02833                                           ! 1059 }
02834                       00000A08            .39:
02835                                           ! Debug: postinc unsigned short i = [S+4-4] (used reg = )
02836 0A08           8B46         FE            mov	ax,-2[bp]
02837 0A0B           40                         inc	ax
02838 0A0C           8946         FE            mov	-2[bp],ax
02839                       00000A0F            .3A:
02840                                           ! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
02841 0A0F           8B46         FE            mov	ax,-2[bp]
02842 0A12           3B46         06            cmp	ax,6[bp]
02843 0A15           76           E0            jbe	.3B
02844                       00000A17            .3E:
02845                       00000A17            .38:
02846 0A17           89EC                       mov	sp,bp
02847 0A19           5D                         pop	bp
02848 0A1A           C3                         ret
02849                                           ! 1060   void
02850                                           ! 1061 bios_printf(action, s)
02851                                           ! 1062   Bit16u action;
02852                                           export	_bios_printf
02853                       00000A1B            _bios_printf:
02854                                           !BCC_EOS
02855                                           ! 1063   Bit8u *s;
02856                                           !BCC_EOS
02857                                           ! 1064 {
02858                                           ! 1065   Bit8u c, format_char;
02859                                           !BCC_EOS
02860                                           ! 1066   bx_bool in_format;
02861                                           !BCC_EOS
02862                                           ! 1067   short i;
02863                                           !BCC_EOS
02864                                           ! 1068   Bit16u *arg_ptr;
02865                                           !BCC_EOS
02866                                           ! 1069   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
02867                                           !BCC_EOS
02868                                           ! 1070   arg_ptr = &s;
02869 0A1B           55                         push	bp
02870 0A1C           89E5                       mov	bp,sp
02871 0A1E           83C4                   EA  add	sp,*-$16
02872                                           ! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02873 0A21           8D5E         06            lea	bx,6[bp]
02874 0A24           895E         F8            mov	-8[bp],bx
02875                                           !BCC_EOS
02876                                           ! 1071   arg_seg = get_SS();
02877                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
02878 0A27           E8         FC23            call	_get_SS
02879                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
02880 0A2A           8946         F6            mov	-$A[bp],ax
02881                                           !BCC_EOS
02882                                           ! 1072   in_format = 0;
02883                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
02884 0A2D           31C0                       xor	ax,ax
02885 0A2F           8946         FC            mov	-4[bp],ax
02886                                           !BCC_EOS
02887                                           ! 1073   format_width = 0;
02888                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02889 0A32           31C0                       xor	ax,ax
02890 0A34           8946         EC            mov	-$14[bp],ax
02891                                           !BCC_EOS
02892                                           ! 1074   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
02893                                           ! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
02894 0A37           8A46         04            mov	al,4[bp]
02895 0A3A           24                     07  and	al,*7
02896                                           ! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
02897 0A3C           3C                     07  cmp	al,*7
02898 0A3E           75           1B            jne 	.3F
02899                       00000A40            .40:
02900                                           ! 1075     outb(0x401, 0x00);
02901                                           ! Debug: list int = const 0 (used reg = )
02902 0A40           31C0                       xor	ax,ax
02903 0A42           50                         push	ax
02904                                           ! Debug: list int = const $401 (used reg = )
02905 0A43           B8                   0401  mov	ax,#$401
02906 0A46           50                         push	ax
02907                                           ! Debug: func () void = outb+0 (used reg = )
02908 0A47           E8         FB0A            call	_outb
02909 0A4A           83C4                   04  add	sp,*4
02910                                           !BCC_EOS
02911                                           ! 1076     bios_printf (2, "FATAL: ");
02912                                           ! Debug: list * char = .41+0 (used reg = )
02913 0A4D           BB                   D673  mov	bx,#.41
02914 0A50           53                         push	bx
02915                                           ! Debug: list int = const 2 (used reg = )
02916 0A51           B8                   0002  mov	ax,*2
02917 0A54           50                         push	ax
02918                                           ! Debug: func () void = bios_printf+0 (used reg = )
02919 0A55           E8         FFC3            call	_bios_printf
02920 0A58           83C4                   04  add	sp,*4
02921                                           !BCC_EOS
02922                                           ! 1077   }
02923                                           ! 1078   while (c = read_byte(get_CS(), s)) {
02924                       00000A5B            .3F:
02925 0A5B           E9         0369            br 	.43
02926                       00000A5E            .44:
02927                                           ! 1079     if ( c == '%' ) {
02928                                           ! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
02929 0A5E           8A46         FF            mov	al,-1[bp]
02930 0A61           3C                     25  cmp	al,*$25
02931 0A63           75           0E            jne 	.45
02932                       00000A65            .46:
02933                                           ! 1080       in_format = 1;
02934                                           ! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
02935 0A65           B8                   0001  mov	ax,*1
02936 0A68           8946         FC            mov	-4[bp],ax
02937                                           !BCC_EOS
02938                                           ! 1081       format_width = 0;
02939                                           ! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
02940 0A6B           31C0                       xor	ax,ax
02941 0A6D           8946         EC            mov	-$14[bp],ax
02942                                           !BCC_EOS
02943                                           ! 1082       }
02944                                           ! 1083     else if (in_format) {
02945 0A70           E9         034D            br 	.47
02946                       00000A73            .45:
02947 0A73           8B46         FC            mov	ax,-4[bp]
02948 0A76           85C0                       test	ax,ax
02949 0A78         0F84         0335            beq 	.48
02950                       00000A7C            .49:
02951                                           ! 1084       if ( (c>='0') && (c<='9') ) {
02952                                           ! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02953 0A7C           8A46         FF            mov	al,-1[bp]
02954 0A7F           3C                     30  cmp	al,*$30
02955 0A81           72           28            jb  	.4A
02956                       00000A83            .4C:
02957                                           ! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
02958 0A83           8A46         FF            mov	al,-1[bp]
02959 0A86           3C                     39  cmp	al,*$39
02960 0A88           77           21            ja  	.4A
02961                       00000A8A            .4B:
02962                                           ! 1085         format_width = (format_width * 10) + (c - '0');
02963                                           ! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
02964 0A8A           8A46         FF            mov	al,-1[bp]
02965 0A8D           30E4                       xor	ah,ah
02966 0A8F           05                   FFD0  add	ax,*-$30
02967 0A92           50                         push	ax
02968                                           ! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
02969 0A93           8B46         EC            mov	ax,-$14[bp]
02970 0A96           89C2                       mov	dx,ax
02971 0A98           D1E0                       shl	ax,*1
02972 0A9A           D1E0                       shl	ax,*1
02973 0A9C           01D0                       add	ax,dx
02974 0A9E           D1E0                       shl	ax,*1
02975                                           ! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
02976 0AA0           0346         E8            add	ax,-$18[bp]
02977 0AA3           44                         inc	sp
02978 0AA4           44                         inc	sp
02979                                           ! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
02980 0AA5           8946         EC            mov	-$14[bp],ax
02981                                           !BCC_EOS
02982                                           ! 1086         }
02983                                           ! 1087       else {
02984 0AA8           E9         0304            br 	.4D
02985                       00000AAB            .4A:
02986                                           ! 1088         arg_ptr++;
02987                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02988 0AAB           8B5E         F8            mov	bx,-8[bp]
02989 0AAE           43                         inc	bx
02990 0AAF           43                         inc	bx
02991 0AB0           895E         F8            mov	-8[bp],bx
02992                                           !BCC_EOS
02993                                           ! 1089         arg = read_word(arg_seg, arg_ptr);
02994                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
02995 0AB3           FF76         F8            push	-8[bp]
02996                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
02997 0AB6           FF76         F6            push	-$A[bp]
02998                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
02999 0AB9           E8         FB4B            call	_read_word
03000 0ABC           83C4                   04  add	sp,*4
03001                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03002 0ABF           8946         F4            mov	-$C[bp],ax
03003                                           !BCC_EOS
03004                                           ! 1090         if (c == 'x' || c == 'X') {
03005                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03006 0AC2           8A46         FF            mov	al,-1[bp]
03007 0AC5           3C                     78  cmp	al,*$78
03008 0AC7           74           07            je  	.4F
03009                       00000AC9            .50:
03010                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03011 0AC9           8A46         FF            mov	al,-1[bp]
03012 0ACC           3C                     58  cmp	al,*$58
03013 0ACE           75           76            jne 	.4E
03014                       00000AD0            .4F:
03015                                           ! 1091           if (format_width == 0)
03016                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03017 0AD0           8B46         EC            mov	ax,-$14[bp]
03018 0AD3           85C0                       test	ax,ax
03019 0AD5           75           06            jne 	.51
03020                       00000AD7            .52:
03021                                           ! 1092             format_width = 4;
03022                                           ! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
03023 0AD7           B8                   0004  mov	ax,*4
03024 0ADA           8946         EC            mov	-$14[bp],ax
03025                                           !BCC_EOS
03026                                           ! 1093           if (c == 'x')
03027                       00000ADD            .51:
03028                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03029 0ADD           8A46         FF            mov	al,-1[bp]
03030 0AE0           3C                     78  cmp	al,*$78
03031 0AE2           75           08            jne 	.53
03032                       00000AE4            .54:
03033                                           ! 1094             hexadd = 'a';
03034                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03035 0AE4           B8                   0061  mov	ax,*$61
03036 0AE7           8946         EA            mov	-$16[bp],ax
03037                                           !BCC_EOS
03038                                           ! 1095           else
03039                                           ! 1096             hexadd = 'A';
03040 0AEA           EB           06            jmp .55
03041                       00000AEC            .53:
03042                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03043 0AEC           B8                   0041  mov	ax,*$41
03044 0AEF           8946         EA            mov	-$16[bp],ax
03045                                           !BCC_EOS
03046                                           ! 1097           for (i=format_width-1; i>=0; i--) {
03047                       00000AF2            .55:
03048                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03049 0AF2           8B46         EC            mov	ax,-$14[bp]
03050                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03051 0AF5           48                         dec	ax
03052 0AF6           8946         FA            mov	-6[bp],ax
03053                                           !BCC_EOS
03054                                           !BCC_EOS
03055 0AF9           EB           41            jmp .58
03056                       00000AFB            .59:
03057                                           ! 1098             nibble = (arg >> (4 * i)) & 0x000f;
03058                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03059                                           ! Debug: expression subtree swapping
03060 0AFB           8B46         FA            mov	ax,-6[bp]
03061 0AFE           D1E0                       shl	ax,*1
03062 0B00           D1E0                       shl	ax,*1
03063                                           ! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03064 0B02           89C3                       mov	bx,ax
03065 0B04           8B46         F4            mov	ax,-$C[bp]
03066 0B07           89D9                       mov	cx,bx
03067 0B09           D3E8                       shr	ax,cl
03068                                           ! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
03069 0B0B           24                     0F  and	al,*$F
03070                                           ! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03071 0B0D           30E4                       xor	ah,ah
03072 0B0F           8946         F2            mov	-$E[bp],ax
03073                                           !BCC_EOS
03074                                           ! 1099             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03075                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03076 0B12           8B46         F2            mov	ax,-$E[bp]
03077 0B15           3D                   0009  cmp	ax,*9
03078 0B18           77           08            ja  	.5A
03079                       00000B1A            .5B:
03080                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03081 0B1A           8B46         F2            mov	ax,-$E[bp]
03082 0B1D           05                   0030  add	ax,*$30
03083 0B20           EB           09            jmp .5C
03084                       00000B22            .5A:
03085                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03086 0B22           8B46         F2            mov	ax,-$E[bp]
03087                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03088 0B25           05                   FFF6  add	ax,*-$A
03089 0B28           0346         EA            add	ax,-$16[bp]
03090                       00000B2B            .5C:
03091                                           ! Debug: list unsigned int = ax+0 (used reg = )
03092 0B2B           50                         push	ax
03093                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03094 0B2C           FF76         04            push	4[bp]
03095                                           ! Debug: func () void = send+0 (used reg = )
03096 0B2F           E8         FB95            call	_send
03097 0B32           83C4                   04  add	sp,*4
03098                                           !BCC_EOS
03099                                           ! 1100             }
03100                                           ! 1101           }
03101                       00000B35            .57:
03102                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03103 0B35           8B46         FA            mov	ax,-6[bp]
03104 0B38           48                         dec	ax
03105 0B39           8946         FA            mov	-6[bp],ax
03106                       00000B3C            .58:
03107                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03108 0B3C           8B46         FA            mov	ax,-6[bp]
03109 0B3F           85C0                       test	ax,ax
03110 0B41           7D           B8            jge	.59
03111                       00000B43            .5D:
03112                       00000B43            .56:
03113                                           ! 1102         else if (c == 'u') {
03114 0B43           E9         0264            br 	.5E
03115                       00000B46            .4E:
03116                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03117 0B46           8A46         FF            mov	al,-1[bp]
03118 0B49           3C                     75  cmp	al,*$75
03119 0B4B           75           15            jne 	.5F
03120                       00000B4D            .60:
03121                                           ! 1103           put_uint(action, arg, format_width, 0);
03122                                           ! Debug: list int = const 0 (used reg = )
03123 0B4D           31C0                       xor	ax,ax
03124 0B4F           50                         push	ax
03125                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03126 0B50           FF76         EC            push	-$14[bp]
03127                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03128 0B53           FF76         F4            push	-$C[bp]
03129                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03130 0B56           FF76         04            push	4[bp]
03131                                           ! Debug: func () void = put_uint+0 (used reg = )
03132 0B59           E8         FC58            call	_put_uint
03133 0B5C           83C4                   08  add	sp,*8
03134                                           !BCC_EOS
03135                                           ! 1104           }
03136                                           ! 1105         else if (c == 'l') {
03137 0B5F           E9         0248            br 	.61
03138                       00000B62            .5F:
03139                                           ! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
03140 0B62           8A46         FF            mov	al,-1[bp]
03141 0B65           3C                     6C  cmp	al,*$6C
03142 0B67         0F85         018F            bne 	.62
03143                       00000B6B            .63:
03144                                           ! 1106           s++;
03145                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03146 0B6B           8B5E         06            mov	bx,6[bp]
03147 0B6E           43                         inc	bx
03148 0B6F           895E         06            mov	6[bp],bx
03149                                           !BCC_EOS
03150                                           ! 1107           c = read_byte(get_CS(), s);
03151                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03152 0B72           FF76         06            push	6[bp]
03153                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03154 0B75           E8         FAD2            call	_get_CS
03155                                           ! Debug: list unsigned short = ax+0 (used reg = )
03156 0B78           50                         push	ax
03157                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03158 0B79           E8         FA78            call	_read_byte
03159 0B7C           83C4                   04  add	sp,*4
03160                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03161 0B7F           8846         FF            mov	-1[bp],al
03162                                           !BCC_EOS
03163                                           ! 1108           arg_ptr++;
03164                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03165 0B82           8B5E         F8            mov	bx,-8[bp]
03166 0B85           43                         inc	bx
03167 0B86           43                         inc	bx
03168 0B87           895E         F8            mov	-8[bp],bx
03169                                           !BCC_EOS
03170                                           ! 1109           hibyte = read_word(arg_seg, arg_ptr);
03171                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03172 0B8A           FF76         F8            push	-8[bp]
03173                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03174 0B8D           FF76         F6            push	-$A[bp]
03175                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03176 0B90           E8         FA74            call	_read_word
03177 0B93           83C4                   04  add	sp,*4
03178                                           ! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
03179 0B96           8946         F0            mov	-$10[bp],ax
03180                                           !BCC_EOS
03181                                           ! 1110           if (c == 'd') {
03182                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03183 0B99           8A46         FF            mov	al,-1[bp]
03184 0B9C           3C                     64  cmp	al,*$64
03185 0B9E         0F85         0073            bne 	.64
03186                       00000BA2            .65:
03187                                           ! 1111             if (hibyte & 0x8000)
03188                                           ! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
03189 0BA2           8B46         F0            mov	ax,-$10[bp]
03190 0BA5           25                   8000  and	ax,#$8000
03191 0BA8           85C0                       test	ax,ax
03192 0BAA           74           3D            je  	.66
03193                       00000BAC            .67:
03194                                           ! 1112               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
03195                                           ! Debug: list int = const 1 (used reg = )
03196 0BAC           B8                   0001  mov	ax,*1
03197 0BAF           50                         push	ax
03198                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03199 0BB0           8B46         EC            mov	ax,-$14[bp]
03200                                           ! Debug: list unsigned int = ax-1 (used reg = )
03201 0BB3           48                         dec	ax
03202 0BB4           50                         push	ax
03203                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03204 0BB5           8B46         F4            mov	ax,-$C[bp]
03205 0BB8           31DB                       xor	bx,bx
03206 0BBA           53                         push	bx
03207 0BBB           50                         push	ax
03208                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03209 0BBC           8B46         F0            mov	ax,-$10[bp]
03210 0BBF           31DB                       xor	bx,bx
03211                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03212 0BC1           93                         xchg	bx,ax
03213 0BC2           31C0                       xor	ax,ax
03214                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03215 0BC4           8D7E         E2            lea	di,-$1E[bp]
03216 0BC7           E8         F53D            call	lorul
03217 0BCA           83C4                   04  add	sp,*4
03218                                           ! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
03219 0BCD           53                         push	bx
03220 0BCE           50                         push	ax
03221 0BCF           31C0                       xor	ax,ax
03222 0BD1           31DB                       xor	bx,bx
03223 0BD3           8D7E         E2            lea	di,-$1E[bp]
03224 0BD6           E8         F508            call	lsubul
03225 0BD9           83C4                   04  add	sp,*4
03226                                           ! Debug: list unsigned long = bx+0 (used reg = )
03227 0BDC           53                         push	bx
03228 0BDD           50                         push	ax
03229                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03230 0BDE           FF76         04            push	4[bp]
03231                                           ! Debug: func () void = put_luint+0 (used reg = )
03232 0BE1           E8         FC53            call	_put_luint
03233 0BE4           83C4                   0A  add	sp,*$A
03234                                           !BCC_EOS
03235                                           ! 1113             else
03236                                           ! 1114               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03237 0BE7           EB           29            jmp .68
03238                       00000BE9            .66:
03239                                           ! Debug: list int = const 0 (used reg = )
03240 0BE9           31C0                       xor	ax,ax
03241 0BEB           50                         push	ax
03242                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03243 0BEC           FF76         EC            push	-$14[bp]
03244                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03245 0BEF           8B46         F4            mov	ax,-$C[bp]
03246 0BF2           31DB                       xor	bx,bx
03247 0BF4           53                         push	bx
03248 0BF5           50                         push	ax
03249                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03250 0BF6           8B46         F0            mov	ax,-$10[bp]
03251 0BF9           31DB                       xor	bx,bx
03252                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03253 0BFB           93                         xchg	bx,ax
03254 0BFC           31C0                       xor	ax,ax
03255                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03256 0BFE           8D7E         E2            lea	di,-$1E[bp]
03257 0C01           E8         F503            call	lorul
03258 0C04           83C4                   04  add	sp,*4
03259                                           ! Debug: list unsigned long = bx+0 (used reg = )
03260 0C07           53                         push	bx
03261 0C08           50                         push	ax
03262                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03263 0C09           FF76         04            push	4[bp]
03264                                           ! Debug: func () void = put_luint+0 (used reg = )
03265 0C0C           E8         FC28            call	_put_luint
03266 0C0F           83C4                   0A  add	sp,*$A
03267                                           !BCC_EOS
03268                                           ! 1115            }
03269                       00000C12            .68:
03270                                           ! 1116           else if (c == 'u') {
03271 0C12           E9         00E2            br 	.69
03272                       00000C15            .64:
03273                                           ! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
03274 0C15           8A46         FF            mov	al,-1[bp]
03275 0C18           3C                     75  cmp	al,*$75
03276 0C1A           75           2C            jne 	.6A
03277                       00000C1C            .6B:
03278                                           ! 1117             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
03279                                           ! Debug: list int = const 0 (used reg = )
03280 0C1C           31C0                       xor	ax,ax
03281 0C1E           50                         push	ax
03282                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03283 0C1F           FF76         EC            push	-$14[bp]
03284                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
03285 0C22           8B46         F4            mov	ax,-$C[bp]
03286 0C25           31DB                       xor	bx,bx
03287 0C27           53                         push	bx
03288 0C28           50                         push	ax
03289                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
03290 0C29           8B46         F0            mov	ax,-$10[bp]
03291 0C2C           31DB                       xor	bx,bx
03292                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03293 0C2E           93                         xchg	bx,ax
03294 0C2F           31C0                       xor	ax,ax
03295                                           ! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
03296 0C31           8D7E         E2            lea	di,-$1E[bp]
03297 0C34           E8         F4D0            call	lorul
03298 0C37           83C4                   04  add	sp,*4
03299                                           ! Debug: list unsigned long = bx+0 (used reg = )
03300 0C3A           53                         push	bx
03301 0C3B           50                         push	ax
03302                                           ! Debug: list unsigned short action = [S+$20+2] (used reg = )
03303 0C3C           FF76         04            push	4[bp]
03304                                           ! Debug: func () void = put_luint+0 (used reg = )
03305 0C3F           E8         FBF5            call	_put_luint
03306 0C42           83C4                   0A  add	sp,*$A
03307                                           !BCC_EOS
03308                                           ! 1118            }
03309                                           ! 1119           else if (c == 'x' || c == 'X')
03310 0C45           E9         00AF            br 	.6C
03311                       00000C48            .6A:
03312                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03313 0C48           8A46         FF            mov	al,-1[bp]
03314 0C4B           3C                     78  cmp	al,*$78
03315 0C4D           74           09            je  	.6E
03316                       00000C4F            .6F:
03317                                           ! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
03318 0C4F           8A46         FF            mov	al,-1[bp]
03319 0C52           3C                     58  cmp	al,*$58
03320 0C54         0F85         009F            bne 	.6D
03321                       00000C58            .6E:
03322                                           ! 1120            {
03323                                           ! 1121             if (format_width == 0)
03324                                           ! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
03325 0C58           8B46         EC            mov	ax,-$14[bp]
03326 0C5B           85C0                       test	ax,ax
03327 0C5D           75           06            jne 	.70
03328                       00000C5F            .71:
03329                                           ! 1122               format_width = 8;
03330                                           ! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
03331 0C5F           B8                   0008  mov	ax,*8
03332 0C62           8946         EC            mov	-$14[bp],ax
03333                                           !BCC_EOS
03334                                           ! 1123             if (c == 'x')
03335                       00000C65            .70:
03336                                           ! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
03337 0C65           8A46         FF            mov	al,-1[bp]
03338 0C68           3C                     78  cmp	al,*$78
03339 0C6A           75           08            jne 	.72
03340                       00000C6C            .73:
03341                                           ! 1124               hexadd = 'a';
03342                                           ! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
03343 0C6C           B8                   0061  mov	ax,*$61
03344 0C6F           8946         EA            mov	-$16[bp],ax
03345                                           !BCC_EOS
03346                                           ! 1125             else
03347                                           ! 1126               hexadd = 'A';
03348 0C72           EB           06            jmp .74
03349                       00000C74            .72:
03350                                           ! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
03351 0C74           B8                   0041  mov	ax,*$41
03352 0C77           8946         EA            mov	-$16[bp],ax
03353                                           !BCC_EOS
03354                                           ! 1127             for (i=format_width-1; i>=0; i--) {
03355                       00000C7A            .74:
03356                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
03357 0C7A           8B46         EC            mov	ax,-$14[bp]
03358                                           ! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
03359 0C7D           48                         dec	ax
03360 0C7E           8946         FA            mov	-6[bp],ax
03361                                           !BCC_EOS
03362                                           !BCC_EOS
03363 0C81           EB           6D            jmp .77
03364                       00000C83            .78:
03365                                           ! 1128             
03366                                           ! 1128   nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
03367                                           ! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
03368                                           ! Debug: expression subtree swapping
03369 0C83           8B46         FA            mov	ax,-6[bp]
03370 0C86           D1E0                       shl	ax,*1
03371 0C88           D1E0                       shl	ax,*1
03372 0C8A           50                         push	ax
03373                                           ! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
03374 0C8B           8B46         F4            mov	ax,-$C[bp]
03375 0C8E           31DB                       xor	bx,bx
03376 0C90           53                         push	bx
03377 0C91           50                         push	ax
03378                                           ! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
03379 0C92           8B46         F0            mov	ax,-$10[bp]
03380 0C95           31DB                       xor	bx,bx
03381                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
03382 0C97           93                         xchg	bx,ax
03383 0C98           31C0                       xor	ax,ax
03384                                           ! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
03385 0C9A           8D7E         E4            lea	di,-$1C[bp]
03386 0C9D           E8         F467            call	lorul
03387 0CA0           83C4                   04  add	sp,*4
03388                                           ! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
03389 0CA3           8B7E         E8            mov	di,-$18[bp]
03390 0CA6           E8         F480            call	lsrul
03391 0CA9           44                         inc	sp
03392 0CAA           44                         inc	sp
03393                                           ! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
03394 0CAB           53                         push	bx
03395 0CAC           50                         push	ax
03396 0CAD           B8                   000F  mov	ax,*$F
03397 0CB0           31DB                       xor	bx,bx
03398 0CB2           53                         push	bx
03399 0CB3           50                         push	ax
03400 0CB4           8B46         E6            mov	ax,-$1A[bp]
03401 0CB7           8B5E         E8            mov	bx,-$18[bp]
03402 0CBA           8D7E         E2            lea	di,-$1E[bp]
03403 0CBD           E8         F3FB            call	landul
03404 0CC0           83C4                   08  add	sp,*8
03405                                           ! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
03406 0CC3           8946         F2            mov	-$E[bp],ax
03407                                           !BCC_EOS
03408                                           ! 1129               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
03409                                           ! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
03410 0CC6           8B46         F2            mov	ax,-$E[bp]
03411 0CC9           3D                   0009  cmp	ax,*9
03412 0CCC           77           08            ja  	.79
03413                       00000CCE            .7A:
03414                                           ! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
03415 0CCE           8B46         F2            mov	ax,-$E[bp]
03416 0CD1           05                   0030  add	ax,*$30
03417 0CD4           EB           09            jmp .7B
03418                       00000CD6            .79:
03419                                           ! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
03420 0CD6           8B46         F2            mov	ax,-$E[bp]
03421                                           ! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
03422 0CD9           05                   FFF6  add	ax,*-$A
03423 0CDC           0346         EA            add	ax,-$16[bp]
03424                       00000CDF            .7B:
03425                                           ! Debug: list unsigned int = ax+0 (used reg = )
03426 0CDF           50                         push	ax
03427                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03428 0CE0           FF76         04            push	4[bp]
03429                                           ! Debug: func () void = send+0 (used reg = )
03430 0CE3           E8         F9E1            call	_send
03431 0CE6           83C4                   04  add	sp,*4
03432                                           !BCC_EOS
03433                                           ! 1130               }
03434                                           ! 1131            }
03435                       00000CE9            .76:
03436                                           ! Debug: postdec short i = [S+$18-8] (used reg = )
03437 0CE9           8B46         FA            mov	ax,-6[bp]
03438 0CEC           48                         dec	ax
03439 0CED           8946         FA            mov	-6[bp],ax
03440                       00000CF0            .77:
03441                                           ! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
03442 0CF0           8B46         FA            mov	ax,-6[bp]
03443 0CF3           85C0                       test	ax,ax
03444 0CF5           7D           8C            jge	.78
03445                       00000CF7            .7C:
03446                       00000CF7            .75:
03447                                           ! 1132           }
03448                       00000CF7            .6D:
03449                       00000CF7            .6C:
03450                       00000CF7            .69:
03451                                           ! 1133         else if (c == 'd') {
03452 0CF7           E9         00B0            br 	.7D
03453                       00000CFA            .62:
03454                                           ! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
03455 0CFA           8A46         FF            mov	al,-1[bp]
03456 0CFD           3C                     64  cmp	al,*$64
03457 0CFF           75           38            jne 	.7E
03458                       00000D01            .7F:
03459                                           ! 1134           if (arg & 0x8000)
03460                                           ! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
03461 0D01           8B46         F4            mov	ax,-$C[bp]
03462 0D04           25                   8000  and	ax,#$8000
03463 0D07           85C0                       test	ax,ax
03464 0D09           74           1A            je  	.80
03465                       00000D0B            .81:
03466                                           ! 1135             put_int(action, -arg, format_width - 1, 1);
03467                                           ! Debug: list int = const 1 (used reg = )
03468 0D0B           B8                   0001  mov	ax,*1
03469 0D0E           50                         push	ax
03470                                           ! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
03471 0D0F           8B46         EC            mov	ax,-$14[bp]
03472                                           ! Debug: list unsigned int = ax-1 (used reg = )
03473 0D12           48                         dec	ax
03474 0D13           50                         push	ax
03475                                           ! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
03476 0D14           31C0                       xor	ax,ax
03477 0D16           2B46         F4            sub	ax,-$C[bp]
03478                                           ! Debug: list unsigned int = ax+0 (used reg = )
03479 0D19           50                         push	ax
03480                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03481 0D1A           FF76         04            push	4[bp]
03482                                           ! Debug: func () void = put_int+0 (used reg = )
03483 0D1D           E8         FA0F            call	_put_int
03484 0D20           83C4                   08  add	sp,*8
03485                                           !BCC_EOS
03486                                           ! 1136           else
03487                                           ! 1137             put_int(action, arg, format_width, 0);
03488 0D23           EB           12            jmp .82
03489                       00000D25            .80:
03490                                           ! Debug: list int = const 0 (used reg = )
03491 0D25           31C0                       xor	ax,ax
03492 0D27           50                         push	ax
03493                                           ! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
03494 0D28           FF76         EC            push	-$14[bp]
03495                                           ! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
03496 0D2B           FF76         F4            push	-$C[bp]
03497                                           ! Debug: list unsigned short action = [S+$1E+2] (used reg = )
03498 0D2E           FF76         04            push	4[bp]
03499                                           ! Debug: func () void = put_int+0 (used reg = )
03500 0D31           E8         F9FB            call	_put_int
03501 0D34           83C4                   08  add	sp,*8
03502                                           !BCC_EOS
03503                                           ! 1138           }
03504                       00000D37            .82:
03505                                           ! 1139         else if (c == 's') {
03506 0D37           EB           71            jmp .83
03507                       00000D39            .7E:
03508                                           ! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
03509 0D39           8A46         FF            mov	al,-1[bp]
03510 0D3C           3C                     73  cmp	al,*$73
03511 0D3E           75           12            jne 	.84
03512                       00000D40            .85:
03513                                           ! 1140           put_str(action, get_CS(), arg);
03514                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03515 0D40           FF76         F4            push	-$C[bp]
03516                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03517 0D43           E8         F904            call	_get_CS
03518                                           ! Debug: list unsigned short = ax+0 (used reg = )
03519 0D46           50                         push	ax
03520                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03521 0D47           FF76         04            push	4[bp]
03522                                           ! Debug: func () void = put_str+0 (used reg = )
03523 0D4A           E8         FBA1            call	_put_str
03524 0D4D           83C4                   06  add	sp,*6
03525                                           !BCC_EOS
03526                                           ! 1141           }
03527                                           ! 1142         else if (c == 'S') {
03528 0D50           EB           58            jmp .86
03529                       00000D52            .84:
03530                                           ! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
03531 0D52           8A46         FF            mov	al,-1[bp]
03532 0D55           3C                     53  cmp	al,*$53
03533 0D57           75           2E            jne 	.87
03534                       00000D59            .88:
03535                                           ! 1143           hibyte = arg;
03536                                           ! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
03537 0D59           8B46         F4            mov	ax,-$C[bp]
03538 0D5C           8946         F0            mov	-$10[bp],ax
03539                                           !BCC_EOS
03540                                           ! 1144           arg_ptr++;
03541                                           ! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03542 0D5F           8B5E         F8            mov	bx,-8[bp]
03543 0D62           43                         inc	bx
03544 0D63           43                         inc	bx
03545 0D64           895E         F8            mov	-8[bp],bx
03546                                           !BCC_EOS
03547                                           ! 1145           arg = read_word(arg_seg, arg_ptr);
03548                                           ! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
03549 0D67           FF76         F8            push	-8[bp]
03550                                           ! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
03551 0D6A           FF76         F6            push	-$A[bp]
03552                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
03553 0D6D           E8         F897            call	_read_word
03554 0D70           83C4                   04  add	sp,*4
03555                                           ! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
03556 0D73           8946         F4            mov	-$C[bp],ax
03557                                           !BCC_EOS
03558                                           ! 1146           put_str(action, hibyte, arg);
03559                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03560 0D76           FF76         F4            push	-$C[bp]
03561                                           ! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
03562 0D79           FF76         F0            push	-$10[bp]
03563                                           ! Debug: list unsigned short action = [S+$1C+2] (used reg = )
03564 0D7C           FF76         04            push	4[bp]
03565                                           ! Debug: func () void = put_str+0 (used reg = )
03566 0D7F           E8         FB6C            call	_put_str
03567 0D82           83C4                   06  add	sp,*6
03568                                           !BCC_EOS
03569                                           ! 1147           }
03570                                           ! 1148         else if (c == 'c') {
03571 0D85           EB           23            jmp .89
03572                       00000D87            .87:
03573                                           ! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
03574 0D87           8A46         FF            mov	al,-1[bp]
03575 0D8A           3C                     63  cmp	al,*$63
03576 0D8C           75           0E            jne 	.8A
03577                       00000D8E            .8B:
03578                                           ! 1149           send(action, arg);
03579                                           ! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
03580 0D8E           FF76         F4            push	-$C[bp]
03581                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03582 0D91           FF76         04            push	4[bp]
03583                                           ! Debug: func () void = send+0 (used reg = )
03584 0D94           E8         F930            call	_send
03585 0D97           83C4                   04  add	sp,*4
03586                                           !BCC_EOS
03587                                           ! 1150           }
03588                                           ! 1151         else
03589                                           ! 1152           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
03590 0D9A           EB           0E            jmp .8C
03591                       00000D9C            .8A:
03592                                           ! Debug: list * char = .8D+0 (used reg = )
03593 0D9C           BB                   D656  mov	bx,#.8D
03594 0D9F           53                         push	bx
03595                                           ! Debug: list int = const 7 (used reg = )
03596 0DA0           B8                   0007  mov	ax,*7
03597 0DA3           50                         push	ax
03598                                           ! Debug: func () void = bios_printf+0 (used reg = )
03599 0DA4           E8         FC74            call	_bios_printf
03600 0DA7           83C4                   04  add	sp,*4
03601                                           !BCC_EOS
03602                                           ! 1153           in_format = 0;
03603                       00000DAA            .8C:
03604                       00000DAA            .89:
03605                       00000DAA            .86:
03606                       00000DAA            .83:
03607                       00000DAA            .7D:
03608                       00000DAA            .61:
03609                       00000DAA            .5E:
03610                                           ! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
03611 0DAA           31C0                       xor	ax,ax
03612 0DAC           8946         FC            mov	-4[bp],ax
03613                                           !BCC_EOS
03614                                           ! 1154         }
03615                                           ! 1155       }
03616                       00000DAF            .4D:
03617                                           ! 1156     else {
03618 0DAF           EB           0F            jmp .8E
03619                       00000DB1            .48:
03620                                           ! 1157       send(action, c);
03621                                           ! Debug: list unsigned char c = [S+$18-3] (used reg = )
03622 0DB1           8A46         FF            mov	al,-1[bp]
03623 0DB4           30E4                       xor	ah,ah
03624 0DB6           50                         push	ax
03625                                           ! Debug: list unsigned short action = [S+$1A+2] (used reg = )
03626 0DB7           FF76         04            push	4[bp]
03627                                           ! Debug: func () void = send+0 (used reg = )
03628 0DBA           E8         F90A            call	_send
03629 0DBD           83C4                   04  add	sp,*4
03630                                           !BCC_EOS
03631                                           ! 1158       }
03632                                           ! 1159     s ++;
03633                       00000DC0            .8E:
03634                       00000DC0            .47:
03635                                           ! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
03636 0DC0           8B5E         06            mov	bx,6[bp]
03637 0DC3           43                         inc	bx
03638 0DC4           895E         06            mov	6[bp],bx
03639                                           !BCC_EOS
03640                                           ! 1160     }
03641                                           ! 1161   if (action & 1) {
03642                       00000DC7            .43:
03643                                           ! Debug: list * unsigned char s = [S+$18+4] (used reg = )
03644 0DC7           FF76         06            push	6[bp]
03645                                           ! Debug: func () unsigned short = get_CS+0 (used reg = )
03646 0DCA           E8         F87D            call	_get_CS
03647                                           ! Debug: list unsigned short = ax+0 (used reg = )
03648 0DCD           50                         push	ax
03649                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
03650 0DCE           E8         F823            call	_read_byte
03651 0DD1           83C4                   04  add	sp,*4
03652                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
03653 0DD4           8846         FF            mov	-1[bp],al
03654 0DD7           84C0                       test	al,al
03655 0DD9         0F85         FC81            bne 	.44
03656                       00000DDD            .8F:
03657                       00000DDD            .42:
03658                                           ! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
03659 0DDD           8A46         04            mov	al,4[bp]
03660 0DE0           24                     01  and	al,*1
03661 0DE2           84C0                       test	al,al
03662 0DE4           74           04            je  	.90
03663                       00000DE6            .91:
03664                                           ! 1162 #asm
03665                                           !BCC_EOS
03666                                           !BCC_ASM
03667                       00000002            _bios_printf.format_width	set	2
03668                       FFFFFFEC            .bios_printf.format_width	set	-$14
03669                       00000014            _bios_printf.format_char	set	$14
03670                       FFFFFFFE            .bios_printf.format_char	set	-2
03671                       00000006            _bios_printf.hibyte	set	6
03672                       FFFFFFF0            .bios_printf.hibyte	set	-$10
03673                       0000000E            _bios_printf.arg_ptr	set	$E
03674                       FFFFFFF8            .bios_printf.arg_ptr	set	-8
03675                       0000001A            _bios_printf.action	set	$1A
03676                       00000004            .bios_printf.action	set	4
03677                       00000010            _bios_printf.i	set	$10
03678                       FFFFFFFA            .bios_printf.i	set	-6
03679                       0000000C            _bios_printf.arg_seg	set	$C
03680                       FFFFFFF6            .bios_printf.arg_seg	set	-$A
03681                       00000004            _bios_printf.shift_count	set	4
03682                       FFFFFFEE            .bios_printf.shift_count	set	-$12
03683                       00000012            _bios_printf.in_format	set	$12
03684                       FFFFFFFC            .bios_printf.in_format	set	-4
03685                       0000001C            _bios_printf.s	set	$1C
03686                       00000006            .bios_printf.s	set	6
03687                       00000008            _bios_printf.nibble	set	8
03688                       FFFFFFF2            .bios_printf.nibble	set	-$E
03689                       00000015            _bios_printf.c	set	$15
03690                       FFFFFFFF            .bios_printf.c	set	-1
03691                       00000000            _bios_printf.hexadd	set	0
03692                       FFFFFFEA            .bios_printf.hexadd	set	-$16
03693                       0000000A            _bios_printf.arg	set	$A
03694                       FFFFFFF4            .bios_printf.arg	set	-$C
03695 0DE6           FA                             cli
03696                       00000DE7             halt2_loop:
03697 0DE7           F4                             hlt
03698 0DE8           EB           FD                jmp halt2_loop
03699                                           ! 1167 endasm
03700                                           !BCC_ENDASM
03701                                           !BCC_EOS
03702                                           ! 1168     }
03703                                           ! 1169 }
03704                       00000DEA            .90:
03705 0DEA           89EC                       mov	sp,bp
03706 0DEC           5D                         pop	bp
03707 0DED           C3                         ret
03708                                           ! 1170   void
03709                                           ! Register BX used in function bios_printf
03710                                           ! 1171 keyboard_init()
03711                                           ! 1172 {
03712                                           export	_keyboard_init
03713                       00000DEE            _keyboard_init:
03714                                           ! 1173     Bit16u max;
03715                                           !BCC_EOS
03716                                           ! 1174     max=0xffff;
03717 0DEE           55                         push	bp
03718 0DEF           89E5                       mov	bp,sp
03719 0DF1           4C                         dec	sp
03720 0DF2           4C                         dec	sp
03721                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03722 0DF3           B8                   FFFF  mov	ax,#$FFFF
03723 0DF6           8946         FE            mov	-2[bp],ax
03724                                           !BCC_EOS
03725                                           ! 1175     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03726 0DF9           EB           0D            jmp .93
03727                       00000DFB            .94:
03728                                           ! Debug: list int = const 0 (used reg = )
03729 0DFB           31C0                       xor	ax,ax
03730 0DFD           50                         push	ax
03731                                           ! Debug: list int = const $80 (used reg = )
03732 0DFE           B8                   0080  mov	ax,#$80
03733 0E01           50                         push	ax
03734                                           ! Debug: func () void = outb+0 (used reg = )
03735 0E02           E8         F74F            call	_outb
03736 0E05           83C4                   04  add	sp,*4
03737                                           !BCC_EOS
03738                                           ! 1176     max=2;
03739                       00000E08            .93:
03740                                           ! Debug: list int = const $64 (used reg = )
03741 0E08           B8                   0064  mov	ax,*$64
03742 0E0B           50                         push	ax
03743                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03744 0E0C           E8         F72F            call	_inb
03745 0E0F           44                         inc	sp
03746 0E10           44                         inc	sp
03747                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03748 0E11           24                     02  and	al,*2
03749 0E13           84C0                       test	al,al
03750 0E15           74           0B            je  	.95
03751                       00000E17            .96:
03752                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03753 0E17           8B46         FE            mov	ax,-2[bp]
03754 0E1A           48                         dec	ax
03755 0E1B           8946         FE            mov	-2[bp],ax
03756                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03757 0E1E           85C0                       test	ax,ax
03758 0E20           75           D9            jne	.94
03759                       00000E22            .95:
03760                       00000E22            .92:
03761                                           ! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
03762 0E22           B8                   0002  mov	ax,*2
03763 0E25           8946         FE            mov	-2[bp],ax
03764                                           !BCC_EOS
03765                                           ! 1177     while (--max > 0) {
03766 0E28           EB           2B            jmp .98
03767                       00000E2A            .99:
03768                                           ! 1178         outb(0x80, 0x00);
03769                                           ! Debug: list int = const 0 (used reg = )
03770 0E2A           31C0                       xor	ax,ax
03771 0E2C           50                         push	ax
03772                                           ! Debug: list int = const $80 (used reg = )
03773 0E2D           B8                   0080  mov	ax,#$80
03774 0E30           50                         push	ax
03775                                           ! Debug: func () void = outb+0 (used reg = )
03776 0E31           E8         F720            call	_outb
03777 0E34           83C4                   04  add	sp,*4
03778                                           !BCC_EOS
03779                                           ! 1179         if (inb(0x64) & 0x01) {
03780                                           ! Debug: list int = const $64 (used reg = )
03781 0E37           B8                   0064  mov	ax,*$64
03782 0E3A           50                         push	ax
03783                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03784 0E3B           E8         F700            call	_inb
03785 0E3E           44                         inc	sp
03786 0E3F           44                         inc	sp
03787                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03788 0E40           24                     01  and	al,*1
03789 0E42           84C0                       test	al,al
03790 0E44           74           0F            je  	.9A
03791                       00000E46            .9B:
03792                                           ! 1180             inb(0x60);
03793                                           ! Debug: list int = const $60 (used reg = )
03794 0E46           B8                   0060  mov	ax,*$60
03795 0E49           50                         push	ax
03796                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03797 0E4A           E8         F6F1            call	_inb
03798 0E4D           44                         inc	sp
03799 0E4E           44                         inc	sp
03800                                           !BCC_EOS
03801                                           ! 1181             max = 2;
03802                                           ! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
03803 0E4F           B8                   0002  mov	ax,*2
03804 0E52           8946         FE            mov	-2[bp],ax
03805                                           !BCC_EOS
03806                                           ! 1182             }
03807                                           ! 1183         }
03808                       00000E55            .9A:
03809                                           ! 1184     outb(0x64, 0xaa);
03810                       00000E55            .98:
03811                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03812 0E55           8B46         FE            mov	ax,-2[bp]
03813 0E58           48                         dec	ax
03814 0E59           8946         FE            mov	-2[bp],ax
03815                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03816 0E5C           85C0                       test	ax,ax
03817 0E5E           75           CA            jne	.99
03818                       00000E60            .9C:
03819                       00000E60            .97:
03820                                           ! Debug: list int = const $AA (used reg = )
03821 0E60           B8                   00AA  mov	ax,#$AA
03822 0E63           50                         push	ax
03823                                           ! Debug: list int = const $64 (used reg = )
03824 0E64           B8                   0064  mov	ax,*$64
03825 0E67           50                         push	ax
03826                                           ! Debug: func () void = outb+0 (used reg = )
03827 0E68           E8         F6E9            call	_outb
03828 0E6B           83C4                   04  add	sp,*4
03829                                           !BCC_EOS
03830                                           ! 1185     max=0xffff;
03831                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03832 0E6E           B8                   FFFF  mov	ax,#$FFFF
03833 0E71           8946         FE            mov	-2[bp],ax
03834                                           !BCC_EOS
03835                                           ! 1186     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
03836 0E74           EB           0D            jmp .9E
03837                       00000E76            .9F:
03838                                           ! Debug: list int = const 0 (used reg = )
03839 0E76           31C0                       xor	ax,ax
03840 0E78           50                         push	ax
03841                                           ! Debug: list int = const $80 (used reg = )
03842 0E79           B8                   0080  mov	ax,#$80
03843 0E7C           50                         push	ax
03844                                           ! Debug: func () void = outb+0 (used reg = )
03845 0E7D           E8         F6D4            call	_outb
03846 0E80           83C4                   04  add	sp,*4
03847                                           !BCC_EOS
03848                                           ! 1187     if (max==0x0) keyboard_panic(00);
03849                       00000E83            .9E:
03850                                           ! Debug: list int = const $64 (used reg = )
03851 0E83           B8                   0064  mov	ax,*$64
03852 0E86           50                         push	ax
03853                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03854 0E87           E8         F6B4            call	_inb
03855 0E8A           44                         inc	sp
03856 0E8B           44                         inc	sp
03857                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
03858 0E8C           24                     02  and	al,*2
03859 0E8E           84C0                       test	al,al
03860 0E90           74           0B            je  	.A0
03861                       00000E92            .A1:
03862                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03863 0E92           8B46         FE            mov	ax,-2[bp]
03864 0E95           48                         dec	ax
03865 0E96           8946         FE            mov	-2[bp],ax
03866                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03867 0E99           85C0                       test	ax,ax
03868 0E9B           75           D9            jne	.9F
03869                       00000E9D            .A0:
03870                       00000E9D            .9D:
03871                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03872 0E9D           8B46         FE            mov	ax,-2[bp]
03873 0EA0           85C0                       test	ax,ax
03874 0EA2           75           08            jne 	.A2
03875                       00000EA4            .A3:
03876                                           ! Debug: list int = const 0 (used reg = )
03877 0EA4           31C0                       xor	ax,ax
03878 0EA6           50                         push	ax
03879                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03880 0EA7           E8         0408            call	_keyboard_panic
03881 0EAA           44                         inc	sp
03882 0EAB           44                         inc	sp
03883                                           !BCC_EOS
03884                                           ! 1188     max=0xffff;
03885                       00000EAC            .A2:
03886                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03887 0EAC           B8                   FFFF  mov	ax,#$FFFF
03888 0EAF           8946         FE            mov	-2[bp],ax
03889                                           !BCC_EOS
03890                                           ! 1189     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
03891 0EB2           EB           0E            jmp .A5
03892                       00000EB4            .A6:
03893                                           ! Debug: list int = const 1 (used reg = )
03894 0EB4           B8                   0001  mov	ax,*1
03895 0EB7           50                         push	ax
03896                                           ! Debug: list int = const $80 (used reg = )
03897 0EB8           B8                   0080  mov	ax,#$80
03898 0EBB           50                         push	ax
03899                                           ! Debug: func () void = outb+0 (used reg = )
03900 0EBC           E8         F695            call	_outb
03901 0EBF           83C4                   04  add	sp,*4
03902                                           !BCC_EOS
03903                                           ! 1190     if (max==0x0) keyboard_panic(01);
03904                       00000EC2            .A5:
03905                                           ! Debug: list int = const $64 (used reg = )
03906 0EC2           B8                   0064  mov	ax,*$64
03907 0EC5           50                         push	ax
03908                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03909 0EC6           E8         F675            call	_inb
03910 0EC9           44                         inc	sp
03911 0ECA           44                         inc	sp
03912                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
03913 0ECB           24                     01  and	al,*1
03914                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
03915 0ECD           84C0                       test	al,al
03916 0ECF           75           0B            jne 	.A7
03917                       00000ED1            .A8:
03918                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
03919 0ED1           8B46         FE            mov	ax,-2[bp]
03920 0ED4           48                         dec	ax
03921 0ED5           8946         FE            mov	-2[bp],ax
03922                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
03923 0ED8           85C0                       test	ax,ax
03924 0EDA           75           D8            jne	.A6
03925                       00000EDC            .A7:
03926                       00000EDC            .A4:
03927                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
03928 0EDC           8B46         FE            mov	ax,-2[bp]
03929 0EDF           85C0                       test	ax,ax
03930 0EE1           75           09            jne 	.A9
03931                       00000EE3            .AA:
03932                                           ! Debug: list int = const 1 (used reg = )
03933 0EE3           B8                   0001  mov	ax,*1
03934 0EE6           50                         push	ax
03935                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03936 0EE7           E8         03C8            call	_keyboard_panic
03937 0EEA           44                         inc	sp
03938 0EEB           44                         inc	sp
03939                                           !BCC_EOS
03940                                           ! 1191     if ((inb(0x60) != 0x55)){
03941                       00000EEC            .A9:
03942                                           ! Debug: list int = const $60 (used reg = )
03943 0EEC           B8                   0060  mov	ax,*$60
03944 0EEF           50                         push	ax
03945                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03946 0EF0           E8         F64B            call	_inb
03947 0EF3           44                         inc	sp
03948 0EF4           44                         inc	sp
03949                                           ! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
03950 0EF5           3C                     55  cmp	al,*$55
03951 0EF7           74           09            je  	.AB
03952                       00000EF9            .AC:
03953                                           ! 1192         keyboard_panic(991);
03954                                           ! Debug: list int = const $3DF (used reg = )
03955 0EF9           B8                   03DF  mov	ax,#$3DF
03956 0EFC           50                         push	ax
03957                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
03958 0EFD           E8         03B2            call	_keyboard_panic
03959 0F00           44                         inc	sp
03960 0F01           44                         inc	sp
03961                                           !BCC_EOS
03962                                           ! 1193     }
03963                                           ! 1194     outb(0x64,0xab);
03964                       00000F02            .AB:
03965                                           ! Debug: list int = const $AB (used reg = )
03966 0F02           B8                   00AB  mov	ax,#$AB
03967 0F05           50                         push	ax
03968                                           ! Debug: list int = const $64 (used reg = )
03969 0F06           B8                   0064  mov	ax,*$64
03970 0F09           50                         push	ax
03971                                           ! Debug: func () void = outb+0 (used reg = )
03972 0F0A           E8         F647            call	_outb
03973 0F0D           83C4                   04  add	sp,*4
03974                                           !BCC_EOS
03975                                           ! 1195     max=0xffff;
03976                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
03977 0F10           B8                   FFFF  mov	ax,#$FFFF
03978 0F13           8946         FE            mov	-2[bp],ax
03979                                           !BCC_EOS
03980                                           ! 1196     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
03981 0F16           EB           0E            jmp .AE
03982                       00000F18            .AF:
03983                                           ! Debug: list int = const $10 (used reg = )
03984 0F18           B8                   0010  mov	ax,*$10
03985 0F1B           50                         push	ax
03986                                           ! Debug: list int = const $80 (used reg = )
03987 0F1C           B8                   0080  mov	ax,#$80
03988 0F1F           50                         push	ax
03989                                           ! Debug: func () void = outb+0 (used reg = )
03990 0F20           E8         F631            call	_outb
03991 0F23           83C4                   04  add	sp,*4
03992                                           !BCC_EOS
03993                                           ! 1197     if (max==0x0) keyboard_panic(10);
03994                       00000F26            .AE:
03995                                           ! Debug: list int = const $64 (used reg = )
03996 0F26           B8                   0064  mov	ax,*$64
03997 0F29           50                         push	ax
03998                                           ! Debug: func () unsigned char = inb+0 (used reg = )
03999 0F2A           E8         F611            call	_inb
04000 0F2D           44                         inc	sp
04001 0F2E           44                         inc	sp
04002                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04003 0F2F           24                     02  and	al,*2
04004 0F31           84C0                       test	al,al
04005 0F33           74           0B            je  	.B0
04006                       00000F35            .B1:
04007                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04008 0F35           8B46         FE            mov	ax,-2[bp]
04009 0F38           48                         dec	ax
04010 0F39           8946         FE            mov	-2[bp],ax
04011                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04012 0F3C           85C0                       test	ax,ax
04013 0F3E           75           D8            jne	.AF
04014                       00000F40            .B0:
04015                       00000F40            .AD:
04016                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04017 0F40           8B46         FE            mov	ax,-2[bp]
04018 0F43           85C0                       test	ax,ax
04019 0F45           75           09            jne 	.B2
04020                       00000F47            .B3:
04021                                           ! Debug: list int = const $A (used reg = )
04022 0F47           B8                   000A  mov	ax,*$A
04023 0F4A           50                         push	ax
04024                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04025 0F4B           E8         0364            call	_keyboard_panic
04026 0F4E           44                         inc	sp
04027 0F4F           44                         inc	sp
04028                                           !BCC_EOS
04029                                           ! 1198     max=0xffff;
04030                       00000F50            .B2:
04031                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04032 0F50           B8                   FFFF  mov	ax,#$FFFF
04033 0F53           8946         FE            mov	-2[bp],ax
04034                                           !BCC_EOS
04035                                           ! 1199     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
04036 0F56           EB           0E            jmp .B5
04037                       00000F58            .B6:
04038                                           ! Debug: list int = const $11 (used reg = )
04039 0F58           B8                   0011  mov	ax,*$11
04040 0F5B           50                         push	ax
04041                                           ! Debug: list int = const $80 (used reg = )
04042 0F5C           B8                   0080  mov	ax,#$80
04043 0F5F           50                         push	ax
04044                                           ! Debug: func () void = outb+0 (used reg = )
04045 0F60           E8         F5F1            call	_outb
04046 0F63           83C4                   04  add	sp,*4
04047                                           !BCC_EOS
04048                                           ! 1200     if (max==0x0) keyboard_panic(11);
04049                       00000F66            .B5:
04050                                           ! Debug: list int = const $64 (used reg = )
04051 0F66           B8                   0064  mov	ax,*$64
04052 0F69           50                         push	ax
04053                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04054 0F6A           E8         F5D1            call	_inb
04055 0F6D           44                         inc	sp
04056 0F6E           44                         inc	sp
04057                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04058 0F6F           24                     01  and	al,*1
04059                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04060 0F71           84C0                       test	al,al
04061 0F73           75           0B            jne 	.B7
04062                       00000F75            .B8:
04063                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04064 0F75           8B46         FE            mov	ax,-2[bp]
04065 0F78           48                         dec	ax
04066 0F79           8946         FE            mov	-2[bp],ax
04067                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04068 0F7C           85C0                       test	ax,ax
04069 0F7E           75           D8            jne	.B6
04070                       00000F80            .B7:
04071                       00000F80            .B4:
04072                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04073 0F80           8B46         FE            mov	ax,-2[bp]
04074 0F83           85C0                       test	ax,ax
04075 0F85           75           09            jne 	.B9
04076                       00000F87            .BA:
04077                                           ! Debug: list int = const $B (used reg = )
04078 0F87           B8                   000B  mov	ax,*$B
04079 0F8A           50                         push	ax
04080                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04081 0F8B           E8         0324            call	_keyboard_panic
04082 0F8E           44                         inc	sp
04083 0F8F           44                         inc	sp
04084                                           !BCC_EOS
04085                                           ! 1201     if ((inb(0x60) != 0x00)) {
04086                       00000F90            .B9:
04087                                           ! Debug: list int = const $60 (used reg = )
04088 0F90           B8                   0060  mov	ax,*$60
04089 0F93           50                         push	ax
04090                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04091 0F94           E8         F5A7            call	_inb
04092 0F97           44                         inc	sp
04093 0F98           44                         inc	sp
04094                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
04095 0F99           84C0                       test	al,al
04096 0F9B           74           09            je  	.BB
04097                       00000F9D            .BC:
04098                                           ! 1202         keyboard_panic(992);
04099                                           ! Debug: list int = const $3E0 (used reg = )
04100 0F9D           B8                   03E0  mov	ax,#$3E0
04101 0FA0           50                         push	ax
04102                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04103 0FA1           E8         030E            call	_keyboard_panic
04104 0FA4           44                         inc	sp
04105 0FA5           44                         inc	sp
04106                                           !BCC_EOS
04107                                           ! 1203     }
04108                                           ! 1204     outb(0x64,0xae);
04109                       00000FA6            .BB:
04110                                           ! Debug: list int = const $AE (used reg = )
04111 0FA6           B8                   00AE  mov	ax,#$AE
04112 0FA9           50                         push	ax
04113                                           ! Debug: list int = const $64 (used reg = )
04114 0FAA           B8                   0064  mov	ax,*$64
04115 0FAD           50                         push	ax
04116                                           ! Debug: func () void = outb+0 (used reg = )
04117 0FAE           E8         F5A3            call	_outb
04118 0FB1           83C4                   04  add	sp,*4
04119                                           !BCC_EOS
04120                                           ! 1205     outb(0x64,0xa8);
04121                                           ! Debug: list int = const $A8 (used reg = )
04122 0FB4           B8                   00A8  mov	ax,#$A8
04123 0FB7           50                         push	ax
04124                                           ! Debug: list int = const $64 (used reg = )
04125 0FB8           B8                   0064  mov	ax,*$64
04126 0FBB           50                         push	ax
04127                                           ! Debug: func () void = outb+0 (used reg = )
04128 0FBC           E8         F595            call	_outb
04129 0FBF           83C4                   04  add	sp,*4
04130                                           !BCC_EOS
04131                                           ! 1206     outb(0x60, 0xff);
04132                                           ! Debug: list int = const $FF (used reg = )
04133 0FC2           B8                   00FF  mov	ax,#$FF
04134 0FC5           50                         push	ax
04135                                           ! Debug: list int = const $60 (used reg = )
04136 0FC6           B8                   0060  mov	ax,*$60
04137 0FC9           50                         push	ax
04138                                           ! Debug: func () void = outb+0 (used reg = )
04139 0FCA           E8         F587            call	_outb
04140 0FCD           83C4                   04  add	sp,*4
04141                                           !BCC_EOS
04142                                           ! 1207     max=0xffff;
04143                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04144 0FD0           B8                   FFFF  mov	ax,#$FFFF
04145 0FD3           8946         FE            mov	-2[bp],ax
04146                                           !BCC_EOS
04147                                           ! 1208     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20)
04148 0FD6           EB           0E            jmp .BE
04149                       00000FD8            .BF:
04150                                           ! 1208 ;
04151                                           ! Debug: list int = const $20 (used reg = )
04152 0FD8           B8                   0020  mov	ax,*$20
04153 0FDB           50                         push	ax
04154                                           ! Debug: list int = const $80 (used reg = )
04155 0FDC           B8                   0080  mov	ax,#$80
04156 0FDF           50                         push	ax
04157                                           ! Debug: func () void = outb+0 (used reg = )
04158 0FE0           E8         F571            call	_outb
04159 0FE3           83C4                   04  add	sp,*4
04160                                           !BCC_EOS
04161                                           ! 1209     if (max==0x0) keyboard_panic(20);
04162                       00000FE6            .BE:
04163                                           ! Debug: list int = const $64 (used reg = )
04164 0FE6           B8                   0064  mov	ax,*$64
04165 0FE9           50                         push	ax
04166                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04167 0FEA           E8         F551            call	_inb
04168 0FED           44                         inc	sp
04169 0FEE           44                         inc	sp
04170                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04171 0FEF           24                     02  and	al,*2
04172 0FF1           84C0                       test	al,al
04173 0FF3           74           0B            je  	.C0
04174                       00000FF5            .C1:
04175                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04176 0FF5           8B46         FE            mov	ax,-2[bp]
04177 0FF8           48                         dec	ax
04178 0FF9           8946         FE            mov	-2[bp],ax
04179                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04180 0FFC           85C0                       test	ax,ax
04181 0FFE           75           D8            jne	.BF
04182                       00001000            .C0:
04183                       00001000            .BD:
04184                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04185 1000           8B46         FE            mov	ax,-2[bp]
04186 1003           85C0                       test	ax,ax
04187 1005           75           09            jne 	.C2
04188                       00001007            .C3:
04189                                           ! Debug: list int = const $14 (used reg = )
04190 1007           B8                   0014  mov	ax,*$14
04191 100A           50                         push	ax
04192                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04193 100B           E8         02A4            call	_keyboard_panic
04194 100E           44                         inc	sp
04195 100F           44                         inc	sp
04196                                           !BCC_EOS
04197                                           ! 1210     max=0xffff;
04198                       00001010            .C2:
04199                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04200 1010           B8                   FFFF  mov	ax,#$FFFF
04201 1013           8946         FE            mov	-2[bp],ax
04202                                           !BCC_EOS
04203                                           ! 1211     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
04204 1016           EB           0E            jmp .C5
04205                       00001018            .C6:
04206                                           ! Debug: list int = const $21 (used reg = )
04207 1018           B8                   0021  mov	ax,*$21
04208 101B           50                         push	ax
04209                                           ! Debug: list int = const $80 (used reg = )
04210 101C           B8                   0080  mov	ax,#$80
04211 101F           50                         push	ax
04212                                           ! Debug: func () void = outb+0 (used reg = )
04213 1020           E8         F531            call	_outb
04214 1023           83C4                   04  add	sp,*4
04215                                           !BCC_EOS
04216                                           ! 1212     if (max==0x0) keyboard_panic(21);
04217                       00001026            .C5:
04218                                           ! Debug: list int = const $64 (used reg = )
04219 1026           B8                   0064  mov	ax,*$64
04220 1029           50                         push	ax
04221                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04222 102A           E8         F511            call	_inb
04223 102D           44                         inc	sp
04224 102E           44                         inc	sp
04225                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04226 102F           24                     01  and	al,*1
04227                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04228 1031           84C0                       test	al,al
04229 1033           75           0B            jne 	.C7
04230                       00001035            .C8:
04231                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04232 1035           8B46         FE            mov	ax,-2[bp]
04233 1038           48                         dec	ax
04234 1039           8946         FE            mov	-2[bp],ax
04235                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04236 103C           85C0                       test	ax,ax
04237 103E           75           D8            jne	.C6
04238                       00001040            .C7:
04239                       00001040            .C4:
04240                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04241 1040           8B46         FE            mov	ax,-2[bp]
04242 1043           85C0                       test	ax,ax
04243 1045           75           09            jne 	.C9
04244                       00001047            .CA:
04245                                           ! Debug: list int = const $15 (used reg = )
04246 1047           B8                   0015  mov	ax,*$15
04247 104A           50                         push	ax
04248                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04249 104B           E8         0264            call	_keyboard_panic
04250 104E           44                         inc	sp
04251 104F           44                         inc	sp
04252                                           !BCC_EOS
04253                                           ! 1213     if ((inb(0x60) != 0xfa)) {
04254                       00001050            .C9:
04255                                           ! Debug: list int = const $60 (used reg = )
04256 1050           B8                   0060  mov	ax,*$60
04257 1053           50                         push	ax
04258                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04259 1054           E8         F4E7            call	_inb
04260 1057           44                         inc	sp
04261 1058           44                         inc	sp
04262                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04263 1059           3C                     FA  cmp	al,#$FA
04264 105B           74           09            je  	.CB
04265                       0000105D            .CC:
04266                                           ! 1214         keyboard_panic(993);
04267                                           ! Debug: list int = const $3E1 (used reg = )
04268 105D           B8                   03E1  mov	ax,#$3E1
04269 1060           50                         push	ax
04270                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04271 1061           E8         024E            call	_keyboard_panic
04272 1064           44                         inc	sp
04273 1065           44                         inc	sp
04274                                           !BCC_EOS
04275                                           ! 1215     }
04276                                           ! 1216     max=0xffff;
04277                       00001066            .CB:
04278                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04279 1066           B8                   FFFF  mov	ax,#$FFFF
04280 1069           8946         FE            mov	-2[bp],ax
04281                                           !BCC_EOS
04282                                           ! 1217     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
04283 106C           EB           0E            jmp .CE
04284                       0000106E            .CF:
04285                                           ! Debug: list int = const $31 (used reg = )
04286 106E           B8                   0031  mov	ax,*$31
04287 1071           50                         push	ax
04288                                           ! Debug: list int = const $80 (used reg = )
04289 1072           B8                   0080  mov	ax,#$80
04290 1075           50                         push	ax
04291                                           ! Debug: func () void = outb+0 (used reg = )
04292 1076           E8         F4DB            call	_outb
04293 1079           83C4                   04  add	sp,*4
04294                                           !BCC_EOS
04295                                           ! 1218     if (max==0x0) keyboard_panic(31);
04296                       0000107C            .CE:
04297                                           ! Debug: list int = const $64 (used reg = )
04298 107C           B8                   0064  mov	ax,*$64
04299 107F           50                         push	ax
04300                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04301 1080           E8         F4BB            call	_inb
04302 1083           44                         inc	sp
04303 1084           44                         inc	sp
04304                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04305 1085           24                     01  and	al,*1
04306                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04307 1087           84C0                       test	al,al
04308 1089           75           0B            jne 	.D0
04309                       0000108B            .D1:
04310                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04311 108B           8B46         FE            mov	ax,-2[bp]
04312 108E           48                         dec	ax
04313 108F           8946         FE            mov	-2[bp],ax
04314                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04315 1092           85C0                       test	ax,ax
04316 1094           75           D8            jne	.CF
04317                       00001096            .D0:
04318                       00001096            .CD:
04319                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04320 1096           8B46         FE            mov	ax,-2[bp]
04321 1099           85C0                       test	ax,ax
04322 109B           75           09            jne 	.D2
04323                       0000109D            .D3:
04324                                           ! Debug: list int = const $1F (used reg = )
04325 109D           B8                   001F  mov	ax,*$1F
04326 10A0           50                         push	ax
04327                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04328 10A1           E8         020E            call	_keyboard_panic
04329 10A4           44                         inc	sp
04330 10A5           44                         inc	sp
04331                                           !BCC_EOS
04332                                           ! 1219     if ((inb(0x60) != 0xaa)) {
04333                       000010A6            .D2:
04334                                           ! Debug: list int = const $60 (used reg = )
04335 10A6           B8                   0060  mov	ax,*$60
04336 10A9           50                         push	ax
04337                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04338 10AA           E8         F491            call	_inb
04339 10AD           44                         inc	sp
04340 10AE           44                         inc	sp
04341                                           ! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
04342 10AF           3C                     AA  cmp	al,#$AA
04343 10B1           74           09            je  	.D4
04344                       000010B3            .D5:
04345                                           ! 1220         keyboard_panic(994);
04346                                           ! Debug: list int = const $3E2 (used reg = )
04347 10B3           B8                   03E2  mov	ax,#$3E2
04348 10B6           50                         push	ax
04349                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04350 10B7           E8         01F8            call	_keyboard_panic
04351 10BA           44                         inc	sp
04352 10BB           44                         inc	sp
04353                                           !BCC_EOS
04354                                           ! 1221     }
04355                                           ! 1222     outb(0x60, 0xf5);
04356                       000010BC            .D4:
04357                                           ! Debug: list int = const $F5 (used reg = )
04358 10BC           B8                   00F5  mov	ax,#$F5
04359 10BF           50                         push	ax
04360                                           ! Debug: list int = const $60 (used reg = )
04361 10C0           B8                   0060  mov	ax,*$60
04362 10C3           50                         push	ax
04363                                           ! Debug: func () void = outb+0 (used reg = )
04364 10C4           E8         F48D            call	_outb
04365 10C7           83C4                   04  add	sp,*4
04366                                           !BCC_EOS
04367                                           ! 1223     max=0xffff;
04368                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04369 10CA           B8                   FFFF  mov	ax,#$FFFF
04370 10CD           8946         FE            mov	-2[bp],ax
04371                                           !BCC_EOS
04372                                           ! 1224     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
04373 10D0           EB           0E            jmp .D7
04374                       000010D2            .D8:
04375                                           ! Debug: list int = const $40 (used reg = )
04376 10D2           B8                   0040  mov	ax,*$40
04377 10D5           50                         push	ax
04378                                           ! Debug: list int = const $80 (used reg = )
04379 10D6           B8                   0080  mov	ax,#$80
04380 10D9           50                         push	ax
04381                                           ! Debug: func () void = outb+0 (used reg = )
04382 10DA           E8         F477            call	_outb
04383 10DD           83C4                   04  add	sp,*4
04384                                           !BCC_EOS
04385                                           ! 1225     if (max==0x0) keyboard_panic(40);
04386                       000010E0            .D7:
04387                                           ! Debug: list int = const $64 (used reg = )
04388 10E0           B8                   0064  mov	ax,*$64
04389 10E3           50                         push	ax
04390                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04391 10E4           E8         F457            call	_inb
04392 10E7           44                         inc	sp
04393 10E8           44                         inc	sp
04394                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04395 10E9           24                     02  and	al,*2
04396 10EB           84C0                       test	al,al
04397 10ED           74           0B            je  	.D9
04398                       000010EF            .DA:
04399                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04400 10EF           8B46         FE            mov	ax,-2[bp]
04401 10F2           48                         dec	ax
04402 10F3           8946         FE            mov	-2[bp],ax
04403                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04404 10F6           85C0                       test	ax,ax
04405 10F8           75           D8            jne	.D8
04406                       000010FA            .D9:
04407                       000010FA            .D6:
04408                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04409 10FA           8B46         FE            mov	ax,-2[bp]
04410 10FD           85C0                       test	ax,ax
04411 10FF           75           09            jne 	.DB
04412                       00001101            .DC:
04413                                           ! Debug: list int = const $28 (used reg = )
04414 1101           B8                   0028  mov	ax,*$28
04415 1104           50                         push	ax
04416                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04417 1105           E8         01AA            call	_keyboard_panic
04418 1108           44                         inc	sp
04419 1109           44                         inc	sp
04420                                           !BCC_EOS
04421                                           ! 1226     max=0xffff;
04422                       0000110A            .DB:
04423                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04424 110A           B8                   FFFF  mov	ax,#$FFFF
04425 110D           8946         FE            mov	-2[bp],ax
04426                                           !BCC_EOS
04427                                           ! 1227     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
04428 1110           EB           0E            jmp .DE
04429                       00001112            .DF:
04430                                           ! Debug: list int = const $41 (used reg = )
04431 1112           B8                   0041  mov	ax,*$41
04432 1115           50                         push	ax
04433                                           ! Debug: list int = const $80 (used reg = )
04434 1116           B8                   0080  mov	ax,#$80
04435 1119           50                         push	ax
04436                                           ! Debug: func () void = outb+0 (used reg = )
04437 111A           E8         F437            call	_outb
04438 111D           83C4                   04  add	sp,*4
04439                                           !BCC_EOS
04440                                           ! 1228     if (max==0x0) keyboard_panic(41);
04441                       00001120            .DE:
04442                                           ! Debug: list int = const $64 (used reg = )
04443 1120           B8                   0064  mov	ax,*$64
04444 1123           50                         push	ax
04445                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04446 1124           E8         F417            call	_inb
04447 1127           44                         inc	sp
04448 1128           44                         inc	sp
04449                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04450 1129           24                     01  and	al,*1
04451                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04452 112B           84C0                       test	al,al
04453 112D           75           0B            jne 	.E0
04454                       0000112F            .E1:
04455                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04456 112F           8B46         FE            mov	ax,-2[bp]
04457 1132           48                         dec	ax
04458 1133           8946         FE            mov	-2[bp],ax
04459                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04460 1136           85C0                       test	ax,ax
04461 1138           75           D8            jne	.DF
04462                       0000113A            .E0:
04463                       0000113A            .DD:
04464                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04465 113A           8B46         FE            mov	ax,-2[bp]
04466 113D           85C0                       test	ax,ax
04467 113F           75           09            jne 	.E2
04468                       00001141            .E3:
04469                                           ! Debug: list int = const $29 (used reg = )
04470 1141           B8                   0029  mov	ax,*$29
04471 1144           50                         push	ax
04472                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04473 1145           E8         016A            call	_keyboard_panic
04474 1148           44                         inc	sp
04475 1149           44                         inc	sp
04476                                           !BCC_EOS
04477                                           ! 1229     if ((inb(0x60) != 0xfa)) {
04478                       0000114A            .E2:
04479                                           ! Debug: list int = const $60 (used reg = )
04480 114A           B8                   0060  mov	ax,*$60
04481 114D           50                         push	ax
04482                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04483 114E           E8         F3ED            call	_inb
04484 1151           44                         inc	sp
04485 1152           44                         inc	sp
04486                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04487 1153           3C                     FA  cmp	al,#$FA
04488 1155           74           09            je  	.E4
04489                       00001157            .E5:
04490                                           ! 1230         keyboard_panic(995);
04491                                           ! Debug: list int = const $3E3 (used reg = )
04492 1157           B8                   03E3  mov	ax,#$3E3
04493 115A           50                         push	ax
04494                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04495 115B           E8         0154            call	_keyboard_panic
04496 115E           44                         inc	sp
04497 115F           44                         inc	sp
04498                                           !BCC_EOS
04499                                           ! 1231     }
04500                                           ! 1232     outb(0x64, 0x60);
04501                       00001160            .E4:
04502                                           ! Debug: list int = const $60 (used reg = )
04503 1160           B8                   0060  mov	ax,*$60
04504 1163           50                         push	ax
04505                                           ! Debug: list int = const $64 (used reg = )
04506 1164           B8                   0064  mov	ax,*$64
04507 1167           50                         push	ax
04508                                           ! Debug: func () void = outb+0 (used reg = )
04509 1168           E8         F3E9            call	_outb
04510 116B           83C4                   04  add	sp,*4
04511                                           !BCC_EOS
04512                                           ! 1233     max=0xffff;
04513                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04514 116E           B8                   FFFF  mov	ax,#$FFFF
04515 1171           8946         FE            mov	-2[bp],ax
04516                                           !BCC_EOS
04517                                           ! 1234     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
04518 1174           EB           0E            jmp .E7
04519                       00001176            .E8:
04520                                           ! Debug: list int = const $50 (used reg = )
04521 1176           B8                   0050  mov	ax,*$50
04522 1179           50                         push	ax
04523                                           ! Debug: list int = const $80 (used reg = )
04524 117A           B8                   0080  mov	ax,#$80
04525 117D           50                         push	ax
04526                                           ! Debug: func () void = outb+0 (used reg = )
04527 117E           E8         F3D3            call	_outb
04528 1181           83C4                   04  add	sp,*4
04529                                           !BCC_EOS
04530                                           ! 1235     if (max==0x0) keyboard_panic(50);
04531                       00001184            .E7:
04532                                           ! Debug: list int = const $64 (used reg = )
04533 1184           B8                   0064  mov	ax,*$64
04534 1187           50                         push	ax
04535                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04536 1188           E8         F3B3            call	_inb
04537 118B           44                         inc	sp
04538 118C           44                         inc	sp
04539                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04540 118D           24                     02  and	al,*2
04541 118F           84C0                       test	al,al
04542 1191           74           0B            je  	.E9
04543                       00001193            .EA:
04544                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04545 1193           8B46         FE            mov	ax,-2[bp]
04546 1196           48                         dec	ax
04547 1197           8946         FE            mov	-2[bp],ax
04548                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04549 119A           85C0                       test	ax,ax
04550 119C           75           D8            jne	.E8
04551                       0000119E            .E9:
04552                       0000119E            .E6:
04553                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04554 119E           8B46         FE            mov	ax,-2[bp]
04555 11A1           85C0                       test	ax,ax
04556 11A3           75           09            jne 	.EB
04557                       000011A5            .EC:
04558                                           ! Debug: list int = const $32 (used reg = )
04559 11A5           B8                   0032  mov	ax,*$32
04560 11A8           50                         push	ax
04561                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04562 11A9           E8         0106            call	_keyboard_panic
04563 11AC           44                         inc	sp
04564 11AD           44                         inc	sp
04565                                           !BCC_EOS
04566                                           ! 1236     outb(0x60, 0x61);
04567                       000011AE            .EB:
04568                                           ! Debug: list int = const $61 (used reg = )
04569 11AE           B8                   0061  mov	ax,*$61
04570 11B1           50                         push	ax
04571                                           ! Debug: list int = const $60 (used reg = )
04572 11B2           B8                   0060  mov	ax,*$60
04573 11B5           50                         push	ax
04574                                           ! Debug: func () void = outb+0 (used reg = )
04575 11B6           E8         F39B            call	_outb
04576 11B9           83C4                   04  add	sp,*4
04577                                           !BCC_EOS
04578                                           ! 1237     max=0xffff;
04579                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04580 11BC           B8                   FFFF  mov	ax,#$FFFF
04581 11BF           8946         FE            mov	-2[bp],ax
04582                                           !BCC_EOS
04583                                           ! 1238     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
04584 11C2           EB           0E            jmp .EE
04585                       000011C4            .EF:
04586                                           ! Debug: list int = const $60 (used reg = )
04587 11C4           B8                   0060  mov	ax,*$60
04588 11C7           50                         push	ax
04589                                           ! Debug: list int = const $80 (used reg = )
04590 11C8           B8                   0080  mov	ax,#$80
04591 11CB           50                         push	ax
04592                                           ! Debug: func () void = outb+0 (used reg = )
04593 11CC           E8         F385            call	_outb
04594 11CF           83C4                   04  add	sp,*4
04595                                           !BCC_EOS
04596                                           ! 1239     if (max==0x0) keyboard_panic(60);
04597                       000011D2            .EE:
04598                                           ! Debug: list int = const $64 (used reg = )
04599 11D2           B8                   0064  mov	ax,*$64
04600 11D5           50                         push	ax
04601                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04602 11D6           E8         F365            call	_inb
04603 11D9           44                         inc	sp
04604 11DA           44                         inc	sp
04605                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04606 11DB           24                     02  and	al,*2
04607 11DD           84C0                       test	al,al
04608 11DF           74           0B            je  	.F0
04609                       000011E1            .F1:
04610                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04611 11E1           8B46         FE            mov	ax,-2[bp]
04612 11E4           48                         dec	ax
04613 11E5           8946         FE            mov	-2[bp],ax
04614                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04615 11E8           85C0                       test	ax,ax
04616 11EA           75           D8            jne	.EF
04617                       000011EC            .F0:
04618                       000011EC            .ED:
04619                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04620 11EC           8B46         FE            mov	ax,-2[bp]
04621 11EF           85C0                       test	ax,ax
04622 11F1           75           09            jne 	.F2
04623                       000011F3            .F3:
04624                                           ! Debug: list int = const $3C (used reg = )
04625 11F3           B8                   003C  mov	ax,*$3C
04626 11F6           50                         push	ax
04627                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04628 11F7           E8         00B8            call	_keyboard_panic
04629 11FA           44                         inc	sp
04630 11FB           44                         inc	sp
04631                                           !BCC_EOS
04632                                           ! 1240     outb(0x60, 0xf4);
04633                       000011FC            .F2:
04634                                           ! Debug: list int = const $F4 (used reg = )
04635 11FC           B8                   00F4  mov	ax,#$F4
04636 11FF           50                         push	ax
04637                                           ! Debug: list int = const $60 (used reg = )
04638 1200           B8                   0060  mov	ax,*$60
04639 1203           50                         push	ax
04640                                           ! Debug: func () void = outb+0 (used reg = )
04641 1204           E8         F34D            call	_outb
04642 1207           83C4                   04  add	sp,*4
04643                                           !BCC_EOS
04644                                           ! 1241     max=0xffff;
04645                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04646 120A           B8                   FFFF  mov	ax,#$FFFF
04647 120D           8946         FE            mov	-2[bp],ax
04648                                           !BCC_EOS
04649                                           ! 1242     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
04650 1210           EB           0E            jmp .F5
04651                       00001212            .F6:
04652                                           ! Debug: list int = const $70 (used reg = )
04653 1212           B8                   0070  mov	ax,*$70
04654 1215           50                         push	ax
04655                                           ! Debug: list int = const $80 (used reg = )
04656 1216           B8                   0080  mov	ax,#$80
04657 1219           50                         push	ax
04658                                           ! Debug: func () void = outb+0 (used reg = )
04659 121A           E8         F337            call	_outb
04660 121D           83C4                   04  add	sp,*4
04661                                           !BCC_EOS
04662                                           ! 1243     if (max==0x0) keyboard_panic(70);
04663                       00001220            .F5:
04664                                           ! Debug: list int = const $64 (used reg = )
04665 1220           B8                   0064  mov	ax,*$64
04666 1223           50                         push	ax
04667                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04668 1224           E8         F317            call	_inb
04669 1227           44                         inc	sp
04670 1228           44                         inc	sp
04671                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
04672 1229           24                     02  and	al,*2
04673 122B           84C0                       test	al,al
04674 122D           74           0B            je  	.F7
04675                       0000122F            .F8:
04676                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04677 122F           8B46         FE            mov	ax,-2[bp]
04678 1232           48                         dec	ax
04679 1233           8946         FE            mov	-2[bp],ax
04680                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04681 1236           85C0                       test	ax,ax
04682 1238           75           D8            jne	.F6
04683                       0000123A            .F7:
04684                       0000123A            .F4:
04685                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04686 123A           8B46         FE            mov	ax,-2[bp]
04687 123D           85C0                       test	ax,ax
04688 123F           75           09            jne 	.F9
04689                       00001241            .FA:
04690                                           ! Debug: list int = const $46 (used reg = )
04691 1241           B8                   0046  mov	ax,*$46
04692 1244           50                         push	ax
04693                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04694 1245           E8         006A            call	_keyboard_panic
04695 1248           44                         inc	sp
04696 1249           44                         inc	sp
04697                                           !BCC_EOS
04698                                           ! 1244     max=0xffff;
04699                       0000124A            .F9:
04700                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
04701 124A           B8                   FFFF  mov	ax,#$FFFF
04702 124D           8946         FE            mov	-2[bp],ax
04703                                           !BCC_EOS
04704                                           ! 1245     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
04705 1250           EB           0E            jmp .FC
04706                       00001252            .FD:
04707                                           ! Debug: list int = const $71 (used reg = )
04708 1252           B8                   0071  mov	ax,*$71
04709 1255           50                         push	ax
04710                                           ! Debug: list int = const $80 (used reg = )
04711 1256           B8                   0080  mov	ax,#$80
04712 1259           50                         push	ax
04713                                           ! Debug: func () void = outb+0 (used reg = )
04714 125A           E8         F2F7            call	_outb
04715 125D           83C4                   04  add	sp,*4
04716                                           !BCC_EOS
04717                                           ! 1246     if (max==0x0) keyboard_panic(70);
04718                       00001260            .FC:
04719                                           ! Debug: list int = const $64 (used reg = )
04720 1260           B8                   0064  mov	ax,*$64
04721 1263           50                         push	ax
04722                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04723 1264           E8         F2D7            call	_inb
04724 1267           44                         inc	sp
04725 1268           44                         inc	sp
04726                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
04727 1269           24                     01  and	al,*1
04728                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
04729 126B           84C0                       test	al,al
04730 126D           75           0B            jne 	.FE
04731                       0000126F            .FF:
04732                                           ! Debug: predec unsigned short max = [S+4-4] (used reg = )
04733 126F           8B46         FE            mov	ax,-2[bp]
04734 1272           48                         dec	ax
04735 1273           8946         FE            mov	-2[bp],ax
04736                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
04737 1276           85C0                       test	ax,ax
04738 1278           75           D8            jne	.FD
04739                       0000127A            .FE:
04740                       0000127A            .FB:
04741                                           ! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
04742 127A           8B46         FE            mov	ax,-2[bp]
04743 127D           85C0                       test	ax,ax
04744 127F           75           09            jne 	.100
04745                       00001281            .101:
04746                                           ! Debug: list int = const $46 (used reg = )
04747 1281           B8                   0046  mov	ax,*$46
04748 1284           50                         push	ax
04749                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04750 1285           E8         002A            call	_keyboard_panic
04751 1288           44                         inc	sp
04752 1289           44                         inc	sp
04753                                           !BCC_EOS
04754                                           ! 1247     if ((inb(0x60) != 0xfa)) {
04755                       0000128A            .100:
04756                                           ! Debug: list int = const $60 (used reg = )
04757 128A           B8                   0060  mov	ax,*$60
04758 128D           50                         push	ax
04759                                           ! Debug: func () unsigned char = inb+0 (used reg = )
04760 128E           E8         F2AD            call	_inb
04761 1291           44                         inc	sp
04762 1292           44                         inc	sp
04763                                           ! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
04764 1293           3C                     FA  cmp	al,#$FA
04765 1295           74           09            je  	.102
04766                       00001297            .103:
04767                                           ! 1248         keyboard_panic(996);
04768                                           ! Debug: list int = const $3E4 (used reg = )
04769 1297           B8                   03E4  mov	ax,#$3E4
04770 129A           50                         push	ax
04771                                           ! Debug: func () void = keyboard_panic+0 (used reg = )
04772 129B           E8         0014            call	_keyboard_panic
04773 129E           44                         inc	sp
04774 129F           44                         inc	sp
04775                                           !BCC_EOS
04776                                           ! 1249     }
04777                                           ! 1250     outb(0x80, 0x77);
04778                       000012A0            .102:
04779                                           ! Debug: list int = const $77 (used reg = )
04780 12A0           B8                   0077  mov	ax,*$77
04781 12A3           50                         push	ax
04782                                           ! Debug: list int = const $80 (used reg = )
04783 12A4           B8                   0080  mov	ax,#$80
04784 12A7           50                         push	ax
04785                                           ! Debug: func () void = outb+0 (used reg = )
04786 12A8           E8         F2A9            call	_outb
04787 12AB           83C4                   04  add	sp,*4
04788                                           !BCC_EOS
04789                                           ! 1251 }
04790 12AE           89EC                       mov	sp,bp
04791 12B0           5D                         pop	bp
04792 12B1           C3                         ret
04793                                           ! 1252   void
04794                                           ! 1253 keyboard_panic(status)
04795                                           ! 1254   Bit16u status;
04796                                           export	_keyboard_panic
04797                       000012B2            _keyboard_panic:
04798                                           !BCC_EOS
04799                                           ! 1255 {
04800                                           ! 1256   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
04801 12B2           55                         push	bp
04802 12B3           89E5                       mov	bp,sp
04803                                           ! Debug: list unsigned short status = [S+2+2] (used reg = )
04804 12B5           FF76         04            push	4[bp]
04805                                           ! Debug: list * char = .104+0 (used reg = )
04806 12B8           BB                   D643  mov	bx,#.104
04807 12BB           53                         push	bx
04808                                           ! Debug: list int = const 7 (used reg = )
04809 12BC           B8                   0007  mov	ax,*7
04810 12BF           50                         push	ax
04811                                           ! Debug: func () void = bios_printf+0 (used reg = )
04812 12C0           E8         F758            call	_bios_printf
04813 12C3           89EC                       mov	sp,bp
04814                                           !BCC_EOS
04815                                           ! 1257 }
04816 12C5           5D                         pop	bp
04817 12C6           C3                         ret
04818                                           ! 1258   void
04819                                           ! Register BX used in function keyboard_panic
04820                                           ! 1259 machine_reset()
04821                                           ! 1260 {
04822                                           export	_machine_reset
04823                       000012C7            _machine_reset:
04824                                           ! 1261 #asm
04825                                           !BCC_ASM
04826                                           ;we must check whether 0xFE is set or not
04827                                           ;if it is s3 resume, just jmp back to normal Post Entry
04828                                           ;below port io will prevent s3 resume
04829 12C7           B0                     0F    mov al, #0x0f
04830 12C9           E6                     70    out 0x70, al
04831 12CB           E4                     71    in al, 0x71
04832 12CD           3C                     FE    cmp al, #0xFE
04833 12CF   7503    E9         CD87              jz post
04834                                           ! 1270 endasm
04835                                           !BCC_ENDASM
04836                                           ! 1271   outb(0x64, 0x60);
04837 12D4           55                         push	bp
04838 12D5           89E5                       mov	bp,sp
04839                                           ! Debug: list int = const $60 (used reg = )
04840 12D7           B8                   0060  mov	ax,*$60
04841 12DA           50                         push	ax
04842                                           ! Debug: list int = const $64 (used reg = )
04843 12DB           B8                   0064  mov	ax,*$64
04844 12DE           50                         push	ax
04845                                           ! Debug: func () void = outb+0 (used reg = )
04846 12DF           E8         F272            call	_outb
04847 12E2           89EC                       mov	sp,bp
04848                                           !BCC_EOS
04849                                           ! 1272   outb(0x60, 0x14);
04850                                           ! Debug: list int = const $14 (used reg = )
04851 12E4           B8                   0014  mov	ax,*$14
04852 12E7           50                         push	ax
04853                                           ! Debug: list int = const $60 (used reg = )
04854 12E8           B8                   0060  mov	ax,*$60
04855 12EB           50                         push	ax
04856                                           ! Debug: func () void = outb+0 (used reg = )
04857 12EC           E8         F265            call	_outb
04858 12EF           89EC                       mov	sp,bp
04859                                           !BCC_EOS
04860                                           ! 1273   outb(0x64, 0xfe);
04861                                           ! Debug: list int = const $FE (used reg = )
04862 12F1           B8                   00FE  mov	ax,#$FE
04863 12F4           50                         push	ax
04864                                           ! Debug: list int = const $64 (used reg = )
04865 12F5           B8                   0064  mov	ax,*$64
04866 12F8           50                         push	ax
04867                                           ! Debug: func () void = outb+0 (used reg = )
04868 12F9           E8         F258            call	_outb
04869 12FC           89EC                       mov	sp,bp
04870                                           !BCC_EOS
04871                                           ! 1274   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
04872                                           ! Debug: list * char = .105+0 (used reg = )
04873 12FE           BB                   D627  mov	bx,#.105
04874 1301           53                         push	bx
04875                                           ! Debug: list int = const 7 (used reg = )
04876 1302           B8                   0007  mov	ax,*7
04877 1305           50                         push	ax
04878                                           ! Debug: func () void = bios_printf+0 (used reg = )
04879 1306           E8         F712            call	_bios_printf
04880 1309           89EC                       mov	sp,bp
04881                                           !BCC_EOS
04882                                           ! 1275 }
04883 130B           5D                         pop	bp
04884 130C           C3                         ret
04885                                           ! 1276   void
04886                                           ! Register BX used in function machine_reset
04887                                           ! 1277 clobber_entry_point()
04888                                           ! 1278 {
04889                                           export	_clobber_entry_point
04890                       0000130D            _clobber_entry_point:
04891                                           ! 1279     write_word(0xffff, 0x0001, machine_reset);
04892 130D           55                         push	bp
04893 130E           89E5                       mov	bp,sp
04894                                           ! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
04895                                           ! Debug: list * () void = machine_reset+0 (used reg = )
04896 1310           BB                   12C7  mov	bx,#_machine_reset
04897 1313           53                         push	bx
04898                                           ! Debug: list int = const 1 (used reg = )
04899 1314           B8                   0001  mov	ax,*1
04900 1317           50                         push	ax
04901                                           ! Debug: list unsigned int = const $FFFF (used reg = )
04902 1318           B8                   FFFF  mov	ax,#$FFFF
04903 131B           50                         push	ax
04904                                           ! Debug: func () void = write_word+0 (used reg = )
04905 131C           E8         F313            call	_write_word
04906 131F           89EC                       mov	sp,bp
04907                                           !BCC_EOS
04908                                           ! 1280 }
04909 1321           5D                         pop	bp
04910 1322           C3                         ret
04911                                           ! 1281   void
04912                                           ! Register BX used in function clobber_entry_point
04913                                           ! 1282 shutdown_status_panic(status)
04914                                           ! 1283   Bit16u status;
04915                                           export	_shutdown_status_panic
04916                       00001323            _shutdown_status_panic:
04917                                           !BCC_EOS
04918                                           ! 1284 {
04919                                           ! 1285   bios_printf((2 | 4 | 1), "Unimplemented shutdown statu
04920 1323           55                         push	bp
04921 1324           89E5                       mov	bp,sp
04922                                           ! 1285 s: %02x\n",(Bit8u)status);
04923                                           ! Debug: list unsigned char status = [S+2+2] (used reg = )
04924 1326           8A46         04            mov	al,4[bp]
04925 1329           30E4                       xor	ah,ah
04926 132B           50                         push	ax
04927                                           ! Debug: list * char = .106+0 (used reg = )
04928 132C           BB                   D602  mov	bx,#.106
04929 132F           53                         push	bx
04930                                           ! Debug: list int = const 7 (used reg = )
04931 1330           B8                   0007  mov	ax,*7
04932 1333           50                         push	ax
04933                                           ! Debug: func () void = bios_printf+0 (used reg = )
04934 1334           E8         F6E4            call	_bios_printf
04935 1337           89EC                       mov	sp,bp
04936                                           !BCC_EOS
04937                                           ! 1286 }
04938 1339           5D                         pop	bp
04939 133A           C3                         ret
04940                                           ! 1287 void s3_resume_panic()
04941                                           ! Register BX used in function shutdown_status_panic
04942                                           ! 1288 {
04943                                           export	_s3_resume_panic
04944                       0000133B            _s3_resume_panic:
04945                                           ! 1289   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
04946 133B           55                         push	bp
04947 133C           89E5                       mov	bp,sp
04948                                           ! Debug: list * char = .107+0 (used reg = )
04949 133E           BB                   D5E8  mov	bx,#.107
04950 1341           53                         push	bx
04951                                           ! Debug: list int = const 7 (used reg = )
04952 1342           B8                   0007  mov	ax,*7
04953 1345           50                         push	ax
04954                                           ! Debug: func () void = bios_printf+0 (used reg = )
04955 1346           E8         F6D2            call	_bios_printf
04956 1349           89EC                       mov	sp,bp
04957                                           !BCC_EOS
04958                                           ! 1290 }
04959 134B           5D                         pop	bp
04960 134C           C3                         ret
04961                                           ! 1291 void
04962                                           ! Register BX used in function s3_resume_panic
04963                                           ! 1292 print_bios_banner()
04964                                           ! 1293 {
04965                                           export	_print_bios_banner
04966                       0000134D            _print_bios_banner:
04967                                           ! 1294   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "06/23/99", bios_cvs_version_string);
04968 134D           55                         push	bp
04969 134E           89E5                       mov	bp,sp
04970                                           ! Debug: list * char = bios_cvs_version_string+0 (used reg = )
04971 1350           BB                   0194  mov	bx,#_bios_cvs_version_string
04972 1353           53                         push	bx
04973                                           ! Debug: list * char = .109+0 (used reg = )
04974 1354           BB                   D5BB  mov	bx,#.109
04975 1357           53                         push	bx
04976                                           ! Debug: list * char = .108+0 (used reg = )
04977 1358           BB                   D5C4  mov	bx,#.108
04978 135B           53                         push	bx
04979                                           ! Debug: list int = const 2 (used reg = )
04980 135C           B8                   0002  mov	ax,*2
04981 135F           50                         push	ax
04982                                           ! Debug: func () void = bios_printf+0 (used reg = )
04983 1360           E8         F6B8            call	_bios_printf
04984 1363           89EC                       mov	sp,bp
04985                                           !BCC_EOS
04986                                           ! 1295   bios_printf(2, "apmbios " "pcibios " "eltorito " "PMM " "\n\n");
04987                                           ! Debug: list * char = .10A+0 (used reg = )
04988 1365           BB                   D59B  mov	bx,#.10A
04989 1368           53                         push	bx
04990                                           ! Debug: list int = const 2 (used reg = )
04991 1369           B8                   0002  mov	ax,*2
04992 136C           50                         push	ax
04993                                           ! Debug: func () void = bios_printf+0 (used reg = )
04994 136D           E8         F6AB            call	_bios_printf
04995 1370           89EC                       mov	sp,bp
04996                                           !BCC_EOS
04997                                           ! 1296 }
04998 1372           5D                         pop	bp
04999 1373           C3                         ret
05000                                           ! 1297 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
05001                                           ! Register BX used in function print_bios_banner
05002                                           
05003                       00001374            _drivetypes:
05004                       00001374            .10B:
05005 1374                        00            .byte	0
05006 1375                  00000009            .blkb	9
05007                       0000137E            .10C:
05008 137E                        46            .ascii	"Floppy"
05009 1384                        00            .byte	0
05010 1385                  00000003            .blkb	3
05011                       00001388            .10D:
05012 1388                        48            .ascii	"Hard Disk"
05013 1391                        00            .byte	0
05014                       00001392            .10E:
05015 1392                        43            .ascii	"CD-Rom"
05016 1398                        00            .byte	0
05017 1399                  00000003            .blkb	3
05018                       0000139C            .10F:
05019 139C                        4E            .ascii	"Network"
05020 13A3                        00            .byte	0
05021 13A4                  00000002            .blkb	2
05022                                           !BCC_EOS
05023                                           ! 1298 static void
05024                                           ! 1299 init_boot_vectors()
05025                                           ! 1300 {
05026                                           
05027                       000013A6            _init_boot_vectors:
05028                                           ! 1301   ipl_entry_t e;
05029                                           !BCC_EOS
05030                                           ! 1302   Bit16u count = 0;
05031 13A6           55                         push	bp
05032 13A7           89E5                       mov	bp,sp
05033 13A9           83C4                   EE  add	sp,*-$12
05034                                           ! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
05035 13AC           31C0                       xor	ax,ax
05036 13AE           8946         EE            mov	-$12[bp],ax
05037                                           !BCC_EOS
05038                                           ! 1303   Bit16u ss = get_SS();
05039 13B1           4C                         dec	sp
05040 13B2           4C                         dec	sp
05041                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05042 13B3           E8         F297            call	_get_SS
05043                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
05044 13B6           8946         EC            mov	-$14[bp],ax
05045                                           !BCC_EOS
05046                                           ! 1304   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05047 13B9           4C                         dec	sp
05048 13BA           4C                         dec	sp
05049                                           ! Debug: list int = const $E (used reg = )
05050 13BB           B8                   000E  mov	ax,*$E
05051 13BE           50                         push	ax
05052                                           ! Debug: list int = const $40 (used reg = )
05053 13BF           B8                   0040  mov	ax,*$40
05054 13C2           50                         push	ax
05055                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05056 13C3           E8         F241            call	_read_word
05057 13C6           83C4                   04  add	sp,*4
05058                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$18-$18] (used reg = )
05059 13C9           8946         EA            mov	-$16[bp],ax
05060                                           !BCC_EOS
05061                                           ! 1305   memsetb(ebda_seg, 0x0300, 0, 0xff);
05062                                           ! Debug: list int = const $FF (used reg = )
05063 13CC           B8                   00FF  mov	ax,#$FF
05064 13CF           50                         push	ax
05065                                           ! Debug: list int = const 0 (used reg = )
05066 13D0           31C0                       xor	ax,ax
05067 13D2           50                         push	ax
05068                                           ! Debug: list int = const $300 (used reg = )
05069 13D3           B8                   0300  mov	ax,#$300
05070 13D6           50                         push	ax
05071                                           ! Debug: list unsigned short ebda_seg = [S+$1E-$18] (used reg = )
05072 13D7           FF76         EA            push	-$16[bp]
05073                                           ! Debug: func () void = memsetb+0 (used reg = )
05074 13DA           E8         EC23            call	_memsetb
05075 13DD           83C4                   08  add	sp,*8
05076                                           !BCC_EOS
05077                                           ! 1306   write_word(ebda_seg, 0x0384, 0xFFFF);
05078                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05079 13E0           B8                   FFFF  mov	ax,#$FFFF
05080 13E3           50                         push	ax
05081                                           ! Debug: list int = const $384 (used reg = )
05082 13E4           B8                   0384  mov	ax,#$384
05083 13E7           50                         push	ax
05084                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05085 13E8           FF76         EA            push	-$16[bp]
05086                                           ! Debug: func () void = write_word+0 (used reg = )
05087 13EB           E8         F244            call	_write_word
05088 13EE           83C4                   06  add	sp,*6
05089                                           !BCC_EOS
05090                                           ! 1307   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05091                                           ! Debug: eq int = const 1 to unsigned short e = [S+$18-$12] (used reg = )
05092 13F1           B8                   0001  mov	ax,*1
05093 13F4           8946         F0            mov	-$10[bp],ax
05094                                           !BCC_EOS
05095                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05096 13F7           31C0                       xor	ax,ax
05097 13F9           8946         F2            mov	-$E[bp],ax
05098                                           !BCC_EOS
05099                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05100 13FC           31C0                       xor	ax,ax
05101 13FE           31DB                       xor	bx,bx
05102 1400           8946         F4            mov	-$C[bp],ax
05103 1403           895E         F6            mov	-$A[bp],bx
05104                                           !BCC_EOS
05105                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05106 1406           31C0                       xor	ax,ax
05107 1408           31DB                       xor	bx,bx
05108 140A           8946         F8            mov	-8[bp],ax
05109 140D           895E         FA            mov	-6[bp],bx
05110                                           !BCC_EOS
05111                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05112 1410           31C0                       xor	ax,ax
05113 1412           31DB                       xor	bx,bx
05114 1414           8946         FC            mov	-4[bp],ax
05115 1417           895E         FE            mov	-2[bp],bx
05116                                           !BCC_EOS
05117                                           ! 1308   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05118                                           ! Debug: list int = const $10 (used reg = )
05119 141A           B8                   0010  mov	ax,*$10
05120 141D           50                         push	ax
05121                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05122 141E           8D5E         F0            lea	bx,-$10[bp]
05123 1421           53                         push	bx
05124                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05125 1422           FF76         EC            push	-$14[bp]
05126                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05127 1425           8B46         EE            mov	ax,-$12[bp]
05128 1428           B1                     04  mov	cl,*4
05129 142A           D3E0                       shl	ax,cl
05130                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05131                                           ! Debug: expression subtree swapping
05132                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05133 142C           05                   0300  add	ax,#$300
05134 142F           50                         push	ax
05135                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05136 1430           FF76         EA            push	-$16[bp]
05137                                           ! Debug: func () void = memcpyb+0 (used reg = )
05138 1433           E8         EBEE            call	_memcpyb
05139 1436           83C4                   0A  add	sp,*$A
05140                                           !BCC_EOS
05141                                           ! 1309   count++;
05142                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05143 1439           8B46         EE            mov	ax,-$12[bp]
05144 143C           40                         inc	ax
05145 143D           8946         EE            mov	-$12[bp],ax
05146                                           !BCC_EOS
05147                                           ! 1310   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05148                                           ! Debug: eq int = const 2 to unsigned short e = [S+$18-$12] (used reg = )
05149 1440           B8                   0002  mov	ax,*2
05150 1443           8946         F0            mov	-$10[bp],ax
05151                                           !BCC_EOS
05152                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05153 1446           31C0                       xor	ax,ax
05154 1448           8946         F2            mov	-$E[bp],ax
05155                                           !BCC_EOS
05156                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05157 144B           31C0                       xor	ax,ax
05158 144D           31DB                       xor	bx,bx
05159 144F           8946         F4            mov	-$C[bp],ax
05160 1452           895E         F6            mov	-$A[bp],bx
05161                                           !BCC_EOS
05162                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05163 1455           31C0                       xor	ax,ax
05164 1457           31DB                       xor	bx,bx
05165 1459           8946         F8            mov	-8[bp],ax
05166 145C           895E         FA            mov	-6[bp],bx
05167                                           !BCC_EOS
05168                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05169 145F           31C0                       xor	ax,ax
05170 1461           31DB                       xor	bx,bx
05171 1463           8946         FC            mov	-4[bp],ax
05172 1466           895E         FE            mov	-2[bp],bx
05173                                           !BCC_EOS
05174                                           ! 1311   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05175                                           ! Debug: list int = const $10 (used reg = )
05176 1469           B8                   0010  mov	ax,*$10
05177 146C           50                         push	ax
05178                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05179 146D           8D5E         F0            lea	bx,-$10[bp]
05180 1470           53                         push	bx
05181                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05182 1471           FF76         EC            push	-$14[bp]
05183                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05184 1474           8B46         EE            mov	ax,-$12[bp]
05185 1477           B1                     04  mov	cl,*4
05186 1479           D3E0                       shl	ax,cl
05187                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05188                                           ! Debug: expression subtree swapping
05189                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05190 147B           05                   0300  add	ax,#$300
05191 147E           50                         push	ax
05192                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05193 147F           FF76         EA            push	-$16[bp]
05194                                           ! Debug: func () void = memcpyb+0 (used reg = )
05195 1482           E8         EB9F            call	_memcpyb
05196 1485           83C4                   0A  add	sp,*$A
05197                                           !BCC_EOS
05198                                           ! 1312   count++;
05199                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05200 1488           8B46         EE            mov	ax,-$12[bp]
05201 148B           40                         inc	ax
05202 148C           8946         EE            mov	-$12[bp],ax
05203                                           !BCC_EOS
05204                                           ! 1313   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
05205                                           ! Debug: eq int = const 3 to unsigned short e = [S+$18-$12] (used reg = )
05206 148F           B8                   0003  mov	ax,*3
05207 1492           8946         F0            mov	-$10[bp],ax
05208                                           !BCC_EOS
05209                                           ! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
05210 1495           31C0                       xor	ax,ax
05211 1497           8946         F2            mov	-$E[bp],ax
05212                                           !BCC_EOS
05213                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
05214 149A           31C0                       xor	ax,ax
05215 149C           31DB                       xor	bx,bx
05216 149E           8946         F4            mov	-$C[bp],ax
05217 14A1           895E         F6            mov	-$A[bp],bx
05218                                           !BCC_EOS
05219                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
05220 14A4           31C0                       xor	ax,ax
05221 14A6           31DB                       xor	bx,bx
05222 14A8           8946         F8            mov	-8[bp],ax
05223 14AB           895E         FA            mov	-6[bp],bx
05224                                           !BCC_EOS
05225                                           ! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
05226 14AE           31C0                       xor	ax,ax
05227 14B0           31DB                       xor	bx,bx
05228 14B2           8946         FC            mov	-4[bp],ax
05229 14B5           895E         FE            mov	-2[bp],bx
05230                                           !BCC_EOS
05231                                           ! 1314   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
05232                                           ! Debug: list int = const $10 (used reg = )
05233 14B8           B8                   0010  mov	ax,*$10
05234 14BB           50                         push	ax
05235                                           ! Debug: list * struct  e = S+$1A-$12 (used reg = )
05236 14BC           8D5E         F0            lea	bx,-$10[bp]
05237 14BF           53                         push	bx
05238                                           ! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
05239 14C0           FF76         EC            push	-$14[bp]
05240                                           ! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
05241 14C3           8B46         EE            mov	ax,-$12[bp]
05242 14C6           B1                     04  mov	cl,*4
05243 14C8           D3E0                       shl	ax,cl
05244                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05245                                           ! Debug: expression subtree swapping
05246                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05247 14CA           05                   0300  add	ax,#$300
05248 14CD           50                         push	ax
05249                                           ! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
05250 14CE           FF76         EA            push	-$16[bp]
05251                                           ! Debug: func () void = memcpyb+0 (used reg = )
05252 14D1           E8         EB50            call	_memcpyb
05253 14D4           83C4                   0A  add	sp,*$A
05254                                           !BCC_EOS
05255                                           ! 1315   count++;
05256                                           ! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
05257 14D7           8B46         EE            mov	ax,-$12[bp]
05258 14DA           40                         inc	ax
05259 14DB           8946         EE            mov	-$12[bp],ax
05260                                           !BCC_EOS
05261                                           ! 1316   write_word(ebda_seg, 0x0380, count);
05262                                           ! Debug: list unsigned short count = [S+$18-$14] (used reg = )
05263 14DE           FF76         EE            push	-$12[bp]
05264                                           ! Debug: list int = const $380 (used reg = )
05265 14E1           B8                   0380  mov	ax,#$380
05266 14E4           50                         push	ax
05267                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05268 14E5           FF76         EA            push	-$16[bp]
05269                                           ! Debug: func () void = write_word+0 (used reg = )
05270 14E8           E8         F147            call	_write_word
05271 14EB           83C4                   06  add	sp,*6
05272                                           !BCC_EOS
05273                                           ! 1317   write_word(ebda_seg, 0x0382, 0xffff);
05274                                           ! Debug: list unsigned int = const $FFFF (used reg = )
05275 14EE           B8                   FFFF  mov	ax,#$FFFF
05276 14F1           50                         push	ax
05277                                           ! Debug: list int = const $382 (used reg = )
05278 14F2           B8                   0382  mov	ax,#$382
05279 14F5           50                         push	ax
05280                                           ! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
05281 14F6           FF76         EA            push	-$16[bp]
05282                                           ! Debug: func () void = write_word+0 (used reg = )
05283 14F9           E8         F136            call	_write_word
05284 14FC           83C4                   06  add	sp,*6
05285                                           !BCC_EOS
05286                                           ! 1318 }
05287 14FF           89EC                       mov	sp,bp
05288 1501           5D                         pop	bp
05289 1502           C3                         ret
05290                                           ! 1319 static Bit8u
05291                                           ! Register BX used in function init_boot_vectors
05292                                           ! 1320 get_boot_vector(i, e)
05293                                           ! 1321 Bit16u i; ipl_entry_t *e;
05294                       00001503            _get_boot_vector:
05295                                           !BCC_EOS
05296                                           !BCC_EOS
05297                                           ! 1322 {
05298                                           ! 1323   Bit16u count;
05299                                           !BCC_EOS
05300                                           ! 1324   Bit16u ss = get_SS();
05301 1503           55                         push	bp
05302 1504           89E5                       mov	bp,sp
05303 1506           83C4                   FC  add	sp,*-4
05304                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05305 1509           E8         F141            call	_get_SS
05306                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
05307 150C           8946         FC            mov	-4[bp],ax
05308                                           !BCC_EOS
05309                                           ! 1325   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05310 150F           4C                         dec	sp
05311 1510           4C                         dec	sp
05312                                           ! Debug: list int = const $E (used reg = )
05313 1511           B8                   000E  mov	ax,*$E
05314 1514           50                         push	ax
05315                                           ! Debug: list int = const $40 (used reg = )
05316 1515           B8                   0040  mov	ax,*$40
05317 1518           50                         push	ax
05318                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05319 1519           E8         F0EB            call	_read_word
05320 151C           83C4                   04  add	sp,*4
05321                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
05322 151F           8946         FA            mov	-6[bp],ax
05323                                           !BCC_EOS
05324                                           ! 1326   count = read_word(ebda_seg, 0x0380);
05325                                           ! Debug: list int = const $380 (used reg = )
05326 1522           B8                   0380  mov	ax,#$380
05327 1525           50                         push	ax
05328                                           ! Debug: list unsigned short ebda_seg = [S+$A-8] (used reg = )
05329 1526           FF76         FA            push	-6[bp]
05330                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05331 1529           E8         F0DB            call	_read_word
05332 152C           83C4                   04  add	sp,*4
05333                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+8-4] (used reg = )
05334 152F           8946         FE            mov	-2[bp],ax
05335                                           !BCC_EOS
05336                                           ! 1327   if (i >= count) return 0;
05337                                           ! Debug: ge unsigned short count = [S+8-4] to unsigned short i = [S+8+2] (used reg = )
05338 1532           8B46         04            mov	ax,4[bp]
05339 1535           3B46         FE            cmp	ax,-2[bp]
05340 1538           72           06            jb  	.110
05341                       0000153A            .111:
05342 153A           30C0                       xor	al,al
05343 153C           89EC                       mov	sp,bp
05344 153E           5D                         pop	bp
05345 153F           C3                         ret
05346                                           !BCC_EOS
05347                                           ! 1328   memcpyb(ss, e, ebda_seg, 0x0300 + i * sizeof (*e), sizeof (*e));
05348                       00001540            .110:
05349                                           ! Debug: list int = const $10 (used reg = )
05350 1540           B8                   0010  mov	ax,*$10
05351 1543           50                         push	ax
05352                                           ! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
05353 1544           8B46         04            mov	ax,4[bp]
05354 1547           B1                     04  mov	cl,*4
05355 1549           D3E0                       shl	ax,cl
05356                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05357                                           ! Debug: expression subtree swapping
05358                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05359 154B           05                   0300  add	ax,#$300
05360 154E           50                         push	ax
05361                                           ! Debug: list unsigned short ebda_seg = [S+$C-8] (used reg = )
05362 154F           FF76         FA            push	-6[bp]
05363                                           ! Debug: list * struct  e = [S+$E+4] (used reg = )
05364 1552           FF76         06            push	6[bp]
05365                                           ! Debug: list unsigned short ss = [S+$10-6] (used reg = )
05366 1555           FF76         FC            push	-4[bp]
05367                                           ! Debug: func () void = memcpyb+0 (used reg = )
05368 1558           E8         EAC9            call	_memcpyb
05369 155B           83C4                   0A  add	sp,*$A
05370                                           !BCC_EOS
05371                                           ! 1329   return 1;
05372 155E           B0                     01  mov	al,*1
05373 1560           89EC                       mov	sp,bp
05374 1562           5D                         pop	bp
05375 1563           C3                         ret
05376                                           !BCC_EOS
05377                                           ! 1330 }
05378                                           ! 1331   void
05379                                           ! 1332 interactive_bootkey()
05380                                           ! 1333 {
05381                                           export	_interactive_bootkey
05382                       00001564            _interactive_bootkey:
05383                                           ! 1334   ipl_entry_t e;
05384                                           !BCC_EOS
05385                                           ! 1335   Bit16u count;
05386                                           !BCC_EOS
05387                                           ! 1336   char description[33];
05388                                           !BCC_EOS
05389                                           ! 1337   Bit8u scan_code;
05390                                           !BCC_EOS
05391                                           ! 1338   Bit8u i;
05392                                           !BCC_EOS
05393                                           ! 1339   Bit16u ss = get_SS();
05394 1564           55                         push	bp
05395 1565           89E5                       mov	bp,sp
05396 1567           83C4                   C8  add	sp,*-$38
05397                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05398 156A           E8         F0E0            call	_get_SS
05399                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
05400 156D           8946         C8            mov	-$38[bp],ax
05401                                           !BCC_EOS
05402                                           ! 1340   Bit16u valid_choice = 0;
05403 1570           4C                         dec	sp
05404 1571           4C                         dec	sp
05405                                           ! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
05406 1572           31C0                       xor	ax,ax
05407 1574           8946         C6            mov	-$3A[bp],ax
05408                                           !BCC_EOS
05409                                           ! 1341   Bit16u ebda_seg = read_word(0x0040, 0x000E);
05410 1577           4C                         dec	sp
05411 1578           4C                         dec	sp
05412                                           ! Debug: list int = const $E (used reg = )
05413 1579           B8                   000E  mov	ax,*$E
05414 157C           50                         push	ax
05415                                           ! Debug: list int = const $40 (used reg = )
05416 157D           B8                   0040  mov	ax,*$40
05417 1580           50                         push	ax
05418                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05419 1581           E8         F083            call	_read_word
05420 1584           83C4                   04  add	sp,*4
05421                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$3E-$3E] (used reg = )
05422 1587           8946         C4            mov	-$3C[bp],ax
05423                                           !BCC_EOS
05424                                           ! 1342   bios_printf(2, "\n\nPress F12 for boot menu.\n\n");
05425                                           ! Debug: list * char = .112+0 (used reg = )
05426 158A           BB                   D57E  mov	bx,#.112
05427 158D           53                         push	bx
05428                                           ! Debug: list int = const 2 (used reg = )
05429 158E           B8                   0002  mov	ax,*2
05430 1591           50                         push	ax
05431                                           ! Debug: func () void = bios_printf+0 (used reg = )
05432 1592           E8         F486            call	_bios_printf
05433 1595           83C4                   04  add	sp,*4
05434                                           !BCC_EOS
05435                                           ! 1343   while (check_for_keystroke())
05436                                           ! 1344   {
05437 1598           E9         01B4            br 	.114
05438                       0000159B            .115:
05439                                           ! 1345     scan_code = get_keystroke();
05440                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05441 159B           E8         F444            call	_get_keystroke
05442                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05443 159E           8846         CC            mov	-$34[bp],al
05444                                           !BCC_EOS
05445                                           ! 1346     if (scan_code != 0x86)
05446                                           ! Debug: ne int = const $86 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05447 15A1           8A46         CC            mov	al,-$34[bp]
05448 15A4           3C                     86  cmp	al,#$86
05449 15A6           74           03            je  	.116
05450                       000015A8            .117:
05451                                           ! 1347       continue;
05452 15A8           E9         01A4            br 	.114
05453                                           !BCC_EOS
05454                                           ! 1348     while (check_for_keystroke())
05455                       000015AB            .116:
05456                                           ! 1349       get_keystroke();
05457 15AB           EB           03            jmp .119
05458                       000015AD            .11A:
05459                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05460 15AD           E8         F432            call	_get_keystroke
05461                                           !BCC_EOS
05462                                           ! 1350     bios_printf(2, "Select boot device:\n\n");
05463                       000015B0            .119:
05464                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05465 15B0           E8         F421            call	_check_for_keystroke
05466 15B3           84C0                       test	al,al
05467 15B5           75           F6            jne	.11A
05468                       000015B7            .11B:
05469                       000015B7            .118:
05470                                           ! Debug: list * char = .11C+0 (used reg = )
05471 15B7           BB                   D568  mov	bx,#.11C
05472 15BA           53                         push	bx
05473                                           ! Debug: list int = const 2 (used reg = )
05474 15BB           B8                   0002  mov	ax,*2
05475 15BE           50                         push	ax
05476                                           ! Debug: func () void = bios_printf+0 (used reg = )
05477 15BF           E8         F459            call	_bios_printf
05478 15C2           83C4                   04  add	sp,*4
05479                                           !BCC_EOS
05480                                           ! 1351     count = read_word(ebda_seg, 0x0380);
05481                                           ! Debug: list int = const $380 (used reg = )
05482 15C5           B8                   0380  mov	ax,#$380
05483 15C8           50                         push	ax
05484                                           ! Debug: list unsigned short ebda_seg = [S+$40-$3E] (used reg = )
05485 15C9           FF76         C4            push	-$3C[bp]
05486                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
05487 15CC           E8         F038            call	_read_word
05488 15CF           83C4                   04  add	sp,*4
05489                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3E-$14] (used reg = )
05490 15D2           8946         EE            mov	-$12[bp],ax
05491                                           !BCC_EOS
05492                                           ! 1352     for (i = 0; i < count; i++)
05493                                           ! Debug: eq int = const 0 to unsigned char i = [S+$3E-$37] (used reg = )
05494 15D5           30C0                       xor	al,al
05495 15D7           8846         CB            mov	-$35[bp],al
05496                                           !BCC_EOS
05497                                           !BCC_EOS
05498                                           ! 1353     {
05499 15DA           E9         00FE            br 	.11F
05500                       000015DD            .120:
05501                                           ! 1354       memcpyb(ss, &
05502                                           ! 1354 e, ebda_seg, 0x0300 + i * sizeof (e), sizeof (e));
05503                                           ! Debug: list int = const $10 (used reg = )
05504 15DD           B8                   0010  mov	ax,*$10
05505 15E0           50                         push	ax
05506                                           ! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
05507 15E1           8A46         CB            mov	al,-$35[bp]
05508 15E4           30E4                       xor	ah,ah
05509 15E6           B1                     04  mov	cl,*4
05510 15E8           D3E0                       shl	ax,cl
05511                                           ! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
05512                                           ! Debug: expression subtree swapping
05513                                           ! Debug: list unsigned int = ax+$300 (used reg = )
05514 15EA           05                   0300  add	ax,#$300
05515 15ED           50                         push	ax
05516                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05517 15EE           FF76         C4            push	-$3C[bp]
05518                                           ! Debug: list * struct  e = S+$44-$12 (used reg = )
05519 15F1           8D5E         F0            lea	bx,-$10[bp]
05520 15F4           53                         push	bx
05521                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05522 15F5           FF76         C8            push	-$38[bp]
05523                                           ! Debug: func () void = memcpyb+0 (used reg = )
05524 15F8           E8         EA29            call	_memcpyb
05525 15FB           83C4                   0A  add	sp,*$A
05526                                           !BCC_EOS
05527                                           ! 1355       bios_printf(2, "%d. ", i+1);
05528                                           ! Debug: add int = const 1 to unsigned char i = [S+$3E-$37] (used reg = )
05529 15FE           8A46         CB            mov	al,-$35[bp]
05530 1601           30E4                       xor	ah,ah
05531                                           ! Debug: list unsigned int = ax+1 (used reg = )
05532 1603           40                         inc	ax
05533 1604           50                         push	ax
05534                                           ! Debug: list * char = .121+0 (used reg = )
05535 1605           BB                   D563  mov	bx,#.121
05536 1608           53                         push	bx
05537                                           ! Debug: list int = const 2 (used reg = )
05538 1609           B8                   0002  mov	ax,*2
05539 160C           50                         push	ax
05540                                           ! Debug: func () void = bios_printf+0 (used reg = )
05541 160D           E8         F40B            call	_bios_printf
05542 1610           83C4                   06  add	sp,*6
05543                                           !BCC_EOS
05544                                           ! 1356       switch(e.type)
05545 1613           8B46         F0            mov	ax,-$10[bp]
05546                                           ! 1357       {
05547 1616           E9         009F            br 	.124
05548                                           ! 1358         case 0x01:
05549                                           ! 1359         case 0x02:
05550                       00001619            .125:
05551                                           ! 1360         case 0x03:
05552                       00001619            .126:
05553                                           ! 1361           bios_printf(2, "%s\n", drivetypes[e.type]);
05554                       00001619            .127:
05555                                           ! Debug: ptradd unsigned short e = [S+$3E-$12] to [5] [$A] char = drivetypes+0 (used reg = )
05556 1619           8B5E         F0            mov	bx,-$10[bp]
05557 161C           89DA                       mov	dx,bx
05558 161E           D1E3                       shl	bx,*1
05559 1620           D1E3                       shl	bx,*1
05560 1622           01D3                       add	bx,dx
05561 1624           D1E3                       shl	bx,*1
05562                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05563                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05564 1626           81C3                 1374  add	bx,#_drivetypes
05565 162A           53                         push	bx
05566                                           ! Debug: list * char = .128+0 (used reg = )
05567 162B           BB                   D55F  mov	bx,#.128
05568 162E           53                         push	bx
05569                                           ! Debug: list int = const 2 (used reg = )
05570 162F           B8                   0002  mov	ax,*2
05571 1632           50                         push	ax
05572                                           ! Debug: func () void = bios_printf+0 (used reg = )
05573 1633           E8         F3E5            call	_bios_printf
05574 1636           83C4                   06  add	sp,*6
05575                                           !BCC_EOS
05576                                           ! 1362           break;
05577 1639           E9         0098            br 	.122
05578                                           !BCC_EOS
05579                                           ! 1363         case 0x80:
05580                                           ! 1364           bios_printf(2, "%s", drivetypes[4]);
05581                       0000163C            .129:
05582                                           ! Debug: list * char = drivetypes+$28 (used reg = )
05583 163C           BB                   139C  mov	bx,#_drivetypes+$28
05584 163F           53                         push	bx
05585                                           ! Debug: list * char = .12A+0 (used reg = )
05586 1640           BB                   D55C  mov	bx,#.12A
05587 1643           53                         push	bx
05588                                           ! Debug: list int = const 2 (used reg = )
05589 1644           B8                   0002  mov	ax,*2
05590 1647           50                         push	ax
05591                                           ! Debug: func () void = bios_printf+0 (used reg = )
05592 1648           E8         F3D0            call	_bios_printf
05593 164B           83C4                   06  add	sp,*6
05594                                           !BCC_EOS
05595                                           ! 1365           if (e.description != 0)
05596                                           ! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3E-$A] (used reg = )
05597                                           ! Debug: expression subtree swapping
05598 164E           31C0                       xor	ax,ax
05599 1650           31DB                       xor	bx,bx
05600 1652           53                         push	bx
05601 1653           50                         push	ax
05602 1654           8B46         F8            mov	ax,-8[bp]
05603 1657           8B5E         FA            mov	bx,-6[bp]
05604 165A           8D7E         C0            lea	di,-2+..FFFF[bp]
05605 165D           E8         EA6B            call	lcmpul
05606 1660           8D66         C4            lea	sp,2+..FFFF[bp]
05607 1663           74           41            je  	.12B
05608                       00001665            .12C:
05609                                           ! 1366           {
05610                                           ! 1367             memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
05611                                           ! Debug: list int = const $20 (used reg = )
05612 1665           B8                   0020  mov	ax,*$20
05613 1668           50                         push	ax
05614                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$40-$A] (used reg = )
05615                                           ! Debug: expression subtree swapping
05616 1669           B8                   FFFF  mov	ax,#$FFFF
05617 166C           31DB                       xor	bx,bx
05618 166E           8D7E         F8            lea	di,-8[bp]
05619 1671           E8         EA47            call	landul
05620                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05621                                           ! Debug: list unsigned short = ax+0 (used reg = )
05622 1674           50                         push	ax
05623                                           ! Debug: sr int = const $10 to unsigned long e = [S+$42-$A] (used reg = )
05624 1675           8B46         F8            mov	ax,-8[bp]
05625 1678           8B5E         FA            mov	bx,-6[bp]
05626 167B           93                         xchg	bx,ax
05627 167C           31DB                       xor	bx,bx
05628                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05629                                           ! Debug: list unsigned short = ax+0 (used reg = )
05630 167E           50                         push	ax
05631                                           ! Debug: list * [$21] char description = S+$44-$35 (used reg = )
05632 167F           8D5E         CD            lea	bx,-$33[bp]
05633 1682           53                         push	bx
05634                                           ! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
05635 1683           FF76         C8            push	-$38[bp]
05636                                           ! Debug: func () void = memcpyb+0 (used reg = )
05637 1686           E8         E99B            call	_memcpyb
05638 1689           83C4                   0A  add	sp,*$A
05639                                           !BCC_EOS
05640                                           ! 1368             description[32] = 0;
05641                                           ! Debug: eq int = const 0 to char description = [S+$3E-$15] (used reg = )
05642 168C           30C0                       xor	al,al
05643 168E           8846         ED            mov	-$13[bp],al
05644                                           !BCC_EOS
05645                                           ! 1369             bios_printf(2, " [%S]", ss, description);
05646                                           ! Debug: list * char description = S+$3E-$35 (used reg = )
05647 1691           8D5E         CD            lea	bx,-$33[bp]
05648 1694           53                         push	bx
05649                                           ! Debug: list unsigned short ss = [S+$40-$3A] (used reg = )
05650 1695           FF76         C8            push	-$38[bp]
05651                                           ! Debug: list * char = .12D+0 (used reg = )
05652 1698           BB                   D556  mov	bx,#.12D
05653 169B           53                         push	bx
05654                                           ! Debug: list int = const 2 (used reg = )
05655 169C           B8                   0002  mov	ax,*2
05656 169F           50                         push	ax
05657                                           ! Debug: func () void = bios_printf+0 (used reg = )
05658 16A0           E8         F378            call	_bios_printf
05659 16A3           83C4                   08  add	sp,*8
05660                                           !BCC_EOS
05661                                           ! 1370          }
05662                                           ! 1371          bios_printf(2, "\n");
05663                       000016A6            .12B:
05664                                           ! Debug: list * char = .12E+0 (used reg = )
05665 16A6           BB                   D554  mov	bx,#.12E
05666 16A9           53                         push	bx
05667                                           ! Debug: list int = const 2 (used reg = )
05668 16AA           B8                   0002  mov	ax,*2
05669 16AD           50                         push	ax
05670                                           ! Debug: func () void = bios_printf+0 (used reg = )
05671 16AE           E8         F36A            call	_bios_printf
05672 16B1           83C4                   04  add	sp,*4
05673                                           !BCC_EOS
05674                                           ! 1372          break;
05675 16B4           EB           1E            jmp .122
05676                                           !BCC_EOS
05677                                           ! 1373       }
05678                                           ! 1374     }
05679 16B6           EB           1C            jmp .122
05680                       000016B8            .124:
05681 16B8           2D                   0001  sub	ax,*1
05682 16BB         0F84         FF5A            beq 	.125
05683 16BF           2D                   0001  sub	ax,*1
05684 16C2         0F84         FF53            beq 	.126
05685 16C6           2D                   0001  sub	ax,*1
05686 16C9         0F84         FF4C            beq 	.127
05687 16CD           2D                   007D  sub	ax,*$7D
05688 16D0         0F84         FF68            beq 	.129
05689                       000016D4            .122:
05690                       FFFFFFC2            ..FFFF	=	-$3E
05691                                           ! 1375     count++;
05692                       000016D4            .11E:
05693                                           ! Debug: postinc unsigned char i = [S+$3E-$37] (used reg = )
05694 16D4           8A46         CB            mov	al,-$35[bp]
05695 16D7           40                         inc	ax
05696 16D8           8846         CB            mov	-$35[bp],al
05697                       000016DB            .11F:
05698                                           ! Debug: lt unsigned short count = [S+$3E-$14] to unsigned char i = [S+$3E-$37] (used reg = )
05699 16DB           8A46         CB            mov	al,-$35[bp]
05700 16DE           30E4                       xor	ah,ah
05701 16E0           3B46         EE            cmp	ax,-$12[bp]
05702 16E3         0F82         FEF6            blo 	.120
05703                       000016E7            .12F:
05704                       000016E7            .11D:
05705                                           ! Debug: postinc unsigned short count = [S+$3E-$14] (used reg = )
05706 16E7           8B46         EE            mov	ax,-$12[bp]
05707 16EA           40                         inc	ax
05708 16EB           8946         EE            mov	-$12[bp],ax
05709                                           !BCC_EOS
05710                                           ! 1376     while (!valid_choice) {
05711 16EE           EB           48            jmp .131
05712                       000016F0            .132:
05713                                           ! 1377       scan_code = get_keystroke();
05714                                           ! Debug: func () unsigned char = get_keystroke+0 (used reg = )
05715 16F0           E8         F2EF            call	_get_keystroke
05716                                           ! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05717 16F3           8846         CC            mov	-$34[bp],al
05718                                           !BCC_EOS
05719                                           ! 1378       if (scan_code == 0x01 || scan_code == 0x58)
05720                                           ! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05721 16F6           8A46         CC            mov	al,-$34[bp]
05722 16F9           3C                     01  cmp	al,*1
05723 16FB           74           07            je  	.134
05724                       000016FD            .135:
05725                                           ! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05726 16FD           8A46         CC            mov	al,-$34[bp]
05727 1700           3C                     58  cmp	al,*$58
05728 1702           75           08            jne 	.133
05729                       00001704            .134:
05730                                           ! 1379       {
05731                                           ! 1380         valid_choice = 1;
05732                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05733 1704           B8                   0001  mov	ax,*1
05734 1707           8946         C6            mov	-$3A[bp],ax
05735                                           !BCC_EOS
05736                                           ! 1381       }
05737                                           ! 1382       else if (scan_code <= count)
05738 170A           EB           2C            jmp .136
05739                       0000170C            .133:
05740                                           ! Debug: le unsigned short count = [S+$3E-$14] to unsigned char scan_code = [S+$3E-$36] (used reg = )
05741 170C           8A46         CC            mov	al,-$34[bp]
05742 170F           30E4                       xor	ah,ah
05743 1711           3B46         EE            cmp	ax,-$12[bp]
05744 1714           77           22            ja  	.137
05745                       00001716            .138:
05746                                           ! 1383       {
05747                                           ! 1384         valid_choice = 1;
05748                                           ! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
05749 1716           B8                   0001  mov	ax,*1
05750 1719           8946         C6            mov	-$3A[bp],ax
05751                                           !BCC_EOS
05752                                           ! 1385         scan_code -= 1;
05753                                           ! Debug: subab int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
05754 171C           8A46         CC            mov	al,-$34[bp]
05755 171F           30E4                       xor	ah,ah
05756 1721           48                         dec	ax
05757 1722           8846         CC            mov	-$34[bp],al
05758                                           !BCC_EOS
05759                                           ! 1386         write_word(ebda_seg, 0x0384, scan_code);
05760                                           ! Debug: list unsigned char scan_code = [S+$3E-$36] (used reg = )
05761 1725           8A46         CC            mov	al,-$34[bp]
05762 1728           30E4                       xor	ah,ah
05763 172A           50                         push	ax
05764                                           ! Debug: list int = const $384 (used reg = )
05765 172B           B8                   0384  mov	ax,#$384
05766 172E           50                         push	ax
05767                                           ! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
05768 172F           FF76         C4            push	-$3C[bp]
05769                                           ! Debug: func () void = write_word+0 (used reg = )
05770 1732           E8         EEFD            call	_write_word
05771 1735           83C4                   06  add	sp,*6
05772                                           !BCC_EOS
05773                                           ! 1387       }
05774                                           ! 1388     }
05775                       00001738            .137:
05776                       00001738            .136:
05777                                           ! 1389     bios_printf(2, "\n");
05778                       00001738            .131:
05779 1738           8B46         C6            mov	ax,-$3A[bp]
05780 173B           85C0                       test	ax,ax
05781 173D           74           B1            je 	.132
05782                       0000173F            .139:
05783                       0000173F            .130:
05784                                           ! Debug: list * char = .13A+0 (used reg = )
05785 173F           BB                   D552  mov	bx,#.13A
05786 1742           53                         push	bx
05787                                           ! Debug: list int = const 2 (used reg = )
05788 1743           B8                   0002  mov	ax,*2
05789 1746           50                         push	ax
05790                                           ! Debug: func () void = bios_printf+0 (used reg = )
05791 1747           E8         F2D1            call	_bios_printf
05792 174A           83C4                   04  add	sp,*4
05793                                           !BCC_EOS
05794                                           ! 1390     break;
05795 174D           EB           09            jmp .113
05796                                           !BCC_EOS
05797                                           ! 1391   }
05798                                           ! 1392 }
05799                       0000174F            .114:
05800                                           ! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
05801 174F           E8         F282            call	_check_for_keystroke
05802 1752           84C0                       test	al,al
05803 1754         0F85         FE43            bne 	.115
05804                       00001758            .13B:
05805                       00001758            .113:
05806 1758           89EC                       mov	sp,bp
05807 175A           5D                         pop	bp
05808 175B           C3                         ret
05809                                           ! 1393 void
05810                                           ! Register BX used in function interactive_bootkey
05811                                           ! 1394 print_boot_device(type, desc)
05812                                           ! 1395   Bit16u type; Bit32u desc;
05813                                           export	_print_boot_device
05814                       0000175C            _print_boot_device:
05815                                           !BCC_EOS
05816                                           !BCC_EOS
05817                                           ! 1396 {
05818                                           ! 1397   char description[33];
05819                                           !BCC_EOS
05820                                           ! 1398   Bit16u ss = get_SS();
05821 175C           55                         push	bp
05822 175D           89E5                       mov	bp,sp
05823 175F           83C4                   DC  add	sp,*-$24
05824                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
05825 1762           E8         EEE8            call	_get_SS
05826                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$26-$26] (used reg = )
05827 1765           8946         DC            mov	-$24[bp],ax
05828                                           !BCC_EOS
05829                                           ! 1399   if (type == 0x80) type = 0x4;
05830                                           ! Debug: logeq int = const $80 to unsigned short type = [S+$26+2] (used reg = )
05831 1768           8B46         04            mov	ax,4[bp]
05832 176B           3D                   0080  cmp	ax,#$80
05833 176E           75           06            jne 	.13C
05834                       00001770            .13D:
05835                                           ! Debug: eq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05836 1770           B8                   0004  mov	ax,*4
05837 1773           8946         04            mov	4[bp],ax
05838                                           !BCC_EOS
05839                                           ! 1400   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
05840                       00001776            .13C:
05841                                           ! Debug: logeq int = const 0 to unsigned short type = [S+$26+2] (used reg = )
05842 1776           8B46         04            mov	ax,4[bp]
05843 1779           85C0                       test	ax,ax
05844 177B           74           08            je  	.13F
05845                       0000177D            .140:
05846                                           ! Debug: gt int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05847 177D           8B46         04            mov	ax,4[bp]
05848 1780           3D                   0004  cmp	ax,*4
05849 1783           76           0E            jbe 	.13E
05850                       00001785            .13F:
05851                                           ! Debug: list * char = .141+0 (used reg = )
05852 1785           BB                   D542  mov	bx,#.141
05853 1788           53                         push	bx
05854                                           ! Debug: list int = const 7 (used reg = )
05855 1789           B8                   0007  mov	ax,*7
05856 178C           50                         push	ax
05857                                           ! Debug: func () void = bios_printf+0 (used reg = )
05858 178D           E8         F28B            call	_bios_printf
05859 1790           83C4                   04  add	sp,*4
05860                                           !BCC_EOS
05861                                           ! 1401   bios_printf(2, "Booting from %s", drivetypes[type]);
05862                       00001793            .13E:
05863                                           ! Debug: ptradd unsigned short type = [S+$26+2] to [5] [$A] char = drivetypes+0 (used reg = )
05864 1793           8B5E         04            mov	bx,4[bp]
05865 1796           89DA                       mov	dx,bx
05866 1798           D1E3                       shl	bx,*1
05867 179A           D1E3                       shl	bx,*1
05868 179C           01D3                       add	bx,dx
05869 179E           D1E3                       shl	bx,*1
05870                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
05871                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
05872 17A0           81C3                 1374  add	bx,#_drivetypes
05873 17A4           53                         push	bx
05874                                           ! Debug: list * char = .142+0 (used reg = )
05875 17A5           BB                   D532  mov	bx,#.142
05876 17A8           53                         push	bx
05877                                           ! Debug: list int = const 2 (used reg = )
05878 17A9           B8                   0002  mov	ax,*2
05879 17AC           50                         push	ax
05880                                           ! Debug: func () void = bios_printf+0 (used reg = )
05881 17AD           E8         F26B            call	_bios_printf
05882 17B0           83C4                   06  add	sp,*6
05883                                           !BCC_EOS
05884                                           ! 1402   if (type == 4 && desc != 0) {
05885                                           ! Debug: logeq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
05886 17B3           8B46         04            mov	ax,4[bp]
05887 17B6           3D                   0004  cmp	ax,*4
05888 17B9           75           58            jne 	.143
05889                       000017BB            .145:
05890                                           ! Debug: ne unsigned long = const 0 to unsigned long desc = [S+$26+4] (used reg = )
05891                                           ! Debug: expression subtree swapping
05892 17BB           31C0                       xor	ax,ax
05893 17BD           31DB                       xor	bx,bx
05894 17BF           53                         push	bx
05895 17C0           50                         push	ax
05896 17C1           8B46         06            mov	ax,6[bp]
05897 17C4           8B5E         08            mov	bx,8[bp]
05898 17C7           8D7E         D8            lea	di,-$28[bp]
05899 17CA           E8         E8FE            call	lcmpul
05900 17CD           8D66         DC            lea	sp,-$24[bp]
05901 17D0           74           41            je  	.143
05902                       000017D2            .144:
05903                                           ! 1403     memcpyb(ss, &description, (Bit16u)(desc >> 16), (Bit16u)(desc & 0xffff), 32);
05904                                           ! Debug: list int = const $20 (used reg = )
05905 17D2           B8                   0020  mov	ax,*$20
05906 17D5           50                         push	ax
05907                                           ! Debug: and unsigned long = const $FFFF to unsigned long desc = [S+$28+4] (used reg = )
05908                                           ! Debug: expression subtree swapping
05909 17D6           B8                   FFFF  mov	ax,#$FFFF
05910 17D9           31DB                       xor	bx,bx
05911 17DB           8D7E         06            lea	di,6[bp]
05912 17DE           E8         E8DA            call	landul
05913                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05914                                           ! Debug: list unsigned short = ax+0 (used reg = )
05915 17E1           50                         push	ax
05916                                           ! Debug: sr int = const $10 to unsigned long desc = [S+$2A+4] (used reg = )
05917 17E2           8B46         06            mov	ax,6[bp]
05918 17E5           8B5E         08            mov	bx,8[bp]
05919 17E8           93                         xchg	bx,ax
05920 17E9           31DB                       xor	bx,bx
05921                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
05922                                           ! Debug: list unsigned short = ax+0 (used reg = )
05923 17EB           50                         push	ax
05924                                           ! Debug: list * [$21] char description = S+$2C-$23 (used reg = )
05925 17EC           8D5E         DF            lea	bx,-$21[bp]
05926 17EF           53                         push	bx
05927                                           ! Debug: list unsigned short ss = [S+$2E-$26] (used reg = )
05928 17F0           FF76         DC            push	-$24[bp]
05929                                           ! Debug: func () void = memcpyb+0 (used reg = )
05930 17F3           E8         E82E            call	_memcpyb
05931 17F6           83C4                   0A  add	sp,*$A
05932                                           !BCC_EOS
05933                                           ! 1404     description[32] = 0;
05934                                           ! Debug: eq int = const 0 to char description = [S+$26-3] (used reg = )
05935 17F9           30C0                       xor	al,al
05936 17FB           8846         FF            mov	-1[bp],al
05937                                           !BCC_EOS
05938                                           ! 1405     bios_printf(2, " [%S]", ss, description);
05939                                           ! Debug: list * char description = S+$26-$23 (used reg = )
05940 17FE           8D5E         DF            lea	bx,-$21[bp]
05941 1801           53                         push	bx
05942                                           ! Debug: list unsigned short ss = [S+$28-$26] (used reg = )
05943 1802           FF76         DC            push	-$24[bp]
05944                                           ! Debug: list * char = .146+0 (used reg = )
05945 1805           BB                   D52C  mov	bx,#.146
05946 1808           53                         push	bx
05947                                           ! Debug: list int = const 2 (used reg = )
05948 1809           B8                   0002  mov	ax,*2
05949 180C           50                         push	ax
05950                                           ! Debug: func () void = bios_printf+0 (used reg = )
05951 180D           E8         F20B            call	_bios_printf
05952 1810           83C4                   08  add	sp,*8
05953                                           !BCC_EOS
05954                                           ! 1406   }
05955                                           ! 1407   bios_printf(2, "...\n");
05956                       00001813            .143:
05957                                           ! Debug: list * char = .147+0 (used reg = )
05958 1813           BB                   D527  mov	bx,#.147
05959 1816           53                         push	bx
05960                                           ! Debug: list int = const 2 (used reg = )
05961 1817           B8                   0002  mov	ax,*2
05962 181A           50                         push	ax
05963                                           ! Debug: func () void = bios_printf+0 (used reg = )
05964 181B           E8         F1FD            call	_bios_printf
05965 181E           83C4                   04  add	sp,*4
05966                                           !BCC_EOS
05967                                           ! 1408 }
05968 1821           89EC                       mov	sp,bp
05969 1823           5D                         pop	bp
05970 1824           C3                         ret
05971                                           ! 1409   void
05972                                           ! Register BX used in function print_boot_device
05973                                           ! 1410 print_boot_failure(type, reason)
05974                                           ! 1411   Bit16u type; Bit8u reason;
05975                                           export	_print_boot_failure
05976                       00001825            _print_boot_failure:
05977                                           !BCC_EOS
05978                                           !BCC_EOS
05979                                           ! 1412 {
05980                                           ! 1413   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
05981 1825           55                         push	bp
05982 1826           89E5                       mov	bp,sp
05983                                           ! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
05984 1828           8B46         04            mov	ax,4[bp]
05985 182B           85C0                       test	ax,ax
05986 182D           74           08            je  	.149
05987                       0000182F            .14A:
05988                                           ! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
05989 182F           8B46         04            mov	ax,4[bp]
05990 1832           3D                   0003  cmp	ax,*3
05991 1835           76           0D            jbe 	.148
05992                       00001837            .149:
05993                                           ! Debug: list * char = .14B+0 (used reg = )
05994 1837           BB                   D517  mov	bx,#.14B
05995 183A           53                         push	bx
05996                                           ! Debug: list int = const 7 (used reg = )
05997 183B           B8                   0007  mov	ax,*7
05998 183E           50                         push	ax
05999                                           ! Debug: func () void = bios_printf+0 (used reg = )
06000 183F           E8         F1D9            call	_bios_printf
06001 1842           89EC                       mov	sp,bp
06002                                           !BCC_EOS
06003                                           ! 1414   bios_printf(2, "Boot from %s failed", drivetypes[type]);
06004                       00001844            .148:
06005                                           ! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
06006 1844           8B5E         04            mov	bx,4[bp]
06007 1847           89DA                       mov	dx,bx
06008 1849           D1E3                       shl	bx,*1
06009 184B           D1E3                       shl	bx,*1
06010 184D           01D3                       add	bx,dx
06011 184F           D1E3                       shl	bx,*1
06012                                           ! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
06013                                           ! Debug: list * char = bx+_drivetypes+0 (used reg = )
06014 1851           81C3                 1374  add	bx,#_drivetypes
06015 1855           53                         push	bx
06016                                           ! Debug: list * char = .14C+0 (used reg = )
06017 1856           BB                   D503  mov	bx,#.14C
06018 1859           53                         push	bx
06019                                           ! Debug: list int = const 2 (used reg = )
06020 185A           B8                   0002  mov	ax,*2
06021 185D           50                         push	ax
06022                                           ! Debug: func () void = bios_printf+0 (used reg = )
06023 185E           E8         F1BA            call	_bios_printf
06024 1861           89EC                       mov	sp,bp
06025                                           !BCC_EOS
06026                                           ! 1415   if (type < 4) {
06027                                           ! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
06028 1863           8B46         04            mov	ax,4[bp]
06029 1866           3D                   0004  cmp	ax,*4
06030 1869           73           23            jae 	.14D
06031                       0000186B            .14E:
06032                                           ! 1416     if (reason==0)
06033                                           ! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
06034 186B           8A46         06            mov	al,6[bp]
06035 186E           84C0                       test	al,al
06036 1870           75           0F            jne 	.14F
06037                       00001872            .150:
06038                                           ! 1417       bios_printf(2, ": not a bootable disk");
06039                                           ! Debug: list * char = .151+0 (used reg = )
06040 1872           BB                   D4ED  mov	bx,#.151
06041 1875           53                         push	bx
06042                                           ! Debug: list int = const 2 (used reg = )
06043 1876           B8                   0002  mov	ax,*2
06044 1879           50                         push	ax
06045                                           ! Debug: func () void = bios_printf+0 (used reg = )
06046 187A           E8         F19E            call	_bios_printf
06047 187D           89EC                       mov	sp,bp
06048                                           !BCC_EOS
06049                                           ! 1418     else
06050                                           ! 1419       bios_printf(2, ": could not read the boot disk");
06051 187F           EB           0D            jmp .152
06052                       00001881            .14F:
06053                                           ! Debug: list * char = .153+0 (used reg = )
06054 1881           BB                   D4CE  mov	bx,#.153
06055 1884           53                         push	bx
06056                                           ! Debug: list int = const 2 (used reg = )
06057 1885           B8                   0002  mov	ax,*2
06058 1888           50                         push	ax
06059                                           ! Debug: func () void = bios_printf+0 (used reg = )
06060 1889           E8         F18F            call	_bios_printf
06061 188C           89EC                       mov	sp,bp
06062                                           !BCC_EOS
06063                                           ! 1420   }
06064                       0000188E            .152:
06065                                           ! 1421   bios_printf(2, "\n\n");
06066                       0000188E            .14D:
06067                                           ! Debug: list * char = .154+0 (used reg = )
06068 188E           BB                   D4CB  mov	bx,#.154
06069 1891           53                         push	bx
06070                                           ! Debug: list int = const 2 (used reg = )
06071 1892           B8                   0002  mov	ax,*2
06072 1895           50                         push	ax
06073                                           ! Debug: func () void = bios_printf+0 (used reg = )
06074 1896           E8         F182            call	_bios_printf
06075 1899           89EC                       mov	sp,bp
06076                                           !BCC_EOS
06077                                           ! 1422 }
06078 189B           5D                         pop	bp
06079 189C           C3                         ret
06080                                           ! 1423   void
06081                                           ! Register BX used in function print_boot_failure
06082                                           ! 1424 print_cdromboot_failure( code )
06083                                           ! 1425   Bit16u code;
06084                                           export	_print_cdromboot_failure
06085                       0000189D            _print_cdromboot_failure:
06086                                           !BCC_EOS
06087                                           ! 1426 {
06088                                           ! 1427   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
06089 189D           55                         push	bp
06090 189E           89E5                       mov	bp,sp
06091                                           ! Debug: list unsigned short code = [S+2+2] (used reg = )
06092 18A0           FF76         04            push	4[bp]
06093                                           ! Debug: list * char = .155+0 (used reg = )
06094 18A3           BB                   D4AB  mov	bx,#.155
06095 18A6           53                         push	bx
06096                                           ! Debug: list int = const 6 (used reg = )
06097 18A7           B8                   0006  mov	ax,*6
06098 18AA           50                         push	ax
06099                                           ! Debug: func () void = bios_printf+0 (used reg = )
06100 18AB           E8         F16D            call	_bios_printf
06101 18AE           89EC                       mov	sp,bp
06102                                           !BCC_EOS
06103                                           ! 1428   return;
06104 18B0           5D                         pop	bp
06105 18B1           C3                         ret
06106                                           !BCC_EOS
06107                                           ! 1429 }
06108                                           ! 1430 void
06109                                           ! Register BX used in function print_cdromboot_failure
06110                                           ! 1431 nmi_handler_msg()
06111                                           ! 1432 {
06112                                           export	_nmi_handler_msg
06113                       000018B2            _nmi_handler_msg:
06114                                           ! 1433   bios_printf((2 | 4
06115 18B2           55                         push	bp
06116 18B3           89E5                       mov	bp,sp
06117                                           ! 1433  | 1), "NMI Handler called\n");
06118                                           ! Debug: list * char = .156+0 (used reg = )
06119 18B5           BB                   D497  mov	bx,#.156
06120 18B8           53                         push	bx
06121                                           ! Debug: list int = const 7 (used reg = )
06122 18B9           B8                   0007  mov	ax,*7
06123 18BC           50                         push	ax
06124                                           ! Debug: func () void = bios_printf+0 (used reg = )
06125 18BD           E8         F15B            call	_bios_printf
06126 18C0           89EC                       mov	sp,bp
06127                                           !BCC_EOS
06128                                           ! 1434 }
06129 18C2           5D                         pop	bp
06130 18C3           C3                         ret
06131                                           ! 1435 void
06132                                           ! Register BX used in function nmi_handler_msg
06133                                           ! 1436 int18_panic_msg()
06134                                           ! 1437 {
06135                                           export	_int18_panic_msg
06136                       000018C4            _int18_panic_msg:
06137                                           ! 1438   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
06138 18C4           55                         push	bp
06139 18C5           89E5                       mov	bp,sp
06140                                           ! Debug: list * char = .157+0 (used reg = )
06141 18C7           BB                   D482  mov	bx,#.157
06142 18CA           53                         push	bx
06143                                           ! Debug: list int = const 7 (used reg = )
06144 18CB           B8                   0007  mov	ax,*7
06145 18CE           50                         push	ax
06146                                           ! Debug: func () void = bios_printf+0 (used reg = )
06147 18CF           E8         F149            call	_bios_printf
06148 18D2           89EC                       mov	sp,bp
06149                                           !BCC_EOS
06150                                           ! 1439 }
06151 18D4           5D                         pop	bp
06152 18D5           C3                         ret
06153                                           ! 1440 void
06154                                           ! Register BX used in function int18_panic_msg
06155                                           ! 1441 log_bios_start()
06156                                           ! 1442 {
06157                                           export	_log_bios_start
06158                       000018D6            _log_bios_start:
06159                                           ! 1443   ;
06160 18D6           55                         push	bp
06161 18D7           89E5                       mov	bp,sp
06162                                           !BCC_EOS
06163                                           ! 1444 }
06164 18D9           5D                         pop	bp
06165 18DA           C3                         ret
06166                                           ! 1445   bx_bool
06167                                           ! 1446 set_enable_a20(val)
06168                                           ! 1447   bx_bool val;
06169                                           export	_set_enable_a20
06170                       000018DB            _set_enable_a20:
06171                                           !BCC_EOS
06172                                           ! 1448 {
06173                                           ! 1449   Bit8u oldval;
06174                                           !BCC_EOS
06175                                           ! 1450   oldval = inb(0x92);
06176 18DB           55                         push	bp
06177 18DC           89E5                       mov	bp,sp
06178 18DE           4C                         dec	sp
06179 18DF           4C                         dec	sp
06180                                           ! Debug: list int = const $92 (used reg = )
06181 18E0           B8                   0092  mov	ax,#$92
06182 18E3           50                         push	ax
06183                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06184 18E4           E8         EC57            call	_inb
06185 18E7           44                         inc	sp
06186 18E8           44                         inc	sp
06187                                           ! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
06188 18E9           8846         FF            mov	-1[bp],al
06189                                           !BCC_EOS
06190                                           ! 1451   if (val)
06191 18EC           8B46         04            mov	ax,4[bp]
06192 18EF           85C0                       test	ax,ax
06193 18F1           74           14            je  	.158
06194                       000018F3            .159:
06195                                           ! 1452     outb(0x92, oldval | 0x02);
06196                                           ! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06197 18F3           8A46         FF            mov	al,-1[bp]
06198 18F6           0C                     02  or	al,*2
06199                                           ! Debug: list unsigned char = al+0 (used reg = )
06200 18F8           30E4                       xor	ah,ah
06201 18FA           50                         push	ax
06202                                           ! Debug: list int = const $92 (used reg = )
06203 18FB           B8                   0092  mov	ax,#$92
06204 18FE           50                         push	ax
06205                                           ! Debug: func () void = outb+0 (used reg = )
06206 18FF           E8         EC52            call	_outb
06207 1902           83C4                   04  add	sp,*4
06208                                           !BCC_EOS
06209                                           ! 1453   else
06210                                           ! 1454     outb(0x92, oldval & 0xfd);
06211 1905           EB           12            jmp .15A
06212                       00001907            .158:
06213                                           ! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
06214 1907           8A46         FF            mov	al,-1[bp]
06215 190A           24                     FD  and	al,#$FD
06216                                           ! Debug: list unsigned char = al+0 (used reg = )
06217 190C           30E4                       xor	ah,ah
06218 190E           50                         push	ax
06219                                           ! Debug: list int = const $92 (used reg = )
06220 190F           B8                   0092  mov	ax,#$92
06221 1912           50                         push	ax
06222                                           ! Debug: func () void = outb+0 (used reg = )
06223 1913           E8         EC3E            call	_outb
06224 1916           83C4                   04  add	sp,*4
06225                                           !BCC_EOS
06226                                           ! 1455   return((oldval & 0x02) != 0);
06227                       00001919            .15A:
06228                                           ! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
06229 1919           8A46         FF            mov	al,-1[bp]
06230 191C           24                     02  and	al,*2
06231                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
06232 191E           84C0                       test	al,al
06233 1920           74           04            je 	.15B
06234 1922           B0                     01  mov	al,*1
06235 1924           EB           02            jmp	.15C
06236                       00001926            .15B:
06237 1926           30C0                       xor	al,al
06238                       00001928            .15C:
06239                                           ! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
06240 1928           30E4                       xor	ah,ah
06241 192A           89EC                       mov	sp,bp
06242 192C           5D                         pop	bp
06243 192D           C3                         ret
06244                                           !BCC_EOS
06245                                           ! 1456 }
06246                                           ! 1457   void
06247                                           ! 1458 debugger_on()
06248                                           ! 1459 {
06249                                           export	_debugger_on
06250                       0000192E            _debugger_on:
06251                                           ! 1460   outb(0xfedc, 0x01);
06252 192E           55                         push	bp
06253 192F           89E5                       mov	bp,sp
06254                                           ! Debug: list int = const 1 (used reg = )
06255 1931           B8                   0001  mov	ax,*1
06256 1934           50                         push	ax
06257                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06258 1935           B8                   FEDC  mov	ax,#$FEDC
06259 1938           50                         push	ax
06260                                           ! Debug: func () void = outb+0 (used reg = )
06261 1939           E8         EC18            call	_outb
06262 193C           89EC                       mov	sp,bp
06263                                           !BCC_EOS
06264                                           ! 1461 }
06265 193E           5D                         pop	bp
06266 193F           C3                         ret
06267                                           ! 1462   void
06268                                           ! 1463 debugger_off()
06269                                           ! 1464 {
06270                                           export	_debugger_off
06271                       00001940            _debugger_off:
06272                                           ! 1465   outb(0xfedc, 0x00);
06273 1940           55                         push	bp
06274 1941           89E5                       mov	bp,sp
06275                                           ! Debug: list int = const 0 (used reg = )
06276 1943           31C0                       xor	ax,ax
06277 1945           50                         push	ax
06278                                           ! Debug: list unsigned int = const $FEDC (used reg = )
06279 1946           B8                   FEDC  mov	ax,#$FEDC
06280 1949           50                         push	ax
06281                                           ! Debug: func () void = outb+0 (used reg = )
06282 194A           E8         EC07            call	_outb
06283 194D           89EC                       mov	sp,bp
06284                                           !BCC_EOS
06285                                           ! 1466 }
06286 194F           5D                         pop	bp
06287 1950           C3                         ret
06288                                           ! 1467 int
06289                                           ! 1468 s3_resume()
06290                                           ! 1469 {
06291                                           export	_s3_resume
06292                       00001951            _s3_resume:
06293                                           ! 1470     Bit32u s3_wakeup_vector;
06294                                           !BCC_EOS
06295                                           ! 1471     Bit8u s3_resume_flag;
06296                                           !BCC_EOS
06297                                           ! 1472     s3_resume_flag = read_byte(0x40, 0xb0);
06298 1951           55                         push	bp
06299 1952           89E5                       mov	bp,sp
06300 1954           83C4                   FA  add	sp,*-6
06301                                           ! Debug: list int = const $B0 (used reg = )
06302 1957           B8                   00B0  mov	ax,#$B0
06303 195A           50                         push	ax
06304                                           ! Debug: list int = const $40 (used reg = )
06305 195B           B8                   0040  mov	ax,*$40
06306 195E           50                         push	ax
06307                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
06308 195F           E8         EC92            call	_read_byte
06309 1962           83C4                   04  add	sp,*4
06310                                           ! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06311 1965           8846         FB            mov	-5[bp],al
06312                                           !BCC_EOS
06313                                           ! 1473     s3_wakeup_vector = get_s3_waking_vector();
06314                                           ! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
06315 1968           E8         9680            call	_get_s3_waking_vector
06316 196B           89D3                       mov	bx,dx
06317                                           ! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06318 196D           8946         FC            mov	-4[bp],ax
06319 1970           895E         FE            mov	-2[bp],bx
06320                                           !BCC_EOS
06321                                           ! 1474     ;
06322                                           !BCC_EOS
06323                                           ! 1475     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
06324                                           ! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
06325 1973           8A46         FB            mov	al,-5[bp]
06326 1976           3C                     FE  cmp	al,#$FE
06327 1978           75           0B            jne 	.15E
06328                       0000197A            .15F:
06329 197A           8B46         FC            mov	ax,-4[bp]
06330 197D           8B5E         FE            mov	bx,-2[bp]
06331 1980           E8         E791            call	ltstl
06332 1983           75           06            jne 	.15D
06333                       00001985            .15E:
06334                                           ! 1476      return 0;
06335 1985           31C0                       xor	ax,ax
06336 1987           89EC                       mov	sp,bp
06337 1989           5D                         pop	bp
06338 198A           C3                         ret
06339                                           !BCC_EOS
06340                                           ! 1477     write_byte(0x40, 0xb0, 0);
06341                       0000198B            .15D:
06342                                           ! Debug: list int = const 0 (used reg = )
06343 198B           31C0                       xor	ax,ax
06344 198D           50                         push	ax
06345                                           ! Debug: list int = const $B0 (used reg = )
06346 198E           B8                   00B0  mov	ax,#$B0
06347 1991           50                         push	ax
06348                                           ! Debug: list int = const $40 (used reg = )
06349 1992           B8                   0040  mov	ax,*$40
06350 1995           50                         push	ax
06351                                           ! Debug: func () void = write_byte+0 (used reg = )
06352 1996           E8         EC81            call	_write_byte
06353 1999           83C4                   06  add	sp,*6
06354                                           !BCC_EOS
06355                                           ! 1478     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
06356                                           ! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06357                                           ! Debug: expression subtree swapping
06358 199C           B8                   000F  mov	ax,*$F
06359 199F           31DB                       xor	bx,bx
06360 19A1           8D7E         FC            lea	di,-4[bp]
06361 19A4           E8         E714            call	landul
06362                                           ! Debug: list unsigned long = bx+0 (used reg = )
06363 19A7           53                         push	bx
06364 19A8           50                         push	ax
06365                                           ! Debug: list int = const $B6 (used reg = )
06366 19A9           B8                   00B6  mov	ax,#$B6
06367 19AC           50                         push	ax
06368                                           ! Debug: list int = const $40 (used reg = )
06369 19AD           B8                   0040  mov	ax,*$40
06370 19B0           50                         push	ax
06371                                           ! Debug: func () void = write_word+0 (used reg = )
06372 19B1           E8         EC7E            call	_write_word
06373 19B4           83C4                   08  add	sp,*8
06374                                           !BCC_EOS
06375                                           ! 1479     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
06376                                           ! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
06377 19B7           8B46         FC            mov	ax,-4[bp]
06378 19BA           8B5E         FE            mov	bx,-2[bp]
06379 19BD           BF                   0004  mov	di,*4
06380 19C0           E8         E766            call	lsrul
06381                                           ! Debug: list unsigned long = bx+0 (used reg = )
06382 19C3           53                         push	bx
06383 19C4           50                         push	ax
06384                                           ! Debug: list int = const $B8 (used reg = )
06385 19C5           B8                   00B8  mov	ax,#$B8
06386 19C8           50                         push	ax
06387                                           ! Debug: list int = const $40 (used reg = )
06388 19C9           B8                   0040  mov	ax,*$40
06389 19CC           50                         push	ax
06390                                           ! Debug: func () void = write_word+0 (used reg = )
06391 19CD           E8         EC62            call	_write_word
06392 19D0           83C4                   08  add	sp,*8
06393                                           !BCC_EOS
06394                                           ! 1480     ;
06395                                           !BCC_EOS
06396                                           ! 1481 #asm
06397                                           !BCC_EOS
06398                                           !BCC_ASM
06399                       00000001            _s3_resume.s3_resume_flag	set	1
06400                       FFFFFFFB            .s3_resume.s3_resume_flag	set	-5
06401                       00000002            _s3_resume.s3_wakeup_vector	set	2
06402                       FFFFFFFC            .s3_resume.s3_wakeup_vector	set	-4
06403 19D3           FF2E       04B6                jmpf [0x04b6]
06404                                           ! 1483 endasm
06405                                           !BCC_ENDASM
06406                                           !BCC_EOS
06407                                           ! 1484     return 1;
06408 19D7           B8                   0001  mov	ax,*1
06409 19DA           89EC                       mov	sp,bp
06410 19DC           5D                         pop	bp
06411 19DD           C3                         ret
06412                                           !BCC_EOS
06413                                           ! 1485 }
06414                                           ! 1486 void ata_init( )
06415                                           ! Register BX used in function s3_resume
06416                                           ! 1487 {
06417                                           export	_ata_init
06418                       000019DE            _ata_init:
06419                                           ! 1488   Bit16u ebda_seg=read_word(0x0040,0x000E);
06420 19DE           55                         push	bp
06421 19DF           89E5                       mov	bp,sp
06422 19E1           4C                         dec	sp
06423 19E2           4C                         dec	sp
06424                                           ! Debug: list int = const $E (used reg = )
06425 19E3           B8                   000E  mov	ax,*$E
06426 19E6           50                         push	ax
06427                                           ! Debug: list int = const $40 (used reg = )
06428 19E7           B8                   0040  mov	ax,*$40
06429 19EA           50                         push	ax
06430                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
06431 19EB           E8         EC19            call	_read_word
06432 19EE           83C4                   04  add	sp,*4
06433                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
06434 19F1           8946         FE            mov	-2[bp],ax
06435                                           !BCC_EOS
06436                                           ! 1489   Bit8u channel, device;
06437                                           !BCC_EOS
06438                                           ! 1490   for (channel=0; channel<4; channel++) {
06439 19F4           4C                         dec	sp
06440 19F5           4C                         dec	sp
06441                                           ! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
06442 19F6           30C0                       xor	al,al
06443 19F8           8846         FD            mov	-3[bp],al
06444                                           !BCC_EOS
06445                                           !BCC_EOS
06446 19FB           E9         0077            br 	.162
06447                       000019FE            .163:
06448                                           ! 1491     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
06449                                           ! Debug: list int = const 0 (used reg = )
06450 19FE           31C0                       xor	ax,ax
06451 1A00           50                         push	ax
06452                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06453 1A01           8A46         FD            mov	al,-3[bp]
06454 1A04           30E4                       xor	ah,ah
06455 1A06           B1                     03  mov	cl,*3
06456 1A08           D3E0                       shl	ax,cl
06457 1A0A           89C3                       mov	bx,ax
06458                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
06459                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
06460 1A0C           81C3                 0122  add	bx,#$122
06461 1A10           53                         push	bx
06462                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06463 1A11           FF76         FE            push	-2[bp]
06464                                           ! Debug: func () void = write_byte+0 (used reg = )
06465 1A14           E8         EC03            call	_write_byte
06466 1A17           83C4                   06  add	sp,*6
06467                                           !BCC_EOS
06468                                           ! 1492     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
06469                                           ! Debug: list int = const 0 (used reg = )
06470 1A1A           31C0                       xor	ax,ax
06471 1A1C           50                         push	ax
06472                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06473 1A1D           8A46         FD            mov	al,-3[bp]
06474 1A20           30E4                       xor	ah,ah
06475 1A22           B1                     03  mov	cl,*3
06476 1A24           D3E0                       shl	ax,cl
06477 1A26           89C3                       mov	bx,ax
06478                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
06479                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
06480 1A28           81C3                 0124  add	bx,#$124
06481 1A2C           53                         push	bx
06482                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06483 1A2D           FF76         FE            push	-2[bp]
06484                                           ! Debug: func () void = write_word+0 (used reg = )
06485 1A30           E8         EBFF            call	_write_word
06486 1A33           83C4                   06  add	sp,*6
06487                                           !BCC_EOS
06488                                           ! 1493     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
06489                                           ! Debug: list int = const 0 (used reg = )
06490 1A36           31C0                       xor	ax,ax
06491 1A38           50                         push	ax
06492                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06493 1A39           8A46         FD            mov	al,-3[bp]
06494 1A3C           30E4                       xor	ah,ah
06495 1A3E           B1                     03  mov	cl,*3
06496 1A40           D3E0                       shl	ax,cl
06497 1A42           89C3                       mov	bx,ax
06498                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
06499                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
06500 1A44           81C3                 0126  add	bx,#$126
06501 1A48           53                         push	bx
06502                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06503 1A49           FF76         FE            push	-2[bp]
06504                                           ! Debug: func () void = write_word+0 (used reg = )
06505 1A4C           E8         EBE3            call	_write_word
06506 1A4F           83C4                   06  add	sp,*6
06507                                           !BCC_EOS
06508                                           ! 1494     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
06509                                           ! Debug: list int = const 0 (used reg = )
06510 1A52           31C0                       xor	ax,ax
06511 1A54           50                         push	ax
06512                                           ! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
06513 1A55           8A46         FD            mov	al,-3[bp]
06514 1A58           30E4                       xor	ah,ah
06515 1A5A           B1                     03  mov	cl,*3
06516 1A5C           D3E0                       shl	ax,cl
06517 1A5E           89C3                       mov	bx,ax
06518                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
06519                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
06520 1A60           81C3                 0128  add	bx,#$128
06521 1A64           53                         push	bx
06522                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06523 1A65           FF76         FE            push	-2[bp]
06524                                           ! Debug: func () void = write_byte+0 (used reg = )
06525 1A68           E8         EBAF            call	_write_byte
06526 1A6B           83C4                   06  add	sp,*6
06527                                           !BCC_EOS
06528                                           ! 1495     }
06529                                           ! 1496   for (device=0; device<(4*2); device++) {
06530                       00001A6E            .161:
06531                                           ! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
06532 1A6E           8A46         FD            mov	al,-3[bp]
06533 1A71           40                         inc	ax
06534 1A72           8846         FD            mov	-3[bp],al
06535                       00001A75            .162:
06536                                           ! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
06537 1A75           8A46         FD            mov	al,-3[bp]
06538 1A78           3C                     04  cmp	al,*4
06539 1A7A           72           82            jb 	.163
06540                       00001A7C            .164:
06541                       00001A7C            .160:
06542                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06543 1A7C           30C0                       xor	al,al
06544 1A7E           8846         FC            mov	-4[bp],al
06545                                           !BCC_EOS
06546                                           !BCC_EOS
06547 1A81           E9         01C0            br 	.167
06548                       00001A84            .168:
06549                                           ! 1497     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
06550                                           ! Debug: list int = const 0 (used reg = )
06551 1A84           31C0                       xor	ax,ax
06552 1A86           50                         push	ax
06553                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06554 1A87           8A46         FC            mov	al,-4[bp]
06555 1A8A           30E4                       xor	ah,ah
06556 1A8C           B9                   001E  mov	cx,*$1E
06557 1A8F           F7E9                       imul	cx
06558 1A91           89C3                       mov	bx,ax
06559                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
06560                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
06561 1A93           81C3                 0142  add	bx,#$142
06562 1A97           53                         push	bx
06563                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06564 1A98           FF76         FE            push	-2[bp]
06565                                           ! Debug: func () void = write_byte+0 (used reg = )
06566 1A9B           E8         EB7C            call	_write_byte
06567 1A9E           83C4                   06  add	sp,*6
06568                                           !BCC_EOS
06569                                           ! 1498     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
06570                                           ! Debug: list int = const 0 (used reg = )
06571 1AA1           31C0                       xor	ax,ax
06572 1AA3           50                         push	ax
06573                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06574 1AA4           8A46         FC            mov	al,-4[bp]
06575 1AA7           30E4                       xor	ah,ah
06576 1AA9           B9                   001E  mov	cx,*$1E
06577 1AAC           F7E9                       imul	cx
06578 1AAE           89C3                       mov	bx,ax
06579                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
06580                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
06581 1AB0           81C3                 0143  add	bx,#$143
06582 1AB4           53                         push	bx
06583                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06584 1AB5           FF76         FE            push	-2[bp]
06585                                           ! Debug: func () void = write_byte+0 (used reg = )
06586 1AB8           E8         EB5F            call	_write_byte
06587 1ABB           83C4                   06  add	sp,*6
06588                                           !BCC_EOS
06589                                           ! 1499     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
06590                                           ! Debug: list int = const 0 (used reg = )
06591 1ABE           31C0                       xor	ax,ax
06592 1AC0           50                         push	ax
06593                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06594 1AC1           8A46         FC            mov	al,-4[bp]
06595 1AC4           30E4                       xor	ah,ah
06596 1AC6           B9                   001E  mov	cx,*$1E
06597 1AC9           F7E9                       imul	cx
06598 1ACB           89C3                       mov	bx,ax
06599                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
06600                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
06601 1ACD           81C3                 0144  add	bx,#$144
06602 1AD1           53                         push	bx
06603                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06604 1AD2           FF76         FE            push	-2[bp]
06605                                           ! Debug: func () void = write_byte+0 (used reg = )
06606 1AD5           E8         EB42            call	_write_byte
06607 1AD8           83C4                   06  add	sp,*6
06608                                           !BCC_EOS
06609                                           ! 1500     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
06610                                           ! Debug: list int = const 0 (used reg = )
06611 1ADB           31C0                       xor	ax,ax
06612 1ADD           50                         push	ax
06613                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06614 1ADE           8A46         FC            mov	al,-4[bp]
06615 1AE1           30E4                       xor	ah,ah
06616 1AE3           B9                   001E  mov	cx,*$1E
06617 1AE6           F7E9                       imul	cx
06618 1AE8           89C3                       mov	bx,ax
06619                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
06620                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
06621 1AEA           81C3                 0145  add	bx,#$145
06622 1AEE           53                         push	bx
06623                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06624 1AEF           FF76         FE            push	-2[bp]
06625                                           ! Debug: func () void = write_byte+0 (used reg = )
06626 1AF2           E8         EB25            call	_write_byte
06627 1AF5           83C4                   06  add	sp,*6
06628                                           !BCC_EOS
06629                                           ! 1501     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
06630                                           ! Debug: list int = const 0 (used reg = )
06631 1AF8           31C0                       xor	ax,ax
06632 1AFA           50                         push	ax
06633                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06634 1AFB           8A46         FC            mov	al,-4[bp]
06635 1AFE           30E4                       xor	ah,ah
06636 1B00           B9                   001E  mov	cx,*$1E
06637 1B03           F7E9                       imul	cx
06638 1B05           89C3                       mov	bx,ax
06639                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
06640                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
06641 1B07           81C3                 0146  add	bx,#$146
06642 1B0B           53                         push	bx
06643                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06644 1B0C           FF76         FE            push	-2[bp]
06645                                           ! Debug: func () void = write_byte+0 (used reg = )
06646 1B0F           E8         EB08            call	_write_byte
06647 1B12           83C4                   06  add	sp,*6
06648                                           !BCC_EOS
06649                                           ! 1502     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
06650                                           ! Debug: list int = const 0 (used reg = )
06651 1B15           31C0                       xor	ax,ax
06652 1B17           50                         push	ax
06653                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06654 1B18           8A46         FC            mov	al,-4[bp]
06655 1B1B           30E4                       xor	ah,ah
06656 1B1D           B9                   001E  mov	cx,*$1E
06657 1B20           F7E9                       imul	cx
06658 1B22           89C3                       mov	bx,ax
06659                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
06660                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
06661 1B24           81C3                 0148  add	bx,#$148
06662 1B28           53                         push	bx
06663                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06664 1B29           FF76         FE            push	-2[bp]
06665                                           ! Debug: func () void = write_word+0 (used reg = )
06666 1B2C           E8         EB03            call	_write_word
06667 1B2F           83C4                   06  add	sp,*6
06668                                           !BCC_EOS
06669                                           ! 1503     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
06670                                           ! Debug: list int = const 0 (used reg = )
06671 1B32           31C0                       xor	ax,ax
06672 1B34           50                         push	ax
06673                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06674 1B35           8A46         FC            mov	al,-4[bp]
06675 1B38           30E4                       xor	ah,ah
06676 1B3A           B9                   001E  mov	cx,*$1E
06677 1B3D           F7E9                       imul	cx
06678 1B3F           89C3                       mov	bx,ax
06679                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
06680                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
06681 1B41           81C3                 014A  add	bx,#$14A
06682 1B45           53                         push	bx
06683                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06684 1B46           FF76         FE            push	-2[bp]
06685                                           ! Debug: func () void = write_byte+0 (used reg = )
06686 1B49           E8         EACE            call	_write_byte
06687 1B4C           83C4                   06  add	sp,*6
06688                                           !BCC_EOS
06689                                           ! 1504     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
06690                                           ! Debug: list int = const 0 (used reg = )
06691 1B4F           31C0                       xor	ax,ax
06692 1B51           50                         push	ax
06693                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06694 1B52           8A46         FC            mov	al,-4[bp]
06695 1B55           30E4                       xor	ah,ah
06696 1B57           B9                   001E  mov	cx,*$1E
06697 1B5A           F7E9                       imul	cx
06698 1B5C           89C3                       mov	bx,ax
06699                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
06700                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
06701 1B5E           81C3                 014C  add	bx,#$14C
06702 1B62           53                         push	bx
06703                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06704 1B63           FF76         FE            push	-2[bp]
06705                                           ! Debug: func () void = write_word+0 (used reg = )
06706 1B66           E8         EAC9            call	_write_word
06707 1B69           83C4                   06  add	sp,*6
06708                                           !BCC_EOS
06709                                           ! 1505     write_word(ebda_seg,&((ebda_data_t *) 0)->ata
06710                                           ! 1505 .devices[device].lchs.cylinders,0);
06711                                           ! Debug: list int = const 0 (used reg = )
06712 1B6C           31C0                       xor	ax,ax
06713 1B6E           50                         push	ax
06714                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06715 1B6F           8A46         FC            mov	al,-4[bp]
06716 1B72           30E4                       xor	ah,ah
06717 1B74           B9                   001E  mov	cx,*$1E
06718 1B77           F7E9                       imul	cx
06719 1B79           89C3                       mov	bx,ax
06720                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
06721                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
06722 1B7B           81C3                 014E  add	bx,#$14E
06723 1B7F           53                         push	bx
06724                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06725 1B80           FF76         FE            push	-2[bp]
06726                                           ! Debug: func () void = write_word+0 (used reg = )
06727 1B83           E8         EAAC            call	_write_word
06728 1B86           83C4                   06  add	sp,*6
06729                                           !BCC_EOS
06730                                           ! 1506     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
06731                                           ! Debug: list int = const 0 (used reg = )
06732 1B89           31C0                       xor	ax,ax
06733 1B8B           50                         push	ax
06734                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06735 1B8C           8A46         FC            mov	al,-4[bp]
06736 1B8F           30E4                       xor	ah,ah
06737 1B91           B9                   001E  mov	cx,*$1E
06738 1B94           F7E9                       imul	cx
06739 1B96           89C3                       mov	bx,ax
06740                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
06741                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
06742 1B98           81C3                 0150  add	bx,#$150
06743 1B9C           53                         push	bx
06744                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06745 1B9D           FF76         FE            push	-2[bp]
06746                                           ! Debug: func () void = write_word+0 (used reg = )
06747 1BA0           E8         EA8F            call	_write_word
06748 1BA3           83C4                   06  add	sp,*6
06749                                           !BCC_EOS
06750                                           ! 1507     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
06751                                           ! Debug: list int = const 0 (used reg = )
06752 1BA6           31C0                       xor	ax,ax
06753 1BA8           50                         push	ax
06754                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06755 1BA9           8A46         FC            mov	al,-4[bp]
06756 1BAC           30E4                       xor	ah,ah
06757 1BAE           B9                   001E  mov	cx,*$1E
06758 1BB1           F7E9                       imul	cx
06759 1BB3           89C3                       mov	bx,ax
06760                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
06761                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
06762 1BB5           81C3                 0152  add	bx,#$152
06763 1BB9           53                         push	bx
06764                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06765 1BBA           FF76         FE            push	-2[bp]
06766                                           ! Debug: func () void = write_word+0 (used reg = )
06767 1BBD           E8         EA72            call	_write_word
06768 1BC0           83C4                   06  add	sp,*6
06769                                           !BCC_EOS
06770                                           ! 1508     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
06771                                           ! Debug: list int = const 0 (used reg = )
06772 1BC3           31C0                       xor	ax,ax
06773 1BC5           50                         push	ax
06774                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06775 1BC6           8A46         FC            mov	al,-4[bp]
06776 1BC9           30E4                       xor	ah,ah
06777 1BCB           B9                   001E  mov	cx,*$1E
06778 1BCE           F7E9                       imul	cx
06779 1BD0           89C3                       mov	bx,ax
06780                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
06781                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
06782 1BD2           81C3                 0154  add	bx,#$154
06783 1BD6           53                         push	bx
06784                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06785 1BD7           FF76         FE            push	-2[bp]
06786                                           ! Debug: func () void = write_word+0 (used reg = )
06787 1BDA           E8         EA55            call	_write_word
06788 1BDD           83C4                   06  add	sp,*6
06789                                           !BCC_EOS
06790                                           ! 1509     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
06791                                           ! Debug: list int = const 0 (used reg = )
06792 1BE0           31C0                       xor	ax,ax
06793 1BE2           50                         push	ax
06794                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
06795 1BE3           8A46         FC            mov	al,-4[bp]
06796 1BE6           30E4                       xor	ah,ah
06797 1BE8           B9                   001E  mov	cx,*$1E
06798 1BEB           F7E9                       imul	cx
06799 1BED           89C3                       mov	bx,ax
06800                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
06801                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
06802 1BEF           81C3                 0156  add	bx,#$156
06803 1BF3           53                         push	bx
06804                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06805 1BF4           FF76         FE            push	-2[bp]
06806                                           ! Debug: func () void = write_word+0 (used reg = )
06807 1BF7           E8         EA38            call	_write_word
06808 1BFA           83C4                   06  add	sp,*6
06809                                           !BCC_EOS
06810                                           ! 1510     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
06811                                           ! Debug: list long = const 0 (used reg = )
06812 1BFD           31C0                       xor	ax,ax
06813 1BFF           31DB                       xor	bx,bx
06814 1C01           53                         push	bx
06815 1C02           50                         push	ax
06816                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06817 1C03           8A46         FC            mov	al,-4[bp]
06818 1C06           30E4                       xor	ah,ah
06819 1C08           B9                   001E  mov	cx,*$1E
06820 1C0B           F7E9                       imul	cx
06821 1C0D           89C3                       mov	bx,ax
06822                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
06823                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
06824 1C0F           81C3                 0158  add	bx,#$158
06825 1C13           53                         push	bx
06826                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06827 1C14           FF76         FE            push	-2[bp]
06828                                           ! Debug: func () void = write_dword+0 (used reg = )
06829 1C17           E8         E481            call	_write_dword
06830 1C1A           83C4                   08  add	sp,*8
06831                                           !BCC_EOS
06832                                           ! 1511     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
06833                                           ! Debug: list long = const 0 (used reg = )
06834 1C1D           31C0                       xor	ax,ax
06835 1C1F           31DB                       xor	bx,bx
06836 1C21           53                         push	bx
06837 1C22           50                         push	ax
06838                                           ! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
06839 1C23           8A46         FC            mov	al,-4[bp]
06840 1C26           30E4                       xor	ah,ah
06841 1C28           B9                   001E  mov	cx,*$1E
06842 1C2B           F7E9                       imul	cx
06843 1C2D           89C3                       mov	bx,ax
06844                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
06845                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
06846 1C2F           81C3                 015C  add	bx,#$15C
06847 1C33           53                         push	bx
06848                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
06849 1C34           FF76         FE            push	-2[bp]
06850                                           ! Debug: func () void = write_dword+0 (used reg = )
06851 1C37           E8         E461            call	_write_dword
06852 1C3A           83C4                   08  add	sp,*8
06853                                           !BCC_EOS
06854                                           ! 1512     }
06855                                           ! 1513   for (device=0; device<(4*2); device++) {
06856                       00001C3D            .166:
06857                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06858 1C3D           8A46         FC            mov	al,-4[bp]
06859 1C40           40                         inc	ax
06860 1C41           8846         FC            mov	-4[bp],al
06861                       00001C44            .167:
06862                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06863 1C44           8A46         FC            mov	al,-4[bp]
06864 1C47           3C                     08  cmp	al,*8
06865 1C49         0F82         FE37            blo 	.168
06866                       00001C4D            .169:
06867                       00001C4D            .165:
06868                                           ! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
06869 1C4D           30C0                       xor	al,al
06870 1C4F           8846         FC            mov	-4[bp],al
06871                                           !BCC_EOS
06872                                           !BCC_EOS
06873 1C52           EB           39            jmp .16C
06874                       00001C54            .16D:
06875                                           ! 1514     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
06876                                           ! Debug: list int = const 8 (used reg = )
06877 1C54           B8                   0008  mov	ax,*8
06878 1C57           50                         push	ax
06879                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
06880 1C58           8A46         FC            mov	al,-4[bp]
06881 1C5B           30E4                       xor	ah,ah
06882 1C5D           89C3                       mov	bx,ax
06883                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
06884                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
06885 1C5F           81C3                 0233  add	bx,#$233
06886 1C63           53                         push	bx
06887                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06888 1C64           FF76         FE            push	-2[bp]
06889                                           ! Debug: func () void = write_byte+0 (used reg = )
06890 1C67           E8         E9B0            call	_write_byte
06891 1C6A           83C4                   06  add	sp,*6
06892                                           !BCC_EOS
06893                                           ! 1515     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
06894                                           ! Debug: list int = const 8 (used reg = )
06895 1C6D           B8                   0008  mov	ax,*8
06896 1C70           50                         push	ax
06897                                           ! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
06898 1C71           8A46         FC            mov	al,-4[bp]
06899 1C74           30E4                       xor	ah,ah
06900 1C76           89C3                       mov	bx,ax
06901                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
06902                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
06903 1C78           81C3                 023C  add	bx,#$23C
06904 1C7C           53                         push	bx
06905                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06906 1C7D           FF76         FE            push	-2[bp]
06907                                           ! Debug: func () void = write_byte+0 (used reg = )
06908 1C80           E8         E997            call	_write_byte
06909 1C83           83C4                   06  add	sp,*6
06910                                           !BCC_EOS
06911                                           ! 1516     }
06912                                           ! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
06913                       00001C86            .16B:
06914                                           ! Debug: postinc unsigned char device = [S+6-6] (used reg = )
06915 1C86           8A46         FC            mov	al,-4[bp]
06916 1C89           40                         inc	ax
06917 1C8A           8846         FC            mov	-4[bp],al
06918                       00001C8D            .16C:
06919                                           ! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
06920 1C8D           8A46         FC            mov	al,-4[bp]
06921 1C90           3C                     08  cmp	al,*8
06922 1C92           72           C0            jb 	.16D
06923                       00001C94            .16E:
06924                       00001C94            .16A:
06925                                           ! Debug: list int = const 0 (used reg = )
06926 1C94           31C0                       xor	ax,ax
06927 1C96           50                         push	ax
06928                                           ! Debug: list * unsigned char = const $232 (used reg = )
06929 1C97           B8                   0232  mov	ax,#$232
06930 1C9A           50                         push	ax
06931                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06932 1C9B           FF76         FE            push	-2[bp]
06933                                           ! Debug: func () void = write_byte+0 (used reg = )
06934 1C9E           E8         E979            call	_write_byte
06935 1CA1           83C4                   06  add	sp,*6
06936                                           !BCC_EOS
06937                                           ! 1518   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
06938                                           ! Debug: list int = const 0 (used reg = )
06939 1CA4           31C0                       xor	ax,ax
06940 1CA6           50                         push	ax
06941                                           ! Debug: list * unsigned char = const $23B (used reg = )
06942 1CA7           B8                   023B  mov	ax,#$23B
06943 1CAA           50                         push	ax
06944                                           ! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
06945 1CAB           FF76         FE            push	-2[bp]
06946                                           ! Debug: func () void = write_byte+0 (used reg = )
06947 1CAE           E8         E969            call	_write_byte
06948 1CB1           83C4                   06  add	sp,*6
06949                                           !BCC_EOS
06950                                           ! 1519 }
06951 1CB4           89EC                       mov	sp,bp
06952 1CB6           5D                         pop	bp
06953 1CB7           C3                         ret
06954                                           ! 1520 Bit8u await_ide();
06955                                           ! Register BX used in function ata_init
06956                                           !BCC_EOS
06957                                           ! 1521 static Bit8u await_ide(when_done,base,timeout)
06958                                           ! 1522   Bit8u when_done;
06959                       00001CB8            _await_ide:
06960                                           !BCC_EOS
06961                                           ! 1523   Bit16u base;
06962                                           !BCC_EOS
06963                                           ! 1524   Bit16u timeout;
06964                                           !BCC_EOS
06965                                           ! 1525 {
06966                                           ! 1526   Bit32u time=0,last=0;
06967 1CB8           55                         push	bp
06968 1CB9           89E5                       mov	bp,sp
06969 1CBB           83C4                   FC  add	sp,*-4
06970                                           ! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
06971 1CBE           31C0                       xor	ax,ax
06972 1CC0           31DB                       xor	bx,bx
06973 1CC2           8946         FC            mov	-4[bp],ax
06974 1CC5           895E         FE            mov	-2[bp],bx
06975 1CC8           83C4                   FC  add	sp,*-4
06976                                           ! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
06977 1CCB           31C0                       xor	ax,ax
06978 1CCD           31DB                       xor	bx,bx
06979 1CCF           8946         F8            mov	-8[bp],ax
06980 1CD2           895E         FA            mov	-6[bp],bx
06981                                           !BCC_EOS
06982                                           ! 1527   Bit8u status;
06983                                           !BCC_EOS
06984                                           ! 1528   Bit8u result;
06985                                           !BCC_EOS
06986                                           ! 1529   for(;;) {
06987 1CD5           4C                         dec	sp
06988 1CD6           4C                         dec	sp
06989                                           !BCC_EOS
06990                                           !BCC_EOS
06991                       00001CD7            .171:
06992                                           ! 1530     status = inb(base+7);
06993                                           ! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
06994 1CD7           8B46         06            mov	ax,6[bp]
06995                                           ! Debug: list unsigned int = ax+7 (used reg = )
06996 1CDA           05                   0007  add	ax,*7
06997 1CDD           50                         push	ax
06998                                           ! Debug: func () unsigned char = inb+0 (used reg = )
06999 1CDE           E8         E85D            call	_inb
07000 1CE1           44                         inc	sp
07001 1CE2           44                         inc	sp
07002                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$C-$B] (used reg = )
07003 1CE3           8846         F7            mov	-9[bp],al
07004                                           !BCC_EOS
07005                                           ! 1531     time++;
07006                                           ! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
07007 1CE6           8B46         FC            mov	ax,-4[bp]
07008 1CE9           8B76         FE            mov	si,-2[bp]
07009 1CEC           8D5E         FC            lea	bx,-4[bp]
07010 1CEF           E8         E41D            call	lincl
07011                                           !BCC_EOS
07012                                           ! 1532     if (when_done == 1)
07013                                           ! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
07014 1CF2           8A46         04            mov	al,4[bp]
07015 1CF5           3C                     01  cmp	al,*1
07016 1CF7           75           0B            jne 	.172
07017                       00001CF9            .173:
07018                                           ! 1533       result = status & 0x80;
07019                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07020 1CF9           8A46         F7            mov	al,-9[bp]
07021 1CFC           24                     80  and	al,#$80
07022                                           ! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07023 1CFE           8846         F6            mov	-$A[bp],al
07024                                           !BCC_EOS
07025                                           ! 1534     else if (when_done == 2)
07026 1D01           E9         0094            br 	.174
07027                       00001D04            .172:
07028                                           ! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
07029 1D04           8A46         04            mov	al,4[bp]
07030 1D07           3C                     02  cmp	al,*2
07031 1D09           75           15            jne 	.175
07032                       00001D0B            .176:
07033                                           ! 1535       result = !(status & 0x80);
07034                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07035 1D0B           8A46         F7            mov	al,-9[bp]
07036 1D0E           24                     80  and	al,#$80
07037 1D10           84C0                       test	al,al
07038 1D12           75           04            jne 	.177
07039                       00001D14            .178:
07040 1D14           B0                     01  mov	al,*1
07041 1D16           EB           02            jmp	.179
07042                       00001D18            .177:
07043 1D18           30C0                       xor	al,al
07044                       00001D1A            .179:
07045                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07046 1D1A           8846         F6            mov	-$A[bp],al
07047                                           !BCC_EOS
07048                                           ! 1536     else if (when_done == 3)
07049 1D1D           E9         0078            br 	.17A
07050                       00001D20            .175:
07051                                           ! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
07052 1D20           8A46         04            mov	al,4[bp]
07053 1D23           3C                     03  cmp	al,*3
07054 1D25           75           1D            jne 	.17B
07055                       00001D27            .17C:
07056                                           ! 1537       result = !(status & 0x80) && (status & 0x08);
07057                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07058 1D27           8A46         F7            mov	al,-9[bp]
07059 1D2A           24                     80  and	al,#$80
07060 1D2C           84C0                       test	al,al
07061 1D2E           75           0D            jne 	.17D
07062                       00001D30            .17F:
07063                                           ! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
07064 1D30           8A46         F7            mov	al,-9[bp]
07065 1D33           24                     08  and	al,*8
07066 1D35           84C0                       test	al,al
07067 1D37           74           04            je  	.17D
07068                       00001D39            .17E:
07069 1D39           B0                     01  mov	al,*1
07070 1D3B           EB           02            jmp	.180
07071                       00001D3D            .17D:
07072 1D3D           30C0                       xor	al,al
07073                       00001D3F            .180:
07074                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07075 1D3F           8846         F6            mov	-$A[bp],al
07076                                           !BCC_EOS
07077                                           ! 1538     else if (when_done == 4)
07078 1D42           EB           54            jmp .181
07079                       00001D44            .17B:
07080                                           ! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
07081 1D44           8A46         04            mov	al,4[bp]
07082 1D47           3C                     04  cmp	al,*4
07083 1D49           75           1D            jne 	.182
07084                       00001D4B            .183:
07085                                           ! 1539       result = !(status & 0x80) && !(status & 0x08);
07086                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07087 1D4B           8A46         F7            mov	al,-9[bp]
07088 1D4E           24                     80  and	al,#$80
07089 1D50           84C0                       test	al,al
07090 1D52           75           0D            jne 	.184
07091                       00001D54            .186:
07092                                           ! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
07093 1D54           8A46         F7            mov	al,-9[bp]
07094 1D57           24                     08  and	al,*8
07095 1D59           84C0                       test	al,al
07096 1D5B           75           04            jne 	.184
07097                       00001D5D            .185:
07098 1D5D           B0                     01  mov	al,*1
07099 1D5F           EB           02            jmp	.187
07100                       00001D61            .184:
07101 1D61           30C0                       xor	al,al
07102                       00001D63            .187:
07103                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07104 1D63           8846         F6            mov	-$A[bp],al
07105                                           !BCC_EOS
07106                                           ! 1540     else if (when_done == 5)
07107 1D66           EB           30            jmp .188
07108                       00001D68            .182:
07109                                           ! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
07110 1D68           8A46         04            mov	al,4[bp]
07111 1D6B           3C                     05  cmp	al,*5
07112 1D6D           75           1D            jne 	.189
07113                       00001D6F            .18A:
07114                                           ! 1541       result = !(status & 0x80) && (status & 0x40);
07115                                           ! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
07116 1D6F           8A46         F7            mov	al,-9[bp]
07117 1D72           24                     80  and	al,#$80
07118 1D74           84C0                       test	al,al
07119 1D76           75           0D            jne 	.18B
07120                       00001D78            .18D:
07121                                           ! Debug: and int = const $40 to unsigned char status = [S+$C-$B] (used reg = )
07122 1D78           8A46         F7            mov	al,-9[bp]
07123 1D7B           24                     40  and	al,*$40
07124 1D7D           84C0                       test	al,al
07125 1D7F           74           04            je  	.18B
07126                       00001D81            .18C:
07127 1D81           B0                     01  mov	al,*1
07128 1D83           EB           02            jmp	.18E
07129                       00001D85            .18B:
07130 1D85           30C0                       xor	al,al
07131                       00001D87            .18E:
07132                                           ! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
07133 1D87           8846         F6            mov	-$A[bp],al
07134                                           !BCC_EOS
07135                                           ! 1542     else if (when_done == 0)
07136 1D8A           EB           0C            jmp .18F
07137                       00001D8C            .189:
07138                                           ! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
07139 1D8C           8A46         04            mov	al,4[bp]
07140 1D8F           84C0                       test	al,al
07141 1D91           75           05            jne 	.190
07142                       00001D93            .191:
07143                                           ! 1543       result = 0;
07144                                           ! Debug: eq int = const 0 to unsigned char result = [S+$C-$C] (used reg = )
07145 1D93           30C0                       xor	al,al
07146 1D95           8846         F6            mov	-$A[bp],al
07147                                           !BCC_EOS
07148                                           ! 1544     if (result) return status;
07149                       00001D98            .190:
07150                       00001D98            .18F:
07151                       00001D98            .188:
07152                       00001D98            .181:
07153                       00001D98            .17A:
07154                       00001D98            .174:
07155 1D98           8A46         F6            mov	al,-$A[bp]
07156 1D9B           84C0                       test	al,al
07157 1D9D           74           07            je  	.192
07158                       00001D9F            .193:
07159 1D9F           8A46         F7            mov	al,-9[bp]
07160 1DA2           89EC                       mov	sp,bp
07161 1DA4           5D                         pop	bp
07162 1DA5           C3                         ret
07163                                           !BCC_EOS
07164                                           ! 1545     if (time>>16 != last)
07165                       00001DA6            .192:
07166                                           ! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
07167 1DA6           8B46         FC            mov	ax,-4[bp]
07168 1DA9           8B5E         FE            mov	bx,-2[bp]
07169 1DAC           93                         xchg	bx,ax
07170 1DAD           31DB                       xor	bx,bx
07171                                           ! Debug: ne unsigned long last = [S+$C-$A] to unsigned long = bx+0 (used reg = )
07172 1DAF           8D7E         F8            lea	di,-8[bp]
07173 1DB2           E8         E316            call	lcmpul
07174 1DB5           74           0F            je  	.194
07175                       00001DB7            .195:
07176                                           ! 1546     {
07177                                           ! 1547       last = time >>16;
07178                                           ! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
07179 1DB7           8B46         FC            mov	ax,-4[bp]
07180 1DBA           8B5E         FE            mov	bx,-2[bp]
07181 1DBD           93                         xchg	bx,ax
07182 1DBE           31DB                       xor	bx,bx
07183                                           ! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$C-$A] (used reg = )
07184 1DC0           8946         F8            mov	-8[bp],ax
07185 1DC3           895E         FA            mov	-6[bp],bx
07186                                           !BCC_EOS
07187                                           ! 1548       ;
07188                                           !BCC_EOS
07189                                           ! 1549     }
07190                                           ! 1550     if (status & 0x01)
07191                       00001DC6            .194:
07192                                           ! Debug: and int = const 1 to unsigned char status = [S+$C-$B] (used reg = )
07193 1DC6           8A46         F7            mov	al,-9[bp]
07194 1DC9           24                     01  and	al,*1
07195 1DCB           84C0                       test	al,al
07196 1DCD           74           07            je  	.196
07197                       00001DCF            .197:
07198                                           ! 1551     {
07199                                           ! 1552       ;
07200                                           !BCC_EOS
07201                                           ! 1553       return status;
07202 1DCF           8A46         F7            mov	al,-9[bp]
07203 1DD2           89EC                       mov	sp,bp
07204 1DD4           5D                         pop	bp
07205 1DD5           C3                         ret
07206                                           !BCC_EOS
07207                                           ! 1554     }
07208                                           ! 1555     if ((timeout == 0) || ((time>>11) > timeout)) break;
07209                       00001DD6            .196:
07210                                           ! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
07211 1DD6           8B46         08            mov	ax,8[bp]
07212 1DD9           85C0                       test	ax,ax
07213 1DDB           74           26            je  	.199
07214                       00001DDD            .19A:
07215                                           ! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
07216 1DDD           8B46         08            mov	ax,8[bp]
07217 1DE0           31DB                       xor	bx,bx
07218 1DE2           53                         push	bx
07219 1DE3           50                         push	ax
07220                                           ! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
07221 1DE4           8B46         FC            mov	ax,-4[bp]
07222 1DE7           8B5E         FE            mov	bx,-2[bp]
07223 1DEA           88E0                       mov	al,ah
07224 1DEC           88DC                       mov	ah,bl
07225 1DEE           88FB                       mov	bl,bh
07226 1DF0           28FF                       sub	bh,bh
07227 1DF2           BF                   0003  mov	di,*3
07228 1DF5           E8         E331            call	lsrul
07229                                           ! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
07230 1DF8           8D7E         F2            lea	di,-$E[bp]
07231 1DFB           E8         E2CD            call	lcmpul
07232 1DFE           8D66         F6            lea	sp,-$A[bp]
07233 1E01           76           02            jbe 	.198
07234                       00001E03            .199:
07235 1E03           EB           03            jmp .16F
07236                                           !BCC_EOS
07237                                           ! 1556   }
07238                       00001E05            .198:
07239                                           ! 1557   ;
07240                       00001E05            .170:
07241 1E05           E9         FECF            br 	.171
07242                       00001E08            .16F:
07243                                           !BCC_EOS
07244                                           ! 1558   return status;
07245 1E08           8A46         F7            mov	al,-9[bp]
07246 1E0B           89EC                       mov	sp,bp
07247 1E0D           5D                         pop	bp
07248 1E0E           C3                         ret
07249                                           !BCC_EOS
07250                                           ! 1559 }
07251                                           ! 1560 void ata_detect( )
07252                                           ! Register BX used in function await_ide
07253                                           ! 1561 {
07254                                           export	_ata_detect
07255                       00001E0F            _ata_detect:
07256                                           ! 1562   Bit16u ebda_seg=read_word(0x0040,0x000E);
07257 1E0F           55                         push	bp
07258 1E10           89E5                       mov	bp,sp
07259 1E12           4C                         dec	sp
07260 1E13           4C                         dec	sp
07261                                           ! Debug: list int = const $E (used reg = )
07262 1E14           B8                   000E  mov	ax,*$E
07263 1E17           50                         push	ax
07264                                           ! Debug: list int = const $40 (used reg = )
07265 1E18           B8                   0040  mov	ax,*$40
07266 1E1B           50                         push	ax
07267                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07268 1E1C           E8         E7E8            call	_read_word
07269 1E1F           83C4                   04  add	sp,*4
07270                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
07271 1E22           8946         FE            mov	-2[bp],ax
07272                                           !BCC_EOS
07273                                           ! 1563   Bit8u hdcount, cdcount, device, type;
07274                                           !BCC_EOS
07275                                           ! 1564   Bit8u buffer[0x0200];
07276                                           !BCC_EOS
07277                                           ! 1565   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
07278 1E25           81C4                 FDFC  add	sp,#-$204
07279                                           ! Debug: list int = const 0 (used reg = )
07280 1E29           31C0                       xor	ax,ax
07281 1E2B           50                         push	ax
07282                                           ! Debug: list * unsigned char = const $122 (used reg = )
07283 1E2C           B8                   0122  mov	ax,#$122
07284 1E2F           50                         push	ax
07285                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07286 1E30           FF76         FE            push	-2[bp]
07287                                           ! Debug: func () void = write_byte+0 (used reg = )
07288 1E33           E8         E7E4            call	_write_byte
07289 1E36           83C4                   06  add	sp,*6
07290                                           !BCC_EOS
07291                                           ! 1566   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
07292                                           ! Debug: list int = const $1F0 (used reg = )
07293 1E39           B8                   01F0  mov	ax,#$1F0
07294 1E3C           50                         push	ax
07295                                           ! Debug: list * unsigned short = const $124 (used reg = )
07296 1E3D           B8                   0124  mov	ax,#$124
07297 1E40           50                         push	ax
07298                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07299 1E41           FF76         FE            push	-2[bp]
07300                                           ! Debug: func () void = write_word+0 (used reg = )
07301 1E44           E8         E7EB            call	_write_word
07302 1E47           83C4                   06  add	sp,*6
07303                                           !BCC_EOS
07304                                           ! 1567   write_word(ebda_seg,&((ebda_data
07305                                           ! 1567 _t *) 0)->ata.channels[0].iobase2,0x3f0);
07306                                           ! Debug: list int = const $3F0 (used reg = )
07307 1E4A           B8                   03F0  mov	ax,#$3F0
07308 1E4D           50                         push	ax
07309                                           ! Debug: list * unsigned short = const $126 (used reg = )
07310 1E4E           B8                   0126  mov	ax,#$126
07311 1E51           50                         push	ax
07312                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07313 1E52           FF76         FE            push	-2[bp]
07314                                           ! Debug: func () void = write_word+0 (used reg = )
07315 1E55           E8         E7DA            call	_write_word
07316 1E58           83C4                   06  add	sp,*6
07317                                           !BCC_EOS
07318                                           ! 1568   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
07319                                           ! Debug: list int = const $E (used reg = )
07320 1E5B           B8                   000E  mov	ax,*$E
07321 1E5E           50                         push	ax
07322                                           ! Debug: list * unsigned char = const $128 (used reg = )
07323 1E5F           B8                   0128  mov	ax,#$128
07324 1E62           50                         push	ax
07325                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07326 1E63           FF76         FE            push	-2[bp]
07327                                           ! Debug: func () void = write_byte+0 (used reg = )
07328 1E66           E8         E7B1            call	_write_byte
07329 1E69           83C4                   06  add	sp,*6
07330                                           !BCC_EOS
07331                                           ! 1569   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
07332                                           ! Debug: list int = const 0 (used reg = )
07333 1E6C           31C0                       xor	ax,ax
07334 1E6E           50                         push	ax
07335                                           ! Debug: list * unsigned char = const $12A (used reg = )
07336 1E6F           B8                   012A  mov	ax,#$12A
07337 1E72           50                         push	ax
07338                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07339 1E73           FF76         FE            push	-2[bp]
07340                                           ! Debug: func () void = write_byte+0 (used reg = )
07341 1E76           E8         E7A1            call	_write_byte
07342 1E79           83C4                   06  add	sp,*6
07343                                           !BCC_EOS
07344                                           ! 1570   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
07345                                           ! Debug: list int = const $170 (used reg = )
07346 1E7C           B8                   0170  mov	ax,#$170
07347 1E7F           50                         push	ax
07348                                           ! Debug: list * unsigned short = const $12C (used reg = )
07349 1E80           B8                   012C  mov	ax,#$12C
07350 1E83           50                         push	ax
07351                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07352 1E84           FF76         FE            push	-2[bp]
07353                                           ! Debug: func () void = write_word+0 (used reg = )
07354 1E87           E8         E7A8            call	_write_word
07355 1E8A           83C4                   06  add	sp,*6
07356                                           !BCC_EOS
07357                                           ! 1571   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
07358                                           ! Debug: list int = const $370 (used reg = )
07359 1E8D           B8                   0370  mov	ax,#$370
07360 1E90           50                         push	ax
07361                                           ! Debug: list * unsigned short = const $12E (used reg = )
07362 1E91           B8                   012E  mov	ax,#$12E
07363 1E94           50                         push	ax
07364                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07365 1E95           FF76         FE            push	-2[bp]
07366                                           ! Debug: func () void = write_word+0 (used reg = )
07367 1E98           E8         E797            call	_write_word
07368 1E9B           83C4                   06  add	sp,*6
07369                                           !BCC_EOS
07370                                           ! 1572   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
07371                                           ! Debug: list int = const $F (used reg = )
07372 1E9E           B8                   000F  mov	ax,*$F
07373 1EA1           50                         push	ax
07374                                           ! Debug: list * unsigned char = const $130 (used reg = )
07375 1EA2           B8                   0130  mov	ax,#$130
07376 1EA5           50                         push	ax
07377                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07378 1EA6           FF76         FE            push	-2[bp]
07379                                           ! Debug: func () void = write_byte+0 (used reg = )
07380 1EA9           E8         E76E            call	_write_byte
07381 1EAC           83C4                   06  add	sp,*6
07382                                           !BCC_EOS
07383                                           ! 1573   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
07384                                           ! Debug: list int = const 0 (used reg = )
07385 1EAF           31C0                       xor	ax,ax
07386 1EB1           50                         push	ax
07387                                           ! Debug: list * unsigned char = const $132 (used reg = )
07388 1EB2           B8                   0132  mov	ax,#$132
07389 1EB5           50                         push	ax
07390                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07391 1EB6           FF76         FE            push	-2[bp]
07392                                           ! Debug: func () void = write_byte+0 (used reg = )
07393 1EB9           E8         E75E            call	_write_byte
07394 1EBC           83C4                   06  add	sp,*6
07395                                           !BCC_EOS
07396                                           ! 1574   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
07397                                           ! Debug: list int = const $1E8 (used reg = )
07398 1EBF           B8                   01E8  mov	ax,#$1E8
07399 1EC2           50                         push	ax
07400                                           ! Debug: list * unsigned short = const $134 (used reg = )
07401 1EC3           B8                   0134  mov	ax,#$134
07402 1EC6           50                         push	ax
07403                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07404 1EC7           FF76         FE            push	-2[bp]
07405                                           ! Debug: func () void = write_word+0 (used reg = )
07406 1ECA           E8         E765            call	_write_word
07407 1ECD           83C4                   06  add	sp,*6
07408                                           !BCC_EOS
07409                                           ! 1575   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
07410                                           ! Debug: list int = const $3E0 (used reg = )
07411 1ED0           B8                   03E0  mov	ax,#$3E0
07412 1ED3           50                         push	ax
07413                                           ! Debug: list * unsigned short = const $136 (used reg = )
07414 1ED4           B8                   0136  mov	ax,#$136
07415 1ED7           50                         push	ax
07416                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07417 1ED8           FF76         FE            push	-2[bp]
07418                                           ! Debug: func () void = write_word+0 (used reg = )
07419 1EDB           E8         E754            call	_write_word
07420 1EDE           83C4                   06  add	sp,*6
07421                                           !BCC_EOS
07422                                           ! 1576   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
07423                                           ! Debug: list int = const $C (used reg = )
07424 1EE1           B8                   000C  mov	ax,*$C
07425 1EE4           50                         push	ax
07426                                           ! Debug: list * unsigned char = const $138 (used reg = )
07427 1EE5           B8                   0138  mov	ax,#$138
07428 1EE8           50                         push	ax
07429                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07430 1EE9           FF76         FE            push	-2[bp]
07431                                           ! Debug: func () void = write_byte+0 (used reg = )
07432 1EEC           E8         E72B            call	_write_byte
07433 1EEF           83C4                   06  add	sp,*6
07434                                           !BCC_EOS
07435                                           ! 1577   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
07436                                           ! Debug: list int = const 0 (used reg = )
07437 1EF2           31C0                       xor	ax,ax
07438 1EF4           50                         push	ax
07439                                           ! Debug: list * unsigned char = const $13A (used reg = )
07440 1EF5           B8                   013A  mov	ax,#$13A
07441 1EF8           50                         push	ax
07442                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07443 1EF9           FF76         FE            push	-2[bp]
07444                                           ! Debug: func () void = write_byte+0 (used reg = )
07445 1EFC           E8         E71B            call	_write_byte
07446 1EFF           83C4                   06  add	sp,*6
07447                                           !BCC_EOS
07448                                           ! 1578   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
07449                                           ! Debug: list int = const $168 (used reg = )
07450 1F02           B8                   0168  mov	ax,#$168
07451 1F05           50                         push	ax
07452                                           ! Debug: list * unsigned short = const $13C (used reg = )
07453 1F06           B8                   013C  mov	ax,#$13C
07454 1F09           50                         push	ax
07455                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07456 1F0A           FF76         FE            push	-2[bp]
07457                                           ! Debug: func () void = write_word+0 (used reg = )
07458 1F0D           E8         E722            call	_write_word
07459 1F10           83C4                   06  add	sp,*6
07460                                           !BCC_EOS
07461                                           ! 1579   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
07462                                           ! Debug: list int = const $360 (used reg = )
07463 1F13           B8                   0360  mov	ax,#$360
07464 1F16           50                         push	ax
07465                                           ! Debug: list * unsigned short = const $13E (used reg = )
07466 1F17           B8                   013E  mov	ax,#$13E
07467 1F1A           50                         push	ax
07468                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07469 1F1B           FF76         FE            push	-2[bp]
07470                                           ! Debug: func () void = write_word+0 (used reg = )
07471 1F1E           E8         E711            call	_write_word
07472 1F21           83C4                   06  add	sp,*6
07473                                           !BCC_EOS
07474                                           ! 1580   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
07475                                           ! Debug: list int = const $B (used reg = )
07476 1F24           B8                   000B  mov	ax,*$B
07477 1F27           50                         push	ax
07478                                           ! Debug: list * unsigned char = const $140 (used reg = )
07479 1F28           B8                   0140  mov	ax,#$140
07480 1F2B           50                         push	ax
07481                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
07482 1F2C           FF76         FE            push	-2[bp]
07483                                           ! Debug: func () void = write_byte+0 (used reg = )
07484 1F2F           E8         E6E8            call	_write_byte
07485 1F32           83C4                   06  add	sp,*6
07486                                           !BCC_EOS
07487                                           ! 1581   hdcount=cdcount=0;
07488                                           ! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
07489 1F35           30C0                       xor	al,al
07490 1F37           8846         FC            mov	-4[bp],al
07491                                           ! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
07492 1F3A           8846         FD            mov	-3[bp],al
07493                                           !BCC_EOS
07494                                           ! 1582   for(device=0; device<(4*2); device++) {
07495                                           ! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
07496 1F3D           30C0                       xor	al,al
07497 1F3F           8846         FB            mov	-5[bp],al
07498                                           !BCC_EOS
07499                                           !BCC_EOS
07500 1F42           E9         0D39            br 	.19D
07501                       00001F45            .19E:
07502                                           ! 1583     Bit16u iobase1, iobase2;
07503                                           !BCC_EOS
07504                                           ! 1584     Bit8u channel, slave, shift;
07505                                           !BCC_EOS
07506                                           ! 1585     Bit8u sc, sn, cl, ch, st;
07507                                           !BCC_EOS
07508                                           ! 1586     channel = device / 2;
07509 1F45           83C4                   F4  add	sp,*-$C
07510                                           ! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07511 1F48           8A46         FB            mov	al,-5[bp]
07512 1F4B           30E4                       xor	ah,ah
07513 1F4D           D1E8                       shr	ax,*1
07514                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
07515 1F4F           8886       FDF5            mov	-$20B[bp],al
07516                                           !BCC_EOS
07517                                           ! 1587     slave = device % 2;
07518                                           ! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
07519 1F53           8A46         FB            mov	al,-5[bp]
07520 1F56           30E4                       xor	ah,ah
07521 1F58           24                     01  and	al,*1
07522                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
07523 1F5A           8886       FDF4            mov	-$20C[bp],al
07524                                           !BCC_EOS
07525                                           ! 1588     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
07526                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07527 1F5E           8A86       FDF5            mov	al,-$20B[bp]
07528 1F62           30E4                       xor	ah,ah
07529 1F64           B1                     03  mov	cl,*3
07530 1F66           D3E0                       shl	ax,cl
07531 1F68           89C3                       mov	bx,ax
07532                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
07533                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
07534 1F6A           81C3                 0124  add	bx,#$124
07535 1F6E           53                         push	bx
07536                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07537 1F6F           FF76         FE            push	-2[bp]
07538                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07539 1F72           E8         E692            call	_read_word
07540 1F75           83C4                   04  add	sp,*4
07541                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07542 1F78           8986       FDF8            mov	-$208[bp],ax
07543                                           !BCC_EOS
07544                                           ! 1589     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
07545                                           ! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
07546 1F7C           8A86       FDF5            mov	al,-$20B[bp]
07547 1F80           30E4                       xor	ah,ah
07548 1F82           B1                     03  mov	cl,*3
07549 1F84           D3E0                       shl	ax,cl
07550 1F86           89C3                       mov	bx,ax
07551                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
07552                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
07553 1F88           81C3                 0126  add	bx,#$126
07554 1F8C           53                         push	bx
07555                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07556 1F8D           FF76         FE            push	-2[bp]
07557                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
07558 1F90           E8         E674            call	_read_word
07559 1F93           83C4                   04  add	sp,*4
07560                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
07561 1F96           8986       FDF6            mov	-$20A[bp],ax
07562                                           !BCC_EOS
07563                                           ! 1590     outb(iobase2+6, 0x08 | 0x02);
07564                                           ! Debug: list int = const $A (used reg = )
07565 1F9A           B8                   000A  mov	ax,*$A
07566 1F9D           50                         push	ax
07567                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
07568 1F9E           8B86       FDF6            mov	ax,-$20A[bp]
07569                                           ! Debug: list unsigned int = ax+6 (used reg = )
07570 1FA2           05                   0006  add	ax,*6
07571 1FA5           50                         push	ax
07572                                           ! Debug: func () void = outb+0 (used reg = )
07573 1FA6           E8         E5AB            call	_outb
07574 1FA9           83C4                   04  add	sp,*4
07575                                           !BCC_EOS
07576                                           ! 1591     outb(iobase1+6, slave ? 0xb0 : 0xa0);
07577 1FAC           8A86       FDF4            mov	al,-$20C[bp]
07578 1FB0           84C0                       test	al,al
07579 1FB2           74           04            je  	.19F
07580                       00001FB4            .1A0:
07581 1FB4           B0                     B0  mov	al,#$B0
07582 1FB6           EB           02            jmp .1A1
07583                       00001FB8            .19F:
07584 1FB8           B0                     A0  mov	al,#$A0
07585                       00001FBA            .1A1:
07586                                           ! Debug: list char = al+0 (used reg = )
07587 1FBA           30E4                       xor	ah,ah
07588 1FBC           50                         push	ax
07589                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07590 1FBD           8B86       FDF8            mov	ax,-$208[bp]
07591                                           ! Debug: list unsigned int = ax+6 (used reg = )
07592 1FC1           05                   0006  add	ax,*6
07593 1FC4           50                         push	ax
07594                                           ! Debug: func () void = outb+0 (used reg = )
07595 1FC5           E8         E58C            call	_outb
07596 1FC8           83C4                   04  add	sp,*4
07597                                           !BCC_EOS
07598                                           ! 1592     outb(iobase1+2, 0x55);
07599                                           ! Debug: list int = const $55 (used reg = )
07600 1FCB           B8                   0055  mov	ax,*$55
07601 1FCE           50                         push	ax
07602                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07603 1FCF           8B86       FDF8            mov	ax,-$208[bp]
07604                                           ! Debug: list unsigned int = ax+2 (used reg = )
07605 1FD3           40                         inc	ax
07606 1FD4           40                         inc	ax
07607 1FD5           50                         push	ax
07608                                           ! Debug: func () void = outb+0 (used reg = )
07609 1FD6           E8         E57B            call	_outb
07610 1FD9           83C4                   04  add	sp,*4
07611                                           !BCC_EOS
07612                                           ! 1593     outb(iobase1+3, 0xaa);
07613                                           ! Debug: list int = const $AA (used reg = )
07614 1FDC           B8                   00AA  mov	ax,#$AA
07615 1FDF           50                         push	ax
07616                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07617 1FE0           8B86       FDF8            mov	ax,-$208[bp]
07618                                           ! Debug: list unsigned int = ax+3 (used reg = )
07619 1FE4           05                   0003  add	ax,*3
07620 1FE7           50                         push	ax
07621                                           ! Debug: func () void = outb+0 (used reg = )
07622 1FE8           E8         E569            call	_outb
07623 1FEB           83C4                   04  add	sp,*4
07624                                           !BCC_EOS
07625                                           ! 1594     outb(iobase1+2, 0xaa);
07626                                           ! Debug: list int = const $AA (used reg = )
07627 1FEE           B8                   00AA  mov	ax,#$AA
07628 1FF1           50                         push	ax
07629                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07630 1FF2           8B86       FDF8            mov	ax,-$208[bp]
07631                                           ! Debug: list unsigned int = ax+2 (used reg = )
07632 1FF6           40                         inc	ax
07633 1FF7           40                         inc	ax
07634 1FF8           50                         push	ax
07635                                           ! Debug: func () void = outb+0 (used reg = )
07636 1FF9           E8         E558            call	_outb
07637 1FFC           83C4                   04  add	sp,*4
07638                                           !BCC_EOS
07639                                           ! 1595     outb(iobase1+3, 0x55);
07640                                           ! Debug: list int = const $55 (used reg = )
07641 1FFF           B8                   0055  mov	ax,*$55
07642 2002           50                         push	ax
07643                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07644 2003           8B86       FDF8            mov	ax,-$208[bp]
07645                                           ! Debug: list unsigned int = ax+3 (used reg = )
07646 2007           05                   0003  add	ax,*3
07647 200A           50                         push	ax
07648                                           ! Debug: func () void = outb+0 (used reg = )
07649 200B           E8         E546            call	_outb
07650 200E           83C4                   04  add	sp,*4
07651                                           !BCC_EOS
07652                                           ! 1596     outb(iobase1+2, 0x55);
07653                                           ! Debug: list int = const $55 (used reg = )
07654 2011           B8                   0055  mov	ax,*$55
07655 2014           50                         push	ax
07656                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07657 2015           8B86       FDF8            mov	ax,-$208[bp]
07658                                           ! Debug: list unsigned int = ax+2 (used reg = )
07659 2019           40                         inc	ax
07660 201A           40                         inc	ax
07661 201B           50                         push	ax
07662                                           ! Debug: func () void = outb+0 (used reg = )
07663 201C           E8         E535            call	_outb
07664 201F           83C4                   04  add	sp,*4
07665                                           !BCC_EOS
07666                                           ! 1597     outb(iobase1+3, 0xaa);
07667                                           ! Debug: list int = const $AA (used reg = )
07668 2022           B8                   00AA  mov	ax,#$AA
07669 2025           50                         push	ax
07670                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07671 2026           8B86       FDF8            mov	ax,-$208[bp]
07672                                           ! Debug: list unsigned int = ax+3 (used reg = )
07673 202A           05                   0003  add	ax,*3
07674 202D           50                         push	ax
07675                                           ! Debug: func () void = outb+0 (used reg = )
07676 202E           E8         E523            call	_outb
07677 2031           83C4                   04  add	sp,*4
07678                                           !BCC_EOS
07679                                           ! 1598     sc = inb(iobase1+2);
07680                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07681 2034           8B86       FDF8            mov	ax,-$208[bp]
07682                                           ! Debug: list unsigned int = ax+2 (used reg = )
07683 2038           40                         inc	ax
07684 2039           40                         inc	ax
07685 203A           50                         push	ax
07686                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07687 203B           E8         E500            call	_inb
07688 203E           44                         inc	sp
07689 203F           44                         inc	sp
07690                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07691 2040           8886       FDF2            mov	-$20E[bp],al
07692                                           !BCC_EOS
07693                                           ! 1599     sn = inb(iobase1+3);
07694                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07695 2044           8B86       FDF8            mov	ax,-$208[bp]
07696                                           ! Debug: list unsigned int = ax+3 (used reg = )
07697 2048           05                   0003  add	ax,*3
07698 204B           50                         push	ax
07699                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07700 204C           E8         E4EF            call	_inb
07701 204F           44                         inc	sp
07702 2050           44                         inc	sp
07703                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07704 2051           8886       FDF1            mov	-$20F[bp],al
07705                                           !BCC_EOS
07706                                           ! 1600     if ( (sc == 0x55) && (sn == 0xaa) ) {
07707                                           ! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
07708 2055           8A86       FDF2            mov	al,-$20E[bp]
07709 2059           3C                     55  cmp	al,*$55
07710 205B         0F85         014F            bne 	.1A2
07711                       0000205F            .1A4:
07712                                           ! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
07713 205F           8A86       FDF1            mov	al,-$20F[bp]
07714 2063           3C                     AA  cmp	al,#$AA
07715 2065         0F85         0145            bne 	.1A2
07716                       00002069            .1A3:
07717                                           ! 1601       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
07718                                           ! Debug: list int = const 1 (used reg = )
07719 2069           B8                   0001  mov	ax,*1
07720 206C           50                         push	ax
07721                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07722 206D           8A46         FB            mov	al,-5[bp]
07723 2070           30E4                       xor	ah,ah
07724 2072           B9                   001E  mov	cx,*$1E
07725 2075           F7E9                       imul	cx
07726 2077           89C3                       mov	bx,ax
07727                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07728                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07729 2079           81C3                 0142  add	bx,#$142
07730 207D           53                         push	bx
07731                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07732 207E           FF76         FE            push	-2[bp]
07733                                           ! Debug: func () void = write_byte+0 (used reg = )
07734 2081           E8         E596            call	_write_byte
07735 2084           83C4                   06  add	sp,*6
07736                                           !BCC_EOS
07737                                           ! 1602       ata_reset(device);
07738                                           ! Debug: list unsigned char device = [S+$214-7] (used reg = )
07739 2087           8A46         FB            mov	al,-5[bp]
07740 208A           30E4                       xor	ah,ah
07741 208C           50                         push	ax
07742                                           ! Debug: func () void = ata_reset+0 (used reg = )
07743 208D           E8         0C43            call	_ata_reset
07744 2090           44                         inc	sp
07745 2091           44                         inc	sp
07746                                           !BCC_EOS
07747                                           ! 1603       outb(iobase1+6, slave ? 0xb0 : 0xa0);
07748 2092           8A86       FDF4            mov	al,-$20C[bp]
07749 2096           84C0                       test	al,al
07750 2098           74           04            je  	.1A5
07751                       0000209A            .1A6:
07752 209A           B0                     B0  mov	al,#$B0
07753 209C           EB           02            jmp .1A7
07754                       0000209E            .1A5:
07755 209E           B0                     A0  mov	al,#$A0
07756                       000020A0            .1A7:
07757                                           ! Debug: list char = al+0 (used reg = )
07758 20A0           30E4                       xor	ah,ah
07759 20A2           50                         push	ax
07760                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
07761 20A3           8B86       FDF8            mov	ax,-$208[bp]
07762                                           ! Debug: list unsigned int = ax+6 (used reg = )
07763 20A7           05                   0006  add	ax,*6
07764 20AA           50                         push	ax
07765                                           ! Debug: func () void = outb+0 (used reg = )
07766 20AB           E8         E4A6            call	_outb
07767 20AE           83C4                   04  add	sp,*4
07768                                           !BCC_EOS
07769                                           ! 1604       sc = inb(iobase1+2);
07770                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07771 20B1           8B86       FDF8            mov	ax,-$208[bp]
07772                                           ! Debug: list unsigned int = ax+2 (used reg = )
07773 20B5           40                         inc	ax
07774 20B6           40                         inc	ax
07775 20B7           50                         push	ax
07776                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07777 20B8           E8         E483            call	_inb
07778 20BB           44                         inc	sp
07779 20BC           44                         inc	sp
07780                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
07781 20BD           8886       FDF2            mov	-$20E[bp],al
07782                                           !BCC_EOS
07783                                           ! 1605       sn = inb(iobase1+3);
07784                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07785 20C1           8B86       FDF8            mov	ax,-$208[bp]
07786                                           ! Debug: list unsigned int = ax+3 (used reg = )
07787 20C5           05                   0003  add	ax,*3
07788 20C8           50                         push	ax
07789                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07790 20C9           E8         E472            call	_inb
07791 20CC           44                         inc	sp
07792 20CD           44                         inc	sp
07793                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
07794 20CE           8886       FDF1            mov	-$20F[bp],al
07795                                           !BCC_EOS
07796                                           ! 1606       if ((sc==0x01) && (sn==0x01)) {
07797                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
07798 20D2           8A86       FDF2            mov	al,-$20E[bp]
07799 20D6           3C                     01  cmp	al,*1
07800 20D8         0F85         00D2            bne 	.1A8
07801                       000020DC            .1AA:
07802                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
07803 20DC           8A86       FDF1            mov	al,-$20F[bp]
07804 20E0           3C                     01  cmp	al,*1
07805 20E2         0F85         00C8            bne 	.1A8
07806                       000020E6            .1A9:
07807                                           ! 1607         cl = inb(iobase1+4);
07808                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07809 20E6           8B86       FDF8            mov	ax,-$208[bp]
07810                                           ! Debug: list unsigned int = ax+4 (used reg = )
07811 20EA           05                   0004  add	ax,*4
07812 20ED           50                         push	ax
07813                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07814 20EE           E8         E44D            call	_inb
07815 20F1           44                         inc	sp
07816 20F2           44                         inc	sp
07817                                           ! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
07818 20F3           8886       FDF0            mov	-$210[bp],al
07819                                           !BCC_EOS
07820                                           ! 1608         ch = inb(iobase1+5);
07821                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07822 20F7           8B86       FDF8            mov	ax,-$208[bp]
07823                                           ! Debug: list unsigned int = ax+5 (used reg = )
07824 20FB           05                   0005  add	ax,*5
07825 20FE           50                         push	ax
07826                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07827 20FF           E8         E43C            call	_inb
07828 2102           44                         inc	sp
07829 2103           44                         inc	sp
07830                                           ! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
07831 2104           8886       FDEF            mov	-$211[bp],al
07832                                           !BCC_EOS
07833                                           ! 1609         st = inb(iobase1+7);
07834                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
07835 2108           8B86       FDF8            mov	ax,-$208[bp]
07836                                           ! Debug: list unsigned int = ax+7 (used reg = )
07837 210C           05                   0007  add	ax,*7
07838 210F           50                         push	ax
07839                                           ! Debug: func () unsigned char = inb+0 (used reg = )
07840 2110           E8         E42B            call	_inb
07841 2113           44                         inc	sp
07842 2114           44                         inc	sp
07843                                           ! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
07844 2115           8886       FDEE            mov	-$212[bp],al
07845                                           !BCC_EOS
07846                                           ! 1610         if ((cl==0x1
07847                                           ! 1610 4) && (ch==0xeb)) {
07848                                           ! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
07849 2119           8A86       FDF0            mov	al,-$210[bp]
07850 211D           3C                     14  cmp	al,*$14
07851 211F           75           28            jne 	.1AB
07852                       00002121            .1AD:
07853                                           ! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
07854 2121           8A86       FDEF            mov	al,-$211[bp]
07855 2125           3C                     EB  cmp	al,#$EB
07856 2127           75           20            jne 	.1AB
07857                       00002129            .1AC:
07858                                           ! 1611           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
07859                                           ! Debug: list int = const 3 (used reg = )
07860 2129           B8                   0003  mov	ax,*3
07861 212C           50                         push	ax
07862                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07863 212D           8A46         FB            mov	al,-5[bp]
07864 2130           30E4                       xor	ah,ah
07865 2132           B9                   001E  mov	cx,*$1E
07866 2135           F7E9                       imul	cx
07867 2137           89C3                       mov	bx,ax
07868                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07869                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07870 2139           81C3                 0142  add	bx,#$142
07871 213D           53                         push	bx
07872                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07873 213E           FF76         FE            push	-2[bp]
07874                                           ! Debug: func () void = write_byte+0 (used reg = )
07875 2141           E8         E4D6            call	_write_byte
07876 2144           83C4                   06  add	sp,*6
07877                                           !BCC_EOS
07878                                           ! 1612         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
07879 2147           EB           65            jmp .1AE
07880                       00002149            .1AB:
07881                                           ! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
07882 2149           8A86       FDF0            mov	al,-$210[bp]
07883 214D           84C0                       test	al,al
07884 214F           75           30            jne 	.1AF
07885                       00002151            .1B2:
07886                                           ! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
07887 2151           8A86       FDEF            mov	al,-$211[bp]
07888 2155           84C0                       test	al,al
07889 2157           75           28            jne 	.1AF
07890                       00002159            .1B1:
07891                                           ! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
07892 2159           8A86       FDEE            mov	al,-$212[bp]
07893 215D           84C0                       test	al,al
07894 215F           74           20            je  	.1AF
07895                       00002161            .1B0:
07896                                           ! 1613           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
07897                                           ! Debug: list int = const 2 (used reg = )
07898 2161           B8                   0002  mov	ax,*2
07899 2164           50                         push	ax
07900                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07901 2165           8A46         FB            mov	al,-5[bp]
07902 2168           30E4                       xor	ah,ah
07903 216A           B9                   001E  mov	cx,*$1E
07904 216D           F7E9                       imul	cx
07905 216F           89C3                       mov	bx,ax
07906                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07907                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07908 2171           81C3                 0142  add	bx,#$142
07909 2175           53                         push	bx
07910                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07911 2176           FF76         FE            push	-2[bp]
07912                                           ! Debug: func () void = write_byte+0 (used reg = )
07913 2179           E8         E49E            call	_write_byte
07914 217C           83C4                   06  add	sp,*6
07915                                           !BCC_EOS
07916                                           ! 1614         } else if ((cl==0xff) && (ch==0xff)) {
07917 217F           EB           2D            jmp .1B3
07918                       00002181            .1AF:
07919                                           ! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
07920 2181           8A86       FDF0            mov	al,-$210[bp]
07921 2185           3C                     FF  cmp	al,#$FF
07922 2187           75           25            jne 	.1B4
07923                       00002189            .1B6:
07924                                           ! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
07925 2189           8A86       FDEF            mov	al,-$211[bp]
07926 218D           3C                     FF  cmp	al,#$FF
07927 218F           75           1D            jne 	.1B4
07928                       00002191            .1B5:
07929                                           ! 1615           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
07930                                           ! Debug: list int = const 0 (used reg = )
07931 2191           31C0                       xor	ax,ax
07932 2193           50                         push	ax
07933                                           ! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
07934 2194           8A46         FB            mov	al,-5[bp]
07935 2197           30E4                       xor	ah,ah
07936 2199           B9                   001E  mov	cx,*$1E
07937 219C           F7E9                       imul	cx
07938 219E           89C3                       mov	bx,ax
07939                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07940                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07941 21A0           81C3                 0142  add	bx,#$142
07942 21A4           53                         push	bx
07943                                           ! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
07944 21A5           FF76         FE            push	-2[bp]
07945                                           ! Debug: func () void = write_byte+0 (used reg = )
07946 21A8           E8         E46F            call	_write_byte
07947 21AB           83C4                   06  add	sp,*6
07948                                           !BCC_EOS
07949                                           ! 1616         }
07950                                           ! 1617       }
07951                       000021AE            .1B4:
07952                       000021AE            .1B3:
07953                       000021AE            .1AE:
07954                                           ! 1618     }
07955                       000021AE            .1A8:
07956                                           ! 1619     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
07957                       000021AE            .1A2:
07958                                           ! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
07959 21AE           8A46         FB            mov	al,-5[bp]
07960 21B1           30E4                       xor	ah,ah
07961 21B3           B9                   001E  mov	cx,*$1E
07962 21B6           F7E9                       imul	cx
07963 21B8           89C3                       mov	bx,ax
07964                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
07965                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
07966 21BA           81C3                 0142  add	bx,#$142
07967 21BE           53                         push	bx
07968                                           ! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
07969 21BF           FF76         FE            push	-2[bp]
07970                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
07971 21C2           E8         E42F            call	_read_byte
07972 21C5           83C4                   04  add	sp,*4
07973                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
07974 21C8           8846         FA            mov	-6[bp],al
07975                                           !BCC_EOS
07976                                           ! 1620     if(type == 0x02) {
07977                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
07978 21CB           8A46         FA            mov	al,-6[bp]
07979 21CE           3C                     02  cmp	al,*2
07980 21D0         0F85         0535            bne 	.1B7
07981                       000021D4            .1B8:
07982                                           ! 1621       Bit32u sectors_low, sectors_high;
07983                                           !BCC_EOS
07984                                           ! 1622       Bit16u cylinders, heads, spt, blksize;
07985                                           !BCC_EOS
07986                                           ! 1623       Bit8u translation, removable, mode;
07987                                           !BCC_EOS
07988                                           ! 1624       mode = 0x00;
07989 21D4           83C4                   EC  add	sp,*-$14
07990                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$228-$227] (used reg = )
07991 21D7           30C0                       xor	al,al
07992 21D9           8886       FDDB            mov	-$225[bp],al
07993                                           !BCC_EOS
07994                                           ! 1625       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
07995                                           ! Debug: list int = const $FF (used reg = )
07996 21DD           B8                   00FF  mov	ax,#$FF
07997 21E0           50                         push	ax
07998                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
07999 21E1           8A46         FB            mov	al,-5[bp]
08000 21E4           30E4                       xor	ah,ah
08001 21E6           B9                   001E  mov	cx,*$1E
08002 21E9           F7E9                       imul	cx
08003 21EB           89C3                       mov	bx,ax
08004                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08005                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08006 21ED           81C3                 0143  add	bx,#$143
08007 21F1           53                         push	bx
08008                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08009 21F2           FF76         FE            push	-2[bp]
08010                                           ! Debug: func () void = write_byte+0 (used reg = )
08011 21F5           E8         E422            call	_write_byte
08012 21F8           83C4                   06  add	sp,*6
08013                                           !BCC_EOS
08014                                           ! 1626       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08015                                           ! Debug: list int = const 0 (used reg = )
08016 21FB           31C0                       xor	ax,ax
08017 21FD           50                         push	ax
08018                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08019 21FE           8A46         FB            mov	al,-5[bp]
08020 2201           30E4                       xor	ah,ah
08021 2203           B9                   001E  mov	cx,*$1E
08022 2206           F7E9                       imul	cx
08023 2208           89C3                       mov	bx,ax
08024                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08025                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08026 220A           81C3                 0146  add	bx,#$146
08027 220E           53                         push	bx
08028                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08029 220F           FF76         FE            push	-2[bp]
08030                                           ! Debug: func () void = write_byte+0 (used reg = )
08031 2212           E8         E405            call	_write_byte
08032 2215           83C4                   06  add	sp,*6
08033                                           !BCC_EOS
08034                                           ! 1627       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
08035                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08036 2218           8D9E       FDFA            lea	bx,-$206[bp]
08037 221C           53                         push	bx
08038                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08039 221D           E8         E42D            call	_get_SS
08040                                           ! Debug: list unsigned short = ax+0 (used reg = )
08041 2220           50                         push	ax
08042                                           ! Debug: list long = const 0 (used reg = )
08043 2221           31C0                       xor	ax,ax
08044 2223           31DB                       xor	bx,bx
08045 2225           53                         push	bx
08046 2226           50                         push	ax
08047                                           ! Debug: list long = const 0 (used reg = )
08048 2227           31C0                       xor	ax,ax
08049 2229           31DB                       xor	bx,bx
08050 222B           53                         push	bx
08051 222C           50                         push	ax
08052                                           ! Debug: list int = const 0 (used reg = )
08053 222D           31C0                       xor	ax,ax
08054 222F           50                         push	ax
08055                                           ! Debug: list int = const 0 (used reg = )
08056 2230           31C0                       xor	ax,ax
08057 2232           50                         push	ax
08058                                           ! Debug: list int = const 0 (used reg = )
08059 2233           31C0                       xor	ax,ax
08060 2235           50                         push	ax
08061                                           ! Debug: list int = const 1 (used reg = )
08062 2236           B8                   0001  mov	ax,*1
08063 2239           50                         push	ax
08064                                           ! Debug: list int = const $EC (used reg = )
08065 223A           B8                   00EC  mov	ax,#$EC
08066 223D           50                         push	ax
08067                                           ! Debug: list unsigned char device = [S+$23E-7] (used reg = )
08068 223E           8A46         FB            mov	al,-5[bp]
08069 2241           30E4                       xor	ah,ah
08070 2243           50                         push	ax
08071                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08072 2244           E8         0BE0            call	_ata_cmd_data_in
08073 2247           83C4                   18  add	sp,*$18
08074                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
08075 224A           85C0                       test	ax,ax
08076 224C           74           0E            je  	.1B9
08077                       0000224E            .1BA:
08078                                           ! 1628         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
08079                                           ! Debug: list * char = .1BB+0 (used reg = )
08080 224E           BB                   D459  mov	bx,#.1BB
08081 2251           53                         push	bx
08082                                           ! Debug: list int = const 7 (used reg = )
08083 2252           B8                   0007  mov	ax,*7
08084 2255           50                         push	ax
08085                                           ! Debug: func () void = bios_printf+0 (used reg = )
08086 2256           E8         E7C2            call	_bios_printf
08087 2259           83C4                   04  add	sp,*4
08088                                           !BCC_EOS
08089                                           ! 1629       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
08090                       0000225C            .1B9:
08091                                           ! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
08092 225C           8D9E       FDFA            lea	bx,-$206[bp]
08093 2260           53                         push	bx
08094                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08095 2261           E8         E3E9            call	_get_SS
08096                                           ! Debug: list unsigned short = ax+0 (used reg = )
08097 2264           50                         push	ax
08098                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08099 2265           E8         E38C            call	_read_byte
08100 2268           83C4                   04  add	sp,*4
08101                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
08102 226B           24                     80  and	al,#$80
08103 226D           84C0                       test	al,al
08104 226F           74           04            je  	.1BC
08105                       00002271            .1BD:
08106 2271           B0                     01  mov	al,*1
08107 2273           EB           02            jmp .1BE
08108                       00002275            .1BC:
08109 2275           30C0                       xor	al,al
08110                       00002277            .1BE:
08111                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
08112 2277           8886       FDDC            mov	-$224[bp],al
08113                                           !BCC_EOS
08114                                           ! 1630       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
08115                                           ! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
08116 227B           8D9E       FE5A            lea	bx,-$1A6[bp]
08117 227F           53                         push	bx
08118                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08119 2280           E8         E3CA            call	_get_SS
08120                                           ! Debug: list unsigned short = ax+0 (used reg = )
08121 2283           50                         push	ax
08122                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
08123 2284           E8         E36D            call	_read_byte
08124 2287           83C4                   04  add	sp,*4
08125 228A           84C0                       test	al,al
08126 228C           74           04            je  	.1BF
08127                       0000228E            .1C0:
08128 228E           B0                     01  mov	al,*1
08129 2290           EB           02            jmp .1C1
08130                       00002292            .1BF:
08131 2292           30C0                       xor	al,al
08132                       00002294            .1C1:
08133                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
08134 2294           8886       FDDB            mov	-$225[bp],al
08135                                           !BCC_EOS
08136                                           ! 1631       blksize = read_word(get_SS(),buffer+10);
08137                                           ! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
08138 2298           8D9E       FE04            lea	bx,-$1FC[bp]
08139 229C           53                         push	bx
08140                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08141 229D           E8         E3AD            call	_get_SS
08142                                           ! Debug: list unsigned short = ax+0 (used reg = )
08143 22A0           50                         push	ax
08144                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08145 22A1           E8         E363            call	_read_word
08146 22A4           83C4                   04  add	sp,*4
08147                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
08148 22A7           8986       FDDE            mov	-$222[bp],ax
08149                                           !BCC_EOS
08150                                           ! 1632       cylinders = read_word(get_SS(),buffer+(1*2));
08151                                           ! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
08152 22AB           8D9E       FDFC            lea	bx,-$204[bp]
08153 22AF           53                         push	bx
08154                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08155 22B0           E8         E39A            call	_get_SS
08156                                           ! Debug: list unsigned short = ax+0 (used reg = )
08157 22B3           50                         push	ax
08158                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08159 22B4           E8         E350            call	_read_word
08160 22B7           83C4                   04  add	sp,*4
08161                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08162 22BA           8986       FDE4            mov	-$21C[bp],ax
08163                                           !BCC_EOS
08164                                           ! 1633       heads = read_word(get_SS(),buffer+(3*2));
08165                                           ! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
08166 22BE           8D9E       FE00            lea	bx,-$200[bp]
08167 22C2           53                         push	bx
08168                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08169 22C3           E8         E387            call	_get_SS
08170                                           ! Debug: list unsigned short = ax+0 (used reg = )
08171 22C6           50                         push	ax
08172                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08173 22C7           E8         E33D            call	_read_word
08174 22CA           83C4                   04  add	sp,*4
08175                                           ! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
08176 22CD           8986       FDE2            mov	-$21E[bp],ax
08177                                           !BCC_EOS
08178                                           ! 1634       spt = read_word(get_SS(),buffer+(6*2));
08179                                           ! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
08180 22D1           8D9E       FE06            lea	bx,-$1FA[bp]
08181 22D5           53                         push	bx
08182                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08183 22D6           E8         E374            call	_get_SS
08184                                           ! Debug: list unsigned short = ax+0 (used reg = )
08185 22D9           50                         push	ax
08186                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08187 22DA           E8         E32A            call	_read_word
08188 22DD           83C4                   04  add	sp,*4
08189                                           ! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
08190 22E0           8986       FDE0            mov	-$220[bp],ax
08191                                           !BCC_EOS
08192                                           ! 1635       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
08193                                           ! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
08194 22E4           8D9E       FEA0            lea	bx,-$160[bp]
08195 22E8           53                         push	bx
08196                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08197 22E9           E8         E361            call	_get_SS
08198                                           ! Debug: list unsigned short = ax+0 (used reg = )
08199 22EC           50                         push	ax
08200                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
08201 22ED           E8         E317            call	_read_word
08202 22F0           83C4                   04  add	sp,*4
08203                                           ! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
08204 22F3           25                   0400  and	ax,#$400
08205 22F6           85C0                       test	ax,ax
08206 22F8           74           34            je  	.1C2
08207                       000022FA            .1C3:
08208                                           ! 1636         sectors_low = read_dword(get_SS(),buffer+(100*2));
08209                                           ! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
08210 22FA           8D9E       FEC2            lea	bx,-$13E[bp]
08211 22FE           53                         push	bx
08212                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08213 22FF           E8         E34B            call	_get_SS
08214                                           ! Debug: list unsigned short = ax+0 (used reg = )
08215 2302           50                         push	ax
08216                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08217 2303           E8         DD7D            call	_read_dword
08218 2306           89D3                       mov	bx,dx
08219 2308           83C4                   04  add	sp,*4
08220                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08221 230B           8986       FDEA            mov	-$216[bp],ax
08222 230F           899E       FDEC            mov	-$214[bp],bx
08223                                           !BCC_EOS
08224                                           ! 1637         sectors_high = read_dword(get_SS(),buffer+(102*2));
08225                                           ! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
08226 2313           8D9E       FEC6            lea	bx,-$13A[bp]
08227 2317           53                         push	bx
08228                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08229 2318           E8         E332            call	_get_SS
08230                                           ! Debug: list unsigned short = ax+0 (used reg = )
08231 231B           50                         push	ax
08232                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08233 231C           E8         DD64            call	_read_dword
08234 231F           89D3                       mov	bx,dx
08235 2321           83C4                   04  add	sp,*4
08236                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08237 2324           8986       FDE6            mov	-$21A[bp],ax
08238 2328           899E       FDE8            mov	-$218[bp],bx
08239                                           !BCC_EOS
08240                                           ! 1638       } else {
08241 232C           EB           25            jmp .1C4
08242                       0000232E            .1C2:
08243                                           ! 1639         sectors_low = read_dword(get_SS(),buffer+(60*2));
08244                                           ! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
08245 232E           8D9E       FE72            lea	bx,-$18E[bp]
08246 2332           53                         push	bx
08247                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08248 2333           E8         E317            call	_get_SS
08249                                           ! Debug: list unsigned short = ax+0 (used reg = )
08250 2336           50                         push	ax
08251                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
08252 2337           E8         DD49            call	_read_dword
08253 233A           89D3                       mov	bx,dx
08254 233C           83C4                   04  add	sp,*4
08255                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08256 233F           8986       FDEA            mov	-$216[bp],ax
08257 2343           899E       FDEC            mov	-$214[bp],bx
08258                                           !BCC_EOS
08259                                           ! 1640         sectors_high = 0;
08260                                           ! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
08261 2347           31C0                       xor	ax,ax
08262 2349           31DB                       xor	bx,bx
08263 234B           8986       FDE6            mov	-$21A[bp],ax
08264 234F           899E       FDE8            mov	-$218[bp],bx
08265                                           !BCC_EOS
08266                                           ! 1641       }
08267                                           ! 1642       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
08268                       00002353            .1C4:
08269                                           ! Debug: list int = const $FF (used reg = )
08270 2353           B8                   00FF  mov	ax,#$FF
08271 2356           50                         push	ax
08272                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08273 2357           8A46         FB            mov	al,-5[bp]
08274 235A           30E4                       xor	ah,ah
08275 235C           B9                   001E  mov	cx,*$1E
08276 235F           F7E9                       imul	cx
08277 2361           89C3                       mov	bx,ax
08278                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08279                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08280 2363           81C3                 0143  add	bx,#$143
08281 2367           53                         push	bx
08282                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08283 2368           FF76         FE            push	-2[bp]
08284                                           ! Debug: func () void = write_byte+0 (used reg = )
08285 236B           E8         E2AC            call	_write_byte
08286 236E           83C4                   06  add	sp,*6
08287                                           !BCC_EOS
08288                                           ! 1643       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
08289                                           ! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
08290 2371           8A86       FDDC            mov	al,-$224[bp]
08291 2375           30E4                       xor	ah,ah
08292 2377           50                         push	ax
08293                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08294 2378           8A46         FB            mov	al,-5[bp]
08295 237B           30E4                       xor	ah,ah
08296 237D           B9                   001E  mov	cx,*$1E
08297 2380           F7E9                       imul	cx
08298 2382           89C3                       mov	bx,ax
08299                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
08300                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
08301 2384           81C3                 0144  add	bx,#$144
08302 2388           53                         push	bx
08303                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08304 2389           FF76         FE            push	-2[bp]
08305                                           ! Debug: func () void = write_byte+0 (used reg = )
08306 238C           E8         E28B            call	_write_byte
08307 238F           83C4                   06  add	sp,*6
08308                                           !BCC_EOS
08309                                           ! 1644       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
08310                                           ! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
08311 2392           8A86       FDDB            mov	al,-$225[bp]
08312 2396           30E4                       xor	ah,ah
08313 2398           50                         push	ax
08314                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08315 2399           8A46         FB            mov	al,-5[bp]
08316 239C           30E4                       xor	ah,ah
08317 239E           B9                   001E  mov	cx,*$1E
08318 23A1           F7E9                       imul	cx
08319 23A3           89C3                       mov	bx,ax
08320                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08321                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08322 23A5           81C3                 0146  add	bx,#$146
08323 23A9           53                         push	bx
08324                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08325 23AA           FF76         FE            push	-2[bp]
08326                                           ! Debug: func () void = write_byte+0 (used reg = )
08327 23AD           E8         E26A            call	_write_byte
08328 23B0           83C4                   06  add	sp,*6
08329                                           !BCC_EOS
08330                                           ! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
08331                                           ! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
08332 23B3           FFB6       FDDE            push	-$222[bp]
08333                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08334 23B7           8A46         FB            mov	al,-5[bp]
08335 23BA           30E4                       xor	ah,ah
08336 23BC           B9                   001E  mov	cx,*$1E
08337 23BF           F7E9                       imul	cx
08338 23C1           89C3                       mov	bx,ax
08339                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
08340                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
08341 23C3           81C3                 0148  add	bx,#$148
08342 23C7           53                         push	bx
08343                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08344 23C8           FF76         FE            push	-2[bp]
08345                                           ! Debug: func () void = write_word+0 (used reg = )
08346 23CB           E8         E264            call	_write_word
08347 23CE           83C4                   06  add	sp,*6
08348                                           !BCC_EOS
08349                                           ! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
08350                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08351 23D1           FFB6       FDE2            push	-$21E[bp]
08352                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08353 23D5           8A46         FB            mov	al,-5[bp]
08354 23D8           30E4                       xor	ah,ah
08355 23DA           B9                   001E  mov	cx,*$1E
08356 23DD           F7E9                       imul	cx
08357 23DF           89C3                       mov	bx,ax
08358                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
08359                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
08360 23E1           81C3                 0152  add	bx,#$152
08361 23E5           53                         push	bx
08362                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08363 23E6           FF76         FE            push	-2[bp]
08364                                           ! Debug: func () void = write_word+0 (used reg = )
08365 23E9           E8         E246            call	_write_word
08366 23EC           83C4                   06  add	sp,*6
08367                                           !BCC_EOS
08368                                           ! 1647       write_word(ebda_seg,&((ebda_data_t *) 
08369                                           ! 1647 0)->ata.devices[device].pchs.cylinders, cylinders);
08370                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08371 23EF           FFB6       FDE4            push	-$21C[bp]
08372                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08373 23F3           8A46         FB            mov	al,-5[bp]
08374 23F6           30E4                       xor	ah,ah
08375 23F8           B9                   001E  mov	cx,*$1E
08376 23FB           F7E9                       imul	cx
08377 23FD           89C3                       mov	bx,ax
08378                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
08379                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
08380 23FF           81C3                 0154  add	bx,#$154
08381 2403           53                         push	bx
08382                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08383 2404           FF76         FE            push	-2[bp]
08384                                           ! Debug: func () void = write_word+0 (used reg = )
08385 2407           E8         E228            call	_write_word
08386 240A           83C4                   06  add	sp,*6
08387                                           !BCC_EOS
08388                                           ! 1648       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
08389                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08390 240D           FFB6       FDE0            push	-$220[bp]
08391                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08392 2411           8A46         FB            mov	al,-5[bp]
08393 2414           30E4                       xor	ah,ah
08394 2416           B9                   001E  mov	cx,*$1E
08395 2419           F7E9                       imul	cx
08396 241B           89C3                       mov	bx,ax
08397                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
08398                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
08399 241D           81C3                 0156  add	bx,#$156
08400 2421           53                         push	bx
08401                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08402 2422           FF76         FE            push	-2[bp]
08403                                           ! Debug: func () void = write_word+0 (used reg = )
08404 2425           E8         E20A            call	_write_word
08405 2428           83C4                   06  add	sp,*6
08406                                           !BCC_EOS
08407                                           ! 1649       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
08408                                           ! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
08409 242B           FFB6       FDEC            push	-$214[bp]
08410 242F           FFB6       FDEA            push	-$216[bp]
08411                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08412 2433           8A46         FB            mov	al,-5[bp]
08413 2436           30E4                       xor	ah,ah
08414 2438           B9                   001E  mov	cx,*$1E
08415 243B           F7E9                       imul	cx
08416 243D           89C3                       mov	bx,ax
08417                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
08418                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
08419 243F           81C3                 0158  add	bx,#$158
08420 2443           53                         push	bx
08421                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08422 2444           FF76         FE            push	-2[bp]
08423                                           ! Debug: func () void = write_dword+0 (used reg = )
08424 2447           E8         DC51            call	_write_dword
08425 244A           83C4                   08  add	sp,*8
08426                                           !BCC_EOS
08427                                           ! 1650       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
08428                                           ! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
08429 244D           FFB6       FDE8            push	-$218[bp]
08430 2451           FFB6       FDE6            push	-$21A[bp]
08431                                           ! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
08432 2455           8A46         FB            mov	al,-5[bp]
08433 2458           30E4                       xor	ah,ah
08434 245A           B9                   001E  mov	cx,*$1E
08435 245D           F7E9                       imul	cx
08436 245F           89C3                       mov	bx,ax
08437                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
08438                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
08439 2461           81C3                 015C  add	bx,#$15C
08440 2465           53                         push	bx
08441                                           ! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
08442 2466           FF76         FE            push	-2[bp]
08443                                           ! Debug: func () void = write_dword+0 (used reg = )
08444 2469           E8         DC2F            call	_write_dword
08445 246C           83C4                   08  add	sp,*8
08446                                           !BCC_EOS
08447                                           ! 1651       ;
08448                                           !BCC_EOS
08449                                           ! 1652       translation = inb_cmos(0x39 + channel/2);
08450                                           ! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
08451 246F           8A86       FDF5            mov	al,-$20B[bp]
08452 2473           30E4                       xor	ah,ah
08453 2475           D1E8                       shr	ax,*1
08454                                           ! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
08455                                           ! Debug: expression subtree swapping
08456                                           ! Debug: list unsigned int = ax+$39 (used reg = )
08457 2477           05                   0039  add	ax,*$39
08458 247A           50                         push	ax
08459                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
08460 247B           E8         E105            call	_inb_cmos
08461 247E           44                         inc	sp
08462 247F           44                         inc	sp
08463                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
08464 2480           8886       FDDD            mov	-$223[bp],al
08465                                           !BCC_EOS
08466                                           ! 1653       for (shift=device%4; shift>0; shift--) translation >>= 2;
08467                                           ! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
08468 2484           8A46         FB            mov	al,-5[bp]
08469 2487           30E4                       xor	ah,ah
08470 2489           24                     03  and	al,*3
08471                                           ! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
08472 248B           8886       FDF3            mov	-$20D[bp],al
08473                                           !BCC_EOS
08474                                           !BCC_EOS
08475 248F           EB           17            jmp .1C7
08476                       00002491            .1C8:
08477                                           ! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
08478 2491           8A86       FDDD            mov	al,-$223[bp]
08479 2495           30E4                       xor	ah,ah
08480 2497           D1E8                       shr	ax,*1
08481 2499           D1E8                       shr	ax,*1
08482 249B           8886       FDDD            mov	-$223[bp],al
08483                                           !BCC_EOS
08484                                           ! 1654       translation &= 0x03;
08485                       0000249F            .1C6:
08486                                           ! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
08487 249F           8A86       FDF3            mov	al,-$20D[bp]
08488 24A3           48                         dec	ax
08489 24A4           8886       FDF3            mov	-$20D[bp],al
08490                       000024A8            .1C7:
08491                                           ! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
08492 24A8           8A86       FDF3            mov	al,-$20D[bp]
08493 24AC           84C0                       test	al,al
08494 24AE           75           E1            jne	.1C8
08495                       000024B0            .1C9:
08496                       000024B0            .1C5:
08497                                           ! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
08498 24B0           8A86       FDDD            mov	al,-$223[bp]
08499 24B4           24                     03  and	al,*3
08500 24B6           8886       FDDD            mov	-$223[bp],al
08501                                           !BCC_EOS
08502                                           ! 1655       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
08503                                           ! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
08504 24BA           8A86       FDDD            mov	al,-$223[bp]
08505 24BE           30E4                       xor	ah,ah
08506 24C0           50                         push	ax
08507                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08508 24C1           8A46         FB            mov	al,-5[bp]
08509 24C4           30E4                       xor	ah,ah
08510 24C6           B9                   001E  mov	cx,*$1E
08511 24C9           F7E9                       imul	cx
08512 24CB           89C3                       mov	bx,ax
08513                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
08514                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
08515 24CD           81C3                 014A  add	bx,#$14A
08516 24D1           53                         push	bx
08517                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08518 24D2           FF76         FE            push	-2[bp]
08519                                           ! Debug: func () void = write_byte+0 (used reg = )
08520 24D5           E8         E142            call	_write_byte
08521 24D8           83C4                   06  add	sp,*6
08522                                           !BCC_EOS
08523                                           ! 1656       switch (translation) {
08524 24DB           8A86       FDDD            mov	al,-$223[bp]
08525 24DF           EB           0A            jmp .1CC
08526                                           ! 1657         case 0:
08527                                           ! 1658           ;
08528                       000024E1            .1CD:
08529                                           !BCC_EOS
08530                                           ! 1659           break;
08531 24E1           EB           18            jmp .1CA
08532                                           !BCC_EOS
08533                                           ! 1660         case 1:
08534                                           ! 1661           ;
08535                       000024E3            .1CE:
08536                                           !BCC_EOS
08537                                           ! 1662           break;
08538 24E3           EB           16            jmp .1CA
08539                                           !BCC_EOS
08540                                           ! 1663         case 2:
08541                                           ! 1664           ;
08542                       000024E5            .1CF:
08543                                           !BCC_EOS
08544                                           ! 1665           break;
08545 24E5           EB           14            jmp .1CA
08546                                           !BCC_EOS
08547                                           ! 1666         case 3:
08548                                           ! 1667           ;
08549                       000024E7            .1D0:
08550                                           !BCC_EOS
08551                                           ! 1668           break;
08552 24E7           EB           12            jmp .1CA
08553                                           !BCC_EOS
08554                                           ! 1669         }
08555                                           ! 1670       switch (translation) {
08556 24E9           EB           10            jmp .1CA
08557                       000024EB            .1CC:
08558 24EB           2C                     00  sub	al,*0
08559 24ED           74           F2            je 	.1CD
08560 24EF           2C                     01  sub	al,*1
08561 24F1           74           F0            je 	.1CE
08562 24F3           2C                     01  sub	al,*1
08563 24F5           74           EE            je 	.1CF
08564 24F7           2C                     01  sub	al,*1
08565 24F9           74           EC            je 	.1D0
08566                       000024FB            .1CA:
08567                       FFFFFDD8            ..FFFE	=	-$228
08568 24FB           8A86       FDDD            mov	al,-$223[bp]
08569 24FF           E9         0162            br 	.1D3
08570                                           ! 1671         case 0:
08571                                           ! 1672           break;
08572                       00002502            .1D4:
08573 2502           E9         0175            br 	.1D1
08574                                           !BCC_EOS
08575                                           ! 1673         case 1:
08576                                           ! 1674           spt = 63;
08577                       00002505            .1D5:
08578                                           ! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
08579 2505           B8                   003F  mov	ax,*$3F
08580 2508           8986       FDE0            mov	-$220[bp],ax
08581                                           !BCC_EOS
08582                                           ! 1675           sectors_low /= 63;
08583                                           ! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
08584 250C           B8                   003F  mov	ax,*$3F
08585 250F           31DB                       xor	bx,bx
08586 2511           53                         push	bx
08587 2512           50                         push	ax
08588 2513           8B86       FDEA            mov	ax,-$216[bp]
08589 2517           8B9E       FDEC            mov	bx,-$214[bp]
08590 251B           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08591 251F           E8         DC4C            call	ldivul
08592 2522           8986       FDEA            mov	-$216[bp],ax
08593 2526           899E       FDEC            mov	-$214[bp],bx
08594 252A           83C4                   04  add	sp,*4
08595                                           !BCC_EOS
08596                                           ! 1676           heads = sectors_low / 1024;
08597                                           ! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08598 252D           B8                   0400  mov	ax,#$400
08599 2530           31DB                       xor	bx,bx
08600 2532           53                         push	bx
08601 2533           50                         push	ax
08602 2534           8B86       FDEA            mov	ax,-$216[bp]
08603 2538           8B9E       FDEC            mov	bx,-$214[bp]
08604 253C           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08605 2540           E8         DC2B            call	ldivul
08606 2543           83C4                   04  add	sp,*4
08607                                           ! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
08608 2546           8986       FDE2            mov	-$21E[bp],ax
08609                                           !BCC_EOS
08610                                           ! 1677           if (heads>128) heads = 255;
08611                                           ! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08612 254A           8B86       FDE2            mov	ax,-$21E[bp]
08613 254E           3D                   0080  cmp	ax,#$80
08614 2551           76           09            jbe 	.1D6
08615                       00002553            .1D7:
08616                                           ! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
08617 2553           B8                   00FF  mov	ax,#$FF
08618 2556           8986       FDE2            mov	-$21E[bp],ax
08619                                           !BCC_EOS
08620                                           ! 1678           else if (heads>64) heads = 128;
08621 255A           EB           3D            jmp .1D8
08622                       0000255C            .1D6:
08623                                           ! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08624 255C           8B86       FDE2            mov	ax,-$21E[bp]
08625 2560           3D                   0040  cmp	ax,*$40
08626 2563           76           09            jbe 	.1D9
08627                       00002565            .1DA:
08628                                           ! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
08629 2565           B8                   0080  mov	ax,#$80
08630 2568           8986       FDE2            mov	-$21E[bp],ax
08631                                           !BCC_EOS
08632                                           ! 1679           else if (heads>32) heads = 64;
08633 256C           EB           2B            jmp .1DB
08634                       0000256E            .1D9:
08635                                           ! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08636 256E           8B86       FDE2            mov	ax,-$21E[bp]
08637 2572           3D                   0020  cmp	ax,*$20
08638 2575           76           09            jbe 	.1DC
08639                       00002577            .1DD:
08640                                           ! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
08641 2577           B8                   0040  mov	ax,*$40
08642 257A           8986       FDE2            mov	-$21E[bp],ax
08643                                           !BCC_EOS
08644                                           ! 1680           else if (heads>16) heads = 32;
08645 257E           EB           19            jmp .1DE
08646                       00002580            .1DC:
08647                                           ! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08648 2580           8B86       FDE2            mov	ax,-$21E[bp]
08649 2584           3D                   0010  cmp	ax,*$10
08650 2587           76           09            jbe 	.1DF
08651                       00002589            .1E0:
08652                                           ! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
08653 2589           B8                   0020  mov	ax,*$20
08654 258C           8986       FDE2            mov	-$21E[bp],ax
08655                                           !BCC_EOS
08656                                           ! 1681           else heads=16;
08657 2590           EB           07            jmp .1E1
08658                       00002592            .1DF:
08659                                           ! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08660 2592           B8                   0010  mov	ax,*$10
08661 2595           8986       FDE2            mov	-$21E[bp],ax
08662                                           !BCC_EOS
08663                                           ! 1682           cylinders = sectors_low / heads;
08664                       00002599            .1E1:
08665                       00002599            .1DE:
08666                       00002599            .1DB:
08667                       00002599            .1D8:
08668                                           ! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
08669 2599           8B86       FDE2            mov	ax,-$21E[bp]
08670 259D           31DB                       xor	bx,bx
08671                                           ! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
08672 259F           53                         push	bx
08673 25A0           50                         push	ax
08674 25A1           8B86       FDEA            mov	ax,-$216[bp]
08675 25A5           8B9E       FDEC            mov	bx,-$214[bp]
08676 25A9           8DBE       FDD6            lea	di,-2+..FFFD[bp]
08677 25AD           E8         DBBE            call	ldivul
08678 25B0           83C4                   04  add	sp,*4
08679                                           ! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08680 25B3           8986       FDE4            mov	-$21C[bp],ax
08681                                           !BCC_EOS
08682                                           ! 1683           break;
08683 25B7           E9         00C0            br 	.1D1
08684                                           !BCC_EOS
08685                                           ! 1684         case 3:
08686                                           ! 1685           if (heads==16) {
08687                       000025BA            .1E2:
08688                                           ! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
08689 25BA           8B86       FDE2            mov	ax,-$21E[bp]
08690 25BE           3D                   0010  cmp	ax,*$10
08691 25C1           75           72            jne 	.1E3
08692                       000025C3            .1E4:
08693                                           ! 1686             if(cylinders>61439) cylinders=61439;
08694                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08695 25C3           8B86       FDE4            mov	ax,-$21C[bp]
08696 25C7           31DB                       xor	bx,bx
08697                                           ! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
08698 25C9           53                         push	bx
08699 25CA           50                         push	ax
08700 25CB           B8                   EFFF  mov	ax,#$EFFF
08701 25CE           31DB                       xor	bx,bx
08702 25D0           53                         push	bx
08703 25D1           50                         push	ax
08704 25D2           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08705 25D6           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08706 25DA           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08707 25DE           E8         DAEA            call	lcmpul
08708 25E1           8DA6       FDDA            lea	sp,2+..FFFD[bp]
08709 25E5           76           07            jbe 	.1E5
08710                       000025E7            .1E6:
08711                                           ! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
08712 25E7           B8                   EFFF  mov	ax,#$EFFF
08713 25EA           8986       FDE4            mov	-$21C[bp],ax
08714                                           !BCC_EOS
08715                                           ! 1687             heads=15;
08716                       000025EE            .1E5:
08717                                           ! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
08718 25EE           B8                   000F  mov	ax,*$F
08719 25F1           8986       FDE2            mov	-$21E[bp],ax
08720                                           !BCC_EOS
08721                                           ! 1688             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
08722                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08723 25F5           8B86       FDE4            mov	ax,-$21C[bp]
08724 25F9           31DB                       xor	bx,bx
08725                                           ! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
08726 25FB           53                         push	bx
08727 25FC           50                         push	ax
08728 25FD           B8                   0010  mov	ax,*$10
08729 2600           31DB                       xor	bx,bx
08730 2602           53                         push	bx
08731 2603           50                         push	ax
08732 2604           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08733 2608           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08734 260C           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08735 2610           E8         DAD6            call	lmulul
08736 2613           83C4                   08  add	sp,*8
08737                                           ! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
08738 2616           53                         push	bx
08739 2617           50                         push	ax
08740 2618           B8                   000F  mov	ax,*$F
08741 261B           31DB                       xor	bx,bx
08742 261D           53                         push	bx
08743 261E           50                         push	ax
08744 261F           8B86       FDD6            mov	ax,-2+..FFFD[bp]
08745 2623           8B9E       FDD8            mov	bx,0+..FFFD[bp]
08746 2627           8DBE       FDD2            lea	di,-6+..FFFD[bp]
08747 262B           E8         DB40            call	ldivul
08748 262E           83C4                   08  add	sp,*8
08749                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
08750                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08751 2631           8986       FDE4            mov	-$21C[bp],ax
08752                                           !BCC_EOS
08753                                           ! 1689             }
08754                                           ! 1690         case 2:
08755                       00002635            .1E3:
08756                                           ! 1691           while(cylinders > 1024) {
08757                       00002635            .1E7:
08758 2635           E9         001F            br 	.1E9
08759                       00002638            .1EA:
08760                                           ! 1692             cylinders >>= 1;
08761                                           ! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08762 2638           8B86       FDE4            mov	ax,-$21C[bp]
08763 263C           D1E8                       shr	ax,*1
08764 263E           8986       FDE4            mov	-$21C[bp],ax
08765                                           !BCC_EOS
08766                                           ! 1693             heads <<= 1;
08767                                           ! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
08768 2642           8B86       FDE2            mov	ax,-$21E[bp]
08769 2646           D1E0                       shl	ax,*1
08770 2648           8986       FDE2            mov	-$21E[bp],ax
08771                                           !BCC_EOS
08772                                           ! 1694             if (heads > 127) break;
08773                                           ! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
08774 264C           8B86       FDE2            mov	ax,-$21E[bp]
08775 2650           3D                   007F  cmp	ax,*$7F
08776 2653           76           02            jbe 	.1EB
08777                       00002655            .1EC:
08778 2655           EB           09            jmp .1E8
08779                                           !BCC_EOS
08780                                           ! 1695           }
08781                       00002657            .1EB:
08782                                           ! 1696           break;
08783                       00002657            .1E9:
08784                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08785 2657           8B86       FDE4            mov	ax,-$21C[bp]
08786 265B           3D                   0400  cmp	ax,#$400
08787 265E           77           D8            ja 	.1EA
08788                       00002660            .1ED:
08789                       00002660            .1E8:
08790 2660           EB           18            jmp .1D1
08791                                           !BCC_EOS
08792                                           ! 1697         }
08793                                           ! 1698       if (cylinders > 1024) cylinders=1024;
08794 2662           EB           16            jmp .1D1
08795                       00002664            .1D3:
08796 2664           2C                     00  sub	al,*0
08797 2666         0F84         FE98            beq 	.1D4
08798 266A           2C                     01  sub	al,*1
08799 266C         0F84         FE95            beq 	.1D5
08800 2670           2C                     01  sub	al,*1
08801 2672           74           C1            je 	.1E7
08802 2674           2C                     01  sub	al,*1
08803 2676         0F84         FF40            beq 	.1E2
08804                       0000267A            .1D1:
08805                       FFFFFDD8            ..FFFD	=	-$228
08806                                           ! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08807 267A           8B86       FDE4            mov	ax,-$21C[bp]
08808 267E           3D                   0400  cmp	ax,#$400
08809 2681           76           07            jbe 	.1EE
08810                       00002683            .1EF:
08811                                           ! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
08812 2683           B8                   0400  mov	ax,#$400
08813 2686           8986       FDE4            mov	-$21C[bp],ax
08814                                           !BCC_EOS
08815                                           ! 1699       ;
08816                       0000268A            .1EE:
08817                                           !BCC_EOS
08818                                           ! 1700       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
08819                                           ! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
08820 268A           FFB6       FDE2            push	-$21E[bp]
08821                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08822 268E           8A46         FB            mov	al,-5[bp]
08823 2691           30E4                       xor	ah,ah
08824 2693           B9                   001E  mov	cx,*$1E
08825 2696           F7E9                       imul	cx
08826 2698           89C3                       mov	bx,ax
08827                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
08828                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
08829 269A           81C3                 014C  add	bx,#$14C
08830 269E           53                         push	bx
08831                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08832 269F           FF76         FE            push	-2[bp]
08833                                           ! Debug: func () void = write_word+0 (used reg = )
08834 26A2           E8         DF8D            call	_write_word
08835 26A5           83C4                   06  add	sp,*6
08836                                           !BCC_EOS
08837                                           ! 1701       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
08838                                           ! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
08839 26A8           FFB6       FDE4            push	-$21C[bp]
08840                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08841 26AC           8A46         FB            mov	al,-5[bp]
08842 26AF           30E4                       xor	ah,ah
08843 26B1           B9                   001E  mov	cx,*$1E
08844 26B4           F7E9                       imul	cx
08845 26B6           89C3                       mov	bx,ax
08846                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
08847                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
08848 26B8           81C3                 014E  add	bx,#$14E
08849 26BC           53                         push	bx
08850                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08851 26BD           FF76         FE            push	-2[bp]
08852                                           ! Debug: func () void = write_word+0 (used reg = )
08853 26C0           E8         DF6F            call	_write_word
08854 26C3           83C4                   06  add	sp,*6
08855                                           !BCC_EOS
08856                                           ! 1702       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
08857                                           ! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
08858 26C6           FFB6       FDE0            push	-$220[bp]
08859                                           ! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
08860 26CA           8A46         FB            mov	al,-5[bp]
08861 26CD           30E4                       xor	ah,ah
08862 26CF           B9                   001E  mov	cx,*$1E
08863 26D2           F7E9                       imul	cx
08864 26D4           89C3                       mov	bx,ax
08865                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
08866                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
08867 26D6           81C3                 0150  add	bx,#$150
08868 26DA           53                         push	bx
08869                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08870 26DB           FF76         FE            push	-2[bp]
08871                                           ! Debug: func () void = write_word+0 (used reg = )
08872 26DE           E8         DF51            call	_write_word
08873 26E1           83C4                   06  add	sp,*6
08874                                           !BCC_EOS
08875                                           ! 1703       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
08876                                           ! Debug: list unsigned char device = [S+$228-7] (used reg = )
08877 26E4           8A46         FB            mov	al,-5[bp]
08878 26E7           30E4                       xor	ah,ah
08879 26E9           50                         push	ax
08880                                           ! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
08881 26EA           8A46         FD            mov	al,-3[bp]
08882 26ED           30E4                       xor	ah,ah
08883 26EF           89C3                       mov	bx,ax
08884                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
08885                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
08886 26F1           81C3                 0233  add	bx,#$233
08887 26F5           53                         push	bx
08888                                           ! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
08889 26F6           FF76         FE            push	-2[bp]
08890                                           ! Debug: func () void = write_byte+0 (used reg = )
08891 26F9           E8         DF1E            call	_write_byte
08892 26FC           83C4                   06  add	sp,*6
08893                                           !BCC_EOS
08894                                           ! 1704       hdcount++;
08895                                           ! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
08896 26FF           8A46         FD            mov	al,-3[bp]
08897 2702           40                         inc	ax
08898 2703           8846         FD            mov	-3[bp],al
08899                                           !BCC_EOS
08900                                           ! 1705       }
08901 2706           83C4                   14  add	sp,*$14
08902                                           ! 1706     if(type == 0x03) {
08903                       00002709            .1B7:
08904                                           ! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
08905 2709           8A46         FA            mov	al,-6[bp]
08906 270C           3C                     03  cmp	al,*3
08907 270E         0F85         0186            bne 	.1F0
08908                       00002712            .1F1:
08909                                           ! 1707       Bit8u type, removable,
08910                                           ! 1707  mode;
08911                                           !BCC_EOS
08912                                           ! 1708       Bit16u blksize;
08913                                           !BCC_EOS
08914                                           ! 1709       mode = 0x00;
08915 2712           83C4                   FA  add	sp,*-6
08916                                           ! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
08917 2715           30C0                       xor	al,al
08918 2717           8886       FDEB            mov	-$215[bp],al
08919                                           !BCC_EOS
08920                                           ! 1710       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
08921                                           ! Debug: list int = const 5 (used reg = )
08922 271B           B8                   0005  mov	ax,*5
08923 271E           50                         push	ax
08924                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08925 271F           8A46         FB            mov	al,-5[bp]
08926 2722           30E4                       xor	ah,ah
08927 2724           B9                   001E  mov	cx,*$1E
08928 2727           F7E9                       imul	cx
08929 2729           89C3                       mov	bx,ax
08930                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
08931                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
08932 272B           81C3                 0143  add	bx,#$143
08933 272F           53                         push	bx
08934                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08935 2730           FF76         FE            push	-2[bp]
08936                                           ! Debug: func () void = write_byte+0 (used reg = )
08937 2733           E8         DEE4            call	_write_byte
08938 2736           83C4                   06  add	sp,*6
08939                                           !BCC_EOS
08940                                           ! 1711       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
08941                                           ! Debug: list int = const 0 (used reg = )
08942 2739           31C0                       xor	ax,ax
08943 273B           50                         push	ax
08944                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
08945 273C           8A46         FB            mov	al,-5[bp]
08946 273F           30E4                       xor	ah,ah
08947 2741           B9                   001E  mov	cx,*$1E
08948 2744           F7E9                       imul	cx
08949 2746           89C3                       mov	bx,ax
08950                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
08951                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
08952 2748           81C3                 0146  add	bx,#$146
08953 274C           53                         push	bx
08954                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
08955 274D           FF76         FE            push	-2[bp]
08956                                           ! Debug: func () void = write_byte+0 (used reg = )
08957 2750           E8         DEC7            call	_write_byte
08958 2753           83C4                   06  add	sp,*6
08959                                           !BCC_EOS
08960                                           ! 1712       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
08961                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
08962 2756           8D9E       FDFA            lea	bx,-$206[bp]
08963 275A           53                         push	bx
08964                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
08965 275B           E8         DEEF            call	_get_SS
08966                                           ! Debug: list unsigned short = ax+0 (used reg = )
08967 275E           50                         push	ax
08968                                           ! Debug: list long = const 0 (used reg = )
08969 275F           31C0                       xor	ax,ax
08970 2761           31DB                       xor	bx,bx
08971 2763           53                         push	bx
08972 2764           50                         push	ax
08973                                           ! Debug: list long = const 0 (used reg = )
08974 2765           31C0                       xor	ax,ax
08975 2767           31DB                       xor	bx,bx
08976 2769           53                         push	bx
08977 276A           50                         push	ax
08978                                           ! Debug: list int = const 0 (used reg = )
08979 276B           31C0                       xor	ax,ax
08980 276D           50                         push	ax
08981                                           ! Debug: list int = const 0 (used reg = )
08982 276E           31C0                       xor	ax,ax
08983 2770           50                         push	ax
08984                                           ! Debug: list int = const 0 (used reg = )
08985 2771           31C0                       xor	ax,ax
08986 2773           50                         push	ax
08987                                           ! Debug: list int = const 1 (used reg = )
08988 2774           B8                   0001  mov	ax,*1
08989 2777           50                         push	ax
08990                                           ! Debug: list int = const $A1 (used reg = )
08991 2778           B8                   00A1  mov	ax,#$A1
08992 277B           50                         push	ax
08993                                           ! Debug: list unsigned char device = [S+$230-7] (used reg = )
08994 277C           8A46         FB            mov	al,-5[bp]
08995 277F           30E4                       xor	ah,ah
08996 2781           50                         push	ax
08997                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
08998 2782           E8         06A2            call	_ata_cmd_data_in
08999 2785           83C4                   18  add	sp,*$18
09000                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
09001 2788           85C0                       test	ax,ax
09002 278A           74           0E            je  	.1F2
09003                       0000278C            .1F3:
09004                                           ! 1713         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
09005                                           ! Debug: list * char = .1F4+0 (used reg = )
09006 278C           BB                   D42E  mov	bx,#.1F4
09007 278F           53                         push	bx
09008                                           ! Debug: list int = const 7 (used reg = )
09009 2790           B8                   0007  mov	ax,*7
09010 2793           50                         push	ax
09011                                           ! Debug: func () void = bios_printf+0 (used reg = )
09012 2794           E8         E284            call	_bios_printf
09013 2797           83C4                   04  add	sp,*4
09014                                           !BCC_EOS
09015                                           ! 1714       type = read_byte(get_SS(),buffer+1) & 0x1f;
09016                       0000279A            .1F2:
09017                                           ! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
09018 279A           8D9E       FDFB            lea	bx,-$205[bp]
09019 279E           53                         push	bx
09020                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09021 279F           E8         DEAB            call	_get_SS
09022                                           ! Debug: list unsigned short = ax+0 (used reg = )
09023 27A2           50                         push	ax
09024                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09025 27A3           E8         DE4E            call	_read_byte
09026 27A6           83C4                   04  add	sp,*4
09027                                           ! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
09028 27A9           24                     1F  and	al,*$1F
09029                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
09030 27AB           8886       FDED            mov	-$213[bp],al
09031                                           !BCC_EOS
09032                                           ! 1715       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
09033                                           ! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
09034 27AF           8D9E       FDFA            lea	bx,-$206[bp]
09035 27B3           53                         push	bx
09036                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09037 27B4           E8         DE96            call	_get_SS
09038                                           ! Debug: list unsigned short = ax+0 (used reg = )
09039 27B7           50                         push	ax
09040                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09041 27B8           E8         DE39            call	_read_byte
09042 27BB           83C4                   04  add	sp,*4
09043                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
09044 27BE           24                     80  and	al,#$80
09045 27C0           84C0                       test	al,al
09046 27C2           74           04            je  	.1F5
09047                       000027C4            .1F6:
09048 27C4           B0                     01  mov	al,*1
09049 27C6           EB           02            jmp .1F7
09050                       000027C8            .1F5:
09051 27C8           30C0                       xor	al,al
09052                       000027CA            .1F7:
09053                                           ! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
09054 27CA           8886       FDEC            mov	-$214[bp],al
09055                                           !BCC_EOS
09056                                           ! 1716       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
09057                                           ! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
09058 27CE           8D9E       FE5A            lea	bx,-$1A6[bp]
09059 27D2           53                         push	bx
09060                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09061 27D3           E8         DE77            call	_get_SS
09062                                           ! Debug: list unsigned short = ax+0 (used reg = )
09063 27D6           50                         push	ax
09064                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09065 27D7           E8         DE1A            call	_read_byte
09066 27DA           83C4                   04  add	sp,*4
09067 27DD           84C0                       test	al,al
09068 27DF           74           04            je  	.1F8
09069                       000027E1            .1F9:
09070 27E1           B0                     01  mov	al,*1
09071 27E3           EB           02            jmp .1FA
09072                       000027E5            .1F8:
09073 27E5           30C0                       xor	al,al
09074                       000027E7            .1FA:
09075                                           ! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
09076 27E7           8886       FDEB            mov	-$215[bp],al
09077                                           !BCC_EOS
09078                                           ! 1717       blksize = 2048;
09079                                           ! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
09080 27EB           B8                   0800  mov	ax,#$800
09081 27EE           8986       FDE8            mov	-$218[bp],ax
09082                                           !BCC_EOS
09083                                           ! 1718       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
09084                                           ! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
09085 27F2           8A86       FDED            mov	al,-$213[bp]
09086 27F6           30E4                       xor	ah,ah
09087 27F8           50                         push	ax
09088                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09089 27F9           8A46         FB            mov	al,-5[bp]
09090 27FC           30E4                       xor	ah,ah
09091 27FE           B9                   001E  mov	cx,*$1E
09092 2801           F7E9                       imul	cx
09093 2803           89C3                       mov	bx,ax
09094                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09095                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09096 2805           81C3                 0143  add	bx,#$143
09097 2809           53                         push	bx
09098                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09099 280A           FF76         FE            push	-2[bp]
09100                                           ! Debug: func () void = write_byte+0 (used reg = )
09101 280D           E8         DE0A            call	_write_byte
09102 2810           83C4                   06  add	sp,*6
09103                                           !BCC_EOS
09104                                           ! 1719       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
09105                                           ! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
09106 2813           8A86       FDEC            mov	al,-$214[bp]
09107 2817           30E4                       xor	ah,ah
09108 2819           50                         push	ax
09109                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09110 281A           8A46         FB            mov	al,-5[bp]
09111 281D           30E4                       xor	ah,ah
09112 281F           B9                   001E  mov	cx,*$1E
09113 2822           F7E9                       imul	cx
09114 2824           89C3                       mov	bx,ax
09115                                           ! Debug: address unsigned char = [bx+$144] (used reg = )
09116                                           ! Debug: list * unsigned char = bx+$144 (used reg = )
09117 2826           81C3                 0144  add	bx,#$144
09118 282A           53                         push	bx
09119                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09120 282B           FF76         FE            push	-2[bp]
09121                                           ! Debug: func () void = write_byte+0 (used reg = )
09122 282E           E8         DDE9            call	_write_byte
09123 2831           83C4                   06  add	sp,*6
09124                                           !BCC_EOS
09125                                           ! 1720       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
09126                                           ! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
09127 2834           8A86       FDEB            mov	al,-$215[bp]
09128 2838           30E4                       xor	ah,ah
09129 283A           50                         push	ax
09130                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09131 283B           8A46         FB            mov	al,-5[bp]
09132 283E           30E4                       xor	ah,ah
09133 2840           B9                   001E  mov	cx,*$1E
09134 2843           F7E9                       imul	cx
09135 2845           89C3                       mov	bx,ax
09136                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
09137                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
09138 2847           81C3                 0146  add	bx,#$146
09139 284B           53                         push	bx
09140                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09141 284C           FF76         FE            push	-2[bp]
09142                                           ! Debug: func () void = write_byte+0 (used reg = )
09143 284F           E8         DDC8            call	_write_byte
09144 2852           83C4                   06  add	sp,*6
09145                                           !BCC_EOS
09146                                           ! 1721       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
09147                                           ! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
09148 2855           FFB6       FDE8            push	-$218[bp]
09149                                           ! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
09150 2859           8A46         FB            mov	al,-5[bp]
09151 285C           30E4                       xor	ah,ah
09152 285E           B9                   001E  mov	cx,*$1E
09153 2861           F7E9                       imul	cx
09154 2863           89C3                       mov	bx,ax
09155                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
09156                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
09157 2865           81C3                 0148  add	bx,#$148
09158 2869           53                         push	bx
09159                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09160 286A           FF76         FE            push	-2[bp]
09161                                           ! Debug: func () void = write_word+0 (used reg = )
09162 286D           E8         DDC2            call	_write_word
09163 2870           83C4                   06  add	sp,*6
09164                                           !BCC_EOS
09165                                           ! 1722       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
09166                                           ! Debug: list unsigned char device = [S+$21A-7] (used reg = )
09167 2873           8A46         FB            mov	al,-5[bp]
09168 2876           30E4                       xor	ah,ah
09169 2878           50                         push	ax
09170                                           ! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
09171 2879           8A46         FC            mov	al,-4[bp]
09172 287C           30E4                       xor	ah,ah
09173 287E           89C3                       mov	bx,ax
09174                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
09175                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
09176 2880           81C3                 023C  add	bx,#$23C
09177 2884           53                         push	bx
09178                                           ! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
09179 2885           FF76         FE            push	-2[bp]
09180                                           ! Debug: func () void = write_byte+0 (used reg = )
09181 2888           E8         DD8F            call	_write_byte
09182 288B           83C4                   06  add	sp,*6
09183                                           !BCC_EOS
09184                                           ! 1723       cdcount++;
09185                                           ! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
09186 288E           8A46         FC            mov	al,-4[bp]
09187 2891           40                         inc	ax
09188 2892           8846         FC            mov	-4[bp],al
09189                                           !BCC_EOS
09190                                           ! 1724       }
09191 2895           83C4                   06  add	sp,*6
09192                                           ! 1725       {
09193                       00002898            .1F0:
09194                                           ! 1726       Bit32u sizeinmb;
09195                                           !BCC_EOS
09196                                           ! 1727       Bit16u ataversion;
09197                                           !BCC_EOS
09198                                           ! 1728       Bit8u c, i, version, model[41];
09199                                           !BCC_EOS
09200                                           ! 1729       switch (type) {
09201 2898           83C4                   CE  add	sp,*-$32
09202 289B           8A46         FA            mov	al,-6[bp]
09203 289E           E9         020C            br 	.1FD
09204                                           ! 1730         case 0x02:
09205                                           ! 1731           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
09206                       000028A1            .1FE:
09207                                           ! 1732             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
09208                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09209 28A1           8A46         FB            mov	al,-5[bp]
09210 28A4           30E4                       xor	ah,ah
09211 28A6           B9                   001E  mov	cx,*$1E
09212 28A9           F7E9                       imul	cx
09213 28AB           89C3                       mov	bx,ax
09214                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
09215                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
09216 28AD           81C3                 0158  add	bx,#$158
09217 28B1           53                         push	bx
09218                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09219 28B2           FF76         FE            push	-2[bp]
09220                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09221 28B5           E8         D7CB            call	_read_dword
09222 28B8           89D3                       mov	bx,dx
09223 28BA           83C4                   04  add	sp,*4
09224                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
09225 28BD           88E0                       mov	al,ah
09226 28BF           88DC                       mov	ah,bl
09227 28C1           88FB                       mov	bl,bh
09228 28C3           28FF                       sub	bh,bh
09229 28C5           BF                   0003  mov	di,*3
09230 28C8           E8         D85E            call	lsrul
09231 28CB           53                         push	bx
09232 28CC           50                         push	ax
09233                                           ! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
09234 28CD           8A46         FB            mov	al,-5[bp]
09235 28D0           30E4                       xor	ah,ah
09236 28D2           B9                   001E  mov	cx,*$1E
09237 28D5           F7E9                       imul	cx
09238 28D7           89C3                       mov	bx,ax
09239                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
09240                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
09241 28D9           81C3                 015C  add	bx,#$15C
09242 28DD           53                         push	bx
09243                                           ! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
09244 28DE           FF76         FE            push	-2[bp]
09245                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
09246 28E1           E8         D79F            call	_read_dword
09247 28E4           89D3                       mov	bx,dx
09248 28E6           83C4                   04  add	sp,*4
09249                                           ! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
09250 28E9           B1                     05  mov	cl,*5
09251 28EB           D3E0                       shl	ax,cl
09252 28ED           93                         xchg	bx,ax
09253 28EE           31C0                       xor	ax,ax
09254                                           ! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
09255 28F0           8DBE       FDB8            lea	di,-2+..FFFC[bp]
09256 28F4           E8         D810            call	lorul
09257 28F7           83C4                   04  add	sp,*4
09258                                           ! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09259 28FA           8986       FDEA            mov	-$216[bp],ax
09260 28FE           899E       FDEC            mov	-$214[bp],bx
09261                                           !BCC_EOS
09262                                           ! 1733         case 0x03:
09263                                           ! 1734           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
09264                       00002902            .1FF:
09265                                           ! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
09266 2902           8D9E       FE9A            lea	bx,-$166[bp]
09267 2906           53                         push	bx
09268                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09269 2907           E8         DD43            call	_get_SS
09270                                           ! Debug: list unsigned short = ax+0 (used reg = )
09271 290A           50                         push	ax
09272                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09273 290B           E8         DCE6            call	_read_byte
09274 290E           83C4                   04  add	sp,*4
09275 2911           50                         push	ax
09276                                           ! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
09277 2912           8D9E       FE9B            lea	bx,-$165[bp]
09278 2916           53                         push	bx
09279                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09280 2917           E8         DD33            call	_get_SS
09281                                           ! Debug: list unsigned short = ax+0 (used reg = )
09282 291A           50                         push	ax
09283                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09284 291B           E8         DCD6            call	_read_byte
09285 291E           83C4                   04  add	sp,*4
09286                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
09287 2921           30E4                       xor	ah,ah
09288                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
09289 2923           88C4                       mov	ah,al
09290 2925           30C0                       xor	al,al
09291                                           ! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
09292 2927           0A86       FDBA            or	al,0+..FFFC[bp]
09293 292B           44                         inc	sp
09294 292C           44                         inc	sp
09295                                           ! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09296 292D           8986       FDE8            mov	-$218[bp],ax
09297                                           !BCC_EOS
09298                                           ! 1735           for(version=15;version>0;version--) {
09299                                           ! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
09300 2931           B0                     0F  mov	al,*$F
09301 2933           8886       FDE5            mov	-$21B[bp],al
09302                                           !BCC_EOS
09303                                           !BCC_EOS
09304 2937           EB           22            jmp .202
09305                       00002939            .203:
09306                                           ! 1736             if((ataversion&(1<<version))!=0)
09307                                           ! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
09308 2939           8A86       FDE5            mov	al,-$21B[bp]
09309 293D           30E4                       xor	ah,ah
09310 293F           89C3                       mov	bx,ax
09311 2941           B8                   0001  mov	ax,*1
09312 2944           89D9                       mov	cx,bx
09313 2946           D3E0                       shl	ax,cl
09314                                           ! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
09315                                           ! Debug: expression subtree swapping
09316 2948           2386       FDE8            and	ax,-$218[bp]
09317                                           ! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
09318 294C           85C0                       test	ax,ax
09319 294E           74           02            je  	.204
09320                       00002950            .205:
09321                                           ! 1737             break;
09322 2950           EB           11            jmp .200
09323                                           !BCC_EOS
09324                                           ! 1738             }
09325                       00002952            .204:
09326                                           ! 1739           for(i=0;i<20;i++){
09327                       00002952            .201:
09328                                           ! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
09329 2952           8A86       FDE5            mov	al,-$21B[bp]
09330 2956           48                         dec	ax
09331 2957           8886       FDE5            mov	-$21B[bp],al
09332                       0000295B            .202:
09333                                           ! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
09334 295B           8A86       FDE5            mov	al,-$21B[bp]
09335 295F           84C0                       test	al,al
09336 2961           75           D6            jne	.203
09337                       00002963            .206:
09338                       00002963            .200:
09339                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09340 2963           30C0                       xor	al,al
09341 2965           8886       FDE6            mov	-$21A[bp],al
09342                                           !BCC_EOS
09343                                           !BCC_EOS
09344 2969           E9         007B            br 	.209
09345                       0000296C            .20A:
09346                                           ! 1740             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
09347                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09348 296C           8A86       FDE6            mov	al,-$21A[bp]
09349 2970           30E4                       xor	ah,ah
09350 2972           D1E0                       shl	ax,*1
09351                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09352 2974           89EB                       mov	bx,bp
09353 2976           01C3                       add	bx,ax
09354                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09355                                           ! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
09356                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
09357                                           ! Debug: list * unsigned char = bx-$1CF (used reg = )
09358 2978           81C3                 FE31  add	bx,#-$1CF
09359 297C           53                         push	bx
09360                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09361 297D           E8         DCCD            call	_get_SS
09362                                           ! Debug: list unsigned short = ax+0 (used reg = )
09363 2980           50                         push	ax
09364                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09365 2981           E8         DC70            call	_read_byte
09366 2984           83C4                   04  add	sp,*4
09367                                           ! Debug: list unsigned char = al+0 (used reg = )
09368 2987           30E4                       xor	ah,ah
09369 2989           50                         push	ax
09370                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09371 298A           8A86       FDE6            mov	al,-$21A[bp]
09372 298E           30E4                       xor	ah,ah
09373 2990           D1E0                       shl	ax,*1
09374                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09375 2992           89EB                       mov	bx,bp
09376 2994           01C3                       add	bx,ax
09377                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09378                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09379 2996           81C3                 FDBC  add	bx,#-$244
09380 299A           53                         push	bx
09381                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09382 299B           E8         DCAF            call	_get_SS
09383                                           ! Debug: list unsigned short = ax+0 (used reg = )
09384 299E           50                         push	ax
09385                                           ! Debug: func () void = write_byte+0 (used reg = )
09386 299F           E8         DC78            call	_write_byte
09387 29A2           83C4                   06  add	sp,*6
09388                                           !BCC_EOS
09389                                           ! 1741             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
09390                                           ! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
09391 29A5           8A86       FDE6            mov	al,-$21A[bp]
09392 29A9           30E4                       xor	ah,ah
09393 29AB           D1E0                       shl	ax,*1
09394                                           ! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
09395 29AD           89EB                       mov	bx,bp
09396 29AF           01C3                       add	bx,ax
09397                                           ! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
09398                                           ! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
09399                                           ! Debug: list * unsigned char = bx-$1D0 (used reg = )
09400 29B1           81C3                 FE30  add	bx,#-$1D0
09401 29B5           53                         push	bx
09402                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09403 29B6           E8         DC94            call	_get_SS
09404                                           ! Debug: list unsigned short = ax+0 (used reg = )
09405 29B9           50                         push	ax
09406                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09407 29BA           E8         DC37            call	_read_byte
09408 29BD           83C4                   04  add	sp,*4
09409                                           ! Debug: list unsigned char = al+0 (used reg = )
09410 29C0           30E4                       xor	ah,ah
09411 29C2           50                         push	ax
09412                                           ! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
09413 29C3           8A86       FDE6            mov	al,-$21A[bp]
09414 29C7           30E4                       xor	ah,ah
09415 29C9           D1E0                       shl	ax,*1
09416                                           ! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
09417 29CB           89EB                       mov	bx,bp
09418 29CD           01C3                       add	bx,ax
09419                                           ! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
09420                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
09421                                           ! Debug: list * unsigned char = bx-$243 (used reg = )
09422 29CF           81C3                 FDBD  add	bx,#-$243
09423 29D3           53                         push	bx
09424                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09425 29D4           E8         DC76            call	_get_SS
09426                                           ! Debug: list unsigned short = ax+0 (used reg = )
09427 29D7           50                         push	ax
09428                                           ! Debug: func () void = write_byte+0 (used reg = )
09429 29D8           E8         DC3F            call	_write_byte
09430 29DB           83C4                   06  add	sp,*6
09431                                           !BCC_EOS
09432                                           ! 1742           }
09433                                           ! 1743           write_byte(get_SS(),model+40,0x00);
09434                       000029DE            .208:
09435                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09436 29DE           8A86       FDE6            mov	al,-$21A[bp]
09437 29E2           40                         inc	ax
09438 29E3           8886       FDE6            mov	-$21A[bp],al
09439                       000029E7            .209:
09440                                           ! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
09441 29E7           8A86       FDE6            mov	al,-$21A[bp]
09442 29EB           3C                     14  cmp	al,*$14
09443 29ED         0F82         FF7B            blo 	.20A
09444                       000029F1            .20B:
09445                       000029F1            .207:
09446                                           ! Debug: list int = const 0 (used reg = )
09447 29F1           31C0                       xor	ax,ax
09448 29F3           50                         push	ax
09449                                           ! Debug: list * unsigned char model = S+$248-$21E (used reg = )
09450 29F4           8D9E       FDE4            lea	bx,-$21C[bp]
09451 29F8           53                         push	bx
09452                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09453 29F9           E8         DC51            call	_get_SS
09454                                           ! Debug: list unsigned short = ax+0 (used reg = )
09455 29FC           50                         push	ax
09456                                           ! Debug: func () void = write_byte+0 (used reg = )
09457 29FD           E8         DC1A            call	_write_byte
09458 2A00           83C4                   06  add	sp,*6
09459                                           !BCC_EOS
09460                                           ! 1744           for(i=39;i>0;i--){
09461                                           ! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
09462 2A03           B0                     27  mov	al,*$27
09463 2A05           8886       FDE6            mov	-$21A[bp],al
09464                                           !BCC_EOS
09465                                           !BCC_EOS
09466 2A09           EB           46            jmp .20E
09467                       00002A0B            .20F:
09468                                           ! 1745             if(read_byte(get_SS(),model+i)==0x20)
09469                                           ! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
09470 2A0B           8A86       FDE6            mov	al,-$21A[bp]
09471 2A0F           30E4                       xor	ah,ah
09472 2A11           89EB                       mov	bx,bp
09473 2A13           01C3                       add	bx,ax
09474                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09475                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09476 2A15           81C3                 FDBC  add	bx,#-$244
09477 2A19           53                         push	bx
09478                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09479 2A1A           E8         DC30            call	_get_SS
09480                                           ! Debug: list unsigned short = ax+0 (used reg = )
09481 2A1D           50                         push	ax
09482                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09483 2A1E           E8         DBD3            call	_read_byte
09484 2A21           83C4                   04  add	sp,*4
09485                                           ! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
09486 2A24           3C                     20  cmp	al,*$20
09487 2A26           75           1E            jne 	.210
09488                       00002A28            .211:
09489                                           ! 1746               write_byte(get_SS(),model+i,0x00);
09490                                           ! Debug: list int = const 0 (used reg = )
09491 2A28           31C0                       xor	ax,ax
09492 2A2A           50                         push	ax
09493                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09494 2A2B           8A86       FDE6            mov	al,-$21A[bp]
09495 2A2F           30E4                       xor	ah,ah
09496 2A31           89EB                       mov	bx,bp
09497 2A33           01C3                       add	bx,ax
09498                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09499                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09500 2A35           81C3                 FDBC  add	bx,#-$244
09501 2A39           53                         push	bx
09502                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09503 2A3A           E8         DC10            call	_get_SS
09504                                           ! Debug: list unsigned short = ax+0 (used reg = )
09505 2A3D           50                         push	ax
09506                                           ! Debug: func () void = write_byte+0 (used reg = )
09507 2A3E           E8         DBD9            call	_write_byte
09508 2A41           83C4                   06  add	sp,*6
09509                                           !BCC_EOS
09510                                           ! 1747             else break;
09511 2A44           EB           02            jmp .212
09512                       00002A46            .210:
09513 2A46           EB           11            jmp .20C
09514                                           !BCC_EOS
09515                                           ! 1748           }
09516                       00002A48            .212:
09517                                           ! 1749           if (i>36) {
09518                       00002A48            .20D:
09519                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09520 2A48           8A86       FDE6            mov	al,-$21A[bp]
09521 2A4C           48                         dec	ax
09522 2A4D           8886       FDE6            mov	-$21A[bp],al
09523                       00002A51            .20E:
09524                                           ! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09525 2A51           8A86       FDE6            mov	al,-$21A[bp]
09526 2A55           84C0                       test	al,al
09527 2A57           75           B2            jne	.20F
09528                       00002A59            .213:
09529                       00002A59            .20C:
09530                                           ! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
09531 2A59           8A86       FDE6            mov	al,-$21A[bp]
09532 2A5D           3C                     24  cmp	al,*$24
09533 2A5F           76           48            jbe 	.214
09534                       00002A61            .215:
09535                                           ! 1750           
09536                                           ! 1750   write_byte(get_SS(),model+36,0x00);
09537                                           ! Debug: list int = const 0 (used reg = )
09538 2A61           31C0                       xor	ax,ax
09539 2A63           50                         push	ax
09540                                           ! Debug: list * unsigned char model = S+$248-$222 (used reg = )
09541 2A64           8D9E       FDE0            lea	bx,-$220[bp]
09542 2A68           53                         push	bx
09543                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09544 2A69           E8         DBE1            call	_get_SS
09545                                           ! Debug: list unsigned short = ax+0 (used reg = )
09546 2A6C           50                         push	ax
09547                                           ! Debug: func () void = write_byte+0 (used reg = )
09548 2A6D           E8         DBAA            call	_write_byte
09549 2A70           83C4                   06  add	sp,*6
09550                                           !BCC_EOS
09551                                           ! 1751             for(i=35;i>32;i--){
09552                                           ! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
09553 2A73           B0                     23  mov	al,*$23
09554 2A75           8886       FDE6            mov	-$21A[bp],al
09555                                           !BCC_EOS
09556                                           !BCC_EOS
09557 2A79           EB           26            jmp .218
09558                       00002A7B            .219:
09559                                           ! 1752               write_byte(get_SS(),model+i,0x2E);
09560                                           ! Debug: list int = const $2E (used reg = )
09561 2A7B           B8                   002E  mov	ax,*$2E
09562 2A7E           50                         push	ax
09563                                           ! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
09564 2A7F           8A86       FDE6            mov	al,-$21A[bp]
09565 2A83           30E4                       xor	ah,ah
09566 2A85           89EB                       mov	bx,bp
09567 2A87           01C3                       add	bx,ax
09568                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09569                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09570 2A89           81C3                 FDBC  add	bx,#-$244
09571 2A8D           53                         push	bx
09572                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09573 2A8E           E8         DBBC            call	_get_SS
09574                                           ! Debug: list unsigned short = ax+0 (used reg = )
09575 2A91           50                         push	ax
09576                                           ! Debug: func () void = write_byte+0 (used reg = )
09577 2A92           E8         DB85            call	_write_byte
09578 2A95           83C4                   06  add	sp,*6
09579                                           !BCC_EOS
09580                                           ! 1753             }
09581                                           ! 1754           }
09582                       00002A98            .217:
09583                                           ! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
09584 2A98           8A86       FDE6            mov	al,-$21A[bp]
09585 2A9C           48                         dec	ax
09586 2A9D           8886       FDE6            mov	-$21A[bp],al
09587                       00002AA1            .218:
09588                                           ! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
09589 2AA1           8A86       FDE6            mov	al,-$21A[bp]
09590 2AA5           3C                     20  cmp	al,*$20
09591 2AA7           77           D2            ja 	.219
09592                       00002AA9            .21A:
09593                       00002AA9            .216:
09594                                           ! 1755           break;
09595                       00002AA9            .214:
09596 2AA9           EB           0E            jmp .1FB
09597                                           !BCC_EOS
09598                                           ! 1756         }
09599                                           ! 1757       switch (type) {
09600 2AAB           EB           0C            jmp .1FB
09601                       00002AAD            .1FD:
09602 2AAD           2C                     02  sub	al,*2
09603 2AAF         0F84         FDEE            beq 	.1FE
09604 2AB3           2C                     01  sub	al,*1
09605 2AB5         0F84         FE49            beq 	.1FF
09606                       00002AB9            .1FB:
09607                       FFFFFDBA            ..FFFC	=	-$246
09608 2AB9           8A46         FA            mov	al,-6[bp]
09609 2ABC           E9         01A2            br 	.21D
09610                                           ! 1758         case 0x02:
09611                                           ! 1759           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09612                       00002ABF            .21E:
09613 2ABF           8A86       FDF4            mov	al,-$20C[bp]
09614 2AC3           84C0                       test	al,al
09615 2AC5           74           05            je  	.222
09616                       00002AC7            .223:
09617 2AC7           BB                   D41C  mov	bx,#.220
09618 2ACA           EB           03            jmp .224
09619                       00002ACC            .222:
09620 2ACC           BB                   D415  mov	bx,#.221
09621                       00002ACF            .224:
09622                                           ! Debug: list * char = bx+0 (used reg = )
09623 2ACF           53                         push	bx
09624                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09625 2AD0           8A86       FDF5            mov	al,-$20B[bp]
09626 2AD4           30E4                       xor	ah,ah
09627 2AD6           50                         push	ax
09628                                           ! Debug: list * char = .21F+0 (used reg = )
09629 2AD7           BB                   D423  mov	bx,#.21F
09630 2ADA           53                         push	bx
09631                                           ! Debug: list int = const 2 (used reg = )
09632 2ADB           B8                   0002  mov	ax,*2
09633 2ADE           50                         push	ax
09634                                           ! Debug: func () void = bios_printf+0 (used reg = )
09635 2ADF           E8         DF39            call	_bios_printf
09636 2AE2           83C4                   08  add	sp,*8
09637                                           !BCC_EOS
09638                                           ! 1760           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09639                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09640 2AE5           30C0                       xor	al,al
09641 2AE7           8886       FDE6            mov	-$21A[bp],al
09642                                           !BCC_EOS
09643 2AEB           EB           15            jmp .226
09644                       00002AED            .227:
09645                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09646 2AED           8A86       FDE7            mov	al,-$219[bp]
09647 2AF1           30E4                       xor	ah,ah
09648 2AF3           50                         push	ax
09649                                           ! Debug: list * char = .228+0 (used reg = )
09650 2AF4           BB                   D412  mov	bx,#.228
09651 2AF7           53                         push	bx
09652                                           ! Debug: list int = const 2 (used reg = )
09653 2AF8           B8                   0002  mov	ax,*2
09654 2AFB           50                         push	ax
09655                                           ! Debug: func () void = bios_printf+0 (used reg = )
09656 2AFC           E8         DF1C            call	_bios_printf
09657 2AFF           83C4                   06  add	sp,*6
09658                                           !BCC_EOS
09659                                           ! 1761    if (sizeinmb < (1UL<<16))
09660                       00002B02            .226:
09661                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09662 2B02           8A86       FDE6            mov	al,-$21A[bp]
09663 2B06           40                         inc	ax
09664 2B07           8886       FDE6            mov	-$21A[bp],al
09665                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09666 2B0B           48                         dec	ax
09667 2B0C           30E4                       xor	ah,ah
09668 2B0E           89EB                       mov	bx,bp
09669 2B10           01C3                       add	bx,ax
09670                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09671                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09672 2B12           81C3                 FDBC  add	bx,#-$244
09673 2B16           53                         push	bx
09674                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09675 2B17           E8         DB33            call	_get_SS
09676                                           ! Debug: list unsigned short = ax+0 (used reg = )
09677 2B1A           50                         push	ax
09678                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09679 2B1B           E8         DAD6            call	_read_byte
09680 2B1E           83C4                   04  add	sp,*4
09681                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09682 2B21           8886       FDE7            mov	-$219[bp],al
09683 2B25           84C0                       test	al,al
09684 2B27           75           C4            jne	.227
09685                       00002B29            .229:
09686                       00002B29            .225:
09687                                           ! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09688 2B29           31C0                       xor	ax,ax
09689 2B2B           BB                   0001  mov	bx,*1
09690 2B2E           8DBE       FDEA            lea	di,-$216[bp]
09691 2B32           E8         D596            call	lcmpul
09692 2B35           76           1B            jbe 	.22A
09693                       00002B37            .22B:
09694                                           ! 1762             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
09695                                           ! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
09696 2B37           FFB6       FDEA            push	-$216[bp]
09697                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09698 2B3B           8A86       FDE5            mov	al,-$21B[bp]
09699 2B3F           30E4                       xor	ah,ah
09700 2B41           50                         push	ax
09701                                           ! Debug: list * char = .22C+0 (used reg = )
09702 2B42           BB                   D3F2  mov	bx,#.22C
09703 2B45           53                         push	bx
09704                                           ! Debug: list int = const 2 (used reg = )
09705 2B46           B8                   0002  mov	ax,*2
09706 2B49           50                         push	ax
09707                                           ! Debug: func () void = bios_printf+0 (used reg = )
09708 2B4A           E8         DECE            call	_bios_printf
09709 2B4D           83C4                   08  add	sp,*8
09710                                           !BCC_EOS
09711                                           ! 1763    else
09712                                           ! 1764             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
09713 2B50           EB           2C            jmp .22D
09714                       00002B52            .22A:
09715                                           ! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
09716 2B52           8B86       FDEA            mov	ax,-$216[bp]
09717 2B56           8B9E       FDEC            mov	bx,-$214[bp]
09718 2B5A           88E0                       mov	al,ah
09719 2B5C           88DC                       mov	ah,bl
09720 2B5E           88FB                       mov	bl,bh
09721 2B60           28FF                       sub	bh,bh
09722 2B62           BF                   0002  mov	di,*2
09723 2B65           E8         D5C1            call	lsrul
09724                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
09725                                           ! Debug: list unsigned short = ax+0 (used reg = )
09726 2B68           50                         push	ax
09727                                           ! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
09728 2B69           8A86       FDE5            mov	al,-$21B[bp]
09729 2B6D           30E4                       xor	ah,ah
09730 2B6F           50                         push	ax
09731                                           ! Debug: list * char = .22E+0 (used reg = )
09732 2B70           BB                   D3D2  mov	bx,#.22E
09733 2B73           53                         push	bx
09734                                           ! Debug: list int = const 2 (used reg = )
09735 2B74           B8                   0002  mov	ax,*2
09736 2B77           50                         push	ax
09737                                           ! Debug: func () void = bios_printf+0 (used reg = )
09738 2B78           E8         DEA0            call	_bios_printf
09739 2B7B           83C4                   08  add	sp,*8
09740                                           !BCC_EOS
09741                                           ! 1765           break;
09742                       00002B7E            .22D:
09743 2B7E           E9         00F0            br 	.21B
09744                                           !BCC_EOS
09745                                           ! 1766         case 0x03:
09746                                           ! 1767           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
09747                       00002B81            .22F:
09748 2B81           8A86       FDF4            mov	al,-$20C[bp]
09749 2B85           84C0                       test	al,al
09750 2B87           74           05            je  	.233
09751                       00002B89            .234:
09752 2B89           BB                   D3C0  mov	bx,#.231
09753 2B8C           EB           03            jmp .235
09754                       00002B8E            .233:
09755 2B8E           BB                   D3B9  mov	bx,#.232
09756                       00002B91            .235:
09757                                           ! Debug: list * char = bx+0 (used reg = )
09758 2B91           53                         push	bx
09759                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09760 2B92           8A86       FDF5            mov	al,-$20B[bp]
09761 2B96           30E4                       xor	ah,ah
09762 2B98           50                         push	ax
09763                                           ! Debug: list * char = .230+0 (used reg = )
09764 2B99           BB                   D3C7  mov	bx,#.230
09765 2B9C           53                         push	bx
09766                                           ! Debug: list int = const 2 (used reg = )
09767 2B9D           B8                   0002  mov	ax,*2
09768 2BA0           50                         push	ax
09769                                           ! Debug: func () void = bios_printf+0 (used reg = )
09770 2BA1           E8         DE77            call	_bios_printf
09771 2BA4           83C4                   08  add	sp,*8
09772                                           !BCC_EOS
09773                                           ! 1768           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
09774                                           ! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
09775 2BA7           30C0                       xor	al,al
09776 2BA9           8886       FDE6            mov	-$21A[bp],al
09777                                           !BCC_EOS
09778 2BAD           EB           15            jmp .237
09779                       00002BAF            .238:
09780                                           ! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
09781 2BAF           8A86       FDE7            mov	al,-$219[bp]
09782 2BB3           30E4                       xor	ah,ah
09783 2BB5           50                         push	ax
09784                                           ! Debug: list * char = .239+0 (used reg = )
09785 2BB6           BB                   D3B6  mov	bx,#.239
09786 2BB9           53                         push	bx
09787                                           ! Debug: list int = const 2 (used reg = )
09788 2BBA           B8                   0002  mov	ax,*2
09789 2BBD           50                         push	ax
09790                                           ! Debug: func () void = bios_printf+0 (used reg = )
09791 2BBE           E8         DE5A            call	_bios_printf
09792 2BC1           83C4                   06  add	sp,*6
09793                                           !BCC_EOS
09794                                           ! 1769           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
09795                       00002BC4            .237:
09796                                           ! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
09797 2BC4           8A86       FDE6            mov	al,-$21A[bp]
09798 2BC8           40                         inc	ax
09799 2BC9           8886       FDE6            mov	-$21A[bp],al
09800                                           ! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
09801 2BCD           48                         dec	ax
09802 2BCE           30E4                       xor	ah,ah
09803 2BD0           89EB                       mov	bx,bp
09804 2BD2           01C3                       add	bx,ax
09805                                           ! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
09806                                           ! Debug: list * unsigned char = bx-$244 (used reg = )
09807 2BD4           81C3                 FDBC  add	bx,#-$244
09808 2BD8           53                         push	bx
09809                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
09810 2BD9           E8         DA71            call	_get_SS
09811                                           ! Debug: list unsigned short = ax+0 (used reg = )
09812 2BDC           50                         push	ax
09813                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09814 2BDD           E8         DA14            call	_read_byte
09815 2BE0           83C4                   04  add	sp,*4
09816                                           ! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
09817 2BE3           8886       FDE7            mov	-$219[bp],al
09818 2BE7           84C0                       test	al,al
09819 2BE9           75           C4            jne	.238
09820                       00002BEB            .23A:
09821                       00002BEB            .236:
09822                                           ! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
09823 2BEB           8A46         FB            mov	al,-5[bp]
09824 2BEE           30E4                       xor	ah,ah
09825 2BF0           B9                   001E  mov	cx,*$1E
09826 2BF3           F7E9                       imul	cx
09827 2BF5           89C3                       mov	bx,ax
09828                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
09829                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
09830 2BF7           81C3                 0143  add	bx,#$143
09831 2BFB           53                         push	bx
09832                                           ! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
09833 2BFC           FF76         FE            push	-2[bp]
09834                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
09835 2BFF           E8         D9F2            call	_read_byte
09836 2C02           83C4                   04  add	sp,*4
09837                                           ! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
09838 2C05           3C                     05  cmp	al,*5
09839 2C07           75           17            jne 	.23B
09840                       00002C09            .23C:
09841                                           ! 1770             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
09842                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09843 2C09           8A86       FDE5            mov	al,-$21B[bp]
09844 2C0D           30E4                       xor	ah,ah
09845 2C0F           50                         push	ax
09846                                           ! Debug: list * char = .23D+0 (used reg = )
09847 2C10           BB                   D39C  mov	bx,#.23D
09848 2C13           53                         push	bx
09849                                           ! Debug: list int = const 2 (used reg = )
09850 2C14           B8                   0002  mov	ax,*2
09851 2C17           50                         push	ax
09852                                           ! Debug: func () void = bios_printf+0 (used reg = )
09853 2C18           E8         DE00            call	_bios_printf
09854 2C1B           83C4                   06  add	sp,*6
09855                                           !BCC_EOS
09856                                           ! 1771           else
09857                                           ! 1772             bios_printf(2, " ATAPI-%d Device\n",version);
09858 2C1E           EB           15            jmp .23E
09859                       00002C20            .23B:
09860                                           ! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
09861 2C20           8A86       FDE5            mov	al,-$21B[bp]
09862 2C24           30E4                       xor	ah,ah
09863 2C26           50                         push	ax
09864                                           ! Debug: list * char = .23F+0 (used reg = )
09865 2C27           BB                   D38A  mov	bx,#.23F
09866 2C2A           53                         push	bx
09867                                           ! Debug: list int = const 2 (used reg = )
09868 2C2B           B8                   0002  mov	ax,*2
09869 2C2E           50                         push	ax
09870                                           ! Debug: func () void = bios_printf+0 (used reg = )
09871 2C2F           E8         DDE9            call	_bios_printf
09872 2C32           83C4                   06  add	sp,*6
09873                                           !BCC_EOS
09874                                           ! 1773           break;
09875                       00002C35            .23E:
09876 2C35           EB           3A            jmp .21B
09877                                           !BCC_EOS
09878                                           ! 1774         case 0x01:
09879                                           ! 1775           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
09880                       00002C37            .240:
09881 2C37           8A86       FDF4            mov	al,-$20C[bp]
09882 2C3B           84C0                       test	al,al
09883 2C3D           74           05            je  	.244
09884                       00002C3F            .245:
09885 2C3F           BB                   D369  mov	bx,#.242
09886 2C42           EB           03            jmp .246
09887                       00002C44            .244:
09888 2C44           BB                   D362  mov	bx,#.243
09889                       00002C47            .246:
09890                                           ! Debug: list * char = bx+0 (used reg = )
09891 2C47           53                         push	bx
09892                                           ! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
09893 2C48           8A86       FDF5            mov	al,-$20B[bp]
09894 2C4C           30E4                       xor	ah,ah
09895 2C4E           50                         push	ax
09896                                           ! Debug: list * char = .241+0 (used reg = )
09897 2C4F           BB                   D370  mov	bx,#.241
09898 2C52           53                         push	bx
09899                                           ! Debug: list int = const 2 (used reg = )
09900 2C53           B8                   0002  mov	ax,*2
09901 2C56           50                         push	ax
09902                                           ! Debug: func () void = bios_printf+0 (used reg = )
09903 2C57           E8         DDC1            call	_bios_printf
09904 2C5A           83C4                   08  add	sp,*8
09905                                           !BCC_EOS
09906                                           ! 1776           break;
09907 2C5D           EB           12            jmp .21B
09908                                           !BCC_EOS
09909                                           ! 1777         }
09910                                           ! 1778       }
09911 2C5F           EB           10            jmp .21B
09912                       00002C61            .21D:
09913 2C61           2C                     01  sub	al,*1
09914 2C63           74           D2            je 	.240
09915 2C65           2C                     01  sub	al,*1
09916 2C67         0F84         FE54            beq 	.21E
09917 2C6B           2C                     01  sub	al,*1
09918 2C6D         0F84         FF10            beq 	.22F
09919                       00002C71            .21B:
09920                       FFFFFDBA            ..FFFB	=	-$246
09921 2C71           83C4                   32  add	sp,*$32
09922                                           ! 1779     }
09923 2C74           83C4                   0C  add	sp,*$C
09924                                           ! 1780   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
09925                       00002C77            .19C:
09926                                           ! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
09927 2C77           8A46         FB            mov	al,-5[bp]
09928 2C7A           40                         inc	ax
09929 2C7B           8846         FB            mov	-5[bp],al
09930                       00002C7E            .19D:
09931                                           ! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
09932 2C7E           8A46         FB            mov	al,-5[bp]
09933 2C81           3C                     08  cmp	al,*8
09934 2C83         0F82         F2BE            blo 	.19E
09935                       00002C87            .247:
09936                       00002C87            .19B:
09937                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09938 2C87           8A46         FD            mov	al,-3[bp]
09939 2C8A           30E4                       xor	ah,ah
09940 2C8C           50                         push	ax
09941                                           ! Debug: list * unsigned char = const $232 (used reg = )
09942 2C8D           B8                   0232  mov	ax,#$232
09943 2C90           50                         push	ax
09944                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09945 2C91           FF76         FE            push	-2[bp]
09946                                           ! Debug: func () void = write_byte+0 (used reg = )
09947 2C94           E8         D983            call	_write_byte
09948 2C97           83C4                   06  add	sp,*6
09949                                           !BCC_EOS
09950                                           ! 1781   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
09951                                           ! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
09952 2C9A           8A46         FC            mov	al,-4[bp]
09953 2C9D           30E4                       xor	ah,ah
09954 2C9F           50                         push	ax
09955                                           ! Debug: list * unsigned char = const $23B (used reg = )
09956 2CA0           B8                   023B  mov	ax,#$23B
09957 2CA3           50                         push	ax
09958                                           ! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
09959 2CA4           FF76         FE            push	-2[bp]
09960                                           ! Debug: func () void = write_byte+0 (used reg = )
09961 2CA7           E8         D970            call	_write_byte
09962 2CAA           83C4                   06  add	sp,*6
09963                                           !BCC_EOS
09964                                           ! 1782   write_byte(0x40,0x75, hdcount);
09965                                           ! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
09966 2CAD           8A46         FD            mov	al,-3[bp]
09967 2CB0           30E4                       xor	ah,ah
09968 2CB2           50                         push	ax
09969                                           ! Debug: list int = const $75 (used reg = )
09970 2CB3           B8                   0075  mov	ax,*$75
09971 2CB6           50                         push	ax
09972                                           ! Debug: list int = const $40 (used reg = )
09973 2CB7           B8                   0040  mov	ax,*$40
09974 2CBA           50                         push	ax
09975                                           ! Debug: func () void = write_byte+0 (used reg = )
09976 2CBB           E8         D95C            call	_write_byte
09977 2CBE           83C4                   06  add	sp,*6
09978                                           !BCC_EOS
09979                                           ! 1783   bios_printf(2, "\n");
09980                                           ! Debug: list * char = .248+0 (used reg = )
09981 2CC1           BB                   D360  mov	bx,#.248
09982 2CC4           53                         push	bx
09983                                           ! Debug: list int = const 2 (used reg = )
09984 2CC5           B8                   0002  mov	ax,*2
09985 2CC8           50                         push	ax
09986                                           ! Debug: func () void = bios_printf+0 (used reg = )
09987 2CC9           E8         DD4F            call	_bios_printf
09988 2CCC           83C4                   04  add	sp,*4
09989                                           !BCC_EOS
09990                                           ! 1784 }
09991 2CCF           89EC                       mov	sp,bp
09992 2CD1           5D                         pop	bp
09993 2CD2           C3                         ret
09994                                           ! 1785 void ata_reset(device)
09995                                           ! Register BX used in function ata_detect
09996                                           ! 1786 Bit16u device;
09997                                           export	_ata_reset
09998                       00002CD3            _ata_reset:
09999                                           !BCC_EOS
10000                                           ! 1787 {
10001                                           ! 1788   Bit16u ebda_seg=read_word(0x0040,0x000E);
10002 2CD3           55                         push	bp
10003 2CD4           89E5                       mov	bp,sp
10004 2CD6           4C                         dec	sp
10005 2CD7           4C                         dec	sp
10006                                           ! Debug: list int = const $E (used reg = )
10007 2CD8           B8                   000E  mov	ax,*$E
10008 2CDB           50                         push	ax
10009                                           ! Debug: list int = const $40 (used reg = )
10010 2CDC           B8                   0040  mov	ax,*$40
10011 2CDF           50                         push	ax
10012                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10013 2CE0           E8         D924            call	_read_word
10014 2CE3           83C4                   04  add	sp,*4
10015                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10016 2CE6           8946         FE            mov	-2[bp],ax
10017                                           !BCC_EOS
10018                                           ! 1789   Bit16u iobase1, iobase2;
10019                                           !BCC_EOS
10020                                           ! 1790   Bit8u channel, slave, sn, sc;
10021                                           !BCC_EOS
10022                                           ! 1791   Bit8u type;
10023                                           !BCC_EOS
10024                                           ! 1792   Bit16u max;
10025                                           !BCC_EOS
10026                                           ! 1793   channel = device / 2;
10027 2CE9           83C4                   F4  add	sp,*-$C
10028                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10029 2CEC           8B46         04            mov	ax,4[bp]
10030 2CEF           D1E8                       shr	ax,*1
10031                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
10032 2CF1           8846         F9            mov	-7[bp],al
10033                                           !BCC_EOS
10034                                           ! 1794   slave = device % 2;
10035                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10036 2CF4           8B46         04            mov	ax,4[bp]
10037 2CF7           24                     01  and	al,*1
10038                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
10039 2CF9           8846         F8            mov	-8[bp],al
10040                                           !BCC_EOS
10041                                           ! 1795   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10042                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
10043 2CFC           8A46         F9            mov	al,-7[bp]
10044 2CFF           30E4                       xor	ah,ah
10045 2D01           B1                     03  mov	cl,*3
10046 2D03           D3E0                       shl	ax,cl
10047 2D05           89C3                       mov	bx,ax
10048                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10049                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10050 2D07           81C3                 0124  add	bx,#$124
10051 2D0B           53                         push	bx
10052                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10053 2D0C           FF76         FE            push	-2[bp]
10054                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10055 2D0F           E8         D8F5            call	_read_word
10056 2D12           83C4                   04  add	sp,*4
10057                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10058 2D15           8946         FC            mov	-4[bp],ax
10059                                           !BCC_EOS
10060                                           ! 1796   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10061                                           ! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
10062 2D18           8A46         F9            mov	al,-7[bp]
10063 2D1B           30E4                       xor	ah,ah
10064 2D1D           B1                     03  mov	cl,*3
10065 2D1F           D3E0                       shl	ax,cl
10066 2D21           89C3                       mov	bx,ax
10067                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10068                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10069 2D23           81C3                 0126  add	bx,#$126
10070 2D27           53                         push	bx
10071                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10072 2D28           FF76         FE            push	-2[bp]
10073                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10074 2D2B           E8         D8D9            call	_read_word
10075 2D2E           83C4                   04  add	sp,*4
10076                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10077 2D31           8946         FA            mov	-6[bp],ax
10078                                           !BCC_EOS
10079                                           ! 1797   outb(iobase2+6, 0x08 | 0x02 | 0x04);
10080                                           ! Debug: list int = const $E (used reg = )
10081 2D34           B8                   000E  mov	ax,*$E
10082 2D37           50                         push	ax
10083                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10084 2D38           8B46         FA            mov	ax,-6[bp]
10085                                           ! Debug: list unsigned int = ax+6 (used reg = )
10086 2D3B           05                   0006  add	ax,*6
10087 2D3E           50                         push	ax
10088                                           ! Debug: func () void = outb+0 (used reg = )
10089 2D3F           E8         D812            call	_outb
10090 2D42           83C4                   04  add	sp,*4
10091                                           !BCC_EOS
10092                                           ! 1798   outb(0x80, 0x00);
10093                                           ! Debug: list int = const 0 (used reg = )
10094 2D45           31C0                       xor	ax,ax
10095 2D47           50                         push	ax
10096                                           ! Debug: list int = const $80 (used reg = )
10097 2D48           B8                   0080  mov	ax,#$80
10098 2D4B           50                         push	ax
10099                                           ! Debug: func () void = outb+0 (used reg = )
10100 2D4C           E8         D805            call	_outb
10101 2D4F           83C4                   04  add	sp,*4
10102                                           !BCC_EOS
10103                                           ! 1799   outb(iobase2+6, 0x08 | 0x02);
10104                                           ! Debug: list int = const $A (used reg = )
10105 2D52           B8                   000A  mov	ax,*$A
10106 2D55           50                         push	ax
10107                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10108 2D56           8B46         FA            mov	ax,-6[bp]
10109                                           ! Debug: list unsigned int = ax+6 (used reg = )
10110 2D59           05                   0006  add	ax,*6
10111 2D5C           50                         push	ax
10112                                           ! Debug: func () void = outb+0 (used reg = )
10113 2D5D           E8         D7F4            call	_outb
10114 2D60           83C4                   04  add	sp,*4
10115                                           !BCC_EOS
10116                                           ! 1800   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
10117                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10118 2D63           8B46         04            mov	ax,4[bp]
10119 2D66           B9                   001E  mov	cx,*$1E
10120 2D69           F7E9                       imul	cx
10121 2D6B           89C3                       mov	bx,ax
10122                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
10123                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
10124 2D6D           81C3                 0142  add	bx,#$142
10125 2D71           53                         push	bx
10126                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10127 2D72           FF76         FE            push	-2[bp]
10128                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10129 2D75           E8         D87C            call	_read_byte
10130 2D78           83C4                   04  add	sp,*4
10131                                           ! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
10132 2D7B           8846         F5            mov	-$B[bp],al
10133                                           !BCC_EOS
10134                                           ! 1801   if (type != 0x00) {
10135                                           ! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
10136 2D7E           8A46         F5            mov	al,-$B[bp]
10137 2D81           84C0                       test	al,al
10138 2D83         0F84         0084            beq 	.249
10139                       00002D87            .24A:
10140                                           ! 1802     outb(iobase1+6, slave?0xb0:0xa0);
10141 2D87           8A46         F8            mov	al,-8[bp]
10142 2D8A           84C0                       test	al,al
10143 2D8C           74           04            je  	.24B
10144                       00002D8E            .24C:
10145 2D8E           B0                     B0  mov	al,#$B0
10146 2D90           EB           02            jmp .24D
10147                       00002D92            .24B:
10148 2D92           B0                     A0  mov	al,#$A0
10149                       00002D94            .24D:
10150                                           ! Debug: list char = al+0 (used reg = )
10151 2D94           30E4                       xor	ah,ah
10152 2D96           50                         push	ax
10153                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10154 2D97           8B46         FC            mov	ax,-4[bp]
10155                                           ! Debug: list unsigned int = ax+6 (used reg = )
10156 2D9A           05                   0006  add	ax,*6
10157 2D9D           50                         push	ax
10158                                           ! Debug: func () void = outb+0 (used reg = )
10159 2D9E           E8         D7B3            call	_outb
10160 2DA1           83C4                   04  add	sp,*4
10161                                           !BCC_EOS
10162                                           ! 1803     sc = inb(iobase1+2);
10163                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
10164 2DA4           8B46         FC            mov	ax,-4[bp]
10165                                           ! Debug: list unsigned int = ax+2 (used reg = )
10166 2DA7           40                         inc	ax
10167 2DA8           40                         inc	ax
10168 2DA9           50                         push	ax
10169                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10170 2DAA           E8         D791            call	_inb
10171 2DAD           44                         inc	sp
10172 2DAE           44                         inc	sp
10173                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
10174 2DAF           8846         F6            mov	-$A[bp],al
10175                                           !BCC_EOS
10176                                           ! 1804     sn = inb(iobase1+3);
10177                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
10178 2DB2           8B46         FC            mov	ax,-4[bp]
10179                                           ! Debug: list unsigned int = ax+3 (used reg = )
10180 2DB5           05                   0003  add	ax,*3
10181 2DB8           50                         push	ax
10182                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10183 2DB9           E8         D782            call	_inb
10184 2DBC           44                         inc	sp
10185 2DBD           44                         inc	sp
10186                                           ! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
10187 2DBE           8846         F7            mov	-9[bp],al
10188                                           !BCC_EOS
10189                                           ! 1805     if ( (sc==0x01) &&
10190                                           ! 1805  (sn==0x01) ) {
10191                                           ! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
10192 2DC1           8A46         F6            mov	al,-$A[bp]
10193 2DC4           3C                     01  cmp	al,*1
10194 2DC6           75           32            jne 	.24E
10195                       00002DC8            .250:
10196                                           ! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
10197 2DC8           8A46         F7            mov	al,-9[bp]
10198 2DCB           3C                     01  cmp	al,*1
10199 2DCD           75           2B            jne 	.24E
10200                       00002DCF            .24F:
10201                                           ! 1806       if (type == 0x02)
10202                                           ! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
10203 2DCF           8A46         F5            mov	al,-$B[bp]
10204 2DD2           3C                     02  cmp	al,*2
10205 2DD4           75           13            jne 	.251
10206                       00002DD6            .252:
10207                                           ! 1807         await_ide(5, iobase1, 32000u);
10208                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10209 2DD6           B8                   7D00  mov	ax,#$7D00
10210 2DD9           50                         push	ax
10211                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10212 2DDA           FF76         FC            push	-4[bp]
10213                                           ! Debug: list int = const 5 (used reg = )
10214 2DDD           B8                   0005  mov	ax,*5
10215 2DE0           50                         push	ax
10216                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10217 2DE1           E8         EED4            call	_await_ide
10218 2DE4           83C4                   06  add	sp,*6
10219                                           !BCC_EOS
10220                                           ! 1808       else
10221                                           ! 1809         await_ide(2, iobase1, 32000u);
10222 2DE7           EB           11            jmp .253
10223                       00002DE9            .251:
10224                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10225 2DE9           B8                   7D00  mov	ax,#$7D00
10226 2DEC           50                         push	ax
10227                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10228 2DED           FF76         FC            push	-4[bp]
10229                                           ! Debug: list int = const 2 (used reg = )
10230 2DF0           B8                   0002  mov	ax,*2
10231 2DF3           50                         push	ax
10232                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10233 2DF4           E8         EEC1            call	_await_ide
10234 2DF7           83C4                   06  add	sp,*6
10235                                           !BCC_EOS
10236                                           ! 1810     }
10237                       00002DFA            .253:
10238                                           ! 1811     await_ide(2, iobase1, 32000u);
10239                       00002DFA            .24E:
10240                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10241 2DFA           B8                   7D00  mov	ax,#$7D00
10242 2DFD           50                         push	ax
10243                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10244 2DFE           FF76         FC            push	-4[bp]
10245                                           ! Debug: list int = const 2 (used reg = )
10246 2E01           B8                   0002  mov	ax,*2
10247 2E04           50                         push	ax
10248                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10249 2E05           E8         EEB0            call	_await_ide
10250 2E08           83C4                   06  add	sp,*6
10251                                           !BCC_EOS
10252                                           ! 1812   }
10253                                           ! 1813   outb(iobase2+6, 0x08);
10254                       00002E0B            .249:
10255                                           ! Debug: list int = const 8 (used reg = )
10256 2E0B           B8                   0008  mov	ax,*8
10257 2E0E           50                         push	ax
10258                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10259 2E0F           8B46         FA            mov	ax,-6[bp]
10260                                           ! Debug: list unsigned int = ax+6 (used reg = )
10261 2E12           05                   0006  add	ax,*6
10262 2E15           50                         push	ax
10263                                           ! Debug: func () void = outb+0 (used reg = )
10264 2E16           E8         D73B            call	_outb
10265 2E19           83C4                   04  add	sp,*4
10266                                           !BCC_EOS
10267                                           ! 1814 }
10268 2E1C           89EC                       mov	sp,bp
10269 2E1E           5D                         pop	bp
10270 2E1F           C3                         ret
10271                                           ! 1815 Bit16u ata_cmd_non_data()
10272                                           ! Register BX used in function ata_reset
10273                                           ! 1816 {return 0;}
10274                                           export	_ata_cmd_non_data
10275                       00002E20            _ata_cmd_non_data:
10276 2E20           55                         push	bp
10277 2E21           89E5                       mov	bp,sp
10278 2E23           31C0                       xor	ax,ax
10279 2E25           5D                         pop	bp
10280 2E26           C3                         ret
10281                                           !BCC_EOS
10282                                           ! 1817 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
10283                                           ! 1818 Bit16u device, command, count, cylinder, head, sector, segment, offset;
10284                                           export	_ata_cmd_data_in
10285                       00002E27            _ata_cmd_data_in:
10286                                           !BCC_EOS
10287                                           ! 1819 Bit32u lba_low, lba_high;
10288                                           !BCC_EOS
10289                                           ! 1820 {
10290                                           ! 1821   Bit16u ebda_seg=read_word(0x0040,0x000E);
10291 2E27           55                         push	bp
10292 2E28           89E5                       mov	bp,sp
10293 2E2A           4C                         dec	sp
10294 2E2B           4C                         dec	sp
10295                                           ! Debug: list int = const $E (used reg = )
10296 2E2C           B8                   000E  mov	ax,*$E
10297 2E2F           50                         push	ax
10298                                           ! Debug: list int = const $40 (used reg = )
10299 2E30           B8                   0040  mov	ax,*$40
10300 2E33           50                         push	ax
10301                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10302 2E34           E8         D7D0            call	_read_word
10303 2E37           83C4                   04  add	sp,*4
10304                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
10305 2E3A           8946         FE            mov	-2[bp],ax
10306                                           !BCC_EOS
10307                                           ! 1822   Bit16u iobase1, iobase2, blksize;
10308                                           !BCC_EOS
10309                                           ! 1823   Bit8u channel, slave;
10310                                           !BCC_EOS
10311                                           ! 1824   Bit8u status, current, mode;
10312                                           !BCC_EOS
10313                                           ! 1825   channel = device / 2;
10314 2E3D           83C4                   F4  add	sp,*-$C
10315                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10316 2E40           8B46         04            mov	ax,4[bp]
10317 2E43           D1E8                       shr	ax,*1
10318                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
10319 2E45           8846         F7            mov	-9[bp],al
10320                                           !BCC_EOS
10321                                           ! 1826   slave = device % 2;
10322                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
10323 2E48           8B46         04            mov	ax,4[bp]
10324 2E4B           24                     01  and	al,*1
10325                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
10326 2E4D           8846         F6            mov	-$A[bp],al
10327                                           !BCC_EOS
10328                                           ! 1827   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
10329                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10330 2E50           8A46         F7            mov	al,-9[bp]
10331 2E53           30E4                       xor	ah,ah
10332 2E55           B1                     03  mov	cl,*3
10333 2E57           D3E0                       shl	ax,cl
10334 2E59           89C3                       mov	bx,ax
10335                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
10336                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
10337 2E5B           81C3                 0124  add	bx,#$124
10338 2E5F           53                         push	bx
10339                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10340 2E60           FF76         FE            push	-2[bp]
10341                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10342 2E63           E8         D7A1            call	_read_word
10343 2E66           83C4                   04  add	sp,*4
10344                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
10345 2E69           8946         FC            mov	-4[bp],ax
10346                                           !BCC_EOS
10347                                           ! 1828   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
10348                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
10349 2E6C           8A46         F7            mov	al,-9[bp]
10350 2E6F           30E4                       xor	ah,ah
10351 2E71           B1                     03  mov	cl,*3
10352 2E73           D3E0                       shl	ax,cl
10353 2E75           89C3                       mov	bx,ax
10354                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
10355                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
10356 2E77           81C3                 0126  add	bx,#$126
10357 2E7B           53                         push	bx
10358                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10359 2E7C           FF76         FE            push	-2[bp]
10360                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
10361 2E7F           E8         D785            call	_read_word
10362 2E82           83C4                   04  add	sp,*4
10363                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
10364 2E85           8946         FA            mov	-6[bp],ax
10365                                           !BCC_EOS
10366                                           ! 1829   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
10367                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
10368 2E88           8B46         04            mov	ax,4[bp]
10369 2E8B           B9                   001E  mov	cx,*$1E
10370 2E8E           F7E9                       imul	cx
10371 2E90           89C3                       mov	bx,ax
10372                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
10373                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
10374 2E92           81C3                 0146  add	bx,#$146
10375 2E96           53                         push	bx
10376                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
10377 2E97           FF76         FE            push	-2[bp]
10378                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
10379 2E9A           E8         D757            call	_read_byte
10380 2E9D           83C4                   04  add	sp,*4
10381                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
10382 2EA0           8846         F3            mov	-$D[bp],al
10383                                           !BCC_EOS
10384                                           ! 1830   blksize = 0x200;
10385                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
10386 2EA3           B8                   0200  mov	ax,#$200
10387 2EA6           8946         F8            mov	-8[bp],ax
10388                                           !BCC_EOS
10389                                           ! 1831   if (mode == 0x01) blksize>>=2;
10390                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
10391 2EA9           8A46         F3            mov	al,-$D[bp]
10392 2EAC           3C                     01  cmp	al,*1
10393 2EAE           75           0C            jne 	.254
10394                       00002EB0            .255:
10395                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
10396 2EB0           8B46         F8            mov	ax,-8[bp]
10397 2EB3           D1E8                       shr	ax,*1
10398 2EB5           D1E8                       shr	ax,*1
10399 2EB7           8946         F8            mov	-8[bp],ax
10400                                           !BCC_EOS
10401                                           ! 1832   else blksize>>=1;
10402 2EBA           EB           08            jmp .256
10403                       00002EBC            .254:
10404                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
10405 2EBC           8B46         F8            mov	ax,-8[bp]
10406 2EBF           D1E8                       shr	ax,*1
10407 2EC1           8946         F8            mov	-8[bp],ax
10408                                           !BCC_EOS
10409                                           ! 1833   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
10410                       00002EC4            .256:
10411                                           ! Debug: list int = const 0 (used reg = )
10412 2EC4           31C0                       xor	ax,ax
10413 2EC6           50                         push	ax
10414                                           ! Debug: list * unsigned short = const $254 (used reg = )
10415 2EC7           B8                   0254  mov	ax,#$254
10416 2ECA           50                         push	ax
10417                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
10418 2ECB           FF76         FE            push	-2[bp]
10419                                           ! Debug: func () void = write_word+0 (used reg = )
10420 2ECE           E8         D761            call	_write_word
10421 2ED1           83C4                   06  add	sp,*6
10422                                           !BCC_EOS
10423                                           ! 1834   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
10424                                           ! Debug: list long = const 0 (used reg = )
10425 2ED4           31C0                       xor	ax,ax
10426 2ED6           31DB                       xor	bx,bx
10427 2ED8           53                         push	bx
10428 2ED9           50                         push	ax
10429                                           ! Debug: list * unsigned long = const $256 (used reg = )
10430 2EDA           B8                   0256  mov	ax,#$256
10431 2EDD           50                         push	ax
10432                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
10433 2EDE           FF76         FE            push	-2[bp]
10434                                           ! Debug: func () void = write_dword+0 (used reg = )
10435 2EE1           E8         D1B7            call	_write_dword
10436 2EE4           83C4                   08  add	sp,*8
10437                                           !BCC_EOS
10438                                           ! 1835   current = 0;
10439                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
10440 2EE7           30C0                       xor	al,al
10441 2EE9           8846         F4            mov	-$C[bp],al
10442                                           !BCC_EOS
10443                                           ! 1836   status = inb(iobase1 + 7);
10444                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
10445 2EEC           8B46         FC            mov	ax,-4[bp]
10446                                           ! Debug: list unsigned int = ax+7 (used reg = )
10447 2EEF           05                   0007  add	ax,*7
10448 2EF2           50                         push	ax
10449                                           ! Debug: func () unsigned char = inb+0 (used reg = )
10450 2EF3           E8         D648            call	_inb
10451 2EF6           44                         inc	sp
10452 2EF7           44                         inc	sp
10453                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10454 2EF8           8846         F5            mov	-$B[bp],al
10455                                           !BCC_EOS
10456                                           ! 1837   if (status & 0x80) return 1;
10457                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
10458 2EFB           8A46         F5            mov	al,-$B[bp]
10459 2EFE           24                     80  and	al,#$80
10460 2F00           84C0                       test	al,al
10461 2F02           74           07            je  	.257
10462                       00002F04            .258:
10463 2F04           B8                   0001  mov	ax,*1
10464 2F07           89EC                       mov	sp,bp
10465 2F09           5D                         pop	bp
10466 2F0A           C3                         ret
10467                                           !BCC_EOS
10468                                           ! 1838   outb(iobase2 + 6, 0x08 | 0x02);
10469                       00002F0B            .257:
10470                                           ! Debug: list int = const $A (used reg = )
10471 2F0B           B8                   000A  mov	ax,*$A
10472 2F0E           50                         push	ax
10473                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
10474 2F0F           8B46         FA            mov	ax,-6[bp]
10475                                           ! Debug: list unsigned int = ax+6 (used reg = )
10476 2F12           05                   0006  add	ax,*6
10477 2F15           50                         push	ax
10478                                           ! Debug: func () void = outb+0 (used reg = )
10479 2F16           E8         D63B            call	_outb
10480 2F19           83C4                   04  add	sp,*4
10481                                           !BCC_EOS
10482                                           ! 1839   if (sector == 0) {
10483                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
10484 2F1C           8B46         0E            mov	ax,$E[bp]
10485 2F1F           85C0                       test	ax,ax
10486 2F21         0F85         0167            bne 	.259
10487                       00002F25            .25A:
10488                                           ! 1840     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
10489                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
10490 2F25           8B46         08            mov	ax,8[bp]
10491 2F28           3D                   0100  cmp	ax,#$100
10492 2F2B           72           04            jb 	.25F
10493 2F2D           B0                     01  mov	al,*1
10494 2F2F           EB           02            jmp	.260
10495                       00002F31            .25F:
10496 2F31           30C0                       xor	al,al
10497                       00002F33            .260:
10498                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
10499 2F33           30E4                       xor	ah,ah
10500 2F35           99                         cwd
10501 2F36           89D3                       mov	bx,dx
10502 2F38           E8         D1D9            call	ltstl
10503 2F3B           75           32            jne 	.25C
10504                       00002F3D            .25E:
10505 2F3D           8B46         14            mov	ax,$14[bp]
10506 2F40           8B5E         16            mov	bx,$16[bp]
10507 2F43           E8         D1CE            call	ltstl
10508 2F46           75           27            jne 	.25C
10509                       00002F48            .25D:
10510                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
10511 2F48           8B46         08            mov	ax,8[bp]
10512 2F4B           31DB                       xor	bx,bx
10513                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
10514                                           ! Debug: expression subtree swapping
10515 2F4D           8D7E         10            lea	di,$10[bp]
10516 2F50           E8         D170            call	laddul
10517                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
10518 2F53           53                         push	bx
10519 2F54           50                         push	ax
10520 2F55           31C0                       xor	ax,ax
10521 2F57           BB                   1000  mov	bx,#$1000
10522 2F5A           53                         push	bx
10523 2F5B           50                         push	ax
10524 2F5C           8B46         EE            mov	ax,-$12[bp]
10525 2F5F           8B5E         F0            mov	bx,-$10[bp]
10526 2F62           8D7E         EA            lea	di,-$16[bp]
10527 2F65           E8         D163            call	lcmpul
10528 2F68           8D66         F2            lea	sp,-$E[bp]
10529 2F6B         0F82         00BC            blo 	.25B
10530                       00002F6F            .25C:
10531                                           ! 1841       outb(iobase1 + 1, 0x00);
10532                                           ! Debug: list int = const 0 (used reg = )
10533 2F6F           31C0                       xor	ax,ax
10534 2F71           50                         push	ax
10535                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10536 2F72           8B46         FC            mov	ax,-4[bp]
10537                                           ! Debug: list unsigned int = ax+1 (used reg = )
10538 2F75           40                         inc	ax
10539 2F76           50                         push	ax
10540                                           ! Debug: func () void = outb+0 (used reg = )
10541 2F77           E8         D5DA            call	_outb
10542 2F7A           83C4                   04  add	sp,*4
10543                                           !BCC_EOS
10544                                           ! 1842       outb(iobase1 + 2, (count >> 8) & 0xff);
10545                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
10546 2F7D           8B46         08            mov	ax,8[bp]
10547 2F80           88E0                       mov	al,ah
10548 2F82           30E4                       xor	ah,ah
10549                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
10550                                           ! Debug: list unsigned char = al+0 (used reg = )
10551 2F84           30E4                       xor	ah,ah
10552 2F86           50                         push	ax
10553                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10554 2F87           8B46         FC            mov	ax,-4[bp]
10555                                           ! Debug: list unsigned int = ax+2 (used reg = )
10556 2F8A           40                         inc	ax
10557 2F8B           40                         inc	ax
10558 2F8C           50                         push	ax
10559                                           ! Debug: func () void = outb+0 (used reg = )
10560 2F8D           E8         D5C4            call	_outb
10561 2F90           83C4                   04  add	sp,*4
10562                                           !BCC_EOS
10563                                           ! 1843       outb(iobase1 + 3, lba_low >> 24);
10564                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10565 2F93           8B46         10            mov	ax,$10[bp]
10566 2F96           8B5E         12            mov	bx,$12[bp]
10567 2F99           93                         xchg	bx,ax
10568 2F9A           88E0                       mov	al,ah
10569 2F9C           30E4                       xor	ah,ah
10570 2F9E           31DB                       xor	bx,bx
10571                                           ! Debug: list unsigned long = bx+0 (used reg = )
10572 2FA0           53                         push	bx
10573 2FA1           50                         push	ax
10574                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
10575 2FA2           8B46         FC            mov	ax,-4[bp]
10576                                           ! Debug: list unsigned int = ax+3 (used reg = )
10577 2FA5           05                   0003  add	ax,*3
10578 2FA8           50                         push	ax
10579                                           ! Debug: func () void = outb+0 (used reg = )
10580 2FA9           E8         D5A8            call	_outb
10581 2FAC           83C4                   06  add	sp,*6
10582                                           !BCC_EOS
10583                                           ! 1844       outb(iobase1 + 4, lba_high & 0xff);
10584                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
10585                                           ! Debug: expression subtree swapping
10586 2FAF           B8                   00FF  mov	ax,#$FF
10587 2FB2           31DB                       xor	bx,bx
10588 2FB4           8D7E         14            lea	di,$14[bp]
10589 2FB7           E8         D101            call	landul
10590                                           ! Debug: list unsigned long = bx+0 (used reg = )
10591 2FBA           53                         push	bx
10592 2FBB           50                         push	ax
10593                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
10594 2FBC           8B46         FC            mov	ax,-4[bp]
10595                                           ! Debug: list unsigned int = ax+4 (used reg = )
10596 2FBF           05                   0004  add	ax,*4
10597 2FC2           50                         push	ax
10598                                           ! Debug: func () void = outb+0 (used reg = )
10599 2FC3           E8         D58E            call	_outb
10600 2FC6           83C4                   06  add	sp,*6
10601                                           !BCC_EOS
10602                                           ! 1845       outb(iobase1 + 5, lba_high >> 8);
10603                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
10604 2FC9           8B46         14            mov	ax,$14[bp]
10605 2FCC           8B5E         16            mov	bx,$16[bp]
10606 2FCF           88E0                       mov	al,ah
10607 2FD1           88DC                       mov	ah,bl
10608 2FD3           88FB                       mov	bl,bh
10609 2FD5           28FF                       sub	bh,bh
10610                                           ! Debug: list unsigned long = bx+0 (used reg = )
10611 2FD7           53                         push	bx
10612 2FD8           50                         push	ax
10613                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
10614 2FD9           8B46         FC            mov	ax,-4[bp]
10615                                           ! Debug: list unsigned int = ax+5 (used reg = )
10616 2FDC           05                   0005  add	ax,*5
10617 2FDF           50                         push	ax
10618                                           ! Debug: func () void = outb+0 (used reg = )
10619 2FE0           E8         D571            call	_outb
10620 2FE3           83C4                   06  add	sp,*6
10621                                           !BCC_EOS
10622                                           ! 1846       command |= 0x04;
10623                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
10624 2FE6           8B46         06            mov	ax,6[bp]
10625 2FE9           0C                     04  or	al,*4
10626 2FEB           8946         06            mov	6[bp],ax
10627                                           !BCC_EOS
10628                                           ! 1847       count &= (1UL << 8) - 1;
10629                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
10630 2FEE           8B46         08            mov	ax,8[bp]
10631 2FF1           31DB                       xor	bx,bx
10632 2FF3           53                         push	bx
10633 2FF4           50                         push	ax
10634 2FF5           B8                   00FF  mov	ax,#$FF
10635 2FF8           31DB                       xor	bx,bx
10636 2FFA           53                         push	bx
10637 2FFB           50                         push	ax
10638 2FFC           8B46         EE            mov	ax,-$12[bp]
10639 2FFF           8B5E         F0            mov	bx,-$10[bp]
10640 3002           8D7E         EA            lea	di,-$16[bp]
10641 3005           E8         D0B3            call	landul
10642 3008           8946         08            mov	8[bp],ax
10643 300B           83C4                   08  add	sp,*8
10644                                           !BCC_EOS
10645                                           ! 1848       lba_low &= (1UL << 24) - 1;
10646                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
10647 300E           B8                   FFFF  mov	ax,#$FFFF
10648 3011           BB                   00FF  mov	bx,#$FF
10649 3014           53                         push	bx
10650 3015           50                         push	ax
10651 3016           8B46         10            mov	ax,$10[bp]
10652 3019           8B5E         12            mov	bx,$12[bp]
10653 301C           8D7E         EE            lea	di,-$12[bp]
10654 301F           E8         D099            call	landul
10655 3022           8946         10            mov	$10[bp],ax
10656 3025           895E         12            mov	$12[bp],bx
10657 3028           83C4                   04  add	sp,*4
10658                                           !BCC_EOS
10659                                           ! 1849       }
10660                                           ! 1850     sector = (Bit16u) (lba_low & 0x000000ffL);
10661                       0000302B            .25B:
10662                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
10663                                           ! Debug: expression subtree swapping
10664 302B           B8                   00FF  mov	ax,#$FF
10665 302E           31DB                       xor	bx,bx
10666 3030           8D7E         10            lea	di,$10[bp]
10667 3033           E8         D085            call	landul
10668                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10669                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
10670 3036           8946         0E            mov	$E[bp],ax
10671                                           !BCC_EOS
10672                                           ! 1851     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
10673                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
10674 3039           8B46         10            mov	ax,$10[bp]
10675 303C           8B5E         12            mov	bx,$12[bp]
10676 303F           88E0                       mov	al,ah
10677 3041           88DC                       mov	ah,bl
10678 3043           88FB                       mov	bl,bh
10679 3045           28FF                       sub	bh,bh
10680                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
10681 3047           53                         push	bx
10682 3048           50                         push	ax
10683 3049           B8                   FFFF  mov	ax,#$FFFF
10684 304C           31DB                       xor	bx,bx
10685 304E           53                         push	bx
10686 304F           50                         push	ax
10687 3050           8B46         EE            mov	ax,-$12[bp]
10688 3053           8B5E         F0            mov	bx,-$10[bp]
10689 3056           8D7E         EA            lea	di,-$16[bp]
10690 3059           E8         D05F            call	landul
10691 305C           83C4                   08  add	sp,*8
10692                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10693                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
10694 305F           8946         0A            mov	$A[bp],ax
10695                                           !BCC_EOS
10696                                           ! 1852     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
10697                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
10698 3062           8B46         10            mov	ax,$10[bp]
10699 3065           8B5E         12            mov	bx,$12[bp]
10700 3068           93                         xchg	bx,ax
10701 3069           88E0                       mov	al,ah
10702 306B           30E4                       xor	ah,ah
10703 306D           31DB                       xor	bx,bx
10704                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
10705 306F           53                         push	bx
10706 3070           50                         push	ax
10707 3071           B8                   000F  mov	ax,*$F
10708 3074           31DB                       xor	bx,bx
10709 3076           53                         push	bx
10710 3077           50                         push	ax
10711 3078           8B46         EE            mov	ax,-$12[bp]
10712 307B           8B5E         F0            mov	bx,-$10[bp]
10713 307E           8D7E         EA            lea	di,-$16[bp]
10714 3081           E8         D037            call	landul
10715 3084           83C4                   08  add	sp,*8
10716                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
10717                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
10718 3087           0C                     40  or	al,*$40
10719                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
10720 3089           8946         0C            mov	$C[bp],ax
10721                                           !BCC_EOS
10722                                           ! 1853   }
10723                                           ! 1854   outb(iobase1 + 1, 0x00);
10724                       0000308C            .259:
10725                                           ! Debug: list int = const 0 (used reg = )
10726 308C           31C0                       xor	ax,ax
10727 308E           50                         push	ax
10728                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
10729 308F           8B46         FC            mov	ax,-4[bp]
10730                                           ! Debug: list unsigned int = ax+1 (used reg = )
10731 3092           40                         inc	ax
10732 3093           50                         push	ax
10733                                           ! Debug: func () void = outb+0 (used reg = )
10734 3094           E8         D4BD            call	_outb
10735 3097           83C4                   04  add	sp,*4
10736                                           !BCC_EOS
10737                                           ! 1855   outb(iobase1 + 2, count);
10738                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
10739 309A           FF76         08            push	8[bp]
10740                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
10741 309D           8B46         FC            mov	ax,-4[bp]
10742                                           ! Debug: list unsigned int = ax+2 (used reg = )
10743 30A0           40                         inc	ax
10744 30A1           40                         inc	ax
10745 30A2           50                         push	ax
10746                                           ! Debug: func () void = outb+0 (used reg = )
10747 30A3           E8         D4AE            call	_outb
10748 30A6           83C4                   04  add	sp,*4
10749                                           !BCC_EOS
10750                                           ! 1856   outb(iobase1 + 3, sector);
10751                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
10752 30A9           FF76         0E            push	$E[bp]
10753                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
10754 30AC           8B46         FC            mov	ax,-4[bp]
10755                                           ! Debug: list unsigned int = ax+3 (used reg = )
10756 30AF           05                   0003  add	ax,*3
10757 30B2           50                         push	ax
10758                                           ! Debug: func () void = outb+0 (used reg = )
10759 30B3           E8         D49E            call	_outb
10760 30B6           83C4                   04  add	sp,*4
10761                                           !BCC_EOS
10762                                           ! 1857   outb(iobase1 + 4, cylinder & 0x00ff);
10763                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
10764 30B9           8A46         0A            mov	al,$A[bp]
10765                                           ! Debug: list unsigned char = al+0 (used reg = )
10766 30BC           30E4                       xor	ah,ah
10767 30BE           50                         push	ax
10768                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
10769 30BF           8B46         FC            mov	ax,-4[bp]
10770                                           ! Debug: list unsigned int = ax+4 (used reg = )
10771 30C2           05                   0004  add	ax,*4
10772 30C5           50                         push	ax
10773                                           ! Debug: func () void = outb+0 (used reg = )
10774 30C6           E8         D48B            call	_outb
10775 30C9           83C4                   04  add	sp,*4
10776                                           !BCC_EOS
10777                                           ! 1858   outb(iobase1 + 5, cylinder >> 8);
10778                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
10779 30CC           8B46         0A            mov	ax,$A[bp]
10780 30CF           88E0                       mov	al,ah
10781 30D1           30E4                       xor	ah,ah
10782                                           ! Debug: list unsigned int = ax+0 (used reg = )
10783 30D3           50                         push	ax
10784                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
10785 30D4           8B46         FC            mov	ax,-4[bp]
10786                                           ! Debug: list unsigned int = ax+5 (used reg = )
10787 30D7           05                   0005  add	ax,*5
10788 30DA           50                         push	ax
10789                                           ! Debug: func () void = outb+0 (used reg = )
10790 30DB           E8         D476            call	_outb
10791 30DE           83C4                   04  add	sp,*4
10792                                           !BCC_EOS
10793                                           ! 1859   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
10794 30E1           8A46         F6            mov	al,-$A[bp]
10795 30E4           84C0                       test	al,al
10796 30E6           74           04            je  	.262
10797                       000030E8            .263:
10798 30E8           B0                     B0  mov	al,#$B0
10799 30EA           EB           02            jmp .264
10800                       000030EC            .262:
10801 30EC           B0                     A0  mov	al,#$A0
10802                       000030EE            .264:
10803                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
10804 30EE           0A46         0C            or	al,$C[bp]
10805                                           ! Debug: list unsigned char = al+0 (used reg = )
10806 30F1           30E4                       xor	ah,ah
10807 30F3           50                         push	ax
10808                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
10809 30F4           8B46         FC            mov	ax,-4[bp]
10810                                           ! Debug: list unsigned int = ax+6 (used reg = )
10811 30F7           05                   0006  add	ax,*6
10812 30FA           50                         push	ax
10813                                           ! Debug: func () void = outb+0 (used reg = )
10814 30FB           E8         D456            call	_outb
10815 30FE           83C4                   04  add	sp,*4
10816                                           !BCC_EOS
10817                                           ! 1860   outb(iobase1 + 7, command);
10818                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
10819 3101           FF76         06            push	6[bp]
10820                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
10821 3104           8B46         FC            mov	ax,-4[bp]
10822                                           ! Debug: list unsigned int = ax+7 (used reg = )
10823 3107           05                   0007  add	ax,*7
10824 310A           50                         push	ax
10825                                           ! Debug: func () void = outb+0 (used reg = )
10826 310B           E8         D446            call	_outb
10827 310E           83C4                   04  add	sp,*4
10828                                           !BCC_EOS
10829                                           ! 1861   status = await_ide(3, iobase1, 32000u);
10830                                           ! Debug: list unsigned int = const $7D00 (used reg = )
10831 3111           B8                   7D00  mov	ax,#$7D00
10832 3114           50                         push	ax
10833                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
10834 3115           FF76         FC            push	-4[bp]
10835                                           ! Debug: list int = const 3 (used reg = )
10836 3118           B8                   0003  mov	ax,*3
10837 311B           50                         push	ax
10838                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
10839 311C           E8         EB99            call	_await_ide
10840 311F           83C4                   06  add	sp,*6
10841                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
10842 3122           8846         F5            mov	-$B[bp],al
10843                                           !BCC_EOS
10844                                           ! 1862   if (status
10845                                           ! 1862  & 0x01) {
10846                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
10847 3125           8A46         F5            mov	al,-$B[bp]
10848 3128           24                     01  and	al,*1
10849 312A           84C0                       test	al,al
10850 312C           74           09            je  	.265
10851                       0000312E            .266:
10852                                           ! 1863     ;
10853                                           !BCC_EOS
10854                                           ! 1864     return 2;
10855 312E           B8                   0002  mov	ax,*2
10856 3131           89EC                       mov	sp,bp
10857 3133           5D                         pop	bp
10858 3134           C3                         ret
10859                                           !BCC_EOS
10860                                           ! 1865     } else if ( !(status & 0x08) ) {
10861 3135           EB           10            jmp .267
10862                       00003137            .265:
10863                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
10864 3137           8A46         F5            mov	al,-$B[bp]
10865 313A           24                     08  and	al,*8
10866 313C           84C0                       test	al,al
10867 313E           75           07            jne 	.268
10868                       00003140            .269:
10869                                           ! 1866     ;
10870                                           !BCC_EOS
10871                                           ! 1867     return 3;
10872 3140           B8                   0003  mov	ax,*3
10873 3143           89EC                       mov	sp,bp
10874 3145           5D                         pop	bp
10875 3146           C3                         ret
10876                                           !BCC_EOS
10877                                           ! 1868   }
10878                                           ! 1869 #asm
10879                       00003147            .268:
10880                       00003147            .267:
10881                                           !BCC_EOS
10882                                           !BCC_ASM
10883                       00000016            _ata_cmd_data_in.count	set	$16
10884                       00000008            .ata_cmd_data_in.count	set	8
10885                       00000026            _ata_cmd_data_in.segment	set	$26
10886                       00000018            .ata_cmd_data_in.segment	set	$18
10887                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10888                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10889                       00000005            _ata_cmd_data_in.channel	set	5
10890                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10891                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10892                       00000010            .ata_cmd_data_in.lba_low	set	$10
10893                       00000022            _ata_cmd_data_in.lba_high	set	$22
10894                       00000014            .ata_cmd_data_in.lba_high	set	$14
10895                       0000001C            _ata_cmd_data_in.sector	set	$1C
10896                       0000000E            .ata_cmd_data_in.sector	set	$E
10897                       00000006            _ata_cmd_data_in.blksize	set	6
10898                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10899                       0000001A            _ata_cmd_data_in.head	set	$1A
10900                       0000000C            .ata_cmd_data_in.head	set	$C
10901                       00000018            _ata_cmd_data_in.cylinder	set	$18
10902                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10903                       00000012            _ata_cmd_data_in.device	set	$12
10904                       00000004            .ata_cmd_data_in.device	set	4
10905                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10906                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10907                       00000003            _ata_cmd_data_in.status	set	3
10908                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10909                       00000002            _ata_cmd_data_in.current	set	2
10910                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10911                       00000014            _ata_cmd_data_in.command	set	$14
10912                       00000006            .ata_cmd_data_in.command	set	6
10913                       00000001            _ata_cmd_data_in.mode	set	1
10914                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10915                       00000008            _ata_cmd_data_in.iobase2	set	8
10916                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10917                       00000028            _ata_cmd_data_in.offset	set	$28
10918                       0000001A            .ata_cmd_data_in.offset	set	$1A
10919                       00000004            _ata_cmd_data_in.slave	set	4
10920                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10921 3147           FB                                 sti ;; enable higher priority interrupts
10922                                           ! 1871 endasm
10923                                           !BCC_ENDASM
10924                                           !BCC_EOS
10925                                           ! 1872   while (1) {
10926                       00003148            .26C:
10927                                           ! 1873 #asm
10928                                           !BCC_EOS
10929                                           !BCC_ASM
10930                       00000016            _ata_cmd_data_in.count	set	$16
10931                       00000008            .ata_cmd_data_in.count	set	8
10932                       00000026            _ata_cmd_data_in.segment	set	$26
10933                       00000018            .ata_cmd_data_in.segment	set	$18
10934                       0000000A            _ata_cmd_data_in.iobase1	set	$A
10935                       FFFFFFFC            .ata_cmd_data_in.iobase1	set	-4
10936                       00000005            _ata_cmd_data_in.channel	set	5
10937                       FFFFFFF7            .ata_cmd_data_in.channel	set	-9
10938                       0000001E            _ata_cmd_data_in.lba_low	set	$1E
10939                       00000010            .ata_cmd_data_in.lba_low	set	$10
10940                       00000022            _ata_cmd_data_in.lba_high	set	$22
10941                       00000014            .ata_cmd_data_in.lba_high	set	$14
10942                       0000001C            _ata_cmd_data_in.sector	set	$1C
10943                       0000000E            .ata_cmd_data_in.sector	set	$E
10944                       00000006            _ata_cmd_data_in.blksize	set	6
10945                       FFFFFFF8            .ata_cmd_data_in.blksize	set	-8
10946                       0000001A            _ata_cmd_data_in.head	set	$1A
10947                       0000000C            .ata_cmd_data_in.head	set	$C
10948                       00000018            _ata_cmd_data_in.cylinder	set	$18
10949                       0000000A            .ata_cmd_data_in.cylinder	set	$A
10950                       00000012            _ata_cmd_data_in.device	set	$12
10951                       00000004            .ata_cmd_data_in.device	set	4
10952                       0000000C            _ata_cmd_data_in.ebda_seg	set	$C
10953                       FFFFFFFE            .ata_cmd_data_in.ebda_seg	set	-2
10954                       00000003            _ata_cmd_data_in.status	set	3
10955                       FFFFFFF5            .ata_cmd_data_in.status	set	-$B
10956                       00000002            _ata_cmd_data_in.current	set	2
10957                       FFFFFFF4            .ata_cmd_data_in.current	set	-$C
10958                       00000014            _ata_cmd_data_in.command	set	$14
10959                       00000006            .ata_cmd_data_in.command	set	6
10960                       00000001            _ata_cmd_data_in.mode	set	1
10961                       FFFFFFF3            .ata_cmd_data_in.mode	set	-$D
10962                       00000008            _ata_cmd_data_in.iobase2	set	8
10963                       FFFFFFFA            .ata_cmd_data_in.iobase2	set	-6
10964                       00000028            _ata_cmd_data_in.offset	set	$28
10965                       0000001A            .ata_cmd_data_in.offset	set	$1A
10966                       00000004            _ata_cmd_data_in.slave	set	4
10967                       FFFFFFF6            .ata_cmd_data_in.slave	set	-$A
10968 3148           55                                 push bp
10969 3149           89E5                               mov bp, sp
10970 314B           8B7E         2A                    mov di, _ata_cmd_data_in.offset + 2[bp]
10971 314E           8B46         28                    mov ax, _ata_cmd_data_in.segment + 2[bp]
10972 3151           8B4E         08                    mov cx, _ata_cmd_data_in.blksize + 2[bp]
10973                                                   ;; adjust if there will be an overrun. 2K max sector size
10974 3154           81FF                 F800          cmp di, #0xf800 ;;
10975 3158           76           07                    jbe ata_in_no_adjust
10976                       0000315A            ata_in_adjust:
10977 315A           81EF                 0800          sub di, #0x0800 ;; sub 2 kbytes from offset
10978 315E           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
10979                       00003161            ata_in_no_adjust:
10980 3161           8EC0                               mov es, ax ;; segment in es
10981 3163           8B56         0C                    mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
10982 3166           8A66         03                    mov ah, _ata_cmd_data_in.mode + 2[bp]
10983 3169           80FC                   01          cmp ah, #0x01
10984 316C           74           04                    je ata_in_32
10985                       0000316E            ata_in_16:
10986 316E           F3                                 rep
10987 316F           6D                                   insw ;; CX words transfered from port(DX) to ES:[DI]
10988 3170           EB           03                    jmp ata_in_done
10989                       00003172            ata_in_32:
10990 3172           F3                                 rep
10991 3173     66    6D                                   insd ;; CX dwords transfered from port(DX) to ES:[DI]
10992                       00003175            ata_in_done:
10993 3175           897E         2A                    mov _ata_cmd_data_in.offset + 2[bp], di
10994 3178           8C46         28                    mov _ata_cmd_data_in.segment + 2[bp], es
10995 317B           5D                                 pop bp
10996                                           ! 1902 endasm
10997                                           !BCC_ENDASM
10998                                           !BCC_EOS
10999                                           ! 1903     current++;
11000                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11001 317C           8A46         F4            mov	al,-$C[bp]
11002 317F           40                         inc	ax
11003 3180           8846         F4            mov	-$C[bp],al
11004                                           !BCC_EOS
11005                                           ! 1904     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
11006                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11007 3183           8A46         F4            mov	al,-$C[bp]
11008 3186           30E4                       xor	ah,ah
11009 3188           50                         push	ax
11010                                           ! Debug: list * unsigned short = const $254 (used reg = )
11011 3189           B8                   0254  mov	ax,#$254
11012 318C           50                         push	ax
11013                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11014 318D           FF76         FE            push	-2[bp]
11015                                           ! Debug: func () void = write_word+0 (used reg = )
11016 3190           E8         D49F            call	_write_word
11017 3193           83C4                   06  add	sp,*6
11018                                           !BCC_EOS
11019                                           ! 1905     count--;
11020                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11021 3196           8B46         08            mov	ax,8[bp]
11022 3199           48                         dec	ax
11023 319A           8946         08            mov	8[bp],ax
11024                                           !BCC_EOS
11025                                           ! 1906     status = await_ide(2, iobase1, 32000u);
11026                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11027 319D           B8                   7D00  mov	ax,#$7D00
11028 31A0           50                         push	ax
11029                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11030 31A1           FF76         FC            push	-4[bp]
11031                                           ! Debug: list int = const 2 (used reg = )
11032 31A4           B8                   0002  mov	ax,*2
11033 31A7           50                         push	ax
11034                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
11035 31A8           E8         EB0D            call	_await_ide
11036 31AB           83C4                   06  add	sp,*6
11037                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11038 31AE           8846         F5            mov	-$B[bp],al
11039                                           !BCC_EOS
11040                                           ! 1907     if (count == 0) {
11041                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11042 31B1           8B46         08            mov	ax,8[bp]
11043 31B4           85C0                       test	ax,ax
11044 31B6           75           14            jne 	.26D
11045                       000031B8            .26E:
11046                                           ! 1908       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11047                                           ! 1909           != 0x40 ) {
11048                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11049 31B8           8A46         F5            mov	al,-$B[bp]
11050 31BB           24                     C9  and	al,#$C9
11051                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11052 31BD           3C                     40  cmp	al,*$40
11053 31BF           74           07            je  	.26F
11054                       000031C1            .270:
11055                                           ! 1910         ;
11056                                           !BCC_EOS
11057                                           ! 1911         return 4;
11058 31C1           B8                   0004  mov	ax,*4
11059 31C4           89EC                       mov	sp,bp
11060 31C6           5D                         pop	bp
11061 31C7           C3                         ret
11062                                           !BCC_EOS
11063                                           ! 1912         }
11064                                           ! 1913       break;
11065                       000031C8            .26F:
11066 31C8           EB           17            jmp .26A
11067                                           !BCC_EOS
11068                                           ! 1914       }
11069                                           ! 1915     else {
11070 31CA           EB           12            jmp .271
11071                       000031CC            .26D:
11072                                           ! 1916       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11073                                           ! 1917           != (0x40 | 0x08) ) {
11074                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11075 31CC           8A46         F5            mov	al,-$B[bp]
11076 31CF           24                     C9  and	al,#$C9
11077                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11078 31D1           3C                     48  cmp	al,*$48
11079 31D3           74           07            je  	.272
11080                       000031D5            .273:
11081                                           ! 1918         ;
11082                                           !BCC_EOS
11083                                           ! 1919         return 5;
11084 31D5           B8                   0005  mov	ax,*5
11085 31D8           89EC                       mov	sp,bp
11086 31DA           5D                         pop	bp
11087 31DB           C3                         ret
11088                                           !BCC_EOS
11089                                           ! 1920       }
11090                                           ! 1921       continue;
11091                       000031DC            .272:
11092 31DC           EB           00            jmp .26B
11093                                           !BCC_EOS
11094                                           ! 1922     }
11095                                           ! 1923   }
11096                       000031DE            .271:
11097                                           ! 1924   outb(iobase2+6, 0x08);
11098                       000031DE            .26B:
11099 31DE           E9         FF67            jmp	.26C
11100                       000031E1            .274:
11101                       000031E1            .26A:
11102                                           ! Debug: list int = const 8 (used reg = )
11103 31E1           B8                   0008  mov	ax,*8
11104 31E4           50                         push	ax
11105                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11106 31E5           8B46         FA            mov	ax,-6[bp]
11107                                           ! Debug: list unsigned int = ax+6 (used reg = )
11108 31E8           05                   0006  add	ax,*6
11109 31EB           50                         push	ax
11110                                           ! Debug: func () void = outb+0 (used reg = )
11111 31EC           E8         D365            call	_outb
11112 31EF           83C4                   04  add	sp,*4
11113                                           !BCC_EOS
11114                                           ! 1925   return 0;
11115 31F2           31C0                       xor	ax,ax
11116 31F4           89EC                       mov	sp,bp
11117 31F6           5D                         pop	bp
11118 31F7           C3                         ret
11119                                           !BCC_EOS
11120                                           ! 1926 }
11121                                           ! 1927 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
11122                                           ! Register BX used in function ata_cmd_data_in
11123                                           ! 1928 Bit16u device, command, count, cylinder, head, sector, segment, offset;
11124                                           export	_ata_cmd_data_out
11125                       000031F8            _ata_cmd_data_out:
11126                                           !BCC_EOS
11127                                           ! 1929 Bit32u lba_low, lba_high;
11128                                           !BCC_EOS
11129                                           ! 1930 {
11130                                           ! 1931   Bit16u ebda_seg=read_word(0x0040,0x000E);
11131 31F8           55                         push	bp
11132 31F9           89E5                       mov	bp,sp
11133 31FB           4C                         dec	sp
11134 31FC           4C                         dec	sp
11135                                           ! Debug: list int = const $E (used reg = )
11136 31FD           B8                   000E  mov	ax,*$E
11137 3200           50                         push	ax
11138                                           ! Debug: list int = const $40 (used reg = )
11139 3201           B8                   0040  mov	ax,*$40
11140 3204           50                         push	ax
11141                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11142 3205           E8         D3FF            call	_read_word
11143 3208           83C4                   04  add	sp,*4
11144                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11145 320B           8946         FE            mov	-2[bp],ax
11146                                           !BCC_EOS
11147                                           ! 1932   Bit16u iobase1, iobase2, blksize;
11148                                           !BCC_EOS
11149                                           ! 1933   Bit8u channel, slave;
11150                                           !BCC_EOS
11151                                           ! 1934   Bit8u status, current, mode;
11152                                           !BCC_EOS
11153                                           ! 1935   channel = device / 2;
11154 320E           83C4                   F4  add	sp,*-$C
11155                                           ! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11156 3211           8B46         04            mov	ax,4[bp]
11157 3214           D1E8                       shr	ax,*1
11158                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
11159 3216           8846         F7            mov	-9[bp],al
11160                                           !BCC_EOS
11161                                           ! 1936   slave = device % 2;
11162                                           ! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
11163 3219           8B46         04            mov	ax,4[bp]
11164 321C           24                     01  and	al,*1
11165                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
11166 321E           8846         F6            mov	-$A[bp],al
11167                                           !BCC_EOS
11168                                           ! 1937   iobase1 = read_word(ebda_s
11169                                           ! 1937 eg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
11170                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11171 3221           8A46         F7            mov	al,-9[bp]
11172 3224           30E4                       xor	ah,ah
11173 3226           B1                     03  mov	cl,*3
11174 3228           D3E0                       shl	ax,cl
11175 322A           89C3                       mov	bx,ax
11176                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
11177                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
11178 322C           81C3                 0124  add	bx,#$124
11179 3230           53                         push	bx
11180                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11181 3231           FF76         FE            push	-2[bp]
11182                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11183 3234           E8         D3D0            call	_read_word
11184 3237           83C4                   04  add	sp,*4
11185                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
11186 323A           8946         FC            mov	-4[bp],ax
11187                                           !BCC_EOS
11188                                           ! 1938   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
11189                                           ! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
11190 323D           8A46         F7            mov	al,-9[bp]
11191 3240           30E4                       xor	ah,ah
11192 3242           B1                     03  mov	cl,*3
11193 3244           D3E0                       shl	ax,cl
11194 3246           89C3                       mov	bx,ax
11195                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
11196                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
11197 3248           81C3                 0126  add	bx,#$126
11198 324C           53                         push	bx
11199                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11200 324D           FF76         FE            push	-2[bp]
11201                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11202 3250           E8         D3B4            call	_read_word
11203 3253           83C4                   04  add	sp,*4
11204                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
11205 3256           8946         FA            mov	-6[bp],ax
11206                                           !BCC_EOS
11207                                           ! 1939   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
11208                                           ! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
11209 3259           8B46         04            mov	ax,4[bp]
11210 325C           B9                   001E  mov	cx,*$1E
11211 325F           F7E9                       imul	cx
11212 3261           89C3                       mov	bx,ax
11213                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
11214                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
11215 3263           81C3                 0146  add	bx,#$146
11216 3267           53                         push	bx
11217                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
11218 3268           FF76         FE            push	-2[bp]
11219                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
11220 326B           E8         D386            call	_read_byte
11221 326E           83C4                   04  add	sp,*4
11222                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
11223 3271           8846         F3            mov	-$D[bp],al
11224                                           !BCC_EOS
11225                                           ! 1940   blksize = 0x200;
11226                                           ! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
11227 3274           B8                   0200  mov	ax,#$200
11228 3277           8946         F8            mov	-8[bp],ax
11229                                           !BCC_EOS
11230                                           ! 1941   if (mode == 0x01) blksize>>=2;
11231                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
11232 327A           8A46         F3            mov	al,-$D[bp]
11233 327D           3C                     01  cmp	al,*1
11234 327F           75           0C            jne 	.275
11235                       00003281            .276:
11236                                           ! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
11237 3281           8B46         F8            mov	ax,-8[bp]
11238 3284           D1E8                       shr	ax,*1
11239 3286           D1E8                       shr	ax,*1
11240 3288           8946         F8            mov	-8[bp],ax
11241                                           !BCC_EOS
11242                                           ! 1942   else blksize>>=1;
11243 328B           EB           08            jmp .277
11244                       0000328D            .275:
11245                                           ! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
11246 328D           8B46         F8            mov	ax,-8[bp]
11247 3290           D1E8                       shr	ax,*1
11248 3292           8946         F8            mov	-8[bp],ax
11249                                           !BCC_EOS
11250                                           ! 1943   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
11251                       00003295            .277:
11252                                           ! Debug: list int = const 0 (used reg = )
11253 3295           31C0                       xor	ax,ax
11254 3297           50                         push	ax
11255                                           ! Debug: list * unsigned short = const $254 (used reg = )
11256 3298           B8                   0254  mov	ax,#$254
11257 329B           50                         push	ax
11258                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11259 329C           FF76         FE            push	-2[bp]
11260                                           ! Debug: func () void = write_word+0 (used reg = )
11261 329F           E8         D390            call	_write_word
11262 32A2           83C4                   06  add	sp,*6
11263                                           !BCC_EOS
11264                                           ! 1944   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
11265                                           ! Debug: list long = const 0 (used reg = )
11266 32A5           31C0                       xor	ax,ax
11267 32A7           31DB                       xor	bx,bx
11268 32A9           53                         push	bx
11269 32AA           50                         push	ax
11270                                           ! Debug: list * unsigned long = const $256 (used reg = )
11271 32AB           B8                   0256  mov	ax,#$256
11272 32AE           50                         push	ax
11273                                           ! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
11274 32AF           FF76         FE            push	-2[bp]
11275                                           ! Debug: func () void = write_dword+0 (used reg = )
11276 32B2           E8         CDE6            call	_write_dword
11277 32B5           83C4                   08  add	sp,*8
11278                                           !BCC_EOS
11279                                           ! 1945   current = 0;
11280                                           ! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
11281 32B8           30C0                       xor	al,al
11282 32BA           8846         F4            mov	-$C[bp],al
11283                                           !BCC_EOS
11284                                           ! 1946   status = inb(iobase1 + 7);
11285                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
11286 32BD           8B46         FC            mov	ax,-4[bp]
11287                                           ! Debug: list unsigned int = ax+7 (used reg = )
11288 32C0           05                   0007  add	ax,*7
11289 32C3           50                         push	ax
11290                                           ! Debug: func () unsigned char = inb+0 (used reg = )
11291 32C4           E8         D277            call	_inb
11292 32C7           44                         inc	sp
11293 32C8           44                         inc	sp
11294                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11295 32C9           8846         F5            mov	-$B[bp],al
11296                                           !BCC_EOS
11297                                           ! 1947   if (status & 0x80) return 1;
11298                                           ! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
11299 32CC           8A46         F5            mov	al,-$B[bp]
11300 32CF           24                     80  and	al,#$80
11301 32D1           84C0                       test	al,al
11302 32D3           74           07            je  	.278
11303                       000032D5            .279:
11304 32D5           B8                   0001  mov	ax,*1
11305 32D8           89EC                       mov	sp,bp
11306 32DA           5D                         pop	bp
11307 32DB           C3                         ret
11308                                           !BCC_EOS
11309                                           ! 1948   outb(iobase2 + 6, 0x08 | 0x02);
11310                       000032DC            .278:
11311                                           ! Debug: list int = const $A (used reg = )
11312 32DC           B8                   000A  mov	ax,*$A
11313 32DF           50                         push	ax
11314                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11315 32E0           8B46         FA            mov	ax,-6[bp]
11316                                           ! Debug: list unsigned int = ax+6 (used reg = )
11317 32E3           05                   0006  add	ax,*6
11318 32E6           50                         push	ax
11319                                           ! Debug: func () void = outb+0 (used reg = )
11320 32E7           E8         D26A            call	_outb
11321 32EA           83C4                   04  add	sp,*4
11322                                           !BCC_EOS
11323                                           ! 1949   if (sector == 0) {
11324                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
11325 32ED           8B46         0E            mov	ax,$E[bp]
11326 32F0           85C0                       test	ax,ax
11327 32F2         0F85         0167            bne 	.27A
11328                       000032F6            .27B:
11329                                           ! 1950     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
11330                                           ! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
11331 32F6           8B46         08            mov	ax,8[bp]
11332 32F9           3D                   0100  cmp	ax,#$100
11333 32FC           72           04            jb 	.280
11334 32FE           B0                     01  mov	al,*1
11335 3300           EB           02            jmp	.281
11336                       00003302            .280:
11337 3302           30C0                       xor	al,al
11338                       00003304            .281:
11339                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
11340 3304           30E4                       xor	ah,ah
11341 3306           99                         cwd
11342 3307           89D3                       mov	bx,dx
11343 3309           E8         CE08            call	ltstl
11344 330C           75           32            jne 	.27D
11345                       0000330E            .27F:
11346 330E           8B46         14            mov	ax,$14[bp]
11347 3311           8B5E         16            mov	bx,$16[bp]
11348 3314           E8         CDFD            call	ltstl
11349 3317           75           27            jne 	.27D
11350                       00003319            .27E:
11351                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
11352 3319           8B46         08            mov	ax,8[bp]
11353 331C           31DB                       xor	bx,bx
11354                                           ! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
11355                                           ! Debug: expression subtree swapping
11356 331E           8D7E         10            lea	di,$10[bp]
11357 3321           E8         CD9F            call	laddul
11358                                           ! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
11359 3324           53                         push	bx
11360 3325           50                         push	ax
11361 3326           31C0                       xor	ax,ax
11362 3328           BB                   1000  mov	bx,#$1000
11363 332B           53                         push	bx
11364 332C           50                         push	ax
11365 332D           8B46         EE            mov	ax,-$12[bp]
11366 3330           8B5E         F0            mov	bx,-$10[bp]
11367 3333           8D7E         EA            lea	di,-$16[bp]
11368 3336           E8         CD92            call	lcmpul
11369 3339           8D66         F2            lea	sp,-$E[bp]
11370 333C         0F82         00BC            blo 	.27C
11371                       00003340            .27D:
11372                                           ! 1951       outb(iobase1 + 1, 0x00);
11373                                           ! Debug: list int = const 0 (used reg = )
11374 3340           31C0                       xor	ax,ax
11375 3342           50                         push	ax
11376                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11377 3343           8B46         FC            mov	ax,-4[bp]
11378                                           ! Debug: list unsigned int = ax+1 (used reg = )
11379 3346           40                         inc	ax
11380 3347           50                         push	ax
11381                                           ! Debug: func () void = outb+0 (used reg = )
11382 3348           E8         D209            call	_outb
11383 334B           83C4                   04  add	sp,*4
11384                                           !BCC_EOS
11385                                           ! 1952       outb(iobase1 + 2, (count >> 8) & 0xff);
11386                                           ! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
11387 334E           8B46         08            mov	ax,8[bp]
11388 3351           88E0                       mov	al,ah
11389 3353           30E4                       xor	ah,ah
11390                                           ! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
11391                                           ! Debug: list unsigned char = al+0 (used reg = )
11392 3355           30E4                       xor	ah,ah
11393 3357           50                         push	ax
11394                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11395 3358           8B46         FC            mov	ax,-4[bp]
11396                                           ! Debug: list unsigned int = ax+2 (used reg = )
11397 335B           40                         inc	ax
11398 335C           40                         inc	ax
11399 335D           50                         push	ax
11400                                           ! Debug: func () void = outb+0 (used reg = )
11401 335E           E8         D1F3            call	_outb
11402 3361           83C4                   04  add	sp,*4
11403                                           !BCC_EOS
11404                                           ! 1953       outb(iobase1 + 3, lba_low >> 24);
11405                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11406 3364           8B46         10            mov	ax,$10[bp]
11407 3367           8B5E         12            mov	bx,$12[bp]
11408 336A           93                         xchg	bx,ax
11409 336B           88E0                       mov	al,ah
11410 336D           30E4                       xor	ah,ah
11411 336F           31DB                       xor	bx,bx
11412                                           ! Debug: list unsigned long = bx+0 (used reg = )
11413 3371           53                         push	bx
11414 3372           50                         push	ax
11415                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
11416 3373           8B46         FC            mov	ax,-4[bp]
11417                                           ! Debug: list unsigned int = ax+3 (used reg = )
11418 3376           05                   0003  add	ax,*3
11419 3379           50                         push	ax
11420                                           ! Debug: func () void = outb+0 (used reg = )
11421 337A           E8         D1D7            call	_outb
11422 337D           83C4                   06  add	sp,*6
11423                                           !BCC_EOS
11424                                           ! 1954       outb(iobase1 + 4, lba_high & 0xff);
11425                                           ! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
11426                                           ! Debug: expression subtree swapping
11427 3380           B8                   00FF  mov	ax,#$FF
11428 3383           31DB                       xor	bx,bx
11429 3385           8D7E         14            lea	di,$14[bp]
11430 3388           E8         CD30            call	landul
11431                                           ! Debug: list unsigned long = bx+0 (used reg = )
11432 338B           53                         push	bx
11433 338C           50                         push	ax
11434                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
11435 338D           8B46         FC            mov	ax,-4[bp]
11436                                           ! Debug: list unsigned int = ax+4 (used reg = )
11437 3390           05                   0004  add	ax,*4
11438 3393           50                         push	ax
11439                                           ! Debug: func () void = outb+0 (used reg = )
11440 3394           E8         D1BD            call	_outb
11441 3397           83C4                   06  add	sp,*6
11442                                           !BCC_EOS
11443                                           ! 1955       outb(iobase1 + 5, lba_high >> 8);
11444                                           ! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
11445 339A           8B46         14            mov	ax,$14[bp]
11446 339D           8B5E         16            mov	bx,$16[bp]
11447 33A0           88E0                       mov	al,ah
11448 33A2           88DC                       mov	ah,bl
11449 33A4           88FB                       mov	bl,bh
11450 33A6           28FF                       sub	bh,bh
11451                                           ! Debug: list unsigned long = bx+0 (used reg = )
11452 33A8           53                         push	bx
11453 33A9           50                         push	ax
11454                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
11455 33AA           8B46         FC            mov	ax,-4[bp]
11456                                           ! Debug: list unsigned int = ax+5 (used reg = )
11457 33AD           05                   0005  add	ax,*5
11458 33B0           50                         push	ax
11459                                           ! Debug: func () void = outb+0 (used reg = )
11460 33B1           E8         D1A0            call	_outb
11461 33B4           83C4                   06  add	sp,*6
11462                                           !BCC_EOS
11463                                           ! 1956       command |= 0x04;
11464                                           ! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
11465 33B7           8B46         06            mov	ax,6[bp]
11466 33BA           0C                     04  or	al,*4
11467 33BC           8946         06            mov	6[bp],ax
11468                                           !BCC_EOS
11469                                           ! 1957       count &= (1UL << 8) - 1;
11470                                           ! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
11471 33BF           8B46         08            mov	ax,8[bp]
11472 33C2           31DB                       xor	bx,bx
11473 33C4           53                         push	bx
11474 33C5           50                         push	ax
11475 33C6           B8                   00FF  mov	ax,#$FF
11476 33C9           31DB                       xor	bx,bx
11477 33CB           53                         push	bx
11478 33CC           50                         push	ax
11479 33CD           8B46         EE            mov	ax,-$12[bp]
11480 33D0           8B5E         F0            mov	bx,-$10[bp]
11481 33D3           8D7E         EA            lea	di,-$16[bp]
11482 33D6           E8         CCE2            call	landul
11483 33D9           8946         08            mov	8[bp],ax
11484 33DC           83C4                   08  add	sp,*8
11485                                           !BCC_EOS
11486                                           ! 1958       lba_low &= (1UL << 24) - 1;
11487                                           ! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
11488 33DF           B8                   FFFF  mov	ax,#$FFFF
11489 33E2           BB                   00FF  mov	bx,#$FF
11490 33E5           53                         push	bx
11491 33E6           50                         push	ax
11492 33E7           8B46         10            mov	ax,$10[bp]
11493 33EA           8B5E         12            mov	bx,$12[bp]
11494 33ED           8D7E         EE            lea	di,-$12[bp]
11495 33F0           E8         CCC8            call	landul
11496 33F3           8946         10            mov	$10[bp],ax
11497 33F6           895E         12            mov	$12[bp],bx
11498 33F9           83C4                   04  add	sp,*4
11499                                           !BCC_EOS
11500                                           ! 1959       }
11501                                           ! 1960     sector = (Bit16u) (lba_low & 0x000000ffL);
11502                       000033FC            .27C:
11503                                           ! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
11504                                           ! Debug: expression subtree swapping
11505 33FC           B8                   00FF  mov	ax,#$FF
11506 33FF           31DB                       xor	bx,bx
11507 3401           8D7E         10            lea	di,$10[bp]
11508 3404           E8         CCB4            call	landul
11509                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11510                                           ! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
11511 3407           8946         0E            mov	$E[bp],ax
11512                                           !BCC_EOS
11513                                           ! 1961     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
11514                                           ! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
11515 340A           8B46         10            mov	ax,$10[bp]
11516 340D           8B5E         12            mov	bx,$12[bp]
11517 3410           88E0                       mov	al,ah
11518 3412           88DC                       mov	ah,bl
11519 3414           88FB                       mov	bl,bh
11520 3416           28FF                       sub	bh,bh
11521                                           ! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
11522 3418           53                         push	bx
11523 3419           50                         push	ax
11524 341A           B8                   FFFF  mov	ax,#$FFFF
11525 341D           31DB                       xor	bx,bx
11526 341F           53                         push	bx
11527 3420           50                         push	ax
11528 3421           8B46         EE            mov	ax,-$12[bp]
11529 3424           8B5E         F0            mov	bx,-$10[bp]
11530 3427           8D7E         EA            lea	di,-$16[bp]
11531 342A           E8         CC8E            call	landul
11532 342D           83C4                   08  add	sp,*8
11533                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11534                                           ! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
11535 3430           8946         0A            mov	$A[bp],ax
11536                                           !BCC_EOS
11537                                           ! 1962     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
11538                                           ! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
11539 3433           8B46         10            mov	ax,$10[bp]
11540 3436           8B5E         12            mov	bx,$12[bp]
11541 3439           93                         xchg	bx,ax
11542 343A           88E0                       mov	al,ah
11543 343C           30E4                       xor	ah,ah
11544 343E           31DB                       xor	bx,bx
11545                                           ! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
11546 3440           53                         push	bx
11547 3441           50                         push	ax
11548 3442           B8                   000F  mov	ax,*$F
11549 3445           31DB                       xor	bx,bx
11550 3447           53                         push	bx
11551 3448           50                         push	ax
11552 3449           8B46         EE            mov	ax,-$12[bp]
11553 344C           8B5E         F0            mov	bx,-$10[bp]
11554 344F           8D7E         EA            lea	di,-$16[bp]
11555 3452           E8         CC66            call	landul
11556 3455           83C4                   08  add	sp,*8
11557                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
11558                                           ! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
11559 3458           0C                     40  or	al,*$40
11560                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
11561 345A           8946         0C            mov	$C[bp],ax
11562                                           !BCC_EOS
11563                                           ! 1963   }
11564                                           ! 1964   outb(iobase1 + 1, 0x00);
11565                       0000345D            .27A:
11566                                           ! Debug: list int = const 0 (used reg = )
11567 345D           31C0                       xor	ax,ax
11568 345F           50                         push	ax
11569                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
11570 3460           8B46         FC            mov	ax,-4[bp]
11571                                           ! Debug: list unsigned int = ax+1 (used reg = )
11572 3463           40                         inc	ax
11573 3464           50                         push	ax
11574                                           ! Debug: func () void = outb+0 (used reg = )
11575 3465           E8         D0EC            call	_outb
11576 3468           83C4                   04  add	sp,*4
11577                                           !BCC_EOS
11578                                           ! 1965   outb(iobase1 + 2, count);
11579                                           ! Debug: list unsigned short count = [S+$10+6] (used reg = )
11580 346B           FF76         08            push	8[bp]
11581                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
11582 346E           8B46         FC            mov	ax,-4[bp]
11583                                           ! Debug: list unsigned int = ax+2 (used reg = )
11584 3471           40                         inc	ax
11585 3472           40                         inc	ax
11586 3473           50                         push	ax
11587                                           ! Debug: func () void = outb+0 (used reg = )
11588 3474           E8         D0DD            call	_outb
11589 3477           83C4                   04  add	sp,*4
11590                                           !BCC_EOS
11591                                           ! 1966   outb(iobase1 + 3, sector);
11592                                           ! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
11593 347A           FF76         0E            push	$E[bp]
11594                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
11595 347D           8B46         FC            mov	ax,-4[bp]
11596                                           ! Debug: list unsigned int = ax+3 (used reg = )
11597 3480           05                   0003  add	ax,*3
11598 3483           50                         push	ax
11599                                           ! Debug: func () void = outb+0 (used reg = )
11600 3484           E8         D0CD            call	_outb
11601 3487           83C4                   04  add	sp,*4
11602                                           !BCC_EOS
11603                                           ! 1967   outb(iobase1 + 4, cylinder & 0x00ff);
11604                                           ! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
11605 348A           8A46         0A            mov	al,$A[bp]
11606                                           ! Debug: list unsigned char = al+0 (used reg = )
11607 348D           30E4                       xor	ah,ah
11608 348F           50                         push	ax
11609                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
11610 3490           8B46         FC            mov	ax,-4[bp]
11611                                           ! Debug: list unsigned int = ax+4 (used reg = )
11612 3493           05                   0004  add	ax,*4
11613 3496           50                         push	ax
11614                                           ! Debug: func () void = outb+0 (used reg = )
11615 3497           E8         D0BA            call	_outb
11616 349A           83C4                   04  add	sp,*4
11617                                           !BCC_EOS
11618                                           ! 1968   outb(iobase1 + 5, cylinder >> 8);
11619                                           ! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
11620 349D           8B46         0A            mov	ax,$A[bp]
11621 34A0           88E0                       mov	al,ah
11622 34A2           30E4                       xor	ah,ah
11623                                           ! Debug: list unsigned int = ax+0 (used reg = )
11624 34A4           50                         push	ax
11625                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
11626 34A5           8B46         FC            mov	ax,-4[bp]
11627                                           ! Debug: list unsigned int = ax+5 (used reg = )
11628 34A8           05                   0005  add	ax,*5
11629 34AB           50                         push	ax
11630                                           ! Debug: func () void = outb+0 (used reg = )
11631 34AC           E8         D0A5            call	_outb
11632 34AF           83C4                   04  add	sp,*4
11633                                           !BCC_EOS
11634                                           ! 1969   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
11635 34B2           8A46         F6            mov	al,-$A[bp]
11636 34B5           84C0                       test	al,al
11637 34B7           74           04            je  	.283
11638                       000034B9            .284:
11639 34B9           B0                     B0  mov	al,#$B0
11640 34BB           EB           02            jmp .285
11641                       000034BD            .283:
11642 34BD           B0                     A0  mov	al,#$A0
11643                       000034BF            .285:
11644                                           ! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
11645 34BF           0A46         0C            or	al,$C[bp]
11646                                           ! Debug: list unsigned char = al+0 (used reg = )
11647 34C2           30E4                       xor	ah,ah
11648 34C4           50                         push	ax
11649                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
11650 34C5           8B46         FC            mov	ax,-4[bp]
11651                                           ! Debug: list unsigned int = ax+6 (used reg = )
11652 34C8           05                   0006  add	ax,*6
11653 34CB           50                         push	ax
11654                                           ! Debug: func () void = outb+0 (used reg = )
11655 34CC           E8         D085            call	_outb
11656 34CF           83C4                   04  add	sp,*4
11657                                           !BCC_EOS
11658                                           ! 1970   outb(iobase1 + 7, command);
11659                                           ! Debug: list unsigned short command = [S+$10+4] (used reg = )
11660 34D2           FF76         06            push	6[bp]
11661                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
11662 34D5           8B46         FC            mov	ax,-4[bp]
11663                                           ! Debug: list unsigned int = ax+7 (used reg = )
11664 34D8           05                   0007  add	ax,*7
11665 34DB           50                         push	ax
11666                                           ! Debug: func () void = outb+0 (used reg = )
11667 34DC           E8         D075            call	_outb
11668 34DF           83C4                   04  add	sp,*4
11669                                           !BCC_EOS
11670                                           ! 1971   status = await_ide(3, iobase1, 32000u);
11671                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11672 34E2           B8                   7D00  mov	ax,#$7D00
11673 34E5           50                         push	ax
11674                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11675 34E6           FF76         FC            push	-4[bp]
11676                                           ! Debug: list int = const 3 (used reg = )
11677 34E9           B8                   0003  mov	ax,*3
11678 34EC           50                         push	ax
11679                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
11680 34ED           E8         E7C8            call	_await_ide
11681 34F0           83C4                   06  add	sp,*6
11682                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11683 34F3           8846         F5            mov	-$B[bp],al
11684                                           !BCC_EOS
11685                                           ! 1972   if (status & 0x01) {
11686                                           ! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
11687 34F6           8A46         F5            mov	al,-$B[bp]
11688 34F9           24                     01  and	al,*1
11689 34FB           84C0                       test	al,al
11690 34FD           74           09            je  	.286
11691                       000034FF            .287:
11692                                           ! 1973     ;
11693                                           !BCC_EOS
11694                                           ! 1974     return 2;
11695 34FF           B8                   0002  mov	ax,*2
11696 3502           89EC                       mov	sp,bp
11697 3504           5D                         pop	bp
11698 3505           C3                         ret
11699                                           !BCC_EOS
11700                                           ! 1975     } else if ( !(status & 0x08) ) {
11701 3506           EB           10            jmp .288
11702                       00003508            .286:
11703                                           ! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
11704 3508           8A46         F5            mov	al,-$B[bp]
11705 350B           24                     08  and	al,*8
11706 350D           84C0                       test	al,al
11707 350F           75           07            jne 	.289
11708                       00003511            .28A:
11709                                           ! 1976     ;
11710                                           !BCC_EOS
11711                                           ! 1977     return 3;
11712 3511           B8                   0003  mov	ax,*3
11713 3514           89EC                       mov	sp,bp
11714 3516           5D                         pop	bp
11715 3517           C3                         ret
11716                                           !BCC_EOS
11717                                           ! 1978     }
11718                                           ! 1979 #asm
11719                       00003518            .289:
11720                       00003518            .288:
11721                                           !BCC_EOS
11722                                           !BCC_ASM
11723                       00000016            _ata_cmd_data_out.count	set	$16
11724                       00000008            .ata_cmd_data_out.count	set	8
11725                       00000026            _ata_cmd_data_out.segment	set	$26
11726                       00000018            .ata_cmd_data_out.segment	set	$18
11727                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11728                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11729                       00000005            _ata_cmd_data_out.channel	set	5
11730                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11731                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11732                       00000010            .ata_cmd_data_out.lba_low	set	$10
11733                       00000022            _ata_cmd_data_out.lba_high	set	$22
11734                       00000014            .ata_cmd_data_out.lba_high	set	$14
11735                       0000001C            _ata_cmd_data_out.sector	set	$1C
11736                       0000000E            .ata_cmd_data_out.sector	set	$E
11737                       00000006            _ata_cmd_data_out.blksize	set	6
11738                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11739                       0000001A            _ata_cmd_data_out.head	set	$1A
11740                       0000000C            .ata_cmd_data_out.head	set	$C
11741                       00000018            _ata_cmd_data_out.cylinder	set	$18
11742                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11743                       00000012            _ata_cmd_data_out.device	set	$12
11744                       00000004            .ata_cmd_data_out.device	set	4
11745                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11746                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11747                       00000003            _ata_cmd_data_out.status	set	3
11748                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11749                       00000002            _ata_cmd_data_out.current	set	2
11750                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11751                       00000014            _ata_cmd_data_out.command	set	$14
11752                       00000006            .ata_cmd_data_out.command	set	6
11753                       00000001            _ata_cmd_data_out.mode	set	1
11754                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11755                       00000008            _ata_cmd_data_out.iobase2	set	8
11756                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11757                       00000028            _ata_cmd_data_out.offset	set	$28
11758                       0000001A            .ata_cmd_data_out.offset	set	$1A
11759                       00000004            _ata_cmd_data_out.slave	set	4
11760                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11761 3518           FB                                 sti ;; enable higher priority interrupts
11762                                           ! 1981 endasm
11763                                           !BCC_ENDASM
11764                                           !BCC_EOS
11765                                           ! 1982   while (1) {
11766                       00003519            .28D:
11767                                           ! 1983 #asm
11768                                           !BCC_EOS
11769                                           !BCC_ASM
11770                       00000016            _ata_cmd_data_out.count	set	$16
11771                       00000008            .ata_cmd_data_out.count	set	8
11772                       00000026            _ata_cmd_data_out.segment	set	$26
11773                       00000018            .ata_cmd_data_out.segment	set	$18
11774                       0000000A            _ata_cmd_data_out.iobase1	set	$A
11775                       FFFFFFFC            .ata_cmd_data_out.iobase1	set	-4
11776                       00000005            _ata_cmd_data_out.channel	set	5
11777                       FFFFFFF7            .ata_cmd_data_out.channel	set	-9
11778                       0000001E            _ata_cmd_data_out.lba_low	set	$1E
11779                       00000010            .ata_cmd_data_out.lba_low	set	$10
11780                       00000022            _ata_cmd_data_out.lba_high	set	$22
11781                       00000014            .ata_cmd_data_out.lba_high	set	$14
11782                       0000001C            _ata_cmd_data_out.sector	set	$1C
11783                       0000000E            .ata_cmd_data_out.sector	set	$E
11784                       00000006            _ata_cmd_data_out.blksize	set	6
11785                       FFFFFFF8            .ata_cmd_data_out.blksize	set	-8
11786                       0000001A            _ata_cmd_data_out.head	set	$1A
11787                       0000000C            .ata_cmd_data_out.head	set	$C
11788                       00000018            _ata_cmd_data_out.cylinder	set	$18
11789                       0000000A            .ata_cmd_data_out.cylinder	set	$A
11790                       00000012            _ata_cmd_data_out.device	set	$12
11791                       00000004            .ata_cmd_data_out.device	set	4
11792                       0000000C            _ata_cmd_data_out.ebda_seg	set	$C
11793                       FFFFFFFE            .ata_cmd_data_out.ebda_seg	set	-2
11794                       00000003            _ata_cmd_data_out.status	set	3
11795                       FFFFFFF5            .ata_cmd_data_out.status	set	-$B
11796                       00000002            _ata_cmd_data_out.current	set	2
11797                       FFFFFFF4            .ata_cmd_data_out.current	set	-$C
11798                       00000014            _ata_cmd_data_out.command	set	$14
11799                       00000006            .ata_cmd_data_out.command	set	6
11800                       00000001            _ata_cmd_data_out.mode	set	1
11801                       FFFFFFF3            .ata_cmd_data_out.mode	set	-$D
11802                       00000008            _ata_cmd_data_out.iobase2	set	8
11803                       FFFFFFFA            .ata_cmd_data_out.iobase2	set	-6
11804                       00000028            _ata_cmd_data_out.offset	set	$28
11805                       0000001A            .ata_cmd_data_out.offset	set	$1A
11806                       00000004            _ata_cmd_data_out.slave	set	4
11807                       FFFFFFF6            .ata_cmd_data_out.slave	set	-$A
11808 3519           55                                 push bp
11809 351A           89E5                               mov bp, sp
11810 351C           8B76         2A                    mov si, _ata_cmd_data_out.offset + 2[bp]
11811 351F           8B46         28                    mov ax, _ata_cmd_data_out.segment + 2[bp]
11812 3522           8B4E         08                    mov cx, _ata_cmd_data_out.blksize + 2[bp]
11813                                                   ;; adjust if there will be an overrun. 2K max sector size
11814 3525           81FE                 F800          cmp si, #0xf800 ;;
11815 3529           76           07                    jbe ata_out_no_adjust
11816                       0000352B            ata_out_adjust:
11817 352B           81EE                 0800          sub si, #0x0800 ;; sub 2 kbytes from offset
11818 352F           05                   0080          add ax, #0x0080 ;; add 2 Kbytes to segment
11819                       00003532            ata_out_no_adjust:
11820 3532           8EC0                               mov es, ax ;; segment in es
11821 3534           8B56         0C                    mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
11822 3537           8A66         03                    mov ah, _ata_cmd_data_out.mode + 2[bp]
11823 353A           80FC                   01          cmp ah, #0x01
11824 353D           74           05                    je ata_out_32
11825                       0000353F            ata_out_16:
11826 353F           26                                 seg ES
11827 3540           F3                                 rep
11828 3541           6F                                   outsw ;; CX words transfered from port(DX) to ES:[SI]
11829 3542           EB           04                    jmp ata_out_done
11830                       00003544            ata_out_32:
11831 3544           26                                 seg ES
11832 3545           F3                                 rep
11833 3546     66    6F                                   outsd ;; CX dwords transfered from port(DX) to ES:[SI]
11834                       00003548            ata_out_done:
11835 3548           8976         2A                    mov _ata_cmd_data_out.offset + 2[bp], si
11836 354B           8C46         28                    mov _ata_cmd_data_out.segment + 2[bp], es
11837 354E           5D                                 pop bp
11838                                           ! 2014 endasm
11839                                           !BCC_ENDASM
11840                                           !BCC_EOS
11841                                           ! 2015     current++;
11842                                           ! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
11843 354F           8A46         F4            mov	al,-$C[bp]
11844 3552           40                         inc	ax
11845 3553           8846         F4            mov	-$C[bp],al
11846                                           !BCC_EOS
11847                                           ! 2016     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
11848                                           ! Debug: list unsigned char current = [S+$10-$E] (used reg = )
11849 3556           8A46         F4            mov	al,-$C[bp]
11850 3559           30E4                       xor	ah,ah
11851 355B           50                         push	ax
11852                                           ! Debug: list * unsigned short = const $254 (used reg = )
11853 355C           B8                   0254  mov	ax,#$254
11854 355F           50                         push	ax
11855                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
11856 3560           FF76         FE            push	-2[bp]
11857                                           ! Debug: func () void = write_word+0 (used reg = )
11858 3563           E8         D0CC            call	_write_word
11859 3566           83C4                   06  add	sp,*6
11860                                           !BCC_EOS
11861                                           ! 2017     count--;
11862                                           ! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
11863 3569           8B46         08            mov	ax,8[bp]
11864 356C           48                         dec	ax
11865 356D           8946         08            mov	8[bp],ax
11866                                           !BCC_EOS
11867                                           ! 2018     status = await_ide(2, iobase1, 32000u);
11868                                           ! Debug: list unsigned int = const $7D00 (used reg = )
11869 3570           B8                   7D00  mov	ax,#$7D00
11870 3573           50                         push	ax
11871                                           ! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
11872 3574           FF76         FC            push	-4[bp]
11873                                           ! Debug: list int = const 2 (used reg = )
11874 3577           B8                   0002  mov	ax,*2
11875 357A           50                         push	ax
11876                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
11877 357B           E8         E73A            call	_await_ide
11878 357E           83C4                   06  add	sp,*6
11879                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
11880 3581           8846         F5            mov	-$B[bp],al
11881                                           !BCC_EOS
11882                                           ! 2019     if (count == 0) {
11883                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
11884 3584           8B46         08            mov	ax,8[bp]
11885 3587           85C0                       test	ax,ax
11886 3589           75           14            jne 	.28E
11887                       0000358B            .28F:
11888                                           ! 2020       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
11889                                           ! 2021           != 0x40 ) {
11890                                           ! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
11891 358B           8A46         F5            mov	al,-$B[bp]
11892 358E           24                     E9  and	al,#$E9
11893                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
11894 3590           3C                     40  cmp	al,*$40
11895 3592           74           07            je  	.290
11896                       00003594            .291:
11897                                           ! 2022         ;
11898                                           !BCC_EOS
11899                                           ! 2023         return 6;
11900 3594           B8                   0006  mov	ax,*6
11901 3597           89EC                       mov	sp,bp
11902 3599           5D                         pop	bp
11903 359A           C3                         ret
11904                                           !BCC_EOS
11905                                           ! 2024         }
11906                                           ! 2025       break;
11907                       0000359B            .290:
11908 359B           EB           17            jmp .28B
11909                                           !BCC_EOS
11910                                           ! 2026       }
11911                                           ! 2027     else {
11912 359D           EB           12            jmp .292
11913                       0000359F            .28E:
11914                                           ! 2028       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
11915                                           ! 2029           != (0x40 | 0x08) ) {
11916                                           ! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
11917 359F           8A46         F5            mov	al,-$B[bp]
11918 35A2           24                     C9  and	al,#$C9
11919                                           ! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
11920 35A4           3C                     48  cmp	al,*$48
11921 35A6           74           07            je  	.293
11922                       000035A8            .294:
11923                                           ! 2030         ;
11924                                           !BCC_EOS
11925                                           ! 2031         return 7;
11926 35A8           B8                   0007  mov	ax,*7
11927 35AB           89EC                       mov	sp,bp
11928 35AD           5D                         pop	bp
11929 35AE           C3                         ret
11930                                           !BCC_EOS
11931                                           ! 2032       }
11932                                           ! 2033       continue;
11933                       000035AF            .293:
11934 35AF           EB           00            jmp .28C
11935                                           !BCC_EOS
11936                                           ! 2034     }
11937                                           ! 2035   }
11938                       000035B1            .292:
11939                                           ! 2036   outb(iobase2+6, 0x08);
11940                       000035B1            .28C:
11941 35B1           E9         FF65            jmp	.28D
11942                       000035B4            .295:
11943                       000035B4            .28B:
11944                                           ! Debug: list int = const 8 (used reg = )
11945 35B4           B8                   0008  mov	ax,*8
11946 35B7           50                         push	ax
11947                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
11948 35B8           8B46         FA            mov	ax,-6[bp]
11949                                           ! Debug: list unsigned int = ax+6 (used reg = )
11950 35BB           05                   0006  add	ax,*6
11951 35BE           50                         push	ax
11952                                           ! Debug: func () void = outb+0 (used reg = )
11953 35BF           E8         CF92            call	_outb
11954 35C2           83C4                   04  add	sp,*4
11955                                           !BCC_EOS
11956                                           ! 2037   return 0;
11957 35C5           31C0                       xor	ax,ax
11958 35C7           89EC                       mov	sp,bp
11959 35C9           5D                         pop	bp
11960 35CA           C3                         ret
11961                                           !BCC_EOS
11962                                           ! 2038 }
11963                                           ! 2039 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
11964                                           ! Register BX used in function ata_cmd_data_out
11965                                           ! 2040 Bit8u cmdlen,inout;
11966                                           export	_ata_cmd_packet
11967                       000035CB            _ata_cmd_packet:
11968                                           !BCC_EOS
11969                                           ! 2041 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
11970                                           !BCC_EOS
11971                                           ! 2042 Bit16u header;
11972                                           !BCC_EOS
11973                                           ! 2043 Bit32u length;
11974                                           !BCC_EOS
11975                                           ! 2044 {
11976                                           ! 2045   Bit16u ebda_seg=read_word(0x0040,0x000E);
11977 35CB           55                         push	bp
11978 35CC           89E5                       mov	bp,sp
11979 35CE           4C                         dec	sp
11980 35CF           4C                         dec	sp
11981                                           ! Debug: list int = const $E (used reg = )
11982 35D0           B8                   000E  mov	ax,*$E
11983 35D3           50                         push	ax
11984                                           ! Debug: list int = const $40 (used reg = )
11985 35D4           B8                   0040  mov	ax,*$40
11986 35D7           50                         push	ax
11987                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
11988 35D8           E8         D02C            call	_read_word
11989 35DB           83C4                   04  add	sp,*4
11990                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
11991 35DE           8946         FE            mov	-2[bp],ax
11992                                           !BCC_EOS
11993                                           ! 2046   Bit16u iobase1, iobase2;
11994                                           !BCC_EOS
11995                                           ! 2047   Bit16u lcount, lbefore, lafter, count;
11996                                           !BCC_EOS
11997                                           ! 2048   Bit8u channel, slave;
11998                                           !BCC_EOS
11999                                           ! 2049   Bit8u status, mode, lmode;
12000                                           !BCC_EOS
12001                                           ! 2050   Bit32u total, transfer;
12002                                           !BCC_EOS
12003                                           ! 2051   channel = device / 2;
12004 35E1           83C4                   E6  add	sp,*-$1A
12005                                           ! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
12006 35E4           8B46         04            mov	ax,4[bp]
12007 35E7           D1E8                       shr	ax,*1
12008                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
12009 35E9           8846         F1            mov	-$F[bp],al
12010                                           !BCC_EOS
12011                                           ! 2052   slave = device % 2;
12012                                           ! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
12013 35EC           8B46         04            mov	ax,4[bp]
12014 35EF           24                     01  and	al,*1
12015                                           ! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
12016 35F1           8846         F0            mov	-$10[bp],al
12017                                           !BCC_EOS
12018                                           ! 2053   if (inout == 0x02) {
12019                                           ! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
12020 35F4           8A46         12            mov	al,$12[bp]
12021 35F7           3C                     02  cmp	al,*2
12022 35F9           75           07            jne 	.296
12023                       000035FB            .297:
12024                                           ! 2054     ;
12025                                           !BCC_EOS
12026                                           ! 2055     return 1;
12027 35FB           B8                   0001  mov	ax,*1
12028 35FE           89EC                       mov	sp,bp
12029 3600           5D                         pop	bp
12030 3601           C3                         ret
12031                                           !BCC_EOS
12032                                           ! 2056     }
12033                                           ! 2057   if (header & 1) {
12034                       00003602            .296:
12035                                           ! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
12036 3602           8A46         0C            mov	al,$C[bp]
12037 3605           24                     01  and	al,*1
12038 3607           84C0                       test	al,al
12039 3609           74           07            je  	.298
12040                       0000360B            .299:
12041                                           ! 2058     ;
12042                                           !BCC_EOS
12043                                           ! 2059     return 1;
12044 360B           B8                   0001  mov	ax,*1
12045 360E           89EC                       mov	sp,bp
12046 3610           5D                         pop	bp
12047 3611           C3                         ret
12048                                           !BCC_EOS
12049                                           ! 2060     }
12050                                           ! 2061   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
12051                       00003612            .298:
12052                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12053 3612           8A46         F1            mov	al,-$F[bp]
12054 3615           30E4                       xor	ah,ah
12055 3617           B1                     03  mov	cl,*3
12056 3619           D3E0                       shl	ax,cl
12057 361B           89C3                       mov	bx,ax
12058                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
12059                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
12060 361D           81C3                 0124  add	bx,#$124
12061 3621           53                         push	bx
12062                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12063 3622           FF76         FE            push	-2[bp]
12064                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12065 3625           E8         CFDF            call	_read_word
12066 3628           83C4                   04  add	sp,*4
12067                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12068 362B           8946         FC            mov	-4[bp],ax
12069                                           !BCC_EOS
12070                                           ! 2062   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
12071                                           ! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
12072 362E           8A46         F1            mov	al,-$F[bp]
12073 3631           30E4                       xor	ah,ah
12074 3633           B1                     03  mov	cl,*3
12075 3635           D3E0                       shl	ax,cl
12076 3637           89C3                       mov	bx,ax
12077                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
12078                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
12079 3639           81C3                 0126  add	bx,#$126
12080 363D           53                         push	bx
12081                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12082 363E           FF76         FE            push	-2[bp]
12083                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
12084 3641           E8         CFC3            call	_read_word
12085 3644           83C4                   04  add	sp,*4
12086                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
12087 3647           8946         FA            mov	-6[bp],ax
12088                                           !BCC_EOS
12089                                           ! 2063   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
12090                                           ! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
12091 364A           8B46         04            mov	ax,4[bp]
12092 364D           B9                   001E  mov	cx,*$1E
12093 3650           F7E9                       imul	cx
12094 3652           89C3                       mov	bx,ax
12095                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
12096                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
12097 3654           81C3                 0146  add	bx,#$146
12098 3658           53                         push	bx
12099                                           ! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
12100 3659           FF76         FE            push	-2[bp]
12101                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
12102 365C           E8         CF95            call	_read_byte
12103 365F           83C4                   04  add	sp,*4
12104                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
12105 3662           8846         EE            mov	-$12[bp],al
12106                                           !BCC_EOS
12107                                           ! 2064   transfer= 0L;
12108                                           ! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
12109 3665           31C0                       xor	ax,ax
12110 3667           31DB                       xor	bx,bx
12111 3669           8946         E4            mov	-$1C[bp],ax
12112 366C           895E         E6            mov	-$1A[bp],bx
12113                                           !BCC_EOS
12114                                           ! 2065   if (cmdlen < 12) cmdlen=12;
12115                                           ! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12116 366F           8A46         06            mov	al,6[bp]
12117 3672           3C                     0C  cmp	al,*$C
12118 3674           73           05            jae 	.29A
12119                       00003676            .29B:
12120                                           ! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12121 3676           B0                     0C  mov	al,*$C
12122 3678           8846         06            mov	6[bp],al
12123                                           !BCC_EOS
12124                                           ! 2066   if (cmdlen > 12) cmdlen=16;
12125                       0000367B            .29A:
12126                                           ! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
12127 367B           8A46         06            mov	al,6[bp]
12128 367E           3C                     0C  cmp	al,*$C
12129 3680           76           05            jbe 	.29C
12130                       00003682            .29D:
12131                                           ! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12132 3682           B0                     10  mov	al,*$10
12133 3684           8846         06            mov	6[bp],al
12134                                           !BCC_EOS
12135                                           ! 2067   cmdlen>>=1;
12136                       00003687            .29C:
12137                                           ! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
12138 3687           8A46         06            mov	al,6[bp]
12139 368A           30E4                       xor	ah,ah
12140 368C           D1E8                       shr	ax,*1
12141 368E           8846         06            mov	6[bp],al
12142                                           !BCC_EOS
12143                                           ! 2068   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
12144                                           ! Debug: list int = const 0 (used reg = )
12145 3691           31C0                       xor	ax,ax
12146 3693           50                         push	ax
12147                                           ! Debug: list * unsigned short = const $254 (used reg = )
12148 3694           B8                   0254  mov	ax,#$254
12149 3697           50                         push	ax
12150                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
12151 3698           FF76         FE            push	-2[bp]
12152                                           ! Debug: func () void = write_word+0 (used reg = )
12153 369B           E8         CF94            call	_write_word
12154 369E           83C4                   06  add	sp,*6
12155                                           !BCC_EOS
12156                                           ! 2069   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
12157                                           ! Debug: list long = const 0 (used reg = )
12158 36A1           31C0                       xor	ax,ax
12159 36A3           31DB                       xor	bx,bx
12160 36A5           53                         push	bx
12161 36A6           50                         push	ax
12162                                           ! Debug: list * unsigned long = const $256 (used reg = )
12163 36A7           B8                   0256  mov	ax,#$256
12164 36AA           50                         push	ax
12165                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
12166 36AB           FF76         FE            push	-2[bp]
12167                                           ! Debug: func () void = write_dword+0 (used reg = )
12168 36AE           E8         C9EA            call	_write_dword
12169 36B1           83C4                   08  add	sp,*8
12170                                           !BCC_EOS
12171                                           ! 2070   status = inb(iobase1
12172                                           ! 2070  + 7);
12173                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
12174 36B4           8B46         FC            mov	ax,-4[bp]
12175                                           ! Debug: list unsigned int = ax+7 (used reg = )
12176 36B7           05                   0007  add	ax,*7
12177 36BA           50                         push	ax
12178                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12179 36BB           E8         CE80            call	_inb
12180 36BE           44                         inc	sp
12181 36BF           44                         inc	sp
12182                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12183 36C0           8846         EF            mov	-$11[bp],al
12184                                           !BCC_EOS
12185                                           ! 2071   if (status & 0x80) return 2;
12186                                           ! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
12187 36C3           8A46         EF            mov	al,-$11[bp]
12188 36C6           24                     80  and	al,#$80
12189 36C8           84C0                       test	al,al
12190 36CA           74           07            je  	.29E
12191                       000036CC            .29F:
12192 36CC           B8                   0002  mov	ax,*2
12193 36CF           89EC                       mov	sp,bp
12194 36D1           5D                         pop	bp
12195 36D2           C3                         ret
12196                                           !BCC_EOS
12197                                           ! 2072   outb(iobase2 + 6, 0x08 | 0x02);
12198                       000036D3            .29E:
12199                                           ! Debug: list int = const $A (used reg = )
12200 36D3           B8                   000A  mov	ax,*$A
12201 36D6           50                         push	ax
12202                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
12203 36D7           8B46         FA            mov	ax,-6[bp]
12204                                           ! Debug: list unsigned int = ax+6 (used reg = )
12205 36DA           05                   0006  add	ax,*6
12206 36DD           50                         push	ax
12207                                           ! Debug: func () void = outb+0 (used reg = )
12208 36DE           E8         CE73            call	_outb
12209 36E1           83C4                   04  add	sp,*4
12210                                           !BCC_EOS
12211                                           ! 2073   outb(iobase1 + 1, 0x00);
12212                                           ! Debug: list int = const 0 (used reg = )
12213 36E4           31C0                       xor	ax,ax
12214 36E6           50                         push	ax
12215                                           ! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
12216 36E7           8B46         FC            mov	ax,-4[bp]
12217                                           ! Debug: list unsigned int = ax+1 (used reg = )
12218 36EA           40                         inc	ax
12219 36EB           50                         push	ax
12220                                           ! Debug: func () void = outb+0 (used reg = )
12221 36EC           E8         CE65            call	_outb
12222 36EF           83C4                   04  add	sp,*4
12223                                           !BCC_EOS
12224                                           ! 2074   outb(iobase1 + 2, 0x00);
12225                                           ! Debug: list int = const 0 (used reg = )
12226 36F2           31C0                       xor	ax,ax
12227 36F4           50                         push	ax
12228                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
12229 36F5           8B46         FC            mov	ax,-4[bp]
12230                                           ! Debug: list unsigned int = ax+2 (used reg = )
12231 36F8           40                         inc	ax
12232 36F9           40                         inc	ax
12233 36FA           50                         push	ax
12234                                           ! Debug: func () void = outb+0 (used reg = )
12235 36FB           E8         CE56            call	_outb
12236 36FE           83C4                   04  add	sp,*4
12237                                           !BCC_EOS
12238                                           ! 2075   outb(iobase1 + 3, 0x00);
12239                                           ! Debug: list int = const 0 (used reg = )
12240 3701           31C0                       xor	ax,ax
12241 3703           50                         push	ax
12242                                           ! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
12243 3704           8B46         FC            mov	ax,-4[bp]
12244                                           ! Debug: list unsigned int = ax+3 (used reg = )
12245 3707           05                   0003  add	ax,*3
12246 370A           50                         push	ax
12247                                           ! Debug: func () void = outb+0 (used reg = )
12248 370B           E8         CE46            call	_outb
12249 370E           83C4                   04  add	sp,*4
12250                                           !BCC_EOS
12251                                           ! 2076   outb(iobase1 + 4, 0xfff0 & 0x00ff);
12252                                           ! Debug: list unsigned int = const $F0 (used reg = )
12253 3711           B8                   00F0  mov	ax,#$F0
12254 3714           50                         push	ax
12255                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
12256 3715           8B46         FC            mov	ax,-4[bp]
12257                                           ! Debug: list unsigned int = ax+4 (used reg = )
12258 3718           05                   0004  add	ax,*4
12259 371B           50                         push	ax
12260                                           ! Debug: func () void = outb+0 (used reg = )
12261 371C           E8         CE35            call	_outb
12262 371F           83C4                   04  add	sp,*4
12263                                           !BCC_EOS
12264                                           ! 2077   outb(iobase1 + 5, 0xfff0 >> 8);
12265                                           ! Debug: list unsigned int = const $FF (used reg = )
12266 3722           B8                   00FF  mov	ax,#$FF
12267 3725           50                         push	ax
12268                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
12269 3726           8B46         FC            mov	ax,-4[bp]
12270                                           ! Debug: list unsigned int = ax+5 (used reg = )
12271 3729           05                   0005  add	ax,*5
12272 372C           50                         push	ax
12273                                           ! Debug: func () void = outb+0 (used reg = )
12274 372D           E8         CE24            call	_outb
12275 3730           83C4                   04  add	sp,*4
12276                                           !BCC_EOS
12277                                           ! 2078   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
12278 3733           8A46         F0            mov	al,-$10[bp]
12279 3736           84C0                       test	al,al
12280 3738           74           04            je  	.2A0
12281                       0000373A            .2A1:
12282 373A           B0                     B0  mov	al,#$B0
12283 373C           EB           02            jmp .2A2
12284                       0000373E            .2A0:
12285 373E           B0                     A0  mov	al,#$A0
12286                       00003740            .2A2:
12287                                           ! Debug: list char = al+0 (used reg = )
12288 3740           30E4                       xor	ah,ah
12289 3742           50                         push	ax
12290                                           ! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
12291 3743           8B46         FC            mov	ax,-4[bp]
12292                                           ! Debug: list unsigned int = ax+6 (used reg = )
12293 3746           05                   0006  add	ax,*6
12294 3749           50                         push	ax
12295                                           ! Debug: func () void = outb+0 (used reg = )
12296 374A           E8         CE07            call	_outb
12297 374D           83C4                   04  add	sp,*4
12298                                           !BCC_EOS
12299                                           ! 2079   outb(iobase1 + 7, 0xA0);
12300                                           ! Debug: list int = const $A0 (used reg = )
12301 3750           B8                   00A0  mov	ax,#$A0
12302 3753           50                         push	ax
12303                                           ! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
12304 3754           8B46         FC            mov	ax,-4[bp]
12305                                           ! Debug: list unsigned int = ax+7 (used reg = )
12306 3757           05                   0007  add	ax,*7
12307 375A           50                         push	ax
12308                                           ! Debug: func () void = outb+0 (used reg = )
12309 375B           E8         CDF6            call	_outb
12310 375E           83C4                   04  add	sp,*4
12311                                           !BCC_EOS
12312                                           ! 2080   status = await_ide(3, iobase1, 32000u);
12313                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12314 3761           B8                   7D00  mov	ax,#$7D00
12315 3764           50                         push	ax
12316                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12317 3765           FF76         FC            push	-4[bp]
12318                                           ! Debug: list int = const 3 (used reg = )
12319 3768           B8                   0003  mov	ax,*3
12320 376B           50                         push	ax
12321                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12322 376C           E8         E549            call	_await_ide
12323 376F           83C4                   06  add	sp,*6
12324                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12325 3772           8846         EF            mov	-$11[bp],al
12326                                           !BCC_EOS
12327                                           ! 2081   if (status & 0x01) {
12328                                           ! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
12329 3775           8A46         EF            mov	al,-$11[bp]
12330 3778           24                     01  and	al,*1
12331 377A           84C0                       test	al,al
12332 377C           74           09            je  	.2A3
12333                       0000377E            .2A4:
12334                                           ! 2082     ;
12335                                           !BCC_EOS
12336                                           ! 2083     return 3;
12337 377E           B8                   0003  mov	ax,*3
12338 3781           89EC                       mov	sp,bp
12339 3783           5D                         pop	bp
12340 3784           C3                         ret
12341                                           !BCC_EOS
12342                                           ! 2084     } else if ( !(status & 0x08) ) {
12343 3785           EB           10            jmp .2A5
12344                       00003787            .2A3:
12345                                           ! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
12346 3787           8A46         EF            mov	al,-$11[bp]
12347 378A           24                     08  and	al,*8
12348 378C           84C0                       test	al,al
12349 378E           75           07            jne 	.2A6
12350                       00003790            .2A7:
12351                                           ! 2085     ;
12352                                           !BCC_EOS
12353                                           ! 2086     return 4;
12354 3790           B8                   0004  mov	ax,*4
12355 3793           89EC                       mov	sp,bp
12356 3795           5D                         pop	bp
12357 3796           C3                         ret
12358                                           !BCC_EOS
12359                                           ! 2087     }
12360                                           ! 2088   cmdseg += (cmdoff / 16);
12361                       00003797            .2A6:
12362                       00003797            .2A5:
12363                                           ! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12364 3797           8B46         0A            mov	ax,$A[bp]
12365 379A           B1                     04  mov	cl,*4
12366 379C           D3E8                       shr	ax,cl
12367                                           ! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
12368 379E           0346         08            add	ax,8[bp]
12369 37A1           8946         08            mov	8[bp],ax
12370                                           !BCC_EOS
12371                                           ! 2089   cmdoff %= 16;
12372                                           ! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
12373 37A4           8B46         0A            mov	ax,$A[bp]
12374 37A7           24                     0F  and	al,*$F
12375 37A9           30E4                       xor	ah,ah
12376 37AB           8946         0A            mov	$A[bp],ax
12377                                           !BCC_EOS
12378                                           ! 2090 #asm
12379                                           !BCC_EOS
12380                                           !BCC_ASM
12381                       00000026            _ata_cmd_packet.cmdoff	set	$26
12382                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12383                       00000028            _ata_cmd_packet.header	set	$28
12384                       0000000C            .ata_cmd_packet.header	set	$C
12385                       0000000E            _ata_cmd_packet.count	set	$E
12386                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12387                       00000010            _ata_cmd_packet.lafter	set	$10
12388                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12389                       00000018            _ata_cmd_packet.iobase1	set	$18
12390                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12391                       0000000D            _ata_cmd_packet.channel	set	$D
12392                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12393                       00000024            _ata_cmd_packet.cmdseg	set	$24
12394                       00000008            .ata_cmd_packet.cmdseg	set	8
12395                       00000022            _ata_cmd_packet.cmdlen	set	$22
12396                       00000006            .ata_cmd_packet.cmdlen	set	6
12397                       00000009            _ata_cmd_packet.lmode	set	9
12398                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12399                       00000020            _ata_cmd_packet.device	set	$20
12400                       00000004            .ata_cmd_packet.device	set	4
12401                       0000001A            _ata_cmd_packet.ebda_seg	set	$1A
12402                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12403                       00000014            _ata_cmd_packet.lcount	set	$14
12404                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12405                       00000004            _ata_cmd_packet.total	set	4
12406                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12407                       0000000B            _ata_cmd_packet.status	set	$B
12408                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12409                       0000000A            _ata_cmd_packet.mode	set	$A
12410                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12411                       00000032            _ata_cmd_packet.bufoff	set	$32
12412                       00000016            .ata_cmd_packet.bufoff	set	$16
12413                       00000000            _ata_cmd_packet.transfer	set	0
12414                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12415                       00000016            _ata_cmd_packet.iobase2	set	$16
12416                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12417                       00000012            _ata_cmd_packet.lbefore	set	$12
12418                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12419                       00000030            _ata_cmd_packet.bufseg	set	$30
12420                       00000014            .ata_cmd_packet.bufseg	set	$14
12421                       0000000C            _ata_cmd_packet.slave	set	$C
12422                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12423                       0000002E            _ata_cmd_packet.inout	set	$2E
12424                       00000012            .ata_cmd_packet.inout	set	$12
12425                       0000002A            _ata_cmd_packet.length	set	$2A
12426                       0000000E            .ata_cmd_packet.length	set	$E
12427 37AE           FB                               sti ;; enable higher priority interrupts
12428 37AF           55                               push bp
12429 37B0           89E5                             mov bp, sp
12430 37B2           8B76         28                  mov si, _ata_cmd_packet.cmdoff + 2[bp]
12431 37B5           8B46         26                  mov ax, _ata_cmd_packet.cmdseg + 2[bp]
12432 37B8           8B4E         24                  mov cx, _ata_cmd_packet.cmdlen + 2[bp]
12433 37BB           8EC0                             mov es, ax ;; segment in es
12434 37BD           8B56         1A                  mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
12435 37C0           26                               seg ES
12436 37C1           F3                               rep
12437 37C2           6F                                 outsw ;; CX words transfered from port(DX) to ES:[SI]
12438 37C3           5D                               pop bp
12439                                           ! 2103 endasm
12440                                           !BCC_ENDASM
12441                                           !BCC_EOS
12442                                           ! 2104   if (inout == 0x00) {
12443                                           ! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
12444 37C4           8A46         12            mov	al,$12[bp]
12445 37C7           84C0                       test	al,al
12446 37C9           75           17            jne 	.2A8
12447                       000037CB            .2A9:
12448                                           ! 2105     status = await_ide(2, iobase1, 32000u);
12449                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12450 37CB           B8                   7D00  mov	ax,#$7D00
12451 37CE           50                         push	ax
12452                                           ! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
12453 37CF           FF76         FC            push	-4[bp]
12454                                           ! Debug: list int = const 2 (used reg = )
12455 37D2           B8                   0002  mov	ax,*2
12456 37D5           50                         push	ax
12457                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12458 37D6           E8         E4DF            call	_await_ide
12459 37D9           83C4                   06  add	sp,*6
12460                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
12461 37DC           8846         EF            mov	-$11[bp],al
12462                                           !BCC_EOS
12463                                           ! 2106     }
12464                                           ! 2107   else {
12465 37DF           E9         0272            br 	.2AA
12466                       000037E2            .2A8:
12467                                           ! 2108         Bit16u loops = 0;
12468 37E2           4C                         dec	sp
12469 37E3           4C                         dec	sp
12470                                           ! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
12471 37E4           31C0                       xor	ax,ax
12472 37E6           8946         E2            mov	-$1E[bp],ax
12473                                           !BCC_EOS
12474                                           ! 2109         Bit8u sc;
12475                                           !BCC_EOS
12476                                           ! 2110   while (1) {
12477 37E9           4C                         dec	sp
12478 37EA           4C                         dec	sp
12479                       000037EB            .2AD:
12480                                           ! 2111       if (loops == 0) {
12481                                           ! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
12482 37EB           8B46         E2            mov	ax,-$1E[bp]
12483 37EE           85C0                       test	ax,ax
12484 37F0           75           25            jne 	.2AE
12485                       000037F2            .2AF:
12486                                           ! 2112         status = inb(iobase2 + 6);
12487                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
12488 37F2           8B46         FA            mov	ax,-6[bp]
12489                                           ! Debug: list unsigned int = ax+6 (used reg = )
12490 37F5           05                   0006  add	ax,*6
12491 37F8           50                         push	ax
12492                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12493 37F9           E8         CD42            call	_inb
12494 37FC           44                         inc	sp
12495 37FD           44                         inc	sp
12496                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12497 37FE           8846         EF            mov	-$11[bp],al
12498                                           !BCC_EOS
12499                                           ! 2113         status = await_ide(3, iobase1, 32000u);
12500                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12501 3801           B8                   7D00  mov	ax,#$7D00
12502 3804           50                         push	ax
12503                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12504 3805           FF76         FC            push	-4[bp]
12505                                           ! Debug: list int = const 3 (used reg = )
12506 3808           B8                   0003  mov	ax,*3
12507 380B           50                         push	ax
12508                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12509 380C           E8         E4A9            call	_await_ide
12510 380F           83C4                   06  add	sp,*6
12511                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12512 3812           8846         EF            mov	-$11[bp],al
12513                                           !BCC_EOS
12514                                           ! 2114       }
12515                                           ! 2115       else
12516                                           ! 2116         status = await_ide(2, iobase1, 32000u);
12517 3815           EB           14            jmp .2B0
12518                       00003817            .2AE:
12519                                           ! Debug: list unsigned int = const $7D00 (used reg = )
12520 3817           B8                   7D00  mov	ax,#$7D00
12521 381A           50                         push	ax
12522                                           ! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
12523 381B           FF76         FC            push	-4[bp]
12524                                           ! Debug: list int = const 2 (used reg = )
12525 381E           B8                   0002  mov	ax,*2
12526 3821           50                         push	ax
12527                                           ! Debug: func () unsigned char = await_ide+0 (used reg = )
12528 3822           E8         E493            call	_await_ide
12529 3825           83C4                   06  add	sp,*6
12530                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
12531 3828           8846         EF            mov	-$11[bp],al
12532                                           !BCC_EOS
12533                                           ! 2117       loops++;
12534                       0000382B            .2B0:
12535                                           ! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
12536 382B           8B46         E2            mov	ax,-$1E[bp]
12537 382E           40                         inc	ax
12538 382F           8946         E2            mov	-$1E[bp],ax
12539                                           !BCC_EOS
12540                                           ! 2118       sc = inb(iobase1 + 2);
12541                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12542 3832           8B46         FC            mov	ax,-4[bp]
12543                                           ! Debug: list unsigned int = ax+2 (used reg = )
12544 3835           40                         inc	ax
12545 3836           40                         inc	ax
12546 3837           50                         push	ax
12547                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12548 3838           E8         CD03            call	_inb
12549 383B           44                         inc	sp
12550 383C           44                         inc	sp
12551                                           ! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
12552 383D           8846         E1            mov	-$1F[bp],al
12553                                           !BCC_EOS
12554                                           ! 2119       if(((inb(iobase1 + 2)&0x7)==0x3) &&
12555                                           ! 2120          ((status & (0x40 | 0x01)) == 0x40)) break;
12556                                           ! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
12557 3840           8B46         FC            mov	ax,-4[bp]
12558                                           ! Debug: list unsigned int = ax+2 (used reg = )
12559 3843           40                         inc	ax
12560 3844           40                         inc	ax
12561 3845           50                         push	ax
12562                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12563 3846           E8         CCF5            call	_inb
12564 3849           44                         inc	sp
12565 384A           44                         inc	sp
12566                                           ! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
12567 384B           24                     07  and	al,*7
12568                                           ! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
12569 384D           3C                     03  cmp	al,*3
12570 384F           75           0C            jne 	.2B1
12571                       00003851            .2B3:
12572                                           ! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
12573 3851           8A46         EF            mov	al,-$11[bp]
12574 3854           24                     41  and	al,*$41
12575                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
12576 3856           3C                     40  cmp	al,*$40
12577 3858           75           03            jne 	.2B1
12578                       0000385A            .2B2:
12579 385A           E9         01F4            br 	.2AB
12580                                           !BCC_EOS
12581                                           ! 2121       if (status & 0x01) {
12582                       0000385D            .2B1:
12583                                           ! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
12584 385D           8A46         EF            mov	al,-$11[bp]
12585 3860           24                     01  and	al,*1
12586 3862           84C0                       test	al,al
12587 3864           74           07            je  	.2B4
12588                       00003866            .2B5:
12589                                           ! 2122         ;
12590                                           !BCC_EOS
12591                                           ! 2123         return 3;
12592 3866           B8                   0003  mov	ax,*3
12593 3869           89EC                       mov	sp,bp
12594 386B           5D                         pop	bp
12595 386C           C3                         ret
12596                                           !BCC_EOS
12597                                           ! 2124       }
12598                                           ! 2125       bufseg += (bufoff / 16);
12599                       0000386D            .2B4:
12600                                           ! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12601 386D           8B46         16            mov	ax,$16[bp]
12602 3870           B1                     04  mov	cl,*4
12603 3872           D3E8                       shr	ax,cl
12604                                           ! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
12605 3874           0346         14            add	ax,$14[bp]
12606 3877           8946         14            mov	$14[bp],ax
12607                                           !BCC_EOS
12608                                           ! 2126       bufoff %= 16;
12609                                           ! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
12610 387A           8B46         16            mov	ax,$16[bp]
12611 387D           24                     0F  and	al,*$F
12612 387F           30E4                       xor	ah,ah
12613 3881           8946         16            mov	$16[bp],ax
12614                                           !BCC_EOS
12615                                           ! 2127       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
12616                                           ! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
12617 3884           8B46         FC            mov	ax,-4[bp]
12618                                           ! Debug: list unsigned int = ax+4 (used reg = )
12619 3887           05                   0004  add	ax,*4
12620 388A           50                         push	ax
12621                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12622 388B           E8         CCB0            call	_inb
12623 388E           44                         inc	sp
12624 388F           44                         inc	sp
12625 3890           50                         push	ax
12626                                           ! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
12627 3891           8B46         FC            mov	ax,-4[bp]
12628                                           ! Debug: list unsigned int = ax+5 (used reg = )
12629 3894           05                   0005  add	ax,*5
12630 3897           50                         push	ax
12631                                           ! Debug: func () unsigned char = inb+0 (used reg = )
12632 3898           E8         CCA3            call	_inb
12633 389B           44                         inc	sp
12634 389C           44                         inc	sp
12635                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
12636 389D           30E4                       xor	ah,ah
12637                                           ! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
12638 389F           88C4                       mov	ah,al
12639 38A1           30C0                       xor	al,al
12640                                           ! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
12641 38A3           0246         DE            add	al,-$22[bp]
12642 38A6           80D4                   00  adc	ah,*0
12643 38A9           44                         inc	sp
12644 38AA           44                         inc	sp
12645                                           ! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
12646 38AB           8946         F8            mov	-8[bp],ax
12647                                           !BCC_EOS
12648                                           ! 2128       if(header>lcount) {
12649                                           ! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12650 38AE           8B46         0C            mov	ax,$C[bp]
12651 38B1           3B46         F8            cmp	ax,-8[bp]
12652 38B4           76           16            jbe 	.2B6
12653                       000038B6            .2B7:
12654                                           ! 2129          lbefore=lcount;
12655                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12656 38B6           8B46         F8            mov	ax,-8[bp]
12657 38B9           8946         F6            mov	-$A[bp],ax
12658                                           !BCC_EOS
12659                                           ! 2130          header-=lcount;
12660                                           ! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
12661 38BC           8B46         0C            mov	ax,$C[bp]
12662 38BF           2B46         F8            sub	ax,-8[bp]
12663 38C2           8946         0C            mov	$C[bp],ax
12664                                           !BCC_EOS
12665                                           ! 2131          lcount=0;
12666                                           ! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12667 38C5           31C0                       xor	ax,ax
12668 38C7           8946         F8            mov	-8[bp],ax
12669                                           !BCC_EOS
12670                                           ! 2132          }
12671                                           ! 2133       else {
12672 38CA           EB           14            jmp .2B8
12673                       000038CC            .2B6:
12674                                           ! 2134         lbefore=header;
12675                                           ! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
12676 38CC           8B46         0C            mov	ax,$C[bp]
12677 38CF           8946         F6            mov	-$A[bp],ax
12678                                           !BCC_EOS
12679                                           ! 2135         header=0;
12680                                           ! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
12681 38D2           31C0                       xor	ax,ax
12682 38D4           8946         0C            mov	$C[bp],ax
12683                                           !BCC_EOS
12684                                           ! 2136         lcount-=lbefore;
12685                                           ! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12686 38D7           8B46         F8            mov	ax,-8[bp]
12687 38DA           2B46         F6            sub	ax,-$A[bp]
12688 38DD           8946         F8            mov	-8[bp],ax
12689                                           !BCC_EOS
12690                                           ! 2137         }
12691                                           ! 2138       if(lcount>length) {
12692                       000038E0            .2B8:
12693                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12694 38E0           8B46         F8            mov	ax,-8[bp]
12695 38E3           31DB                       xor	bx,bx
12696                                           ! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12697 38E5           8D7E         0E            lea	di,$E[bp]
12698 38E8           E8         C7E0            call	lcmpul
12699 38EB           76           20            jbe 	.2B9
12700                       000038ED            .2BA:
12701                                           ! 2139         lafter=lcount-length;
12702                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12703 38ED           8B46         F8            mov	ax,-8[bp]
12704 38F0           31DB                       xor	bx,bx
12705                                           ! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
12706 38F2           8D7E         0E            lea	di,$E[bp]
12707 38F5           E8         C7E9            call	lsubul
12708                                           ! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
12709 38F8           8946         F4            mov	-$C[bp],ax
12710                                           !BCC_EOS
12711                                           ! 2140         lcount=length;
12712                                           ! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
12713 38FB           8B46         0E            mov	ax,$E[bp]
12714 38FE           8946         F8            mov	-8[bp],ax
12715                                           !BCC_EOS
12716                                           ! 2141         length=0;
12717                                           ! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
12718 3901           31C0                       xor	ax,ax
12719 3903           31DB                       xor	bx,bx
12720 3905           8946         0E            mov	$E[bp],ax
12721 3908           895E         10            mov	$10[bp],bx
12722                                           !BCC_EOS
12723                                           ! 2142         }
12724                                           ! 2143       else {
12725 390B           EB           21            jmp .2BB
12726                       0000390D            .2B9:
12727                                           ! 2144         lafter=0;
12728                                           ! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12729 390D           31C0                       xor	ax,ax
12730 390F           8946         F4            mov	-$C[bp],ax
12731                                           !BCC_EOS
12732                                           ! 2145         length-=lcount;
12733                                           ! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
12734 3912           8B46         F8            mov	ax,-8[bp]
12735 3915           31DB                       xor	bx,bx
12736                                           ! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
12737 3917           53                         push	bx
12738 3918           50                         push	ax
12739 3919           8B46         0E            mov	ax,$E[bp]
12740 391C           8B5E         10            mov	bx,$10[bp]
12741 391F           8D7E         DC            lea	di,-$24[bp]
12742 3922           E8         C7BC            call	lsubul
12743 3925           8946         0E            mov	$E[bp],ax
12744 3928           895E         10            mov	$10[bp],bx
12745 392B           83C4                   04  add	sp,*4
12746                                           !BCC_EOS
12747                                           ! 2146         }
12748                                           ! 2147       count = lcount;
12749                       0000392E            .2BB:
12750                                           ! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
12751 392E           8B46         F8            mov	ax,-8[bp]
12752 3931           8946         F2            mov	-$E[bp],ax
12753                                           !BCC_EOS
12754                                           ! 2148       ;
12755                                           !BCC_EOS
12756                                           ! 2149       ;
12757                                           !BCC_EOS
12758                                           ! 2150       lmode = mode;
12759                                           ! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
12760 3934           8A46         EE            mov	al,-$12[bp]
12761 3937           8846         ED            mov	-$13[bp],al
12762                                           !BCC_EOS
12763                                           ! 2151       if (lbefore & 0x03) lmode=0x00;
12764                                           ! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
12765 393A           8A46         F6            mov	al,-$A[bp]
12766 393D           24                     03  and	al,*3
12767 393F           84C0                       test	al,al
12768 3941           74           05            je  	.2BC
12769                       00003943            .2BD:
12770                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12771 3943           30C0                       xor	al,al
12772 3945           8846         ED            mov	-$13[bp],al
12773                                           !BCC_EOS
12774                                           ! 2152       if (lcount & 0x03) lmode=0x00;
12775                       00003948            .2BC:
12776                                           ! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
12777 3948           8A46         F8            mov	al,-8[bp]
12778 394B           24                     03  and	al,*3
12779 394D           84C0                       test	al,al
12780 394F           74           05            je  	.2BE
12781                       00003951            .2BF:
12782                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12783 3951           30C0                       xor	al,al
12784 3953           8846         ED            mov	-$13[bp],al
12785                                           !BCC_EOS
12786                                           ! 2153     
12787                                           ! 2153   if (lafter & 0x03) lmode=0x00;
12788                       00003956            .2BE:
12789                                           ! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
12790 3956           8A46         F4            mov	al,-$C[bp]
12791 3959           24                     03  and	al,*3
12792 395B           84C0                       test	al,al
12793 395D           74           05            je  	.2C0
12794                       0000395F            .2C1:
12795                                           ! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
12796 395F           30C0                       xor	al,al
12797 3961           8846         ED            mov	-$13[bp],al
12798                                           !BCC_EOS
12799                                           ! 2154       if (lcount & 0x01) {
12800                       00003964            .2C0:
12801                                           ! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12802 3964           8A46         F8            mov	al,-8[bp]
12803 3967           24                     01  and	al,*1
12804 3969           84C0                       test	al,al
12805 396B           74           1E            je  	.2C2
12806                       0000396D            .2C3:
12807                                           ! 2155         lcount+=1;
12808                                           ! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12809 396D           8B46         F8            mov	ax,-8[bp]
12810 3970           40                         inc	ax
12811 3971           8946         F8            mov	-8[bp],ax
12812                                           !BCC_EOS
12813                                           ! 2156         if ((lafter > 0) && (lafter & 0x01)) {
12814                                           ! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
12815 3974           8B46         F4            mov	ax,-$C[bp]
12816 3977           85C0                       test	ax,ax
12817 3979           74           10            je  	.2C4
12818                       0000397B            .2C6:
12819                                           ! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12820 397B           8A46         F4            mov	al,-$C[bp]
12821 397E           24                     01  and	al,*1
12822 3980           84C0                       test	al,al
12823 3982           74           07            je  	.2C4
12824                       00003984            .2C5:
12825                                           ! 2157           lafter-=1;
12826                                           ! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12827 3984           8B46         F4            mov	ax,-$C[bp]
12828 3987           48                         dec	ax
12829 3988           8946         F4            mov	-$C[bp],ax
12830                                           !BCC_EOS
12831                                           ! 2158           }
12832                                           ! 2159         }
12833                       0000398B            .2C4:
12834                                           ! 2160       if (lmode == 0x01) {
12835                       0000398B            .2C2:
12836                                           ! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
12837 398B           8A46         ED            mov	al,-$13[bp]
12838 398E           3C                     01  cmp	al,*1
12839 3990           75           20            jne 	.2C7
12840                       00003992            .2C8:
12841                                           ! 2161         lcount>>=2; lbefore>>=2; lafter>>=2;
12842                                           ! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
12843 3992           8B46         F8            mov	ax,-8[bp]
12844 3995           D1E8                       shr	ax,*1
12845 3997           D1E8                       shr	ax,*1
12846 3999           8946         F8            mov	-8[bp],ax
12847                                           !BCC_EOS
12848                                           ! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
12849 399C           8B46         F6            mov	ax,-$A[bp]
12850 399F           D1E8                       shr	ax,*1
12851 39A1           D1E8                       shr	ax,*1
12852 39A3           8946         F6            mov	-$A[bp],ax
12853                                           !BCC_EOS
12854                                           ! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
12855 39A6           8B46         F4            mov	ax,-$C[bp]
12856 39A9           D1E8                       shr	ax,*1
12857 39AB           D1E8                       shr	ax,*1
12858 39AD           8946         F4            mov	-$C[bp],ax
12859                                           !BCC_EOS
12860                                           ! 2162         }
12861                                           ! 2163       else {
12862 39B0           EB           18            jmp .2C9
12863                       000039B2            .2C7:
12864                                           ! 2164         lcount>>=1; lbefore>>=1; lafter>>=1;
12865                                           ! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
12866 39B2           8B46         F8            mov	ax,-8[bp]
12867 39B5           D1E8                       shr	ax,*1
12868 39B7           8946         F8            mov	-8[bp],ax
12869                                           !BCC_EOS
12870                                           ! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
12871 39BA           8B46         F6            mov	ax,-$A[bp]
12872 39BD           D1E8                       shr	ax,*1
12873 39BF           8946         F6            mov	-$A[bp],ax
12874                                           !BCC_EOS
12875                                           ! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
12876 39C2           8B46         F4            mov	ax,-$C[bp]
12877 39C5           D1E8                       shr	ax,*1
12878 39C7           8946         F4            mov	-$C[bp],ax
12879                                           !BCC_EOS
12880                                           ! 2165         }
12881                                           ! 2166        ;
12882                       000039CA            .2C9:
12883                                           !BCC_EOS
12884                                           ! 2167 #asm
12885                                           !BCC_EOS
12886                                           !BCC_ASM
12887                       0000002A            _ata_cmd_packet.cmdoff	set	$2A
12888                       0000000A            .ata_cmd_packet.cmdoff	set	$A
12889                       0000002C            _ata_cmd_packet.header	set	$2C
12890                       0000000C            .ata_cmd_packet.header	set	$C
12891                       00000012            _ata_cmd_packet.count	set	$12
12892                       FFFFFFF2            .ata_cmd_packet.count	set	-$E
12893                       00000014            _ata_cmd_packet.lafter	set	$14
12894                       FFFFFFF4            .ata_cmd_packet.lafter	set	-$C
12895                       0000001C            _ata_cmd_packet.iobase1	set	$1C
12896                       FFFFFFFC            .ata_cmd_packet.iobase1	set	-4
12897                       00000011            _ata_cmd_packet.channel	set	$11
12898                       FFFFFFF1            .ata_cmd_packet.channel	set	-$F
12899                       00000028            _ata_cmd_packet.cmdseg	set	$28
12900                       00000008            .ata_cmd_packet.cmdseg	set	8
12901                       00000026            _ata_cmd_packet.cmdlen	set	$26
12902                       00000006            .ata_cmd_packet.cmdlen	set	6
12903                       0000000D            _ata_cmd_packet.lmode	set	$D
12904                       FFFFFFED            .ata_cmd_packet.lmode	set	-$13
12905                       00000024            _ata_cmd_packet.device	set	$24
12906                       00000004            .ata_cmd_packet.device	set	4
12907                       00000002            _ata_cmd_packet.loops	set	2
12908                       FFFFFFE2            .ata_cmd_packet.loops	set	-$1E
12909                       0000001E            _ata_cmd_packet.ebda_seg	set	$1E
12910                       FFFFFFFE            .ata_cmd_packet.ebda_seg	set	-2
12911                       00000018            _ata_cmd_packet.lcount	set	$18
12912                       FFFFFFF8            .ata_cmd_packet.lcount	set	-8
12913                       00000008            _ata_cmd_packet.total	set	8
12914                       FFFFFFE8            .ata_cmd_packet.total	set	-$18
12915                       0000000F            _ata_cmd_packet.status	set	$F
12916                       FFFFFFEF            .ata_cmd_packet.status	set	-$11
12917                       0000000E            _ata_cmd_packet.mode	set	$E
12918                       FFFFFFEE            .ata_cmd_packet.mode	set	-$12
12919                       00000036            _ata_cmd_packet.bufoff	set	$36
12920                       00000016            .ata_cmd_packet.bufoff	set	$16
12921                       00000004            _ata_cmd_packet.transfer	set	4
12922                       FFFFFFE4            .ata_cmd_packet.transfer	set	-$1C
12923                       00000001            _ata_cmd_packet.sc	set	1
12924                       FFFFFFE1            .ata_cmd_packet.sc	set	-$1F
12925                       0000001A            _ata_cmd_packet.iobase2	set	$1A
12926                       FFFFFFFA            .ata_cmd_packet.iobase2	set	-6
12927                       00000016            _ata_cmd_packet.lbefore	set	$16
12928                       FFFFFFF6            .ata_cmd_packet.lbefore	set	-$A
12929                       00000034            _ata_cmd_packet.bufseg	set	$34
12930                       00000014            .ata_cmd_packet.bufseg	set	$14
12931                       00000010            _ata_cmd_packet.slave	set	$10
12932                       FFFFFFF0            .ata_cmd_packet.slave	set	-$10
12933                       00000032            _ata_cmd_packet.inout	set	$32
12934                       00000012            .ata_cmd_packet.inout	set	$12
12935                       0000002E            _ata_cmd_packet.length	set	$2E
12936                       0000000E            .ata_cmd_packet.length	set	$E
12937 39CA           55                                 push bp
12938 39CB           89E5                               mov bp, sp
12939 39CD           8B56         1E                    mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
12940 39D0           8B4E         18                    mov cx, _ata_cmd_packet.lbefore + 2[bp]
12941 39D3           E3           15                    jcxz ata_packet_no_before
12942 39D5           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12943 39D8           80FC                   01          cmp ah, #0x01
12944 39DB           74           05                    je ata_packet_in_before_32
12945                       000039DD            ata_packet_in_before_16:
12946 39DD           ED                                 in ax, dx
12947 39DE           E2           FD                    loop ata_packet_in_before_16
12948 39E0           EB           08                    jmp ata_packet_no_before
12949                       000039E2            ata_packet_in_before_32:
12950 39E2     66    50                                 push eax
12951                       000039E4            ata_packet_in_before_32_loop:
12952 39E4     66    ED                                 in eax, dx
12953 39E6           E2           FC                    loop ata_packet_in_before_32_loop
12954 39E8     66    58                                 pop eax
12955                       000039EA            ata_packet_no_before:
12956 39EA           8B4E         1A                    mov cx, _ata_cmd_packet.lcount + 2[bp]
12957 39ED           E3           17                    jcxz ata_packet_after
12958 39EF           8B7E         38                    mov di, _ata_cmd_packet.bufoff + 2[bp]
12959 39F2           8B46         36                    mov ax, _ata_cmd_packet.bufseg + 2[bp]
12960 39F5           8EC0                               mov es, ax
12961 39F7           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12962 39FA           80FC                   01          cmp ah, #0x01
12963 39FD           74           04                    je ata_packet_in_32
12964                       000039FF            ata_packet_in_16:
12965 39FF           F3                                 rep
12966 3A00           6D                                   insw ;; CX words transfered tp port(DX) to ES:[DI]
12967 3A01           EB           03                    jmp ata_packet_after
12968                       00003A03            ata_packet_in_32:
12969 3A03           F3                                 rep
12970 3A04     66    6D                                   insd ;; CX dwords transfered to port(DX) to ES:[DI]
12971                       00003A06            ata_packet_after:
12972 3A06           8B4E         16                    mov cx, _ata_cmd_packet.lafter + 2[bp]
12973 3A09           E3           15                    jcxz ata_packet_done
12974 3A0B           8A66         0F                    mov ah, _ata_cmd_packet.lmode + 2[bp]
12975 3A0E           80FC                   01          cmp ah, #0x01
12976 3A11           74           05                    je ata_packet_in_after_32
12977                       00003A13            ata_packet_in_after_16:
12978 3A13           ED                                 in ax, dx
12979 3A14           E2           FD                    loop ata_packet_in_after_16
12980 3A16           EB           08                    jmp ata_packet_done
12981                       00003A18            ata_packet_in_after_32:
12982 3A18     66    50                                 push eax
12983                       00003A1A            ata_packet_in_after_32_loop:
12984 3A1A     66    ED                                 in eax, dx
12985 3A1C           E2           FC                    loop ata_packet_in_after_32_loop
12986 3A1E     66    58                                 pop eax
12987                       00003A20            ata_packet_done:
12988 3A20           5D                                 pop bp
12989                                           ! 2220 endasm
12990                                           !BCC_ENDASM
12991                                           !BCC_EOS
12992                                           ! 2221       bufoff += count;
12993                                           ! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
12994 3A21           8B46         16            mov	ax,$16[bp]
12995 3A24           0346         F2            add	ax,-$E[bp]
12996 3A27           8946         16            mov	$16[bp],ax
12997                                           !BCC_EOS
12998                                           ! 2222       transfer += count;
12999                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
13000 3A2A           8B46         F2            mov	ax,-$E[bp]
13001 3A2D           31DB                       xor	bx,bx
13002                                           ! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
13003 3A2F           8D7E         E4            lea	di,-$1C[bp]
13004 3A32           E8         C68E            call	laddul
13005 3A35           8946         E4            mov	-$1C[bp],ax
13006 3A38           895E         E6            mov	-$1A[bp],bx
13007                                           !BCC_EOS
13008                                           ! 2223       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
13009                                           ! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
13010 3A3B           FF76         E6            push	-$1A[bp]
13011 3A3E           FF76         E4            push	-$1C[bp]
13012                                           ! Debug: list * unsigned long = const $256 (used reg = )
13013 3A41           B8                   0256  mov	ax,#$256
13014 3A44           50                         push	ax
13015                                           ! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
13016 3A45           FF76         FE            push	-2[bp]
13017                                           ! Debug: func () void = write_dword+0 (used reg = )
13018 3A48           E8         C650            call	_write_dword
13019 3A4B           83C4                   08  add	sp,*8
13020                                           !BCC_EOS
13021                                           ! 2224       }
13022                                           ! 2225     }
13023                       00003A4E            .2AC:
13024 3A4E           E9         FD9A            br 	.2AD
13025                       00003A51            .2CA:
13026                       00003A51            .2AB:
13027 3A51           83C4                   04  add	sp,*4
13028                                           ! 2226   if ( (status & (
13029                       00003A54            .2AA:
13030                                           ! 2226 0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
13031                                           ! 2227          != 0x40 ) {
13032                                           ! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
13033 3A54           8A46         EF            mov	al,-$11[bp]
13034 3A57           24                     E9  and	al,#$E9
13035                                           ! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
13036 3A59           3C                     40  cmp	al,*$40
13037 3A5B           74           07            je  	.2CB
13038                       00003A5D            .2CC:
13039                                           ! 2228     ;
13040                                           !BCC_EOS
13041                                           ! 2229     return 4;
13042 3A5D           B8                   0004  mov	ax,*4
13043 3A60           89EC                       mov	sp,bp
13044 3A62           5D                         pop	bp
13045 3A63           C3                         ret
13046                                           !BCC_EOS
13047                                           ! 2230     }
13048                                           ! 2231   outb(iobase2+6, 0x08);
13049                       00003A64            .2CB:
13050                                           ! Debug: list int = const 8 (used reg = )
13051 3A64           B8                   0008  mov	ax,*8
13052 3A67           50                         push	ax
13053                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
13054 3A68           8B46         FA            mov	ax,-6[bp]
13055                                           ! Debug: list unsigned int = ax+6 (used reg = )
13056 3A6B           05                   0006  add	ax,*6
13057 3A6E           50                         push	ax
13058                                           ! Debug: func () void = outb+0 (used reg = )
13059 3A6F           E8         CAE2            call	_outb
13060 3A72           83C4                   04  add	sp,*4
13061                                           !BCC_EOS
13062                                           ! 2232   return 0;
13063 3A75           31C0                       xor	ax,ax
13064 3A77           89EC                       mov	sp,bp
13065 3A79           5D                         pop	bp
13066 3A7A           C3                         ret
13067                                           !BCC_EOS
13068                                           ! 2233 }
13069                                           ! 2234   Bit16u
13070                                           ! Register BX used in function ata_cmd_packet
13071                                           ! 2235 atapi_get_sense(device, seg, asc, ascq)
13072                                           ! 2236   Bit16u device;
13073                                           export	_atapi_get_sense
13074                       00003A7B            _atapi_get_sense:
13075                                           !BCC_EOS
13076                                           ! 2237 {
13077                                           ! 2238   Bit8u atacmd[12];
13078                                           !BCC_EOS
13079                                           ! 2239   Bit8u buffer[18];
13080                                           !BCC_EOS
13081                                           ! 2240   Bit8u i;
13082                                           !BCC_EOS
13083                                           ! 2241   memsetb(get_SS(),atacmd,0,12);
13084 3A7B           55                         push	bp
13085 3A7C           89E5                       mov	bp,sp
13086 3A7E           83C4                   E0  add	sp,*-$20
13087                                           ! Debug: list int = const $C (used reg = )
13088 3A81           B8                   000C  mov	ax,*$C
13089 3A84           50                         push	ax
13090                                           ! Debug: list int = const 0 (used reg = )
13091 3A85           31C0                       xor	ax,ax
13092 3A87           50                         push	ax
13093                                           ! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
13094 3A88           8D5E         F4            lea	bx,-$C[bp]
13095 3A8B           53                         push	bx
13096                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13097 3A8C           E8         CBBE            call	_get_SS
13098                                           ! Debug: list unsigned short = ax+0 (used reg = )
13099 3A8F           50                         push	ax
13100                                           ! Debug: func () void = memsetb+0 (used reg = )
13101 3A90           E8         C56D            call	_memsetb
13102 3A93           83C4                   08  add	sp,*8
13103                                           !BCC_EOS
13104                                           ! 2242   atacmd[0]=0x03;
13105                                           ! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
13106 3A96           B0                     03  mov	al,*3
13107 3A98           8846         F4            mov	-$C[bp],al
13108                                           !BCC_EOS
13109                                           ! 2243   atacmd[4]=sizeof(buffer);
13110                                           ! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
13111 3A9B           B0                     12  mov	al,*$12
13112 3A9D           8846         F8            mov	-8[bp],al
13113                                           !BCC_EOS
13114                                           ! 2244   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
13115                                           ! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
13116 3AA0           8D5E         E2            lea	bx,-$1E[bp]
13117 3AA3           53                         push	bx
13118                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13119 3AA4           E8         CBA6            call	_get_SS
13120                                           ! Debug: list unsigned short = ax+0 (used reg = )
13121 3AA7           50                         push	ax
13122                                           ! Debug: list int = const 1 (used reg = )
13123 3AA8           B8                   0001  mov	ax,*1
13124 3AAB           50                         push	ax
13125                                           ! Debug: list long = const $12 (used reg = )
13126 3AAC           B8                   0012  mov	ax,*$12
13127 3AAF           31DB                       xor	bx,bx
13128 3AB1           53                         push	bx
13129 3AB2           50                         push	ax
13130                                           ! Debug: list int = const 0 (used reg = )
13131 3AB3           31C0                       xor	ax,ax
13132 3AB5           50                         push	ax
13133                                           ! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
13134 3AB6           8D5E         F4            lea	bx,-$C[bp]
13135 3AB9           53                         push	bx
13136                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13137 3ABA           E8         CB90            call	_get_SS
13138                                           ! Debug: list unsigned short = ax+0 (used reg = )
13139 3ABD           50                         push	ax
13140                                           ! Debug: list int = const $C (used reg = )
13141 3ABE           B8                   000C  mov	ax,*$C
13142 3AC1           50                         push	ax
13143                                           ! Debug: list unsigned short device = [S+$34+2] (used reg = )
13144 3AC2           FF76         04            push	4[bp]
13145                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13146 3AC5           E8         FB03            call	_ata_cmd_packet
13147 3AC8           83C4                   14  add	sp,*$14
13148                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
13149 3ACB           85C0                       test	ax,ax
13150 3ACD           74           07            je  	.2CD
13151                       00003ACF            .2CE:
13152                                           ! 2245     return 0x0002;
13153 3ACF           B8                   0002  mov	ax,*2
13154 3AD2           89EC                       mov	sp,bp
13155 3AD4           5D                         pop	bp
13156 3AD5           C3                         ret
13157                                           !BCC_EOS
13158                                           ! 2246   write_byte(seg,asc,buffer[12]);
13159                       00003AD6            .2CD:
13160                                           ! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
13161 3AD6           8A46         EE            mov	al,-$12[bp]
13162 3AD9           30E4                       xor	ah,ah
13163 3ADB           50                         push	ax
13164                                           ! Debug: list int asc = [S+$24+6] (used reg = )
13165 3ADC           FF76         08            push	8[bp]
13166                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13167 3ADF           FF76         06            push	6[bp]
13168                                           ! Debug: func () void = write_byte+0 (used reg = )
13169 3AE2           E8         CB35            call	_write_byte
13170 3AE5           83C4                   06  add	sp,*6
13171                                           !BCC_EOS
13172                                           ! 2247   write_byte(seg,ascq,buffer[13]);
13173                                           ! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
13174 3AE8           8A46         EF            mov	al,-$11[bp]
13175 3AEB           30E4                       xor	ah,ah
13176 3AED           50                         push	ax
13177                                           ! Debug: list int ascq = [S+$24+8] (used reg = )
13178 3AEE           FF76         0A            push	$A[bp]
13179                                           ! Debug: list int seg = [S+$26+4] (used reg = )
13180 3AF1           FF76         06            push	6[bp]
13181                                           ! Debug: func () void = write_byte+0 (used reg = )
13182 3AF4           E8         CB23            call	_write_byte
13183 3AF7           83C4                   06  add	sp,*6
13184                                           !BCC_EOS
13185                                           ! 2248   return 0;
13186 3AFA           31C0                       xor	ax,ax
13187 3AFC           89EC                       mov	sp,bp
13188 3AFE           5D                         pop	bp
13189 3AFF           C3                         ret
13190                                           !BCC_EOS
13191                                           ! 2249 }
13192                                           ! 2250   Bit16u
13193                                           ! Register BX used in function atapi_get_sense
13194                                           ! 2251 atapi_is_ready(device)
13195                                           ! 2252   Bit16u device;
13196                                           export	_atapi_is_ready
13197                       00003B00            _atapi_is_ready:
13198                                           !BCC_EOS
13199                                           ! 2253 {
13200                                           ! 2254   Bit8u packet[12];
13201                                           !BCC_EOS
13202                                           ! 2255   Bit8u buf[8];
13203                                           !BCC_EOS
13204                                           ! 2256   Bit32u block_len;
13205                                           !BCC_EOS
13206                                           ! 2257   Bit32u sectors;
13207                                           !BCC_EOS
13208                                           ! 2258   Bit32u timeout;
13209                                           !BCC_EOS
13210                                           ! 2259   Bit32u time;
13211                                           !BCC_EOS
13212                                           ! 2260   Bit8u asc, ascq;
13213                                           !BCC_EOS
13214                                           ! 2261   Bit8u in_progress;
13215                                           !BCC_EOS
13216                                           ! 2262   Bit16u ebda_seg = read_word(0x0040,0x000E);
13217 3B00           55                         push	bp
13218 3B01           89E5                       mov	bp,sp
13219 3B03           83C4                   D6  add	sp,*-$2A
13220                                           ! Debug: list int = const $E (used reg = )
13221 3B06           B8                   000E  mov	ax,*$E
13222 3B09           50                         push	ax
13223                                           ! Debug: list int = const $40 (used reg = )
13224 3B0A           B8                   0040  mov	ax,*$40
13225 3B0D           50                         push	ax
13226                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13227 3B0E           E8         CAF6            call	_read_word
13228 3B11           83C4                   04  add	sp,*4
13229                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
13230 3B14           8946         D6            mov	-$2A[bp],ax
13231                                           !BCC_EOS
13232                                           ! 2263   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
13233                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13234 3B17           8B46         04            mov	ax,4[bp]
13235 3B1A           B9                   001E  mov	cx,*$1E
13236 3B1D           F7E9                       imul	cx
13237 3B1F           89C3                       mov	bx,ax
13238                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13239                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13240 3B21           81C3                 0142  add	bx,#$142
13241 3B25           53                         push	bx
13242                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13243 3B26           FF76         D6            push	-$2A[bp]
13244                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13245 3B29           E8         CAC8            call	_read_byte
13246 3B2C           83C4                   04  add	sp,*4
13247                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13248 3B2F           3C                     03  cmp	al,*3
13249 3B31           74           15            je  	.2CF
13250                       00003B33            .2D0:
13251                                           ! 2264     bios_printf(2, "not implemented for non-ATAPI device\n");
13252                                           ! Debug: list * char = .2D1+0 (used reg = )
13253 3B33           BB                   D33A  mov	bx,#.2D1
13254 3B36           53                         push	bx
13255                                           ! Debug: list int = const 2 (used reg = )
13256 3B37           B8                   0002  mov	ax,*2
13257 3B3A           50                         push	ax
13258                                           ! Debug: func () void = bios_printf+0 (used reg = )
13259 3B3B           E8         CEDD            call	_bios_printf
13260 3B3E           83C4                   04  add	sp,*4
13261                                           !BCC_EOS
13262                                           ! 2265     return -1;
13263 3B41           B8                   FFFF  mov	ax,#$FFFF
13264 3B44           89EC                       mov	sp,bp
13265 3B46           5D                         pop	bp
13266 3B47           C3                         ret
13267                                           !BCC_EOS
13268                                           ! 2266   }
13269                                           ! 2267   ;
13270                       00003B48            .2CF:
13271                                           !BCC_EOS
13272                                           ! 2268   memsetb(get_SS(),packet, 0, sizeof packet);
13273                                           ! Debug: list int = const $C (used reg = )
13274 3B48           B8                   000C  mov	ax,*$C
13275 3B4B           50                         push	ax
13276                                           ! Debug: list int = const 0 (used reg = )
13277 3B4C           31C0                       xor	ax,ax
13278 3B4E           50                         push	ax
13279                                           ! Debug: list * unsigned char packet = S+$30-$E (used reg = )
13280 3B4F           8D5E         F4            lea	bx,-$C[bp]
13281 3B52           53                         push	bx
13282                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13283 3B53           E8         CAF7            call	_get_SS
13284                                           ! Debug: list unsigned short = ax+0 (used reg = )
13285 3B56           50                         push	ax
13286                                           ! Debug: func () void = memsetb+0 (used reg = )
13287 3B57           E8         C4A6            call	_memsetb
13288 3B5A           83C4                   08  add	sp,*8
13289                                           !BCC_EOS
13290                                           ! 2269   packet[0] = 0x25;
13291                                           ! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
13292 3B5D           B0                     25  mov	al,*$25
13293 3B5F           8846         F4            mov	-$C[bp],al
13294                                           !BCC_EOS
13295                                           ! 2270   timeout = 5000;
13296                                           ! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
13297 3B62           B8                   1388  mov	ax,#$1388
13298 3B65           31DB                       xor	bx,bx
13299 3B67           8946         E0            mov	-$20[bp],ax
13300 3B6A           895E         E2            mov	-$1E[bp],bx
13301                                           !BCC_EOS
13302                                           ! 2271   time = 0;
13303                                           ! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
13304 3B6D           31C0                       xor	ax,ax
13305 3B6F           31DB                       xor	bx,bx
13306 3B71           8946         DC            mov	-$24[bp],ax
13307 3B74           895E         DE            mov	-$22[bp],bx
13308                                           !BCC_EOS
13309                                           ! 2272   in_progress = 0;
13310                                           ! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13311 3B77           30C0                       xor	al,al
13312 3B79           8846         D9            mov	-$27[bp],al
13313                                           !BCC_EOS
13314                                           ! 2273   while (time < timeout) {
13315 3B7C           E9         00AB            br 	.2D3
13316                       00003B7F            .2D4:
13317                                           ! 2274     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
13318                                           ! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
13319 3B7F           8D5E         EC            lea	bx,-$14[bp]
13320 3B82           53                         push	bx
13321                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13322 3B83           E8         CAC7            call	_get_SS
13323                                           ! Debug: list unsigned short = ax+0 (used reg = )
13324 3B86           50                         push	ax
13325                                           ! Debug: list int = const 1 (used reg = )
13326 3B87           B8                   0001  mov	ax,*1
13327 3B8A           50                         push	ax
13328                                           ! Debug: list long = const 8 (used reg = )
13329 3B8B           B8                   0008  mov	ax,*8
13330 3B8E           31DB                       xor	bx,bx
13331 3B90           53                         push	bx
13332 3B91           50                         push	ax
13333                                           ! Debug: list int = const 0 (used reg = )
13334 3B92           31C0                       xor	ax,ax
13335 3B94           50                         push	ax
13336                                           ! Debug: list * unsigned char packet = S+$38-$E (used reg = )
13337 3B95           8D5E         F4            lea	bx,-$C[bp]
13338 3B98           53                         push	bx
13339                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13340 3B99           E8         CAB1            call	_get_SS
13341                                           ! Debug: list unsigned short = ax+0 (used reg = )
13342 3B9C           50                         push	ax
13343                                           ! Debug: list int = const $C (used reg = )
13344 3B9D           B8                   000C  mov	ax,*$C
13345 3BA0           50                         push	ax
13346                                           ! Debug: list unsigned short device = [S+$3E+2] (used reg = )
13347 3BA1           FF76         04            push	4[bp]
13348                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
13349 3BA4           E8         FA24            call	_ata_cmd_packet
13350 3BA7           83C4                   14  add	sp,*$14
13351                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13352 3BAA           85C0                       test	ax,ax
13353 3BAC           75           06            jne 	.2D5
13354                       00003BAE            .2D6:
13355                                           ! 2275       goto ok;
13356 3BAE           83C4                   00  add	sp,#..FFFA+$2C
13357 3BB1           E9         008D            br 	.FFFA
13358                                           !BCC_EOS
13359                                           ! 2276     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
13360                       00003BB4            .2D5:
13361                                           ! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
13362 3BB4           8D5E         DA            lea	bx,-$26[bp]
13363 3BB7           53                         push	bx
13364                                           ! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
13365 3BB8           8D5E         DB            lea	bx,-$25[bp]
13366 3BBB           53                         push	bx
13367                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
13368 3BBC           E8         CA8E            call	_get_SS
13369                                           ! Debug: list unsigned short = ax+0 (used reg = )
13370 3BBF           50                         push	ax
13371                                           ! Debug: list unsigned short device = [S+$32+2] (used reg = )
13372 3BC0           FF76         04            push	4[bp]
13373                                           ! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
13374 3BC3           E8         FEB5            call	_atapi_get_sense
13375 3BC6           83C4                   08  add	sp,*8
13376                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
13377 3BC9           85C0                       test	ax,ax
13378 3BCB           75           41            jne 	.2D7
13379                       00003BCD            .2D8:
13380                                           ! 2277       if (asc == 0x3a) {
13381                                           ! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
13382 3BCD           8A46         DB            mov	al,-$25[bp]
13383 3BD0           3C                     3A  cmp	al,*$3A
13384 3BD2           75           07            jne 	.2D9
13385                       00003BD4            .2DA:
13386                                           ! 2278         ;
13387                                           !BCC_EOS
13388                                           ! 2279         return -1;
13389 3BD4           B8                   FFFF  mov	ax,#$FFFF
13390 3BD7           89EC                       mov	sp,bp
13391 3BD9           5D                         pop	bp
13392 3BDA           C3                         ret
13393                                           !BCC_EOS
13394                                           ! 2280       }
13395                                           ! 2281       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
13396                       00003BDB            .2D9:
13397                                           ! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
13398 3BDB           8A46         DB            mov	al,-$25[bp]
13399 3BDE           3C                     04  cmp	al,*4
13400 3BE0           75           2C            jne 	.2DB
13401                       00003BE2            .2DE:
13402                                           ! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
13403 3BE2           8A46         DA            mov	al,-$26[bp]
13404 3BE5           3C                     01  cmp	al,*1
13405 3BE7           75           25            jne 	.2DB
13406                       00003BE9            .2DD:
13407 3BE9           8A46         D9            mov	al,-$27[bp]
13408 3BEC           84C0                       test	al,al
13409 3BEE           75           1E            jne 	.2DB
13410                       00003BF0            .2DC:
13411                                           ! 2282         bios_printf(2, "Waiting for device to detect medium... ");
13412                                           ! Debug: list * char = .2DF+0 (used reg = )
13413 3BF0           BB                   D312  mov	bx,#.2DF
13414 3BF3           53                         push	bx
13415                                           ! Debug: list int = const 2 (used reg = )
13416 3BF4           B8                   0002  mov	ax,*2
13417 3BF7           50                         push	ax
13418                                           ! Debug: func () void = bios_printf+0 (used reg = )
13419 3BF8           E8         CE20            call	_bios_printf
13420 3BFB           83C4                   04  add	sp,*4
13421                                           !BCC_EOS
13422                                           ! 2283         timeout = 30000;
13423                                           ! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
13424 3BFE           B8                   7530  mov	ax,#$7530
13425 3C01           31DB                       xor	bx,bx
13426 3C03           8946         E0            mov	-$20[bp],ax
13427 3C06           895E         E2            mov	-$1E[bp],bx
13428                                           !BCC_EOS
13429                                           ! 2284         in_progress = 1;
13430                                           ! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
13431 3C09           B0                     01  mov	al,*1
13432 3C0B           8846         D9            mov	-$27[bp],al
13433                                           !BCC_EOS
13434                                           ! 2285       }
13435                                           ! 2286     }
13436                       00003C0E            .2DB:
13437                                           ! 2287     time += 100;
13438                       00003C0E            .2D7:
13439                                           ! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
13440 3C0E           B8                   0064  mov	ax,*$64
13441 3C11           31DB                       xor	bx,bx
13442 3C13           53                         push	bx
13443 3C14           50                         push	ax
13444 3C15           8B46         DC            mov	ax,-$24[bp]
13445 3C18           8B5E         DE            mov	bx,-$22[bp]
13446 3C1B           8D7E         D2            lea	di,-$2E[bp]
13447 3C1E           E8         C4A2            call	laddul
13448 3C21           8946         DC            mov	-$24[bp],ax
13449 3C24           895E         DE            mov	-$22[bp],bx
13450 3C27           83C4                   04  add	sp,*4
13451                                           !BCC_EOS
13452                                           ! 2288   }
13453                                           ! 2289   ;
13454                       00003C2A            .2D3:
13455                                           ! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
13456 3C2A           8B46         E0            mov	ax,-$20[bp]
13457 3C2D           8B5E         E2            mov	bx,-$1E[bp]
13458 3C30           8D7E         DC            lea	di,-$24[bp]
13459 3C33           E8         C495            call	lcmpul
13460 3C36         0F87         FF45            bhi 	.2D4
13461                       00003C3A            .2E0:
13462                       00003C3A            .2D2:
13463                                           !BCC_EOS
13464                                           ! 2290   return -1;
13465 3C3A           B8                   FFFF  mov	ax,#$FFFF
13466 3C3D           89EC                       mov	sp,bp
13467 3C3F           5D                         pop	bp
13468 3C40           C3                         ret
13469                                           !BCC_EOS
13470                                           ! 2291 ok:
13471                       00003C41            .FFFA:
13472                       FFFFFFD4            ..FFFA	=	-$2C
13473                                           ! 2292   block_len = (Bit32u) buf[4] << 24
13474                                           ! 2293     | (Bit32u) buf[5] << 16
13475                                           ! 2294     | (Bit32u) buf[6] << 8
13476                                           ! 2295     | (Bit32u) buf[7] << 0;
13477                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
13478 3C41           8A46         F3            mov	al,-$D[bp]
13479 3C44           30E4                       xor	ah,ah
13480 3C46           31DB                       xor	bx,bx
13481                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13482 3C48           53                         push	bx
13483 3C49           50                         push	ax
13484                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
13485 3C4A           8A46         F2            mov	al,-$E[bp]
13486 3C4D           30E4                       xor	ah,ah
13487 3C4F           31DB                       xor	bx,bx
13488                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13489 3C51           88DF                       mov	bh,bl
13490 3C53           88E3                       mov	bl,ah
13491 3C55           88C4                       mov	ah,al
13492 3C57           30C0                       xor	al,al
13493 3C59           53                         push	bx
13494 3C5A           50                         push	ax
13495                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
13496 3C5B           8A46         F1            mov	al,-$F[bp]
13497 3C5E           30E4                       xor	ah,ah
13498 3C60           31DB                       xor	bx,bx
13499                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13500 3C62           93                         xchg	bx,ax
13501 3C63           31C0                       xor	ax,ax
13502 3C65           53                         push	bx
13503 3C66           50                         push	ax
13504                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
13505 3C67           8A46         F0            mov	al,-$10[bp]
13506 3C6A           30E4                       xor	ah,ah
13507 3C6C           31DB                       xor	bx,bx
13508                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13509 3C6E           88C4                       mov	ah,al
13510 3C70           30C0                       xor	al,al
13511 3C72           93                         xchg	bx,ax
13512 3C73           31C0                       xor	ax,ax
13513                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13514 3C75           8D7E         CA            lea	di,-$36[bp]
13515 3C78           E8         C48C            call	lorul
13516 3C7B           83C4                   04  add	sp,*4
13517                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13518 3C7E           8D7E         CE            lea	di,-$32[bp]
13519 3C81           E8         C483            call	lorul
13520 3C84           83C4                   04  add	sp,*4
13521                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13522 3C87           8D7E         D2            lea	di,-$2E[bp]
13523 3C8A           E8         C47A            call	lorul
13524 3C8D           83C4                   04  add	sp,*4
13525                                           ! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13526 3C90           8946         E8            mov	-$18[bp],ax
13527 3C93           895E         EA            mov	-$16[bp],bx
13528                                           !BCC_EOS
13529                                           ! 2296   ;
13530                                           !BCC_EOS
13531                                           ! 2297   if (block_len!= 2048 && block_len!= 512)
13532                                           ! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13533                                           ! Debug: expression subtree swapping
13534 3C96           B8                   0800  mov	ax,#$800
13535 3C99           31DB                       xor	bx,bx
13536 3C9B           53                         push	bx
13537 3C9C           50                         push	ax
13538 3C9D           8B46         E8            mov	ax,-$18[bp]
13539 3CA0           8B5E         EA            mov	bx,-$16[bp]
13540 3CA3           8D7E         D2            lea	di,-$2E[bp]
13541 3CA6           E8         C422            call	lcmpul
13542 3CA9           8D66         D6            lea	sp,-$2A[bp]
13543 3CAC           74           33            je  	.2E1
13544                       00003CAE            .2E3:
13545                                           ! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13546                                           ! Debug: expression subtree swapping
13547 3CAE           B8                   0200  mov	ax,#$200
13548 3CB1           31DB                       xor	bx,bx
13549 3CB3           53                         push	bx
13550 3CB4           50                         push	ax
13551 3CB5           8B46         E8            mov	ax,-$18[bp]
13552 3CB8           8B5E         EA            mov	bx,-$16[bp]
13553 3CBB           8D7E         D2            lea	di,-$2E[bp]
13554 3CBE           E8         C40A            call	lcmpul
13555 3CC1           8D66         D6            lea	sp,-$2A[bp]
13556 3CC4           74           1B            je  	.2E1
13557                       00003CC6            .2E2:
13558                                           ! 2298   {
13559                                           ! 2299     bios_printf(2, "Unsupported sector size %u\n", block_len);
13560                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13561 3CC6           FF76         EA            push	-$16[bp]
13562 3CC9           FF76         E8            push	-$18[bp]
13563                                           ! Debug: list * char = .2E4+0 (used reg = )
13564 3CCC           BB                   D2F6  mov	bx,#.2E4
13565 3CCF           53                         push	bx
13566                                           ! Debug: list int = const 2 (used reg = )
13567 3CD0           B8                   0002  mov	ax,*2
13568 3CD3           50                         push	ax
13569                                           ! Debug: func () void = bios_printf+0 (used reg = )
13570 3CD4           E8         CD44            call	_bios_printf
13571 3CD7           83C4                   08  add	sp,*8
13572                                           !BCC_EOS
13573                                           ! 2300     return -1;
13574 3CDA           B8                   FFFF  mov	ax,#$FFFF
13575 3CDD           89EC                       mov	sp,bp
13576 3CDF           5D                         pop	bp
13577 3CE0           C3                         ret
13578                                           !BCC_EOS
13579                                           ! 2301   }
13580                                           ! 2302   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
13581                       00003CE1            .2E1:
13582                                           ! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
13583 3CE1           FF76         EA            push	-$16[bp]
13584 3CE4           FF76         E8            push	-$18[bp]
13585                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13586 3CE7           8B46         04            mov	ax,4[bp]
13587 3CEA           B9                   001E  mov	cx,*$1E
13588 3CED           F7E9                       imul	cx
13589 3CEF           89C3                       mov	bx,ax
13590                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
13591                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
13592 3CF1           81C3                 0148  add	bx,#$148
13593 3CF5           53                         push	bx
13594                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13595 3CF6           FF76         D6            push	-$2A[bp]
13596                                           ! Debug: func () void = write_dword+0 (used reg = )
13597 3CF9           E8         C39F            call	_write_dword
13598 3CFC           83C4                   08  add	sp,*8
13599                                           !BCC_EOS
13600                                           ! 2303   sectors = (Bit32u) buf[0] << 24
13601                                           ! 2304     | (Bit32u) buf[1] << 16
13602                                           ! 2305     | (Bit32u) buf[2] << 8
13603                                           ! 2306     | (Bit32u) buf[3] << 0;
13604                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
13605 3CFF           8A46         EF            mov	al,-$11[bp]
13606 3D02           30E4                       xor	ah,ah
13607 3D04           31DB                       xor	bx,bx
13608                                           ! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
13609 3D06           53                         push	bx
13610 3D07           50                         push	ax
13611                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
13612 3D08           8A46         EE            mov	al,-$12[bp]
13613 3D0B           30E4                       xor	ah,ah
13614 3D0D           31DB                       xor	bx,bx
13615                                           ! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
13616 3D0F           88DF                       mov	bh,bl
13617 3D11           88E3                       mov	bl,ah
13618 3D13           88C4                       mov	ah,al
13619 3D15           30C0                       xor	al,al
13620 3D17           53                         push	bx
13621 3D18           50                         push	ax
13622                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
13623 3D19           8A46         ED            mov	al,-$13[bp]
13624 3D1C           30E4                       xor	ah,ah
13625 3D1E           31DB                       xor	bx,bx
13626                                           ! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
13627 3D20           93                         xchg	bx,ax
13628 3D21           31C0                       xor	ax,ax
13629 3D23           53                         push	bx
13630 3D24           50                         push	ax
13631                                           ! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
13632 3D25           8A46         EC            mov	al,-$14[bp]
13633 3D28           30E4                       xor	ah,ah
13634 3D2A           31DB                       xor	bx,bx
13635                                           ! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
13636 3D2C           88C4                       mov	ah,al
13637 3D2E           30C0                       xor	al,al
13638 3D30           93                         xchg	bx,ax
13639 3D31           31C0                       xor	ax,ax
13640                                           ! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
13641 3D33           8D7E         CA            lea	di,-$36[bp]
13642 3D36           E8         C3CE            call	lorul
13643 3D39           83C4                   04  add	sp,*4
13644                                           ! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
13645 3D3C           8D7E         CE            lea	di,-$32[bp]
13646 3D3F           E8         C3C5            call	lorul
13647 3D42           83C4                   04  add	sp,*4
13648                                           ! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
13649 3D45           8D7E         D2            lea	di,-$2E[bp]
13650 3D48           E8         C3BC            call	lorul
13651 3D4B           83C4                   04  add	sp,*4
13652                                           ! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13653 3D4E           8946         E4            mov	-$1C[bp],ax
13654 3D51           895E         E6            mov	-$1A[bp],bx
13655                                           !BCC_EOS
13656                                           ! 2307   ;
13657                                           !BCC_EOS
13658                                           ! 2308   if (block_len == 2048)
13659                                           ! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
13660                                           ! Debug: expression subtree swapping
13661 3D54           B8                   0800  mov	ax,#$800
13662 3D57           31DB                       xor	bx,bx
13663 3D59           53                         push	bx
13664 3D5A           50                         push	ax
13665 3D5B           8B46         E8            mov	ax,-$18[bp]
13666 3D5E           8B5E         EA            mov	bx,-$16[bp]
13667 3D61           8D7E         D2            lea	di,-$2E[bp]
13668 3D64           E8         C364            call	lcmpul
13669 3D67           8D66         D6            lea	sp,-$2A[bp]
13670 3D6A           75           12            jne 	.2E5
13671                       00003D6C            .2E6:
13672                                           ! 2309     sectors <<= 2;
13673                                           ! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13674 3D6C           8B46         E4            mov	ax,-$1C[bp]
13675 3D6F           8B5E         E6            mov	bx,-$1A[bp]
13676 3D72           BF                   0002  mov	di,*2
13677 3D75           E8         C3CF            call	lslul
13678 3D78           8946         E4            mov	-$1C[bp],ax
13679 3D7B           895E         E6            mov	-$1A[bp],bx
13680                                           !BCC_EOS
13681                                           ! 2310   if (sect
13682                       00003D7E            .2E5:
13683                                           ! 2310 ors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
13684                                           ! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
13685 3D7E           8B46         04            mov	ax,4[bp]
13686 3D81           B9                   001E  mov	cx,*$1E
13687 3D84           F7E9                       imul	cx
13688 3D86           89C3                       mov	bx,ax
13689                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13690                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13691 3D88           81C3                 0158  add	bx,#$158
13692 3D8C           53                         push	bx
13693                                           ! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
13694 3D8D           FF76         D6            push	-$2A[bp]
13695                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
13696 3D90           E8         C2F0            call	_read_dword
13697 3D93           89D3                       mov	bx,dx
13698 3D95           83C4                   04  add	sp,*4
13699                                           ! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
13700                                           ! Debug: expression subtree swapping
13701 3D98           8D7E         E4            lea	di,-$1C[bp]
13702 3D9B           E8         C32D            call	lcmpul
13703 3D9E           74           24            je  	.2E7
13704                       00003DA0            .2E8:
13705                                           ! 2311     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
13706                                           ! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
13707 3DA0           8B46         E4            mov	ax,-$1C[bp]
13708 3DA3           8B5E         E6            mov	bx,-$1A[bp]
13709 3DA6           88E0                       mov	al,ah
13710 3DA8           88DC                       mov	ah,bl
13711 3DAA           88FB                       mov	bl,bh
13712 3DAC           28FF                       sub	bh,bh
13713 3DAE           BF                   0003  mov	di,*3
13714 3DB1           E8         C375            call	lsrul
13715                                           ! Debug: list unsigned long = bx+0 (used reg = )
13716 3DB4           53                         push	bx
13717 3DB5           50                         push	ax
13718                                           ! Debug: list * char = .2E9+0 (used reg = )
13719 3DB6           BB                   D2E0  mov	bx,#.2E9
13720 3DB9           53                         push	bx
13721                                           ! Debug: list int = const 2 (used reg = )
13722 3DBA           B8                   0002  mov	ax,*2
13723 3DBD           50                         push	ax
13724                                           ! Debug: func () void = bios_printf+0 (used reg = )
13725 3DBE           E8         CC5A            call	_bios_printf
13726 3DC1           83C4                   08  add	sp,*8
13727                                           !BCC_EOS
13728                                           ! 2312   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
13729                       00003DC4            .2E7:
13730                                           ! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
13731 3DC4           FF76         E6            push	-$1A[bp]
13732 3DC7           FF76         E4            push	-$1C[bp]
13733                                           ! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
13734 3DCA           8B46         04            mov	ax,4[bp]
13735 3DCD           B9                   001E  mov	cx,*$1E
13736 3DD0           F7E9                       imul	cx
13737 3DD2           89C3                       mov	bx,ax
13738                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
13739                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
13740 3DD4           81C3                 0158  add	bx,#$158
13741 3DD8           53                         push	bx
13742                                           ! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
13743 3DD9           FF76         D6            push	-$2A[bp]
13744                                           ! Debug: func () void = write_dword+0 (used reg = )
13745 3DDC           E8         C2BC            call	_write_dword
13746 3DDF           83C4                   08  add	sp,*8
13747                                           !BCC_EOS
13748                                           ! 2313   return 0;
13749 3DE2           31C0                       xor	ax,ax
13750 3DE4           89EC                       mov	sp,bp
13751 3DE6           5D                         pop	bp
13752 3DE7           C3                         ret
13753                                           !BCC_EOS
13754                                           ! 2314 }
13755                                           ! 2315   Bit16u
13756                                           ! Register BX used in function atapi_is_ready
13757                                           ! 2316 atapi_is_cdrom(device)
13758                                           ! 2317   Bit8u device;
13759                                           export	_atapi_is_cdrom
13760                       00003DE8            _atapi_is_cdrom:
13761                                           !BCC_EOS
13762                                           ! 2318 {
13763                                           ! 2319   Bit16u ebda_seg=read_word(0x0040,0x000E);
13764 3DE8           55                         push	bp
13765 3DE9           89E5                       mov	bp,sp
13766 3DEB           4C                         dec	sp
13767 3DEC           4C                         dec	sp
13768                                           ! Debug: list int = const $E (used reg = )
13769 3DED           B8                   000E  mov	ax,*$E
13770 3DF0           50                         push	ax
13771                                           ! Debug: list int = const $40 (used reg = )
13772 3DF1           B8                   0040  mov	ax,*$40
13773 3DF4           50                         push	ax
13774                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13775 3DF5           E8         C80F            call	_read_word
13776 3DF8           83C4                   04  add	sp,*4
13777                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13778 3DFB           8946         FE            mov	-2[bp],ax
13779                                           !BCC_EOS
13780                                           ! 2320   if (device >= (4*2))
13781                                           ! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
13782 3DFE           8A46         04            mov	al,4[bp]
13783 3E01           3C                     08  cmp	al,*8
13784 3E03           72           06            jb  	.2EA
13785                       00003E05            .2EB:
13786                                           ! 2321     return 0;
13787 3E05           31C0                       xor	ax,ax
13788 3E07           89EC                       mov	sp,bp
13789 3E09           5D                         pop	bp
13790 3E0A           C3                         ret
13791                                           !BCC_EOS
13792                                           ! 2322   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
13793                       00003E0B            .2EA:
13794                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13795 3E0B           8A46         04            mov	al,4[bp]
13796 3E0E           30E4                       xor	ah,ah
13797 3E10           B9                   001E  mov	cx,*$1E
13798 3E13           F7E9                       imul	cx
13799 3E15           89C3                       mov	bx,ax
13800                                           ! Debug: address unsigned char = [bx+$142] (used reg = )
13801                                           ! Debug: list * unsigned char = bx+$142 (used reg = )
13802 3E17           81C3                 0142  add	bx,#$142
13803 3E1B           53                         push	bx
13804                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13805 3E1C           FF76         FE            push	-2[bp]
13806                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13807 3E1F           E8         C7D2            call	_read_byte
13808 3E22           83C4                   04  add	sp,*4
13809                                           ! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
13810 3E25           3C                     03  cmp	al,*3
13811 3E27           74           06            je  	.2EC
13812                       00003E29            .2ED:
13813                                           ! 2323     return 0;
13814 3E29           31C0                       xor	ax,ax
13815 3E2B           89EC                       mov	sp,bp
13816 3E2D           5D                         pop	bp
13817 3E2E           C3                         ret
13818                                           !BCC_EOS
13819                                           ! 2324   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
13820                       00003E2F            .2EC:
13821                                           ! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
13822 3E2F           8A46         04            mov	al,4[bp]
13823 3E32           30E4                       xor	ah,ah
13824 3E34           B9                   001E  mov	cx,*$1E
13825 3E37           F7E9                       imul	cx
13826 3E39           89C3                       mov	bx,ax
13827                                           ! Debug: address unsigned char = [bx+$143] (used reg = )
13828                                           ! Debug: list * unsigned char = bx+$143 (used reg = )
13829 3E3B           81C3                 0143  add	bx,#$143
13830 3E3F           53                         push	bx
13831                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13832 3E40           FF76         FE            push	-2[bp]
13833                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13834 3E43           E8         C7AE            call	_read_byte
13835 3E46           83C4                   04  add	sp,*4
13836                                           ! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
13837 3E49           3C                     05  cmp	al,*5
13838 3E4B           74           06            je  	.2EE
13839                       00003E4D            .2EF:
13840                                           ! 2325     return 0;
13841 3E4D           31C0                       xor	ax,ax
13842 3E4F           89EC                       mov	sp,bp
13843 3E51           5D                         pop	bp
13844 3E52           C3                         ret
13845                                           !BCC_EOS
13846                                           ! 2326   return 1;
13847                       00003E53            .2EE:
13848 3E53           B8                   0001  mov	ax,*1
13849 3E56           89EC                       mov	sp,bp
13850 3E58           5D                         pop	bp
13851 3E59           C3                         ret
13852                                           !BCC_EOS
13853                                           ! 2327 }
13854                                           ! 2328   void
13855                                           ! Register BX used in function atapi_is_cdrom
13856                                           ! 2329 cdemu_init()
13857                                           ! 2330 {
13858                                           export	_cdemu_init
13859                       00003E5A            _cdemu_init:
13860                                           ! 2331   Bit16u ebda_seg=read_word(0x0040,0x000E);
13861 3E5A           55                         push	bp
13862 3E5B           89E5                       mov	bp,sp
13863 3E5D           4C                         dec	sp
13864 3E5E           4C                         dec	sp
13865                                           ! Debug: list int = const $E (used reg = )
13866 3E5F           B8                   000E  mov	ax,*$E
13867 3E62           50                         push	ax
13868                                           ! Debug: list int = const $40 (used reg = )
13869 3E63           B8                   0040  mov	ax,*$40
13870 3E66           50                         push	ax
13871                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13872 3E67           E8         C79D            call	_read_word
13873 3E6A           83C4                   04  add	sp,*4
13874                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13875 3E6D           8946         FE            mov	-2[bp],ax
13876                                           !BCC_EOS
13877                                           ! 2332   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
13878                                           ! Debug: list int = const 0 (used reg = )
13879 3E70           31C0                       xor	ax,ax
13880 3E72           50                         push	ax
13881                                           ! Debug: list * unsigned char = const $25A (used reg = )
13882 3E73           B8                   025A  mov	ax,#$25A
13883 3E76           50                         push	ax
13884                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
13885 3E77           FF76         FE            push	-2[bp]
13886                                           ! Debug: func () void = write_byte+0 (used reg = )
13887 3E7A           E8         C79D            call	_write_byte
13888 3E7D           83C4                   06  add	sp,*6
13889                                           !BCC_EOS
13890                                           ! 2333 }
13891 3E80           89EC                       mov	sp,bp
13892 3E82           5D                         pop	bp
13893 3E83           C3                         ret
13894                                           ! 2334   Bit8u
13895                                           ! 2335 cdemu_isactive()
13896                                           ! 2336 {
13897                                           export	_cdemu_isactive
13898                       00003E84            _cdemu_isactive:
13899                                           ! 2337   Bit16u ebda_seg=read_word(0x0040,0x000E);
13900 3E84           55                         push	bp
13901 3E85           89E5                       mov	bp,sp
13902 3E87           4C                         dec	sp
13903 3E88           4C                         dec	sp
13904                                           ! Debug: list int = const $E (used reg = )
13905 3E89           B8                   000E  mov	ax,*$E
13906 3E8C           50                         push	ax
13907                                           ! Debug: list int = const $40 (used reg = )
13908 3E8D           B8                   0040  mov	ax,*$40
13909 3E90           50                         push	ax
13910                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13911 3E91           E8         C773            call	_read_word
13912 3E94           83C4                   04  add	sp,*4
13913                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13914 3E97           8946         FE            mov	-2[bp],ax
13915                                           !BCC_EOS
13916                                           ! 2338   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
13917                                           ! Debug: list * unsigned char = const $25A (used reg = )
13918 3E9A           B8                   025A  mov	ax,#$25A
13919 3E9D           50                         push	ax
13920                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13921 3E9E           FF76         FE            push	-2[bp]
13922                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13923 3EA1           E8         C750            call	_read_byte
13924 3EA4           83C4                   04  add	sp,*4
13925                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13926 3EA7           89EC                       mov	sp,bp
13927 3EA9           5D                         pop	bp
13928 3EAA           C3                         ret
13929                                           !BCC_EOS
13930                                           ! 2339 }
13931                                           ! 2340   Bit8u
13932                                           ! 2341 cdemu_emulated_drive()
13933                                           ! 2342 {
13934                                           export	_cdemu_emulated_drive
13935                       00003EAB            _cdemu_emulated_drive:
13936                                           ! 2343   Bit16u ebda_seg=read_word(0x0040,0x000E);
13937 3EAB           55                         push	bp
13938 3EAC           89E5                       mov	bp,sp
13939 3EAE           4C                         dec	sp
13940 3EAF           4C                         dec	sp
13941                                           ! Debug: list int = const $E (used reg = )
13942 3EB0           B8                   000E  mov	ax,*$E
13943 3EB3           50                         push	ax
13944                                           ! Debug: list int = const $40 (used reg = )
13945 3EB4           B8                   0040  mov	ax,*$40
13946 3EB7           50                         push	ax
13947                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13948 3EB8           E8         C74C            call	_read_word
13949 3EBB           83C4                   04  add	sp,*4
13950                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
13951 3EBE           8946         FE            mov	-2[bp],ax
13952                                           !BCC_EOS
13953                                           ! 2344   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
13954                                           ! Debug: list * unsigned char = const $25C (used reg = )
13955 3EC1           B8                   025C  mov	ax,#$25C
13956 3EC4           50                         push	ax
13957                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
13958 3EC5           FF76         FE            push	-2[bp]
13959                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
13960 3EC8           E8         C729            call	_read_byte
13961 3ECB           83C4                   04  add	sp,*4
13962                                           ! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
13963 3ECE           89EC                       mov	sp,bp
13964 3ED0           5D                         pop	bp
13965 3ED1           C3                         ret
13966                                           !BCC_EOS
13967                                           ! 2345 }
13968                                           ! 2346 static char isotag[6]="CD001";
13969                                           
13970                       00003ED2            _isotag:
13971                       00003ED2            .2F0:
13972 3ED2                        43            .ascii	"CD001"
13973 3ED7                        00            .byte	0
13974                                           !BCC_EOS
13975                                           ! 2347 static char eltorito[24]="EL TORITO SPECIFICATION";
13976                       00003ED8            _eltorito:
13977                       00003ED8            .2F1:
13978 3ED8                        45            .ascii	"EL TORITO SPECIFICATION"
13979 3EEF                        00            .byte	0
13980                                           !BCC_EOS
13981                                           ! 2348   Bit16u
13982                                           ! 2349 cdrom_boot()
13983                                           ! 2350 {
13984                                           
13985                                           export	_cdrom_boot
13986                       00003EF0            _cdrom_boot:
13987                                           ! 2351   Bit16u ebda_seg=read_word(0x0040,0x000E);
13988 3EF0           55                         push	bp
13989 3EF1           89E5                       mov	bp,sp
13990 3EF3           4C                         dec	sp
13991 3EF4           4C                         dec	sp
13992                                           ! Debug: list int = const $E (used reg = )
13993 3EF5           B8                   000E  mov	ax,*$E
13994 3EF8           50                         push	ax
13995                                           ! Debug: list int = const $40 (used reg = )
13996 3EF9           B8                   0040  mov	ax,*$40
13997 3EFC           50                         push	ax
13998                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
13999 3EFD           E8         C707            call	_read_word
14000 3F00           83C4                   04  add	sp,*4
14001                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
14002 3F03           8946         FE            mov	-2[bp],ax
14003                                           !BCC_EOS
14004                                           ! 2352   Bit8u atacmd[12], buffer[2048];
14005                                           !BCC_EOS
14006                                           ! 2353   Bit32u lba;
14007                                           !BCC_EOS
14008                                           ! 2354   Bit16u boot_segment, nbsectors, i, error;
14009                                           !BCC_EOS
14010                                           ! 2355   Bit8u device;
14011                                           !BCC_EOS
14012                                           ! 2356   for (device=0; device<(4*2);device++) {
14013 3F06           81C4                 F7E6  add	sp,#-$81A
14014                                           ! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
14015 3F0A           30C0                       xor	al,al
14016 3F0C           8886       F7E5            mov	-$81B[bp],al
14017                                           !BCC_EOS
14018                                           !BCC_EOS
14019 3F10           EB           1C            jmp .2F4
14020                       00003F12            .2F5:
14021                                           ! 2357     if (atapi_is_cdrom(device)) break;
14022                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14023 3F12           8A86       F7E5            mov	al,-$81B[bp]
14024 3F16           30E4                       xor	ah,ah
14025 3F18           50                         push	ax
14026                                           ! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
14027 3F19           E8         FECC            call	_atapi_is_cdrom
14028 3F1C           44                         inc	sp
14029 3F1D           44                         inc	sp
14030 3F1E           85C0                       test	ax,ax
14031 3F20           74           03            je  	.2F6
14032                       00003F22            .2F7:
14033 3F22           E9         0011            br 	.2F2
14034                                           !BCC_EOS
14035                                           ! 2358     }
14036                       00003F25            .2F6:
14037                                           ! 2359   if(device >= (4*2)) return 2;
14038                       00003F25            .2F3:
14039                                           ! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
14040 3F25           8A86       F7E5            mov	al,-$81B[bp]
14041 3F29           40                         inc	ax
14042 3F2A           8886       F7E5            mov	-$81B[bp],al
14043                       00003F2E            .2F4:
14044                                           ! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14045 3F2E           8A86       F7E5            mov	al,-$81B[bp]
14046 3F32           3C                     08  cmp	al,*8
14047 3F34           72           DC            jb 	.2F5
14048                       00003F36            .2F8:
14049                       00003F36            .2F2:
14050                                           ! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
14051 3F36           8A86       F7E5            mov	al,-$81B[bp]
14052 3F3A           3C                     08  cmp	al,*8
14053 3F3C           72           07            jb  	.2F9
14054                       00003F3E            .2FA:
14055 3F3E           B8                   0002  mov	ax,*2
14056 3F41           89EC                       mov	sp,bp
14057 3F43           5D                         pop	bp
14058 3F44           C3                         ret
14059                                           !BCC_EOS
14060                                           ! 2360   if(error = atapi_is_ready(device) != 0)
14061                       00003F45            .2F9:
14062                                           ! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
14063 3F45           8A86       F7E5            mov	al,-$81B[bp]
14064 3F49           30E4                       xor	ah,ah
14065 3F4B           50                         push	ax
14066                                           ! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
14067 3F4C           E8         FBB1            call	_atapi_is_ready
14068 3F4F           44                         inc	sp
14069 3F50           44                         inc	sp
14070                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14071 3F51           85C0                       test	ax,ax
14072 3F53           74           04            je 	.2FD
14073 3F55           B0                     01  mov	al,*1
14074 3F57           EB           02            jmp	.2FE
14075                       00003F59            .2FD:
14076 3F59           30C0                       xor	al,al
14077                       00003F5B            .2FE:
14078                                           ! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14079 3F5B           30E4                       xor	ah,ah
14080 3F5D           8986       F7E6            mov	-$81A[bp],ax
14081 3F61           85C0                       test	ax,ax
14082 3F63           74           00            je  	.2FB
14083                       00003F65            .2FC:
14084                                           ! 2361     ;
14085                                           !BCC_EOS
14086                                           ! 2362   memsetb(get_SS(),atacmd,0,12);
14087                       00003F65            .2FB:
14088                                           ! Debug: list int = const $C (used reg = )
14089 3F65           B8                   000C  mov	ax,*$C
14090 3F68           50                         push	ax
14091                                           ! Debug: list int = const 0 (used reg = )
14092 3F69           31C0                       xor	ax,ax
14093 3F6B           50                         push	ax
14094                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14095 3F6C           8D5E         F2            lea	bx,-$E[bp]
14096 3F6F           53                         push	bx
14097                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14098 3F70           E8         C6DA            call	_get_SS
14099                                           ! Debug: list unsigned short = ax+0 (used reg = )
14100 3F73           50                         push	ax
14101                                           ! Debug: func () void = memsetb+0 (used reg = )
14102 3F74           E8         C089            call	_memsetb
14103 3F77           83C4                   08  add	sp,*8
14104                                           !BCC_EOS
14105                                           ! 2363   atacmd[0]=0x28;
14106                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14107 3F7A           B0                     28  mov	al,*$28
14108 3F7C           8846         F2            mov	-$E[bp],al
14109                                           !BCC_EOS
14110                                           ! 2364   atacmd[7]=(0x01 & 0xff00) >> 8;
14111                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14112 3F7F           30C0                       xor	al,al
14113 3F81           8846         F9            mov	-7[bp],al
14114                                           !BCC_EOS
14115                                           ! 2365   atacmd[8]=(0x01 & 0x00ff);
14116                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14117 3F84           B0                     01  mov	al,*1
14118 3F86           8846         FA            mov	-6[bp],al
14119                                           !BCC_EOS
14120                                           ! 2366   atacmd[2]=(0x11 & 0xff000000) >> 24;
14121                                           ! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14122 3F89           30C0                       xor	al,al
14123 3F8B           8846         F4            mov	-$C[bp],al
14124                                           !BCC_EOS
14125                                           ! 2367   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
14126                                           ! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14127 3F8E           30C0                       xor	al,al
14128 3F90           8846         F5            mov	-$B[bp],al
14129                                           !BCC_EOS
14130                                           ! 2368   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
14131                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14132 3F93           30C0                       xor	al,al
14133 3F95           8846         F6            mov	-$A[bp],al
14134                                           !BCC_EOS
14135                                           ! 2369   atacmd[5]=(0x11 & 0x000000ff);
14136                                           ! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14137 3F98           B0                     11  mov	al,*$11
14138 3F9A           8846         F7            mov	-9[bp],al
14139                                           !BCC_EOS
14140                                           ! 2370   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14141                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14142 3F9D           8D9E       F7F2            lea	bx,-$80E[bp]
14143 3FA1           53                         push	bx
14144                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14145 3FA2           E8         C6A8            call	_get_SS
14146                                           ! Debug: list unsigned short = ax+0 (used reg = )
14147 3FA5           50                         push	ax
14148                                           ! Debug: list int = const 1 (used reg = )
14149 3FA6           B8                   0001  mov	ax,*1
14150 3FA9           50                         push	ax
14151                                           ! Debug: list long = const $800 (used reg = )
14152 3FAA           B8                   0800  mov	ax,#$800
14153 3FAD           31DB                       xor	bx,bx
14154 3FAF           53                         push	bx
14155 3FB0           50                         push	ax
14156                                           ! Debug: list int = const 0 (used reg = )
14157 3FB1           31C0                       xor	ax,ax
14158 3FB3           50                         push	ax
14159                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14160 3FB4           8D5E         F2            lea	bx,-$E[bp]
14161 3FB7           53                         push	bx
14162                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14163 3FB8           E8         C692            call	_get_SS
14164                                           ! Debug: list unsigned short = ax+0 (used reg = )
14165 3FBB           50                         push	ax
14166                                           ! Debug: list int = const $C (used reg = )
14167 3FBC           B8                   000C  mov	ax,*$C
14168 3FBF           50                         push	ax
14169                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14170 3FC0           8A86       F7E5            mov	al,-$81B[bp]
14171 3FC4           30E4                       xor	ah,ah
14172 3FC6           50                         push	ax
14173                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14174 3FC7           E8         F601            call	_ata_cmd_packet
14175 3FCA           83C4                   14  add	sp,*$14
14176                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14177 3FCD           8986       F7E6            mov	-$81A[bp],ax
14178                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14179 3FD1           85C0                       test	ax,ax
14180 3FD3           74           07            je  	.2FF
14181                       00003FD5            .300:
14182                                           ! 2371     return 3;
14183 3FD5           B8                   0003  mov	ax,*3
14184 3FD8           89EC                       mov	sp,bp
14185 3FDA           5D                         pop	bp
14186 3FDB           C3                         ret
14187                                           !BCC_EOS
14188                                           ! 2372   if(buffer[0]!=0)return 4;
14189                       00003FDC            .2FF:
14190                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
14191 3FDC           8A86       F7F2            mov	al,-$80E[bp]
14192 3FE0           84C0                       test	al,al
14193 3FE2           74           07            je  	.301
14194                       00003FE4            .302:
14195 3FE4           B8                   0004  mov	ax,*4
14196 3FE7           89EC                       mov	sp,bp
14197 3FE9           5D                         pop	bp
14198 3FEA           C3                         ret
14199                                           !BCC_EOS
14200                                           ! 2373   for(i=0;i<5;i++){
14201                       00003FEB            .301:
14202                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14203 3FEB           31C0                       xor	ax,ax
14204 3FED           8986       F7E8            mov	-$818[bp],ax
14205                                           !BCC_EOS
14206                                           !BCC_EOS
14207 3FF1           EB           46            jmp .305
14208                       00003FF3            .306:
14209                                           ! 2374     if(read_byte(get_SS(),&buffer[1+i])!=read_byte(0xf000,&isotag[i]))return 5;
14210                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
14211 3FF3           8B9E       F7E8            mov	bx,-$818[bp]
14212                                           ! Debug: address char = [bx+_isotag+0] (used reg = )
14213                                           ! Debug: list * char = bx+_isotag+0 (used reg = )
14214 3FF7           81C3                 3ED2  add	bx,#_isotag
14215 3FFB           53                         push	bx
14216                                           ! Debug: list unsigned int = const $F000 (used reg = )
14217 3FFC           B8                   F000  mov	ax,#$F000
14218 3FFF           50                         push	ax
14219                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14220 4000           E8         C5F1            call	_read_byte
14221 4003           83C4                   04  add	sp,*4
14222 4006           50                         push	ax
14223                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
14224                                           ! Debug: expression subtree swapping
14225 4007           8B86       F7E8            mov	ax,-$818[bp]
14226                                           ! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14227 400B           40                         inc	ax
14228 400C           89EB                       mov	bx,bp
14229 400E           01C3                       add	bx,ax
14230                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14231                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14232 4010           81C3                 F7F2  add	bx,#-$80E
14233 4014           53                         push	bx
14234                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14235 4015           E8         C635            call	_get_SS
14236                                           ! Debug: list unsigned short = ax+0 (used reg = )
14237 4018           50                         push	ax
14238                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14239 4019           E8         C5D8            call	_read_byte
14240 401C           83C4                   04  add	sp,*4
14241                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14242 401F           3A86       F7E2            cmp	al,-$81E[bp]
14243 4023           8DA6       F7E4            lea	sp,-$81C[bp]
14244 4027           74           07            je  	.307
14245                       00004029            .308:
14246 4029           B8                   0005  mov	ax,*5
14247 402C           89EC                       mov	sp,bp
14248 402E           5D                         pop	bp
14249 402F           C3                         ret
14250                                           !BCC_EOS
14251                                           ! 2375    }
14252                       00004030            .307:
14253                                           ! 2376   for(i=0;i<23;i++)
14254                       00004030            .304:
14255                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14256 4030           8B86       F7E8            mov	ax,-$818[bp]
14257 4034           40                         inc	ax
14258 4035           8986       F7E8            mov	-$818[bp],ax
14259                       00004039            .305:
14260                                           ! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
14261 4039           8B86       F7E8            mov	ax,-$818[bp]
14262 403D           3D                   0005  cmp	ax,*5
14263 4040           72           B1            jb 	.306
14264                       00004042            .309:
14265                       00004042            .303:
14266                                           ! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
14267 4042           31C0                       xor	ax,ax
14268 4044           8986       F7E8            mov	-$818[bp],ax
14269                                           !BCC_EOS
14270                                           !BCC_EOS
14271                                           ! 2377     if(read_byte(get_SS(),&buffer[7+i])!=read_byte(0xf000,&eltorito[i]))return 6;
14272 4048           EB           48            jmp .30C
14273                       0000404A            .30D:
14274                                           ! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
14275 404A           8B9E       F7E8            mov	bx,-$818[bp]
14276                                           ! Debug: address char = [bx+_eltorito+0] (used reg = )
14277                                           ! Debug: list * char = bx+_eltorito+0 (used reg = )
14278 404E           81C3                 3ED8  add	bx,#_eltorito
14279 4052           53                         push	bx
14280                                           ! Debug: list unsigned int = const $F000 (used reg = )
14281 4053           B8                   F000  mov	ax,#$F000
14282 4056           50                         push	ax
14283                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14284 4057           E8         C59A            call	_read_byte
14285 405A           83C4                   04  add	sp,*4
14286 405D           50                         push	ax
14287                                           ! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
14288                                           ! Debug: expression subtree swapping
14289 405E           8B86       F7E8            mov	ax,-$818[bp]
14290                                           ! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
14291 4062           05                   0007  add	ax,*7
14292 4065           89EB                       mov	bx,bp
14293 4067           01C3                       add	bx,ax
14294                                           ! Debug: address unsigned char = [bx-$80E] (used reg = )
14295                                           ! Debug: list * unsigned char = bx-$80E (used reg = )
14296 4069           81C3                 F7F2  add	bx,#-$80E
14297 406D           53                         push	bx
14298                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14299 406E           E8         C5DC            call	_get_SS
14300                                           ! Debug: list unsigned short = ax+0 (used reg = )
14301 4071           50                         push	ax
14302                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
14303 4072           E8         C57F            call	_read_byte
14304 4075           83C4                   04  add	sp,*4
14305                                           ! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
14306 4078           3A86       F7E2            cmp	al,-$81E[bp]
14307 407C           8DA6       F7E4            lea	sp,-$81C[bp]
14308 4080           74           07            je  	.30E
14309                       00004082            .30F:
14310                                           ! 2377 
14311 4082           B8                   0006  mov	ax,*6
14312 4085           89EC                       mov	sp,bp
14313 4087           5D                         pop	bp
14314 4088           C3                         ret
14315                                           !BCC_EOS
14316                                           ! 2378   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
14317                       00004089            .30E:
14318                       00004089            .30B:
14319                                           ! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
14320 4089           8B86       F7E8            mov	ax,-$818[bp]
14321 408D           40                         inc	ax
14322 408E           8986       F7E8            mov	-$818[bp],ax
14323                       00004092            .30C:
14324                                           ! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
14325 4092           8B86       F7E8            mov	ax,-$818[bp]
14326 4096           3D                   0017  cmp	ax,*$17
14327 4099           72           AF            jb 	.30D
14328                       0000409B            .310:
14329                       0000409B            .30A:
14330                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
14331 409B           8A86       F839            mov	al,-$7C7[bp]
14332 409F           30E4                       xor	ah,ah
14333 40A1           31DB                       xor	bx,bx
14334 40A3           53                         push	bx
14335 40A4           50                         push	ax
14336                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
14337 40A5           8A86       F83A            mov	al,-$7C6[bp]
14338 40A9           30E4                       xor	ah,ah
14339 40AB           B9                   0100  mov	cx,#$100
14340 40AE           F7E9                       imul	cx
14341                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14342 40B0           31DB                       xor	bx,bx
14343 40B2           53                         push	bx
14344 40B3           50                         push	ax
14345                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
14346 40B4           8A86       F83B            mov	al,-$7C5[bp]
14347 40B8           30E4                       xor	ah,ah
14348 40BA           31DB                       xor	bx,bx
14349                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14350 40BC           53                         push	bx
14351 40BD           50                         push	ax
14352 40BE           31C0                       xor	ax,ax
14353 40C0           BB                   0001  mov	bx,*1
14354 40C3           53                         push	bx
14355 40C4           50                         push	ax
14356 40C5           8B86       F7D8            mov	ax,-$828[bp]
14357 40C9           8B9E       F7DA            mov	bx,-$826[bp]
14358 40CD           8DBE       F7D4            lea	di,-$82C[bp]
14359 40D1           E8         C015            call	lmulul
14360 40D4           83C4                   08  add	sp,*8
14361 40D7           53                         push	bx
14362 40D8           50                         push	ax
14363                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
14364 40D9           8A86       F83C            mov	al,-$7C4[bp]
14365 40DD           30E4                       xor	ah,ah
14366 40DF           31DB                       xor	bx,bx
14367                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14368 40E1           53                         push	bx
14369 40E2           50                         push	ax
14370 40E3           31C0                       xor	ax,ax
14371 40E5           BB                   0100  mov	bx,#$100
14372 40E8           53                         push	bx
14373 40E9           50                         push	ax
14374 40EA           8B86       F7D4            mov	ax,-$82C[bp]
14375 40EE           8B9E       F7D6            mov	bx,-$82A[bp]
14376 40F2           8DBE       F7D0            lea	di,-$830[bp]
14377 40F6           E8         BFF0            call	lmulul
14378 40F9           83C4                   08  add	sp,*8
14379                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14380 40FC           8DBE       F7D8            lea	di,-$828[bp]
14381 4100           E8         BFC0            call	laddul
14382 4103           83C4                   04  add	sp,*4
14383                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14384 4106           8DBE       F7DC            lea	di,-$824[bp]
14385 410A           E8         BFB6            call	laddul
14386 410D           83C4                   04  add	sp,*4
14387                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14388 4110           8DBE       F7E0            lea	di,-$820[bp]
14389 4114           E8         BFAC            call	laddul
14390 4117           83C4                   04  add	sp,*4
14391                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14392 411A           8986       F7EE            mov	-$812[bp],ax
14393 411E           899E       F7F0            mov	-$810[bp],bx
14394                                           !BCC_EOS
14395                                           ! 2379   memsetb(get_SS(),atacmd,0,12);
14396                                           ! Debug: list int = const $C (used reg = )
14397 4122           B8                   000C  mov	ax,*$C
14398 4125           50                         push	ax
14399                                           ! Debug: list int = const 0 (used reg = )
14400 4126           31C0                       xor	ax,ax
14401 4128           50                         push	ax
14402                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14403 4129           8D5E         F2            lea	bx,-$E[bp]
14404 412C           53                         push	bx
14405                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14406 412D           E8         C51D            call	_get_SS
14407                                           ! Debug: list unsigned short = ax+0 (used reg = )
14408 4130           50                         push	ax
14409                                           ! Debug: func () void = memsetb+0 (used reg = )
14410 4131           E8         BECC            call	_memsetb
14411 4134           83C4                   08  add	sp,*8
14412                                           !BCC_EOS
14413                                           ! 2380   atacmd[0]=0x28;
14414                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14415 4137           B0                     28  mov	al,*$28
14416 4139           8846         F2            mov	-$E[bp],al
14417                                           !BCC_EOS
14418                                           ! 2381   atacmd[7]=(0x01 & 0xff00) >> 8;
14419                                           ! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14420 413C           30C0                       xor	al,al
14421 413E           8846         F9            mov	-7[bp],al
14422                                           !BCC_EOS
14423                                           ! 2382   atacmd[8]=(0x01 & 0x00ff);
14424                                           ! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
14425 4141           B0                     01  mov	al,*1
14426 4143           8846         FA            mov	-6[bp],al
14427                                           !BCC_EOS
14428                                           ! 2383   atacmd[2]=(lba & 0xff000000) >> 24;
14429                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14430                                           ! Debug: expression subtree swapping
14431 4146           31C0                       xor	ax,ax
14432 4148           BB                   FF00  mov	bx,#$FF00
14433 414B           8DBE       F7EE            lea	di,-$812[bp]
14434 414F           E8         BF69            call	landul
14435                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14436 4152           93                         xchg	bx,ax
14437 4153           88E0                       mov	al,ah
14438 4155           30E4                       xor	ah,ah
14439 4157           31DB                       xor	bx,bx
14440                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14441 4159           8846         F4            mov	-$C[bp],al
14442                                           !BCC_EOS
14443                                           ! 2384   atacmd[3]=(lba & 0x00ff0000) >> 16;
14444                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14445                                           ! Debug: expression subtree swapping
14446 415C           31C0                       xor	ax,ax
14447 415E           BB                   00FF  mov	bx,#$FF
14448 4161           8DBE       F7EE            lea	di,-$812[bp]
14449 4165           E8         BF53            call	landul
14450                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14451 4168           93                         xchg	bx,ax
14452 4169           31DB                       xor	bx,bx
14453                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14454 416B           8846         F5            mov	-$B[bp],al
14455                                           !BCC_EOS
14456                                           ! 2385   atacmd[4]=(lba & 0x0000ff00) >> 8;
14457                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14458                                           ! Debug: expression subtree swapping
14459 416E           B8                   FF00  mov	ax,#$FF00
14460 4171           31DB                       xor	bx,bx
14461 4173           8DBE       F7EE            lea	di,-$812[bp]
14462 4177           E8         BF41            call	landul
14463                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14464 417A           88E0                       mov	al,ah
14465 417C           88DC                       mov	ah,bl
14466 417E           88FB                       mov	bl,bh
14467 4180           28FF                       sub	bh,bh
14468                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14469 4182           8846         F6            mov	-$A[bp],al
14470                                           !BCC_EOS
14471                                           ! 2386   atacmd[5]=(lba & 0x000000ff);
14472                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14473                                           ! Debug: expression subtree swapping
14474 4185           B8                   00FF  mov	ax,#$FF
14475 4188           31DB                       xor	bx,bx
14476 418A           8DBE       F7EE            lea	di,-$812[bp]
14477 418E           E8         BF2A            call	landul
14478                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14479 4191           8846         F7            mov	-9[bp],al
14480                                           !BCC_EOS
14481                                           ! 2387   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
14482                                           ! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
14483 4194           8D9E       F7F2            lea	bx,-$80E[bp]
14484 4198           53                         push	bx
14485                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14486 4199           E8         C4B1            call	_get_SS
14487                                           ! Debug: list unsigned short = ax+0 (used reg = )
14488 419C           50                         push	ax
14489                                           ! Debug: list int = const 1 (used reg = )
14490 419D           B8                   0001  mov	ax,*1
14491 41A0           50                         push	ax
14492                                           ! Debug: list long = const $800 (used reg = )
14493 41A1           B8                   0800  mov	ax,#$800
14494 41A4           31DB                       xor	bx,bx
14495 41A6           53                         push	bx
14496 41A7           50                         push	ax
14497                                           ! Debug: list int = const 0 (used reg = )
14498 41A8           31C0                       xor	ax,ax
14499 41AA           50                         push	ax
14500                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14501 41AB           8D5E         F2            lea	bx,-$E[bp]
14502 41AE           53                         push	bx
14503                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14504 41AF           E8         C49B            call	_get_SS
14505                                           ! Debug: list unsigned short = ax+0 (used reg = )
14506 41B2           50                         push	ax
14507                                           ! Debug: list int = const $C (used reg = )
14508 41B3           B8                   000C  mov	ax,*$C
14509 41B6           50                         push	ax
14510                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14511 41B7           8A86       F7E5            mov	al,-$81B[bp]
14512 41BB           30E4                       xor	ah,ah
14513 41BD           50                         push	ax
14514                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
14515 41BE           E8         F40A            call	_ata_cmd_packet
14516 41C1           83C4                   14  add	sp,*$14
14517                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
14518 41C4           8986       F7E6            mov	-$81A[bp],ax
14519                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
14520 41C8           85C0                       test	ax,ax
14521 41CA           74           07            je  	.311
14522                       000041CC            .312:
14523                                           ! 2388     return 7;
14524 41CC           B8                   0007  mov	ax,*7
14525 41CF           89EC                       mov	sp,bp
14526 41D1           5D                         pop	bp
14527 41D2           C3                         ret
14528                                           !BCC_EOS
14529                                           ! 2389   if(buffer[0x00]!=0x01)return 8;
14530                       000041D3            .311:
14531                                           ! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
14532 41D3           8A86       F7F2            mov	al,-$80E[bp]
14533 41D7           3C                     01  cmp	al,*1
14534 41D9           74           07            je  	.313
14535                       000041DB            .314:
14536 41DB           B8                   0008  mov	ax,*8
14537 41DE           89EC                       mov	sp,bp
14538 41E0           5D                         pop	bp
14539 41E1           C3                         ret
14540                                           !BCC_EOS
14541                                           ! 2390   if(buffer[0x01]!=0x00)return 9;
14542                       000041E2            .313:
14543                                           ! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
14544 41E2           8A86       F7F3            mov	al,-$80D[bp]
14545 41E6           84C0                       test	al,al
14546 41E8           74           07            je  	.315
14547                       000041EA            .316:
14548 41EA           B8                   0009  mov	ax,*9
14549 41ED           89EC                       mov	sp,bp
14550 41EF           5D                         pop	bp
14551 41F0           C3                         ret
14552                                           !BCC_EOS
14553                                           ! 2391   if(buffer[0x1E]!=0x55)return 10;
14554                       000041F1            .315:
14555                                           ! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
14556 41F1           8A86       F810            mov	al,-$7F0[bp]
14557 41F5           3C                     55  cmp	al,*$55
14558 41F7           74           07            je  	.317
14559                       000041F9            .318:
14560 41F9           B8                   000A  mov	ax,*$A
14561 41FC           89EC                       mov	sp,bp
14562 41FE           5D                         pop	bp
14563 41FF           C3                         ret
14564                                           !BCC_EOS
14565                                           ! 2392   if(buffer[0x1F]!=0xAA)return 10;
14566                       00004200            .317:
14567                                           ! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
14568 4200           8A86       F811            mov	al,-$7EF[bp]
14569 4204           3C                     AA  cmp	al,#$AA
14570 4206           74           07            je  	.319
14571                       00004208            .31A:
14572 4208           B8                   000A  mov	ax,*$A
14573 420B           89EC                       mov	sp,bp
14574 420D           5D                         pop	bp
14575 420E           C3                         ret
14576                                           !BCC_EOS
14577                                           ! 2393   if(buffer[0x20]!=0x88)return 11;
14578                       0000420F            .319:
14579                                           ! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
14580 420F           8A86       F812            mov	al,-$7EE[bp]
14581 4213           3C                     88  cmp	al,#$88
14582 4215           74           07            je  	.31B
14583                       00004217            .31C:
14584 4217           B8                   000B  mov	ax,*$B
14585 421A           89EC                       mov	sp,bp
14586 421C           5D                         pop	bp
14587 421D           C3                         ret
14588                                           !BCC_EOS
14589                                           ! 2394   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
14590                       0000421E            .31B:
14591                                           ! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
14592 421E           8A86       F813            mov	al,-$7ED[bp]
14593 4222           30E4                       xor	ah,ah
14594 4224           50                         push	ax
14595                                           ! Debug: list * unsigned char = const $25B (used reg = )
14596 4225           B8                   025B  mov	ax,#$25B
14597 4228           50                         push	ax
14598                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14599 4229           FF76         FE            push	-2[bp]
14600                                           ! Debug: func () void = write_byte+0 (used reg = )
14601 422C           E8         C3EB            call	_write_byte
14602 422F           83C4                   06  add	sp,*6
14603                                           !BCC_EOS
14604                                           ! 2395   if(buffer[0x21]==0){
14605                                           ! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14606 4232           8A86       F813            mov	al,-$7ED[bp]
14607 4236           84C0                       test	al,al
14608 4238           75           13            jne 	.31D
14609                       0000423A            .31E:
14610                                           ! 2396     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
14611                                           ! Debug: list int = const $E0 (used reg = )
14612 423A           B8                   00E0  mov	ax,#$E0
14613 423D           50                         push	ax
14614                                           ! Debug: list * unsigned char = const $25C (used reg = )
14615 423E           B8                   025C  mov	ax,#$25C
14616 4241           50                         push	ax
14617                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14618 4242           FF76         FE            push	-2[bp]
14619                                           ! Debug: func () void = write_byte+0 (used reg = )
14620 4245           E8         C3D2            call	_write_byte
14621 4248           83C4                   06  add	sp,*6
14622                                           !BCC_EOS
14623                                           ! 2397     }
14624                                           ! 2398   else if(buffer[0x21]<4)
14625 424B           EB           2B            jmp .31F
14626                       0000424D            .31D:
14627                                           ! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
14628 424D           8A86       F813            mov	al,-$7ED[bp]
14629 4251           3C                     04  cmp	al,*4
14630 4253           73           12            jae 	.320
14631                       00004255            .321:
14632                                           ! 2399     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
14633                                           ! Debug: list int = const 0 (used reg = )
14634 4255           31C0                       xor	ax,ax
14635 4257           50                         push	ax
14636                                           ! Debug: list * unsigned char = const $25C (used reg = )
14637 4258           B8                   025C  mov	ax,#$25C
14638 425B           50                         push	ax
14639                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14640 425C           FF76         FE            push	-2[bp]
14641                                           ! Debug: func () void = write_byte+0 (used reg = )
14642 425F           E8         C3B8            call	_write_byte
14643 4262           83C4                   06  add	sp,*6
14644                                           !BCC_EOS
14645                                           ! 2400   else
14646                                           ! 2401     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
14647 4265           EB           11            jmp .322
14648                       00004267            .320:
14649                                           ! Debug: list int = const $80 (used reg = )
14650 4267           B8                   0080  mov	ax,#$80
14651 426A           50                         push	ax
14652                                           ! Debug: list * unsigned char = const $25C (used reg = )
14653 426B           B8                   025C  mov	ax,#$25C
14654 426E           50                         push	ax
14655                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14656 426F           FF76         FE            push	-2[bp]
14657                                           ! Debug: func () void = write_byte+0 (used reg = )
14658 4272           E8         C3A5            call	_write_byte
14659 4275           83C4                   06  add	sp,*6
14660                                           !BCC_EOS
14661                                           ! 2402   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
14662                       00004278            .322:
14663                       00004278            .31F:
14664                                           ! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14665 4278           8A86       F7E5            mov	al,-$81B[bp]
14666 427C           30E4                       xor	ah,ah
14667 427E           D1E8                       shr	ax,*1
14668                                           ! Debug: list unsigned int = ax+0 (used reg = )
14669 4280           50                         push	ax
14670                                           ! Debug: list * unsigned char = const $25D (used reg = )
14671 4281           B8                   025D  mov	ax,#$25D
14672 4284           50                         push	ax
14673                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14674 4285           FF76         FE            push	-2[bp]
14675                                           ! Debug: func () void = write_byte+0 (used reg = )
14676 4288           E8         C38F            call	_write_byte
14677 428B           83C4                   06  add	sp,*6
14678                                           !BCC_EOS
14679                                           ! 2403   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
14680                                           ! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
14681 428E           8A86       F7E5            mov	al,-$81B[bp]
14682 4292           30E4                       xor	ah,ah
14683 4294           24                     01  and	al,*1
14684                                           ! Debug: list unsigned char = al+0 (used reg = )
14685 4296           30E4                       xor	ah,ah
14686 4298           50                         push	ax
14687                                           ! Debug: list * unsigned short = const $25E (used reg = )
14688 4299           B8                   025E  mov	ax,#$25E
14689 429C           50                         push	ax
14690                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14691 429D           FF76         FE            push	-2[bp]
14692                                           ! Debug: func () void = write_byte+0 (used reg = )
14693 42A0           E8         C377            call	_write_byte
14694 42A3           83C4                   06  add	sp,*6
14695                                           !BCC_EOS
14696                                           ! 2404   boot_segment=buffer[0x23]*0x100+buffer[0x22];
14697                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
14698 42A6           8A86       F815            mov	al,-$7EB[bp]
14699 42AA           30E4                       xor	ah,ah
14700 42AC           B9                   0100  mov	cx,#$100
14701 42AF           F7E9                       imul	cx
14702                                           ! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
14703 42B1           0286       F814            add	al,-$7EC[bp]
14704 42B5           80D4                   00  adc	ah,*0
14705                                           ! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14706 42B8           8986       F7EC            mov	-$814[bp],ax
14707                                           !BCC_EOS
14708                                           ! 2405   if(boot_segment==0x0000)boot_segment=0x07C0;
14709                                           ! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14710 42BC           8B86       F7EC            mov	ax,-$814[bp]
14711 42C0           85C0                       test	ax,ax
14712 42C2           75           07            jne 	.323
14713                       000042C4            .324:
14714                                           ! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
14715 42C4           B8                   07C0  mov	ax,#$7C0
14716 42C7           8986       F7EC            mov	-$814[bp],ax
14717                                           !BCC_EOS
14718                                           ! 2406   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
14719                       000042CB            .323:
14720                                           ! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
14721 42CB           FFB6       F7EC            push	-$814[bp]
14722                                           ! Debug: list * unsigned short = const $266 (used reg = )
14723 42CF           B8                   0266  mov	ax,#$266
14724 42D2           50                         push	ax
14725                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14726 42D3           FF76         FE            push	-2[bp]
14727                                           ! Debug: func () void = write_word+0 (used reg = )
14728 42D6           E8         C359            call	_write_word
14729 42D9           83C4                   06  add	sp,*6
14730                                           !BCC_EOS
14731                                           ! 2407   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
14732                                           ! Debug: list int = const 0 (used reg = )
14733 42DC           31C0                       xor	ax,ax
14734 42DE           50                         push	ax
14735                                           ! Debug: list * unsigned short = const $264 (used reg = )
14736 42DF           B8                   0264  mov	ax,#$264
14737 42E2           50                         push	ax
14738                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14739 42E3           FF76         FE            push	-2[bp]
14740                                           ! Debug: func () void = write_word+0 (used reg = )
14741 42E6           E8         C349            call	_write_word
14742 42E9           83C4                   06  add	sp,*6
14743                                           !BCC_EOS
14744                                           ! 2408   nbsectors=buffer[0x27]*0x100+buffer[0x26];
14745                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
14746 42EC           8A86       F819            mov	al,-$7E7[bp]
14747 42F0           30E4                       xor	ah,ah
14748 42F2           B9                   0100  mov	cx,#$100
14749 42F5           F7E9                       imul	cx
14750                                           ! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
14751 42F7           0286       F818            add	al,-$7E8[bp]
14752 42FB           80D4                   00  adc	ah,*0
14753                                           ! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14754 42FE           8986       F7EA            mov	-$816[bp],ax
14755                                           !BCC_EOS
14756                                           ! 2409   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
14757                                           ! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
14758 4302           FFB6       F7EA            push	-$816[bp]
14759                                           ! Debug: list * unsigned short = const $268 (used reg = )
14760 4306           B8                   0268  mov	ax,#$268
14761 4309           50                         push	ax
14762                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
14763 430A           FF76         FE            push	-2[bp]
14764                                           ! Debug: func () void = write_word+0 (used reg = )
14765 430D           E8         C322            call	_write_word
14766 4310           83C4                   06  add	sp,*6
14767                                           !BCC_EOS
14768                                           ! 2410   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
14769                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
14770 4313           8A86       F81A            mov	al,-$7E6[bp]
14771 4317           30E4                       xor	ah,ah
14772 4319           31DB                       xor	bx,bx
14773 431B           53                         push	bx
14774 431C           50                         push	ax
14775                                           ! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
14776 431D           8A86       F81B            mov	al,-$7E5[bp]
14777 4321           30E4                       xor	ah,ah
14778 4323           B9                   0100  mov	cx,#$100
14779 4326           F7E9                       imul	cx
14780                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
14781 4328           31DB                       xor	bx,bx
14782 432A           53                         push	bx
14783 432B           50                         push	ax
14784                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
14785 432C           8A86       F81C            mov	al,-$7E4[bp]
14786 4330           30E4                       xor	ah,ah
14787 4332           31DB                       xor	bx,bx
14788                                           ! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
14789 4334           53                         push	bx
14790 4335           50                         push	ax
14791 4336           31C0                       xor	ax,ax
14792 4338           BB                   0001  mov	bx,*1
14793 433B           53                         push	bx
14794 433C           50                         push	ax
14795 433D           8B86       F7D8            mov	ax,-$828[bp]
14796 4341           8B9E       F7DA            mov	bx,-$826[bp]
14797 4345           8DBE       F7D4            lea	di,-$82C[bp]
14798 4349           E8         BD9D            call	lmulul
14799 434C           83C4                   08  add	sp,*8
14800 434F           53                         push	bx
14801 4350           50                         push	ax
14802                                           ! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
14803 4351           8A86       F81D            mov	al,-$7E3[bp]
14804 4355           30E4                       xor	ah,ah
14805 4357           31DB                       xor	bx,bx
14806                                           ! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
14807 4359           53                         push	bx
14808 435A           50                         push	ax
14809 435B           31C0                       xor	ax,ax
14810 435D           BB                   0100  mov	bx,#$100
14811 4360           53                         push	bx
14812 4361           50                         push	ax
14813 4362           8B86       F7D4            mov	ax,-$82C[bp]
14814 4366           8B9E       F7D6            mov	bx,-$82A[bp]
14815 436A           8DBE       F7D0            lea	di,-$830[bp]
14816 436E           E8         BD78            call	lmulul
14817 4371           83C4                   08  add	sp,*8
14818                                           ! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
14819 4374           8DBE       F7D8            lea	di,-$828[bp]
14820 4378           E8         BD48            call	laddul
14821 437B           83C4                   04  add	sp,*4
14822                                           ! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
14823 437E           8DBE       F7DC            lea	di,-$824[bp]
14824 4382           E8         BD3E            call	laddul
14825 4385           83C4                   04  add	sp,*4
14826                                           ! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
14827 4388           8DBE       F7E0            lea	di,-$820[bp]
14828 438C           E8         BD34            call	laddul
14829 438F           83C4                   04  add	sp,*4
14830                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
14831 4392           8986       F7EE            mov	-$812[bp],ax
14832 4396           899E       F7F0            mov	-$810[bp],bx
14833                                           !BCC_EOS
14834                                           ! 2411   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
14835                                           ! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
14836 439A           FFB6       F7F0            push	-$810[bp]
14837 439E           FFB6       F7EE            push	-$812[bp]
14838                                           ! Debug: list * unsigned long = const $260 (used reg = )
14839 43A2           B8                   0260  mov	ax,#$260
14840 43A5           50                         push	ax
14841                                           ! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
14842 43A6           FF76         FE            push	-2[bp]
14843                                           ! Debug: func () void = write_dword+0 (used reg = )
14844 43A9           E8         BCEF            call	_write_dword
14845 43AC           83C4                   08  add	sp,*8
14846                                           !BCC_EOS
14847                                           ! 2412   memsetb(get_SS(),atacmd,0,12);
14848                                           ! Debug: list int = const $C (used reg = )
14849 43AF           B8                   000C  mov	ax,*$C
14850 43B2           50                         push	ax
14851                                           ! Debug: list int = const 0 (used reg = )
14852 43B3           31C0                       xor	ax,ax
14853 43B5           50                         push	ax
14854                                           ! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
14855 43B6           8D5E         F2            lea	bx,-$E[bp]
14856 43B9           53                         push	bx
14857                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14858 43BA           E8         C290            call	_get_SS
14859                                           ! Debug: list unsigned short = ax+0 (used reg = )
14860 43BD           50                         push	ax
14861                                           ! Debug: func () void = memsetb+0 (used reg = )
14862 43BE           E8         BC3F            call	_memsetb
14863 43C1           83C4                   08  add	sp,*8
14864                                           !BCC_EOS
14865                                           ! 2413   atacmd[0]=0x28;
14866                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
14867 43C4           B0                     28  mov	al,*$28
14868 43C6           8846         F2            mov	-$E[bp],al
14869                                           !BCC_EOS
14870                                           ! 2414   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
14871                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14872 43C9           8B86       F7EA            mov	ax,-$816[bp]
14873                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14874 43CD           48                         dec	ax
14875 43CE           D1E8                       shr	ax,*1
14876 43D0           D1E8                       shr	ax,*1
14877                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14878                                           ! Debug: expression subtree swapping
14879                                           ! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
14880 43D2           40                         inc	ax
14881 43D3           30C0                       xor	al,al
14882                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
14883 43D5           88E0                       mov	al,ah
14884 43D7           30E4                       xor	ah,ah
14885                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
14886 43D9           8846         F9            mov	-7[bp],al
14887                                           !BCC_EOS
14888                                           ! 2415   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
14889                                           ! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
14890 43DC           8B86       F7EA            mov	ax,-$816[bp]
14891                                           ! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
14892 43E0           48                         dec	ax
14893 43E1           D1E8                       shr	ax,*1
14894 43E3           D1E8                       shr	ax,*1
14895                                           ! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
14896                                           ! Debug: expression subtree swapping
14897                                           ! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
14898 43E5           40                         inc	ax
14899                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
14900 43E6           8846         FA            mov	-6[bp],al
14901                                           !BCC_EOS
14902                                           ! 2416   atacmd[2]=(lba & 0xff000000) >> 24;
14903                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
14904                                           ! Debug: expression subtree swapping
14905 43E9           31C0                       xor	ax,ax
14906 43EB           BB                   FF00  mov	bx,#$FF00
14907 43EE           8DBE       F7EE            lea	di,-$812[bp]
14908 43F2           E8         BCC6            call	landul
14909                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
14910 43F5           93                         xchg	bx,ax
14911 43F6           88E0                       mov	al,ah
14912 43F8           30E4                       xor	ah,ah
14913 43FA           31DB                       xor	bx,bx
14914                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
14915 43FC           8846         F4            mov	-$C[bp],al
14916                                           !BCC_EOS
14917                                           ! 2417   atacmd[3]=(lba & 0x00ff0000) >> 16;
14918                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
14919                                           ! Debug: expression subtree swapping
14920 43FF           31C0                       xor	ax,ax
14921 4401           BB                   00FF  mov	bx,#$FF
14922 4404           8DBE       F7EE            lea	di,-$812[bp]
14923 4408           E8         BCB0            call	landul
14924                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
14925 440B           93                         xchg	bx,ax
14926 440C           31DB                       xor	bx,bx
14927                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
14928 440E           8846         F5            mov	-$B[bp],al
14929                                           !BCC_EOS
14930                                           ! 2418   atacmd[4]=(lba & 0x0000ff00) >> 8;
14931                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
14932                                           ! Debug: expression subtree swapping
14933 4411           B8                   FF00  mov	ax,#$FF00
14934 4414           31DB                       xor	bx,bx
14935 4416           8DBE       F7EE            lea	di,-$812[bp]
14936 441A           E8         BC9E            call	landul
14937                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
14938 441D           88E0                       mov	al,ah
14939 441F           88DC                       mov	ah,bl
14940 4421           88FB                       mov	bl,bh
14941 4423           28FF                       sub	bh,bh
14942                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
14943 4425           8846         F6            mov	-$A[bp],al
14944                                           !BCC_EOS
14945                                           ! 2419   atacmd[5]=(lba & 0x000000ff);
14946                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
14947                                           ! Debug: expression subtree swapping
14948 4428           B8                   00FF  mov	ax,#$FF
14949 442B           31DB                       xor	bx,bx
14950 442D           8DBE       F7EE            lea	di,-$812[bp]
14951 4431           E8         BC87            call	landul
14952                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
14953 4434           8846         F7            mov	-9[bp],al
14954                                           !BCC_EOS
14955                                           ! 2420   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
14956                                           ! Debug: list int = const 0 (used reg = )
14957 4437           31C0                       xor	ax,ax
14958 4439           50                         push	ax
14959                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
14960 443A           FFB6       F7EC            push	-$814[bp]
14961                                           ! Debug: list int = const 1 (used reg = )
14962 443E           B8                   0001  mov	ax,*1
14963 4441           50                         push	ax
14964                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
14965 4442           8B86       F7EA            mov	ax,-$816[bp]
14966 4446           31DB                       xor	bx,bx
14967                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
14968 4448           53                         push	bx
14969 4449           50                         push	ax
14970 444A           B8                   0200  mov	ax,#$200
14971 444D           31DB                       xor	bx,bx
14972 444F           53                         push	bx
14973 4450           50                         push	ax
14974 4451           8B86       F7DA            mov	ax,-$826[bp]
14975 4455           8B9E       F7DC            mov	bx,-$824[bp]
14976 4459           8DBE       F7D6            lea	di,-$82A[bp]
14977 445D           E8         BC89            call	lmulul
14978 4460           83C4                   08  add	sp,*8
14979                                           ! Debug: list unsigned long = bx+0 (used reg = )
14980 4463           53                         push	bx
14981 4464           50                         push	ax
14982                                           ! Debug: list int = const 0 (used reg = )
14983 4465           31C0                       xor	ax,ax
14984 4467           50                         push	ax
14985                                           ! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
14986 4468           8D5E         F2            lea	bx,-$E[bp]
14987 446B           53                         push	bx
14988                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
14989 446C           E8         C1DE            call	_get_SS
14990                                           ! Debug: list unsigned short = ax+0 (used reg = )
14991 446F           50                         push	ax
14992                                           ! Debug: list int = const $C (used reg = )
14993 4470           B8                   000C  mov	ax,*$C
14994 4473           50                         push	ax
14995                                           ! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
14996 4474           8A86       F7E5            mov	al,-$81B[bp]
14997 4478           30E4                       xor	ah,ah
14998 447A           50                         push	ax
14999                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
15000 447B           E8         F14D            call	_ata_cmd_packet
15001 447E           83C4                   14  add	sp,*$14
15002                                           ! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
15003 4481           8986       F7E6            mov	-$81A[bp],ax
15004                                           ! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
15005 4485           85C0                       test	ax,ax
15006 4487           74           07            je  	.325
15007                       00004489            .326:
15008                                           ! 2421     
15009                                           ! 2421 return 12;
15010 4489           B8                   000C  mov	ax,*$C
15011 448C           89EC                       mov	sp,bp
15012 448E           5D                         pop	bp
15013 448F           C3                         ret
15014                                           !BCC_EOS
15015                                           ! 2422   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
15016                       00004490            .325:
15017                                           ! Debug: list * unsigned char = const $25B (used reg = )
15018 4490           B8                   025B  mov	ax,#$25B
15019 4493           50                         push	ax
15020                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15021 4494           FF76         FE            push	-2[bp]
15022                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15023 4497           E8         C15A            call	_read_byte
15024 449A           83C4                   04  add	sp,*4
15025 449D           E9         0120            br 	.329
15026                                           ! 2423     case 0x01:
15027                                           ! 2424       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
15028                       000044A0            .32A:
15029                                           ! Debug: list int = const $F (used reg = )
15030 44A0           B8                   000F  mov	ax,*$F
15031 44A3           50                         push	ax
15032                                           ! Debug: list * unsigned short = const $26E (used reg = )
15033 44A4           B8                   026E  mov	ax,#$26E
15034 44A7           50                         push	ax
15035                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15036 44A8           FF76         FE            push	-2[bp]
15037                                           ! Debug: func () void = write_word+0 (used reg = )
15038 44AB           E8         C184            call	_write_word
15039 44AE           83C4                   06  add	sp,*6
15040                                           !BCC_EOS
15041                                           ! 2425       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15042                                           ! Debug: list int = const $50 (used reg = )
15043 44B1           B8                   0050  mov	ax,*$50
15044 44B4           50                         push	ax
15045                                           ! Debug: list * unsigned short = const $26C (used reg = )
15046 44B5           B8                   026C  mov	ax,#$26C
15047 44B8           50                         push	ax
15048                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15049 44B9           FF76         FE            push	-2[bp]
15050                                           ! Debug: func () void = write_word+0 (used reg = )
15051 44BC           E8         C173            call	_write_word
15052 44BF           83C4                   06  add	sp,*6
15053                                           !BCC_EOS
15054                                           ! 2426       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15055                                           ! Debug: list int = const 2 (used reg = )
15056 44C2           B8                   0002  mov	ax,*2
15057 44C5           50                         push	ax
15058                                           ! Debug: list * unsigned short = const $26A (used reg = )
15059 44C6           B8                   026A  mov	ax,#$26A
15060 44C9           50                         push	ax
15061                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15062 44CA           FF76         FE            push	-2[bp]
15063                                           ! Debug: func () void = write_word+0 (used reg = )
15064 44CD           E8         C162            call	_write_word
15065 44D0           83C4                   06  add	sp,*6
15066                                           !BCC_EOS
15067                                           ! 2427       break;
15068 44D3           E9         0102            br 	.327
15069                                           !BCC_EOS
15070                                           ! 2428     case 0x02:
15071                                           ! 2429       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
15072                       000044D6            .32B:
15073                                           ! Debug: list int = const $12 (used reg = )
15074 44D6           B8                   0012  mov	ax,*$12
15075 44D9           50                         push	ax
15076                                           ! Debug: list * unsigned short = const $26E (used reg = )
15077 44DA           B8                   026E  mov	ax,#$26E
15078 44DD           50                         push	ax
15079                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15080 44DE           FF76         FE            push	-2[bp]
15081                                           ! Debug: func () void = write_word+0 (used reg = )
15082 44E1           E8         C14E            call	_write_word
15083 44E4           83C4                   06  add	sp,*6
15084                                           !BCC_EOS
15085                                           ! 2430       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15086                                           ! Debug: list int = const $50 (used reg = )
15087 44E7           B8                   0050  mov	ax,*$50
15088 44EA           50                         push	ax
15089                                           ! Debug: list * unsigned short = const $26C (used reg = )
15090 44EB           B8                   026C  mov	ax,#$26C
15091 44EE           50                         push	ax
15092                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15093 44EF           FF76         FE            push	-2[bp]
15094                                           ! Debug: func () void = write_word+0 (used reg = )
15095 44F2           E8         C13D            call	_write_word
15096 44F5           83C4                   06  add	sp,*6
15097                                           !BCC_EOS
15098                                           ! 2431       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15099                                           ! Debug: list int = const 2 (used reg = )
15100 44F8           B8                   0002  mov	ax,*2
15101 44FB           50                         push	ax
15102                                           ! Debug: list * unsigned short = const $26A (used reg = )
15103 44FC           B8                   026A  mov	ax,#$26A
15104 44FF           50                         push	ax
15105                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15106 4500           FF76         FE            push	-2[bp]
15107                                           ! Debug: func () void = write_word+0 (used reg = )
15108 4503           E8         C12C            call	_write_word
15109 4506           83C4                   06  add	sp,*6
15110                                           !BCC_EOS
15111                                           ! 2432       break;
15112 4509           E9         00CC            br 	.327
15113                                           !BCC_EOS
15114                                           ! 2433     case 0x03:
15115                                           ! 2434       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
15116                       0000450C            .32C:
15117                                           ! Debug: list int = const $24 (used reg = )
15118 450C           B8                   0024  mov	ax,*$24
15119 450F           50                         push	ax
15120                                           ! Debug: list * unsigned short = const $26E (used reg = )
15121 4510           B8                   026E  mov	ax,#$26E
15122 4513           50                         push	ax
15123                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15124 4514           FF76         FE            push	-2[bp]
15125                                           ! Debug: func () void = write_word+0 (used reg = )
15126 4517           E8         C118            call	_write_word
15127 451A           83C4                   06  add	sp,*6
15128                                           !BCC_EOS
15129                                           ! 2435       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
15130                                           ! Debug: list int = const $50 (used reg = )
15131 451D           B8                   0050  mov	ax,*$50
15132 4520           50                         push	ax
15133                                           ! Debug: list * unsigned short = const $26C (used reg = )
15134 4521           B8                   026C  mov	ax,#$26C
15135 4524           50                         push	ax
15136                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15137 4525           FF76         FE            push	-2[bp]
15138                                           ! Debug: func () void = write_word+0 (used reg = )
15139 4528           E8         C107            call	_write_word
15140 452B           83C4                   06  add	sp,*6
15141                                           !BCC_EOS
15142                                           ! 2436       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
15143                                           ! Debug: list int = const 2 (used reg = )
15144 452E           B8                   0002  mov	ax,*2
15145 4531           50                         push	ax
15146                                           ! Debug: list * unsigned short = const $26A (used reg = )
15147 4532           B8                   026A  mov	ax,#$26A
15148 4535           50                         push	ax
15149                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15150 4536           FF76         FE            push	-2[bp]
15151                                           ! Debug: func () void = write_word+0 (used reg = )
15152 4539           E8         C0F6            call	_write_word
15153 453C           83C4                   06  add	sp,*6
15154                                           !BCC_EOS
15155                                           ! 2437       break;
15156 453F           E9         0096            br 	.327
15157                                           !BCC_EOS
15158                                           ! 2438     case 0x04:
15159                                           ! 2439       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
15160                       00004542            .32D:
15161                                           ! Debug: list int = const $1C4 (used reg = )
15162 4542           B8                   01C4  mov	ax,#$1C4
15163 4545           50                         push	ax
15164                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15165 4546           FFB6       F7EC            push	-$814[bp]
15166                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15167 454A           E8         C0A7            call	_read_byte
15168 454D           83C4                   04  add	sp,*4
15169                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
15170 4550           24                     3F  and	al,*$3F
15171                                           ! Debug: list unsigned char = al+0 (used reg = )
15172 4552           30E4                       xor	ah,ah
15173 4554           50                         push	ax
15174                                           ! Debug: list * unsigned short = const $26E (used reg = )
15175 4555           B8                   026E  mov	ax,#$26E
15176 4558           50                         push	ax
15177                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15178 4559           FF76         FE            push	-2[bp]
15179                                           ! Debug: func () void = write_word+0 (used reg = )
15180 455C           E8         C0D3            call	_write_word
15181 455F           83C4                   06  add	sp,*6
15182                                           !BCC_EOS
15183                                           ! 2440       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
15184                                           ! 2441               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
15185                                           ! Debug: list int = const $1C5 (used reg = )
15186 4562           B8                   01C5  mov	ax,#$1C5
15187 4565           50                         push	ax
15188                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15189 4566           FFB6       F7EC            push	-$814[bp]
15190                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15191 456A           E8         C087            call	_read_byte
15192 456D           83C4                   04  add	sp,*4
15193 4570           50                         push	ax
15194                                           ! Debug: list int = const $1C4 (used reg = )
15195 4571           B8                   01C4  mov	ax,#$1C4
15196 4574           50                         push	ax
15197                                           ! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
15198 4575           FFB6       F7EC            push	-$814[bp]
15199                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15200 4579           E8         C078            call	_read_byte
15201 457C           83C4                   04  add	sp,*4
15202                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
15203 457F           30E4                       xor	ah,ah
15204 4581           D1E0                       shl	ax,*1
15205 4583           D1E0                       shl	ax,*1
15206                                           ! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
15207 4585           0286       F7E2            add	al,0+..FFF9[bp]
15208 4589           80D4                   00  adc	ah,*0
15209 458C           44                         inc	sp
15210 458D           44                         inc	sp
15211                                           ! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
15212                                           ! Debug: list unsigned int = ax+1 (used reg = )
15213 458E           40                         inc	ax
15214 458F           50                         push	ax
15215                                           ! Debug: list * unsigned short = const $26C (used reg = )
15216 4590           B8                   026C  mov	ax,#$26C
15217 4593           50                         push	ax
15218                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15219 4594           FF76         FE            push	-2[bp]
15220                                           ! Debug: func () void = write_word+0 (used reg = )
15221 4597           E8         C098            call	_write_word
15222 459A           83C4                   06  add	sp,*6
15223                                           !BCC_EOS
15224                                           ! 2442       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
15225                                           ! Debug: list int = const $1C3 (used reg = )
15226 459D           B8                   01C3  mov	ax,#$1C3
15227 45A0           50                         push	ax
15228                                           ! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
15229 45A1           FFB6       F7EC            push	-$814[bp]
15230                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15231 45A5           E8         C04C            call	_read_byte
15232 45A8           83C4                   04  add	sp,*4
15233                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15234 45AB           30E4                       xor	ah,ah
15235                                           ! Debug: list unsigned int = ax+1 (used reg = )
15236 45AD           40                         inc	ax
15237 45AE           50                         push	ax
15238                                           ! Debug: list * unsigned short = const $26A (used reg = )
15239 45AF           B8                   026A  mov	ax,#$26A
15240 45B2           50                         push	ax
15241                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15242 45B3           FF76         FE            push	-2[bp]
15243                                           ! Debug: func () void = write_word+0 (used reg = )
15244 45B6           E8         C079            call	_write_word
15245 45B9           83C4                   06  add	sp,*6
15246                                           !BCC_EOS
15247                                           ! 2443       break;
15248 45BC           EB           1A            jmp .327
15249                                           !BCC_EOS
15250                                           ! 2444    }
15251                                           ! 2445   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
15252 45BE           EB           18            jmp .327
15253                       000045C0            .329:
15254 45C0           2C                     01  sub	al,*1
15255 45C2         0F84         FEDA            beq 	.32A
15256 45C6           2C                     01  sub	al,*1
15257 45C8         0F84         FF0A            beq 	.32B
15258 45CC           2C                     01  sub	al,*1
15259 45CE         0F84         FF3A            beq 	.32C
15260 45D2           2C                     01  sub	al,*1
15261 45D4         0F84         FF6A            beq 	.32D
15262                       000045D8            .327:
15263                       FFFFF7E2            ..FFF9	=	-$81E
15264                                           ! Debug: list * unsigned char = const $25B (used reg = )
15265 45D8           B8                   025B  mov	ax,#$25B
15266 45DB           50                         push	ax
15267                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15268 45DC           FF76         FE            push	-2[bp]
15269                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15270 45DF           E8         C012            call	_read_byte
15271 45E2           83C4                   04  add	sp,*4
15272                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15273 45E5           84C0                       test	al,al
15274 45E7           74           52            je  	.32E
15275                       000045E9            .32F:
15276                                           ! 2446     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
15277                                           ! Debug: list * unsigned char = const $25C (used reg = )
15278 45E9           B8                   025C  mov	ax,#$25C
15279 45EC           50                         push	ax
15280                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15281 45ED           FF76         FE            push	-2[bp]
15282                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15283 45F0           E8         C001            call	_read_byte
15284 45F3           83C4                   04  add	sp,*4
15285                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15286 45F6           84C0                       test	al,al
15287 45F8           75           23            jne 	.330
15288                       000045FA            .331:
15289                                           ! 2447       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
15290                                           ! Debug: list int = const $10 (used reg = )
15291 45FA           B8                   0010  mov	ax,*$10
15292 45FD           50                         push	ax
15293                                           ! Debug: list int = const $40 (used reg = )
15294 45FE           B8                   0040  mov	ax,*$40
15295 4601           50                         push	ax
15296                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15297 4602           E8         BFEF            call	_read_byte
15298 4605           83C4                   04  add	sp,*4
15299                                           ! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
15300 4608           0C                     41  or	al,*$41
15301                                           ! Debug: list unsigned char = al+0 (used reg = )
15302 460A           30E4                       xor	ah,ah
15303 460C           50                         push	ax
15304                                           ! Debug: list int = const $10 (used reg = )
15305 460D           B8                   0010  mov	ax,*$10
15306 4610           50                         push	ax
15307                                           ! Debug: list int = const $40 (used reg = )
15308 4611           B8                   0040  mov	ax,*$40
15309 4614           50                         push	ax
15310                                           ! Debug: func () void = write_byte+0 (used reg = )
15311 4615           E8         C002            call	_write_byte
15312 4618           83C4                   06  add	sp,*6
15313                                           !BCC_EOS
15314                                           ! 2448     else
15315                                           ! 2449       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
15316 461B           EB           1E            jmp .332
15317                       0000461D            .330:
15318                                           ! Debug: list * unsigned char = const $232 (used reg = )
15319 461D           B8                   0232  mov	ax,#$232
15320 4620           50                         push	ax
15321                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15322 4621           FF76         FE            push	-2[bp]
15323                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15324 4624           E8         BFCD            call	_read_byte
15325 4627           83C4                   04  add	sp,*4
15326                                           ! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
15327 462A           30E4                       xor	ah,ah
15328                                           ! Debug: list unsigned int = ax+1 (used reg = )
15329 462C           40                         inc	ax
15330 462D           50                         push	ax
15331                                           ! Debug: list * unsigned char = const $232 (used reg = )
15332 462E           B8                   0232  mov	ax,#$232
15333 4631           50                         push	ax
15334                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15335 4632           FF76         FE            push	-2[bp]
15336                                           ! Debug: func () void = write_byte+0 (used reg = )
15337 4635           E8         BFE2            call	_write_byte
15338 4638           83C4                   06  add	sp,*6
15339                                           !BCC_EOS
15340                                           ! 2450    }
15341                       0000463B            .332:
15342                                           ! 2451   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
15343                       0000463B            .32E:
15344                                           ! Debug: list * unsigned char = const $25B (used reg = )
15345 463B           B8                   025B  mov	ax,#$25B
15346 463E           50                         push	ax
15347                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15348 463F           FF76         FE            push	-2[bp]
15349                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15350 4642           E8         BFAF            call	_read_byte
15351 4645           83C4                   04  add	sp,*4
15352                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
15353 4648           84C0                       test	al,al
15354 464A           74           11            je  	.333
15355                       0000464C            .334:
15356                                           ! 2452     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
15357                                           ! Debug: list int = const 1 (used reg = )
15358 464C           B8                   0001  mov	ax,*1
15359 464F           50                         push	ax
15360                                           ! Debug: list * unsigned char = const $25A (used reg = )
15361 4650           B8                   025A  mov	ax,#$25A
15362 4653           50                         push	ax
15363                                           ! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
15364 4654           FF76         FE            push	-2[bp]
15365                                           ! Debug: func () void = write_byte+0 (used reg = )
15366 4657           E8         BFC0            call	_write_byte
15367 465A           83C4                   06  add	sp,*6
15368                                           !BCC_EOS
15369                                           ! 2453   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
15370                       0000465D            .333:
15371                                           ! Debug: list * unsigned char = const $25C (used reg = )
15372 465D           B8                   025C  mov	ax,#$25C
15373 4660           50                         push	ax
15374                                           ! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
15375 4661           FF76         FE            push	-2[bp]
15376                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15377 4664           E8         BF8D            call	_read_byte
15378 4667           83C4                   04  add	sp,*4
15379                                           ! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
15380 466A           30E4                       xor	ah,ah
15381 466C           B9                   0100  mov	cx,#$100
15382 466F           F7E9                       imul	cx
15383                                           ! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
15384                                           ! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
15385 4671           89EC                       mov	sp,bp
15386 4673           5D                         pop	bp
15387 4674           C3                         ret
15388                                           !BCC_EOS
15389                                           ! 2454 }
15390                                           ! 2455   void
15391                                           ! Register BX used in function cdrom_boot
15392                                           ! 2456 int14_function(regs, ds, iret_addr)
15393                                           ! 2457   pusha_regs_t regs;
15394                                           export	_int14_function
15395                       00004675            _int14_function:
15396                                           !BCC_EOS
15397                                           ! 2458   Bit16u ds;
15398                                           !BCC_EOS
15399                                           ! 2459   iret_addr_t iret_addr;
15400                                           !BCC_EOS
15401                                           ! 2460 {
15402                                           ! 2461   Bit16u addr,timer,val16;
15403                                           !BCC_EOS
15404                                           ! 2462   Bit8u timeout;
15405                                           !BCC_EOS
15406                                           ! 2463 #asm
15407 4675           55                         push	bp
15408 4676           89E5                       mov	bp,sp
15409 4678           83C4                   F8  add	sp,*-8
15410                                           !BCC_EOS
15411                                           !BCC_ASM
15412                       0000001C            _int14_function.ds	set	$1C
15413                       00000014            .int14_function.ds	set	$14
15414                       00000004            _int14_function.timer	set	4
15415                       FFFFFFFC            .int14_function.timer	set	-4
15416                       00000001            _int14_function.timeout	set	1
15417                       FFFFFFF9            .int14_function.timeout	set	-7
15418                       0000001E            _int14_function.iret_addr	set	$1E
15419                       00000016            .int14_function.iret_addr	set	$16
15420                       00000006            _int14_function.addr	set	6
15421                       FFFFFFFE            .int14_function.addr	set	-2
15422                       00000002            _int14_function.val16	set	2
15423                       FFFFFFFA            .int14_function.val16	set	-6
15424                       0000000C            _int14_function.regs	set	$C
15425                       00000004            .int14_function.regs	set	4
15426 467B           FB                           sti
15427                                           ! 2465 endasm
15428                                           !BCC_ENDASM
15429                                           !BCC_EOS
15430                                           ! 2466   addr = read_word(0x0040, (regs.u.r16.dx << 1));
15431                                           ! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
15432 467C           8B46         0E            mov	ax,$E[bp]
15433 467F           D1E0                       shl	ax,*1
15434                                           ! Debug: list unsigned int = ax+0 (used reg = )
15435 4681           50                         push	ax
15436                                           ! Debug: list int = const $40 (used reg = )
15437 4682           B8                   0040  mov	ax,*$40
15438 4685           50                         push	ax
15439                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15440 4686           E8         BF7E            call	_read_word
15441 4689           83C4                   04  add	sp,*4
15442                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
15443 468C           8946         FE            mov	-2[bp],ax
15444                                           !BCC_EOS
15445                                           ! 2467   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
15446                                           ! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
15447                                           ! Debug: expression subtree swapping
15448 468F           8B46         0E            mov	ax,$E[bp]
15449                                           ! Debug: list unsigned int = ax+$7C (used reg = )
15450 4692           05                   007C  add	ax,*$7C
15451 4695           50                         push	ax
15452                                           ! Debug: list int = const $40 (used reg = )
15453 4696           B8                   0040  mov	ax,*$40
15454 4699           50                         push	ax
15455                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
15456 469A           E8         BF57            call	_read_byte
15457 469D           83C4                   04  add	sp,*4
15458                                           ! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
15459 46A0           8846         F9            mov	-7[bp],al
15460                                           !BCC_EOS
15461                                           ! 2468   if ((
15462                                           ! 2468 regs.u.r16.dx < 4) && (addr > 0)) {
15463                                           ! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
15464 46A3           8B46         0E            mov	ax,$E[bp]
15465 46A6           3D                   0004  cmp	ax,*4
15466 46A9         0F83         022F            bhis	.335
15467                       000046AD            .337:
15468                                           ! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
15469 46AD           8B46         FE            mov	ax,-2[bp]
15470 46B0           85C0                       test	ax,ax
15471 46B2         0F84         0226            beq 	.335
15472                       000046B6            .336:
15473                                           ! 2469     switch (regs.u.r8.ah) {
15474 46B6           8A46         13            mov	al,$13[bp]
15475 46B9           E9         0206            br 	.33A
15476                                           ! 2470       case 0:
15477                                           ! 2471         outb(addr+3, inb(addr+3) | 0x80);
15478                       000046BC            .33B:
15479                                           ! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
15480 46BC           8B46         FE            mov	ax,-2[bp]
15481                                           ! Debug: list unsigned int = ax+3 (used reg = )
15482 46BF           05                   0003  add	ax,*3
15483 46C2           50                         push	ax
15484                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15485 46C3           E8         BE78            call	_inb
15486 46C6           44                         inc	sp
15487 46C7           44                         inc	sp
15488                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
15489 46C8           0C                     80  or	al,#$80
15490                                           ! Debug: list unsigned char = al+0 (used reg = )
15491 46CA           30E4                       xor	ah,ah
15492 46CC           50                         push	ax
15493                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15494 46CD           8B46         FE            mov	ax,-2[bp]
15495                                           ! Debug: list unsigned int = ax+3 (used reg = )
15496 46D0           05                   0003  add	ax,*3
15497 46D3           50                         push	ax
15498                                           ! Debug: func () void = outb+0 (used reg = )
15499 46D4           E8         BE7D            call	_outb
15500 46D7           83C4                   04  add	sp,*4
15501                                           !BCC_EOS
15502                                           ! 2472         if (regs.u.r8.al & 0xE0 == 0) {
15503                                           ! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
15504 46DA           8A46         12            mov	al,$12[bp]
15505 46DD           30C0                       xor	al,al
15506 46DF           84C0                       test	al,al
15507 46E1           74           1E            je  	.33C
15508                       000046E3            .33D:
15509                                           ! 2473           outb(addr, 0x17);
15510                                           ! Debug: list int = const $17 (used reg = )
15511 46E3           B8                   0017  mov	ax,*$17
15512 46E6           50                         push	ax
15513                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15514 46E7           FF76         FE            push	-2[bp]
15515                                           ! Debug: func () void = outb+0 (used reg = )
15516 46EA           E8         BE67            call	_outb
15517 46ED           83C4                   04  add	sp,*4
15518                                           !BCC_EOS
15519                                           ! 2474           outb(addr+1, 0x04);
15520                                           ! Debug: list int = const 4 (used reg = )
15521 46F0           B8                   0004  mov	ax,*4
15522 46F3           50                         push	ax
15523                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15524 46F4           8B46         FE            mov	ax,-2[bp]
15525                                           ! Debug: list unsigned int = ax+1 (used reg = )
15526 46F7           40                         inc	ax
15527 46F8           50                         push	ax
15528                                           ! Debug: func () void = outb+0 (used reg = )
15529 46F9           E8         BE58            call	_outb
15530 46FC           83C4                   04  add	sp,*4
15531                                           !BCC_EOS
15532                                           ! 2475         } else {
15533 46FF           EB           39            jmp .33E
15534                       00004701            .33C:
15535                                           ! 2476           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
15536                                           ! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
15537 4701           8A46         12            mov	al,$12[bp]
15538 4704           24                     E0  and	al,#$E0
15539                                           ! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
15540 4706           30E4                       xor	ah,ah
15541 4708           B1                     05  mov	cl,*5
15542 470A           D3E8                       shr	ax,cl
15543                                           ! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
15544 470C           89C3                       mov	bx,ax
15545 470E           B8                   0600  mov	ax,#$600
15546 4711           89D9                       mov	cx,bx
15547 4713           D3F8                       sar	ax,cl
15548                                           ! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15549 4715           8946         FA            mov	-6[bp],ax
15550                                           !BCC_EOS
15551                                           ! 2477           outb(addr, val16 & 0xFF);
15552                                           ! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
15553 4718           8A46         FA            mov	al,-6[bp]
15554                                           ! Debug: list unsigned char = al+0 (used reg = )
15555 471B           30E4                       xor	ah,ah
15556 471D           50                         push	ax
15557                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15558 471E           FF76         FE            push	-2[bp]
15559                                           ! Debug: func () void = outb+0 (used reg = )
15560 4721           E8         BE30            call	_outb
15561 4724           83C4                   04  add	sp,*4
15562                                           !BCC_EOS
15563                                           ! 2478           outb(addr+1, val16 >> 8);
15564                                           ! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
15565 4727           8B46         FA            mov	ax,-6[bp]
15566 472A           88E0                       mov	al,ah
15567 472C           30E4                       xor	ah,ah
15568                                           ! Debug: list unsigned int = ax+0 (used reg = )
15569 472E           50                         push	ax
15570                                           ! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
15571 472F           8B46         FE            mov	ax,-2[bp]
15572                                           ! Debug: list unsigned int = ax+1 (used reg = )
15573 4732           40                         inc	ax
15574 4733           50                         push	ax
15575                                           ! Debug: func () void = outb+0 (used reg = )
15576 4734           E8         BE1D            call	_outb
15577 4737           83C4                   04  add	sp,*4
15578                                           !BCC_EOS
15579                                           ! 2479         }
15580                                           ! 2480         outb(addr+3, regs.u.r8.al & 0x1F);
15581                       0000473A            .33E:
15582                                           ! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
15583 473A           8A46         12            mov	al,$12[bp]
15584 473D           24                     1F  and	al,*$1F
15585                                           ! Debug: list unsigned char = al+0 (used reg = )
15586 473F           30E4                       xor	ah,ah
15587 4741           50                         push	ax
15588                                           ! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
15589 4742           8B46         FE            mov	ax,-2[bp]
15590                                           ! Debug: list unsigned int = ax+3 (used reg = )
15591 4745           05                   0003  add	ax,*3
15592 4748           50                         push	ax
15593                                           ! Debug: func () void = outb+0 (used reg = )
15594 4749           E8         BE08            call	_outb
15595 474C           83C4                   04  add	sp,*4
15596                                           !BCC_EOS
15597                                           ! 2481         regs.u.r8.ah = inb(addr+5);
15598                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15599 474F           8B46         FE            mov	ax,-2[bp]
15600                                           ! Debug: list unsigned int = ax+5 (used reg = )
15601 4752           05                   0005  add	ax,*5
15602 4755           50                         push	ax
15603                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15604 4756           E8         BDE5            call	_inb
15605 4759           44                         inc	sp
15606 475A           44                         inc	sp
15607                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15608 475B           8846         13            mov	$13[bp],al
15609                                           !BCC_EOS
15610                                           ! 2482         regs.u.r8.al = inb(addr+6);
15611                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15612 475E           8B46         FE            mov	ax,-2[bp]
15613                                           ! Debug: list unsigned int = ax+6 (used reg = )
15614 4761           05                   0006  add	ax,*6
15615 4764           50                         push	ax
15616                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15617 4765           E8         BDD6            call	_inb
15618 4768           44                         inc	sp
15619 4769           44                         inc	sp
15620                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15621 476A           8846         12            mov	$12[bp],al
15622                                           !BCC_EOS
15623                                           ! 2483         iret_addr.flags.u.r8.flagsl &= 0xfe;
15624                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15625 476D           8A46         1A            mov	al,$1A[bp]
15626 4770           24                     FE  and	al,#$FE
15627 4772           8846         1A            mov	$1A[bp],al
15628                                           !BCC_EOS
15629                                           ! 2484         break;
15630 4775           E9         0162            br 	.338
15631                                           !BCC_EOS
15632                                           ! 2485       case 1:
15633                                           ! 2486         timer = read_word(0x0040, 0x006C);
15634                       00004778            .33F:
15635                                           ! Debug: list int = const $6C (used reg = )
15636 4778           B8                   006C  mov	ax,*$6C
15637 477B           50                         push	ax
15638                                           ! Debug: list int = const $40 (used reg = )
15639 477C           B8                   0040  mov	ax,*$40
15640 477F           50                         push	ax
15641                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15642 4780           E8         BE84            call	_read_word
15643 4783           83C4                   04  add	sp,*4
15644                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15645 4786           8946         FC            mov	-4[bp],ax
15646                                           !BCC_EOS
15647                                           ! 2487         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
15648 4789           EB           26            jmp .341
15649                       0000478B            .342:
15650                                           ! 2488           val16 = read_word(0x0040, 0x006C);
15651                                           ! Debug: list int = const $6C (used reg = )
15652 478B           B8                   006C  mov	ax,*$6C
15653 478E           50                         push	ax
15654                                           ! Debug: list int = const $40 (used reg = )
15655 478F           B8                   0040  mov	ax,*$40
15656 4792           50                         push	ax
15657                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15658 4793           E8         BE71            call	_read_word
15659 4796           83C4                   04  add	sp,*4
15660                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15661 4799           8946         FA            mov	-6[bp],ax
15662                                           !BCC_EOS
15663                                           ! 2489           if (val16 != timer) {
15664                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15665 479C           8B46         FA            mov	ax,-6[bp]
15666 479F           3B46         FC            cmp	ax,-4[bp]
15667 47A2           74           0D            je  	.343
15668                       000047A4            .344:
15669                                           ! 2490             timer = val16;
15670                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15671 47A4           8B46         FA            mov	ax,-6[bp]
15672 47A7           8946         FC            mov	-4[bp],ax
15673                                           !BCC_EOS
15674                                           ! 2491             timeout--;
15675                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
15676 47AA           8A46         F9            mov	al,-7[bp]
15677 47AD           48                         dec	ax
15678 47AE           8846         F9            mov	-7[bp],al
15679                                           !BCC_EOS
15680                                           ! 2492             }
15681                                           ! 2493           }
15682                       000047B1            .343:
15683                                           ! 2494         if (timeout) outb(addr, regs.u.r8.al);
15684                       000047B1            .341:
15685                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15686 47B1           8B46         FE            mov	ax,-2[bp]
15687                                           ! Debug: list unsigned int = ax+5 (used reg = )
15688 47B4           05                   0005  add	ax,*5
15689 47B7           50                         push	ax
15690                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15691 47B8           E8         BD83            call	_inb
15692 47BB           44                         inc	sp
15693 47BC           44                         inc	sp
15694                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
15695 47BD           24                     60  and	al,*$60
15696                                           ! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
15697 47BF           3C                     60  cmp	al,*$60
15698 47C1           74           07            je  	.345
15699                       000047C3            .346:
15700 47C3           8A46         F9            mov	al,-7[bp]
15701 47C6           84C0                       test	al,al
15702 47C8           75           C1            jne	.342
15703                       000047CA            .345:
15704                       000047CA            .340:
15705 47CA           8A46         F9            mov	al,-7[bp]
15706 47CD           84C0                       test	al,al
15707 47CF         0F84         000F            beq 	.347
15708                       000047D3            .348:
15709                                           ! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
15710 47D3           8A46         12            mov	al,$12[bp]
15711 47D6           30E4                       xor	ah,ah
15712 47D8           50                         push	ax
15713                                           ! Debug: list unsigned short addr = [S+$C-4] (used reg = )
15714 47D9           FF76         FE            push	-2[bp]
15715                                           ! Debug: func () void = outb+0 (used reg = )
15716 47DC           E8         BD75            call	_outb
15717 47DF           83C4                   04  add	sp,*4
15718                                           !BCC_EOS
15719                                           ! 2495         regs.u.r8.ah = inb(addr+5);
15720                       000047E2            .347:
15721                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15722 47E2           8B46         FE            mov	ax,-2[bp]
15723                                           ! Debug: list unsigned int = ax+5 (used reg = )
15724 47E5           05                   0005  add	ax,*5
15725 47E8           50                         push	ax
15726                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15727 47E9           E8         BD52            call	_inb
15728 47EC           44                         inc	sp
15729 47ED           44                         inc	sp
15730                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15731 47EE           8846         13            mov	$13[bp],al
15732                                           !BCC_EOS
15733                                           ! 2496         if (!timeout) regs.u.r8.ah |= 0x80;
15734 47F1           8A46         F9            mov	al,-7[bp]
15735 47F4           84C0                       test	al,al
15736 47F6           75           08            jne 	.349
15737                       000047F8            .34A:
15738                                           ! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
15739 47F8           8A46         13            mov	al,$13[bp]
15740 47FB           0C                     80  or	al,#$80
15741 47FD           8846         13            mov	$13[bp],al
15742                                           !BCC_EOS
15743                                           ! 2497         iret_addr.flags.u.r8.flagsl &= 0xfe;
15744                       00004800            .349:
15745                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15746 4800           8A46         1A            mov	al,$1A[bp]
15747 4803           24                     FE  and	al,#$FE
15748 4805           8846         1A            mov	$1A[bp],al
15749                                           !BCC_EOS
15750                                           ! 2498         break;
15751 4808           E9         00CF            br 	.338
15752                                           !BCC_EOS
15753                                           ! 2499       case 2:
15754                                           ! 2500         timer = read_word(0x0040, 0x006C);
15755                       0000480B            .34B:
15756                                           ! Debug: list int = const $6C (used reg = )
15757 480B           B8                   006C  mov	ax,*$6C
15758 480E           50                         push	ax
15759                                           ! Debug: list int = const $40 (used reg = )
15760 480F           B8                   0040  mov	ax,*$40
15761 4812           50                         push	ax
15762                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15763 4813           E8         BDF1            call	_read_word
15764 4816           83C4                   04  add	sp,*4
15765                                           ! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
15766 4819           8946         FC            mov	-4[bp],ax
15767                                           !BCC_EOS
15768                                           ! 2501         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
15769 481C           EB           26            jmp .34D
15770                       0000481E            .34E:
15771                                           ! 2502           val16 = read_word(0x0040, 0x006C);
15772                                           ! Debug: list int = const $6C (used reg = )
15773 481E           B8                   006C  mov	ax,*$6C
15774 4821           50                         push	ax
15775                                           ! Debug: list int = const $40 (used reg = )
15776 4822           B8                   0040  mov	ax,*$40
15777 4825           50                         push	ax
15778                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15779 4826           E8         BDDE            call	_read_word
15780 4829           83C4                   04  add	sp,*4
15781                                           ! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
15782 482C           8946         FA            mov	-6[bp],ax
15783                                           !BCC_EOS
15784                                           ! 2503           if (val16 != timer) {
15785                                           ! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
15786 482F           8B46         FA            mov	ax,-6[bp]
15787 4832           3B46         FC            cmp	ax,-4[bp]
15788 4835           74           0D            je  	.34F
15789                       00004837            .350:
15790                                           ! 2504             timer = val16;
15791                                           ! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
15792 4837           8B46         FA            mov	ax,-6[bp]
15793 483A           8946         FC            mov	-4[bp],ax
15794                                           !BCC_EOS
15795                                           ! 2505             timeout--;
15796                                           ! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
15797 483D           8A46         F9            mov	al,-7[bp]
15798 4840           48                         dec	ax
15799 4841           8846         F9            mov	-7[bp],al
15800                                           !BCC_EOS
15801                                           ! 2506             }
15802                                           ! 2507           }
15803                       00004844            .34F:
15804                                           ! 2508         if (timeout) {
15805                       00004844            .34D:
15806                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15807 4844           8B46         FE            mov	ax,-2[bp]
15808                                           ! Debug: list unsigned int = ax+5 (used reg = )
15809 4847           05                   0005  add	ax,*5
15810 484A           50                         push	ax
15811                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15812 484B           E8         BCF0            call	_inb
15813 484E           44                         inc	sp
15814 484F           44                         inc	sp
15815                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
15816 4850           24                     01  and	al,*1
15817                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
15818 4852           84C0                       test	al,al
15819 4854           75           07            jne 	.351
15820                       00004856            .352:
15821 4856           8A46         F9            mov	al,-7[bp]
15822 4859           84C0                       test	al,al
15823 485B           75           C1            jne	.34E
15824                       0000485D            .351:
15825                       0000485D            .34C:
15826 485D           8A46         F9            mov	al,-7[bp]
15827 4860           84C0                       test	al,al
15828 4862           74           12            je  	.353
15829                       00004864            .354:
15830                                           ! 2509           regs.u.r8.ah = 0;
15831                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
15832 4864           30C0                       xor	al,al
15833 4866           8846         13            mov	$13[bp],al
15834                                           !BCC_EOS
15835                                           ! 2510           regs.u.r8.al = inb(addr);
15836                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
15837 4869           FF76         FE            push	-2[bp]
15838                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15839 486C           E8         BCCF            call	_inb
15840 486F           44                         inc	sp
15841 4870           44                         inc	sp
15842                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15843 4871           8846         12            mov	$12[bp],al
15844                                           !BCC_EOS
15845                                           ! 2511         } else {
15846 4874           EB           0F            jmp .355
15847                       00004876            .353:
15848                                           ! 2512           regs.u.r8.ah = inb(addr+5);
15849                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15850 4876           8B46         FE            mov	ax,-2[bp]
15851                                           ! Debug: list unsigned int = ax+5 (used reg = )
15852 4879           05                   0005  add	ax,*5
15853 487C           50                         push	ax
15854                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15855 487D           E8         BCBE            call	_inb
15856 4880           44                         inc	sp
15857 4881           44                         inc	sp
15858                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15859 4882           8846         13            mov	$13[bp],al
15860                                           !BCC_EOS
15861                                           ! 2513           }
15862                                           ! 2514         iret_addr.flags.u.r8.flagsl &= 0xfe;
15863                       00004885            .355:
15864                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15865 4885           8A46         1A            mov	al,$1A[bp]
15866 4888           24                     FE  and	al,#$FE
15867 488A           8846         1A            mov	$1A[bp],al
15868                                           !BCC_EOS
15869                                           ! 2515         break;
15870 488D           E9         004A            br 	.338
15871                                           !BCC_EOS
15872                                           ! 2516       case 3:
15873                                           ! 2517         regs.u.r8.ah = inb(addr+5);
15874                       00004890            .356:
15875                                           ! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
15876 4890           8B46         FE            mov	ax,-2[bp]
15877                                           ! Debug: list unsigned int = ax+5 (used reg = )
15878 4893           05                   0005  add	ax,*5
15879 4896           50                         push	ax
15880                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15881 4897           E8         BCA4            call	_inb
15882 489A           44                         inc	sp
15883 489B           44                         inc	sp
15884                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
15885 489C           8846         13            mov	$13[bp],al
15886                                           !BCC_EOS
15887                                           ! 2518         regs.u.r8.al = inb(addr+6);
15888                                           ! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
15889 489F           8B46         FE            mov	ax,-2[bp]
15890                                           ! Debug: list unsigned int = ax+6 (used reg = )
15891 48A2           05                   0006  add	ax,*6
15892 48A5           50                         push	ax
15893                                           ! Debug: func () unsigned char = inb+0 (used reg = )
15894 48A6           E8         BC95            call	_inb
15895 48A9           44                         inc	sp
15896 48AA           44                         inc	sp
15897                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
15898 48AB           8846         12            mov	$12[bp],al
15899                                           !BCC_EOS
15900                                           ! 2519         iret_addr.flags.u.r8.flagsl &= 0xfe;
15901                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
15902 48AE           8A46         1A            mov	al,$1A[bp]
15903 48B1           24                     FE  and	al,#$FE
15904 48B3           8846         1A            mov	$1A[bp],al
15905                                           !BCC_EOS
15906                                           ! 2520         break;
15907 48B6           EB           22            jmp .338
15908                                           !BCC_EOS
15909                                           ! 2521       default:
15910                                           ! 2522         iret_addr.flags.u.r8.flagsl |= 0x01;
15911                       000048B8            .357:
15912                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15913 48B8           8A46         1A            mov	al,$1A[bp]
15914 48BB           0C                     01  or	al,*1
15915 48BD           8846         1A            mov	$1A[bp],al
15916                                           !BCC_EOS
15917                                           ! 2523       }
15918                                           ! 2524   } else {
15919 48C0           EB           18            jmp .338
15920                       000048C2            .33A:
15921 48C2           2C                     00  sub	al,*0
15922 48C4         0F84         FDF4            beq 	.33B
15923 48C8           2C                     01  sub	al,*1
15924 48CA         0F84         FEAA            beq 	.33F
15925 48CE           2C                     01  sub	al,*1
15926 48D0         0F84         FF37            beq 	.34B
15927 48D4           2C                     01  sub	al,*1
15928 48D6           74           B8            je 	.356
15929 48D8           EB           DE            jmp	.357
15930                       000048DA            .338:
15931                       FFFFFFF6            ..FFF8	=	-$A
15932 48DA           EB           08            jmp .358
15933                       000048DC            .335:
15934                                           ! 2525     iret_addr.flags.u.r8.flagsl |= 0x01;
15935                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
15936 48DC           8A46         1A            mov	al,$1A[bp]
15937 48DF           0C                     01  or	al,*1
15938 48E1           8846         1A            mov	$1A[bp],al
15939                                           !BCC_EOS
15940                                           ! 2526     }
15941                                           ! 2527 }
15942                       000048E4            .358:
15943 48E4           89EC                       mov	sp,bp
15944 48E6           5D                         pop	bp
15945 48E7           C3                         ret
15946                                           ! 2528   void
15947                                           ! Register BX used in function int14_function
15948                                           ! 2529 int15_function(regs, ES, DS, FLAGS)
15949                                           ! 2530   pusha_regs_t regs;
15950                                           export	_int15_function
15951                       000048E8            _int15_function:
15952                                           !BCC_EOS
15953                                           ! 2531   Bit16u ES, DS, FLAGS;
15954                                           !BCC_EOS
15955                                           ! 2532 {
15956                                           ! 2533   Bit16u ebda_seg=read_word(0x0040,0x000E);
15957 48E8           55                         push	bp
15958 48E9           89E5                       mov	bp,sp
15959 48EB           4C                         dec	sp
15960 48EC           4C                         dec	sp
15961                                           ! Debug: list int = const $E (used reg = )
15962 48ED           B8                   000E  mov	ax,*$E
15963 48F0           50                         push	ax
15964                                           ! Debug: list int = const $40 (used reg = )
15965 48F1           B8                   0040  mov	ax,*$40
15966 48F4           50                         push	ax
15967                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
15968 48F5           E8         BD0F            call	_read_word
15969 48F8           83C4                   04  add	sp,*4
15970                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
15971 48FB           8946         FE            mov	-2[bp],ax
15972                                           !BCC_EOS
15973                                           ! 2534   bx_bool prev_a20_enable;
15974                                           !BCC_EOS
15975                                           ! 2535   Bit16u base15_00;
15976                                           !BCC_EOS
15977                                           ! 2536   Bit8u base23_16;
15978                                           !BCC_EOS
15979                                           ! 2537   Bit16u ss;
15980                                           !BCC_EOS
15981                                           ! 2538   Bit16u CX,DX;
15982                                           !BCC_EOS
15983                                           ! 2539   Bit16u bRegister;
15984                                           !BCC_EOS
15985                                           ! 2540   Bit8u irqDisable;
15986                                           !BCC_EOS
15987                                           ! 2541 ;
15988 48FE           83C4                   F0  add	sp,*-$10
15989                                           !BCC_EOS
15990                                           ! 2542   switch (re
15991                                           ! 2542 gs.u.r8.ah) {
15992 4901           8A46         13            mov	al,$13[bp]
15993 4904           E9         0489            br 	.35B
15994                                           ! 2543     case 0x24:
15995                                           ! 2544       switch (regs.u.r8.al) {
15996                       00004907            .35C:
15997 4907           8A46         12            mov	al,$12[bp]
15998 490A           EB           74            jmp .35F
15999                                           ! 2545         case 0x00:
16000                                           ! 2546           set_enable_a20(0);
16001                       0000490C            .360:
16002                                           ! Debug: list int = const 0 (used reg = )
16003 490C           31C0                       xor	ax,ax
16004 490E           50                         push	ax
16005                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16006 490F           E8         CFC9            call	_set_enable_a20
16007 4912           44                         inc	sp
16008 4913           44                         inc	sp
16009                                           !BCC_EOS
16010                                           ! 2547           FLAGS &= 0xfffe;
16011                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16012 4914           8B46         18            mov	ax,$18[bp]
16013 4917           24                     FE  and	al,#$FE
16014 4919           8946         18            mov	$18[bp],ax
16015                                           !BCC_EOS
16016                                           ! 2548           regs.u.r8.ah = 0;
16017                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16018 491C           30C0                       xor	al,al
16019 491E           8846         13            mov	$13[bp],al
16020                                           !BCC_EOS
16021                                           ! 2549           break;
16022 4921           EB           6F            jmp .35D
16023                                           !BCC_EOS
16024                                           ! 2550         case 0x01:
16025                                           ! 2551           set_enable_a20(1);
16026                       00004923            .361:
16027                                           ! Debug: list int = const 1 (used reg = )
16028 4923           B8                   0001  mov	ax,*1
16029 4926           50                         push	ax
16030                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16031 4927           E8         CFB1            call	_set_enable_a20
16032 492A           44                         inc	sp
16033 492B           44                         inc	sp
16034                                           !BCC_EOS
16035                                           ! 2552           FLAGS &= 0xfffe;
16036                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16037 492C           8B46         18            mov	ax,$18[bp]
16038 492F           24                     FE  and	al,#$FE
16039 4931           8946         18            mov	$18[bp],ax
16040                                           !BCC_EOS
16041                                           ! 2553           regs.u.r8.ah = 0;
16042                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16043 4934           30C0                       xor	al,al
16044 4936           8846         13            mov	$13[bp],al
16045                                           !BCC_EOS
16046                                           ! 2554           break;
16047 4939           EB           57            jmp .35D
16048                                           !BCC_EOS
16049                                           ! 2555         case 0x02:
16050                                           ! 2556           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
16051                       0000493B            .362:
16052                                           ! Debug: list int = const $92 (used reg = )
16053 493B           B8                   0092  mov	ax,#$92
16054 493E           50                         push	ax
16055                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16056 493F           E8         BBFC            call	_inb
16057 4942           44                         inc	sp
16058 4943           44                         inc	sp
16059                                           ! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
16060 4944           30E4                       xor	ah,ah
16061 4946           D1E8                       shr	ax,*1
16062                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
16063 4948           24                     01  and	al,*1
16064                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
16065 494A           8846         12            mov	$12[bp],al
16066                                           !BCC_EOS
16067                                           ! 2557           FLAGS &= 0xfffe;
16068                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16069 494D           8B46         18            mov	ax,$18[bp]
16070 4950           24                     FE  and	al,#$FE
16071 4952           8946         18            mov	$18[bp],ax
16072                                           !BCC_EOS
16073                                           ! 2558           regs.u.r8.ah = 0;
16074                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16075 4955           30C0                       xor	al,al
16076 4957           8846         13            mov	$13[bp],al
16077                                           !BCC_EOS
16078                                           ! 2559           break;
16079 495A           EB           36            jmp .35D
16080                                           !BCC_EOS
16081                                           ! 2560         case 0x03:
16082                                           ! 2561           FLAGS &= 0xfffe;
16083                       0000495C            .363:
16084                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16085 495C           8B46         18            mov	ax,$18[bp]
16086 495F           24                     FE  and	al,#$FE
16087 4961           8946         18            mov	$18[bp],ax
16088                                           !BCC_EOS
16089                                           ! 2562           regs.u.r8.ah = 0;
16090                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16091 4964           30C0                       xor	al,al
16092 4966           8846         13            mov	$13[bp],al
16093                                           !BCC_EOS
16094                                           ! 2563           regs.u.r16.bx = 3;
16095                                           ! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
16096 4969           B8                   0003  mov	ax,*3
16097 496C           8946         0C            mov	$C[bp],ax
16098                                           !BCC_EOS
16099                                           ! 2564           break;
16100 496F           EB           21            jmp .35D
16101                                           !BCC_EOS
16102                                           ! 2565         default:
16103                                           ! 2566           ;
16104                       00004971            .364:
16105                                           !BCC_EOS
16106                                           ! 2567           FLAGS |= 0x0001;
16107                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16108 4971           8B46         18            mov	ax,$18[bp]
16109 4974           0C                     01  or	al,*1
16110 4976           8946         18            mov	$18[bp],ax
16111                                           !BCC_EOS
16112                                           ! 2568           regs.u.r8.ah = 0x86;
16113                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16114 4979           B0                     86  mov	al,#$86
16115 497B           8846         13            mov	$13[bp],al
16116                                           !BCC_EOS
16117                                           ! 2569       }
16118                                           ! 2570       break;
16119 497E           EB           12            jmp .35D
16120                       00004980            .35F:
16121 4980           2C                     00  sub	al,*0
16122 4982           74           88            je 	.360
16123 4984           2C                     01  sub	al,*1
16124 4986           74           9B            je 	.361
16125 4988           2C                     01  sub	al,*1
16126 498A           74           AF            je 	.362
16127 498C           2C                     01  sub	al,*1
16128 498E           74           CC            je 	.363
16129 4990           EB           DF            jmp	.364
16130                       00004992            .35D:
16131 4992           E9         044B            br 	.359
16132                                           !BCC_EOS
16133                                           ! 2571     case 0x41:
16134                                           ! 2572       FLAGS |= 0x0001;
16135                       00004995            .365:
16136                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16137 4995           8B46         18            mov	ax,$18[bp]
16138 4998           0C                     01  or	al,*1
16139 499A           8946         18            mov	$18[bp],ax
16140                                           !BCC_EOS
16141                                           ! 2573       regs.u.r8.ah = 0x86;
16142                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16143 499D           B0                     86  mov	al,#$86
16144 499F           8846         13            mov	$13[bp],al
16145                                           !BCC_EOS
16146                                           ! 2574       break;
16147 49A2           E9         043B            br 	.359
16148                                           !BCC_EOS
16149                                           ! 2575     case 0x4f:
16150                                           ! 2576       FLAGS |= 0x0001;
16151                       000049A5            .366:
16152                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16153 49A5           8B46         18            mov	ax,$18[bp]
16154 49A8           0C                     01  or	al,*1
16155 49AA           8946         18            mov	$18[bp],ax
16156                                           !BCC_EOS
16157                                           ! 2577       break;
16158 49AD           E9         0430            br 	.359
16159                                           !BCC_EOS
16160                                           ! 2578     case 0x52:
16161                                           ! 2579       FLAGS &= 0xfffe;
16162                       000049B0            .367:
16163                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16164 49B0           8B46         18            mov	ax,$18[bp]
16165 49B3           24                     FE  and	al,#$FE
16166 49B5           8946         18            mov	$18[bp],ax
16167                                           !BCC_EOS
16168                                           ! 2580       regs.u.r8.ah = 0;
16169                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16170 49B8           30C0                       xor	al,al
16171 49BA           8846         13            mov	$13[bp],al
16172                                           !BCC_EOS
16173                                           ! 2581       break;
16174 49BD           E9         0420            br 	.359
16175                                           !BCC_EOS
16176                                           ! 2582     case 0x83: {
16177                       000049C0            .368:
16178                                           ! 2583       if( regs.u.r8.al == 0 ) {
16179                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
16180 49C0           8A46         12            mov	al,$12[bp]
16181 49C3           84C0                       test	al,al
16182 49C5         0F85         00C1            bne 	.369
16183                       000049C9            .36A:
16184                                           ! 2584         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
16185                                           ! Debug: list int = const $A0 (used reg = )
16186 49C9           B8                   00A0  mov	ax,#$A0
16187 49CC           50                         push	ax
16188                                           ! Debug: list int = const $40 (used reg = )
16189 49CD           B8                   0040  mov	ax,*$40
16190 49D0           50                         push	ax
16191                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
16192 49D1           E8         BC20            call	_read_byte
16193 49D4           83C4                   04  add	sp,*4
16194                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
16195 49D7           24                     01  and	al,*1
16196                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
16197 49D9           84C0                       test	al,al
16198 49DB         0F85         009C            bne 	.36B
16199                       000049DF            .36C:
16200                                           ! 2585           write_byte( 0x40, 0xA0, 1 );
16201                                           ! Debug: list int = const 1 (used reg = )
16202 49DF           B8                   0001  mov	ax,*1
16203 49E2           50                         push	ax
16204                                           ! Debug: list int = const $A0 (used reg = )
16205 49E3           B8                   00A0  mov	ax,#$A0
16206 49E6           50                         push	ax
16207                                           ! Debug: list int = const $40 (used reg = )
16208 49E7           B8                   0040  mov	ax,*$40
16209 49EA           50                         push	ax
16210                                           ! Debug: func () void = write_byte+0 (used reg = )
16211 49EB           E8         BC2C            call	_write_byte
16212 49EE           83C4                   06  add	sp,*6
16213                                           !BCC_EOS
16214                                           ! 2586           write_word( 0x40, 0x98, ES );
16215                                           ! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
16216 49F1           FF76         14            push	$14[bp]
16217                                           ! Debug: list int = const $98 (used reg = )
16218 49F4           B8                   0098  mov	ax,#$98
16219 49F7           50                         push	ax
16220                                           ! Debug: list int = const $40 (used reg = )
16221 49F8           B8                   0040  mov	ax,*$40
16222 49FB           50                         push	ax
16223                                           ! Debug: func () void = write_word+0 (used reg = )
16224 49FC           E8         BC33            call	_write_word
16225 49FF           83C4                   06  add	sp,*6
16226                                           !BCC_EOS
16227                                           ! 2587           write_word( 0x40, 0x9A, regs.u.r16.bx );
16228                                           ! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
16229 4A02           FF76         0C            push	$C[bp]
16230                                           ! Debug: list int = const $9A (used reg = )
16231 4A05           B8                   009A  mov	ax,#$9A
16232 4A08           50                         push	ax
16233                                           ! Debug: list int = const $40 (used reg = )
16234 4A09           B8                   0040  mov	ax,*$40
16235 4A0C           50                         push	ax
16236                                           ! Debug: func () void = write_word+0 (used reg = )
16237 4A0D           E8         BC22            call	_write_word
16238 4A10           83C4                   06  add	sp,*6
16239                                           !BCC_EOS
16240                                           ! 2588           write_word( 0x40, 0x9C, regs.u.r16.dx );
16241                                           ! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
16242 4A13           FF76         0E            push	$E[bp]
16243                                           ! Debug: list int = const $9C (used reg = )
16244 4A16           B8                   009C  mov	ax,#$9C
16245 4A19           50                         push	ax
16246                                           ! Debug: list int = const $40 (used reg = )
16247 4A1A           B8                   0040  mov	ax,*$40
16248 4A1D           50                         push	ax
16249                                           ! Debug: func () void = write_word+0 (used reg = )
16250 4A1E           E8         BC11            call	_write_word
16251 4A21           83C4                   06  add	sp,*6
16252                                           !BCC_EOS
16253                                           ! 2589           write_word( 0x40, 0x9E, regs.u.r16.cx );
16254                                           ! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
16255 4A24           FF76         10            push	$10[bp]
16256                                           ! Debug: list int = const $9E (used reg = )
16257 4A27           B8                   009E  mov	ax,#$9E
16258 4A2A           50                         push	ax
16259                                           ! Debug: list int = const $40 (used reg = )
16260 4A2B           B8                   0040  mov	ax,*$40
16261 4A2E           50                         push	ax
16262                                           ! Debug: func () void = write_word+0 (used reg = )
16263 4A2F           E8         BC00            call	_write_word
16264 4A32           83C4                   06  add	sp,*6
16265                                           !BCC_EOS
16266                                           ! 2590           FLAGS &= 0xfffe;
16267                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16268 4A35           8B46         18            mov	ax,$18[bp]
16269 4A38           24                     FE  and	al,#$FE
16270 4A3A           8946         18            mov	$18[bp],ax
16271                                           !BCC_EOS
16272                                           ! 2591           irqDisable = inb( 0xA1 );
16273                                           ! Debug: list int = const $A1 (used reg = )
16274 4A3D           B8                   00A1  mov	ax,#$A1
16275 4A40           50                         push	ax
16276                                           ! Debug: func () unsigned char = inb+0 (used reg = )
16277 4A41           E8         BAFA            call	_inb
16278 4A44           44                         inc	sp
16279 4A45           44                         inc	sp
16280                                           ! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
16281 4A46           8846         EF            mov	-$11[bp],al
16282                                           !BCC_EOS
16283                                           ! 2592           outb( 0xA1, irqDisable & 0xFE );
16284                                           ! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
16285 4A49           8A46         EF            mov	al,-$11[bp]
16286 4A4C           24                     FE  and	al,#$FE
16287                                           ! Debug: list unsigned char = al+0 (used reg = )
16288 4A4E           30E4                       xor	ah,ah
16289 4A50           50                         push	ax
16290                                           ! Debug: list int = const $A1 (used reg = )
16291 4A51           B8                   00A1  mov	ax,#$A1
16292 4A54           50                         push	ax
16293                                           ! Debug: func () void = outb+0 (used reg = )
16294 4A55           E8         BAFC            call	_outb
16295 4A58           83C4                   04  add	sp,*4
16296                                           !BCC_EOS
16297                                           ! 2593           bRegister = inb_cmos( 0xB );
16298                                           ! Debug: list int = const $B (used reg = )
16299 4A5B           B8                   000B  mov	ax,*$B
16300 4A5E           50                         push	ax
16301                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16302 4A5F           E8         BB21            call	_inb_cmos
16303 4A62           44                         inc	sp
16304 4A63           44                         inc	sp
16305                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16306 4A64           30E4                       xor	ah,ah
16307 4A66           8946         F0            mov	-$10[bp],ax
16308                                           !BCC_EOS
16309                                           ! 2594           outb_cmos( 0xB, bRegister | 0x40 );
16310                                           ! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
16311 4A69           8B46         F0            mov	ax,-$10[bp]
16312 4A6C           0C                     40  or	al,*$40
16313                                           ! Debug: list unsigned int = ax+0 (used reg = )
16314 4A6E           50                         push	ax
16315                                           ! Debug: list int = const $B (used reg = )
16316 4A6F           B8                   000B  mov	ax,*$B
16317 4A72           50                         push	ax
16318                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16319 4A73           E8         BAFE            call	_outb_cmos
16320 4A76           83C4                   04  add	sp,*4
16321                                           !BCC_EOS
16322                                           ! 2595         } else {
16323 4A79           EB           0D            jmp .36D
16324                       00004A7B            .36B:
16325                                           ! 2596           ;
16326                                           !BCC_EOS
16327                                           ! 2597           FLAGS |= 0x0001;
16328                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16329 4A7B           8B46         18            mov	ax,$18[bp]
16330 4A7E           0C                     01  or	al,*1
16331 4A80           8946         18            mov	$18[bp],ax
16332                                           !BCC_EOS
16333                                           ! 2598           regs.u.r8.ah = 0x86;
16334                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16335 4A83           B0                     86  mov	al,#$86
16336 4A85           8846         13            mov	$13[bp],al
16337                                           !BCC_EOS
16338                                           ! 2599         }
16339                                           ! 2600       } else if( regs.u.r8.al == 1 ) {
16340                       00004A88            .36D:
16341 4A88           EB           54            jmp .36E
16342                       00004A8A            .369:
16343                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
16344 4A8A           8A46         12            mov	al,$12[bp]
16345 4A8D           3C                     01  cmp	al,*1
16346 4A8F           75           39            jne 	.36F
16347                       00004A91            .370:
16348                                           ! 2601         write_byte( 0x40, 0xA0, 0 );
16349                                           ! Debug: list int = const 0 (used reg = )
16350 4A91           31C0                       xor	ax,ax
16351 4A93           50                         push	ax
16352                                           ! Debug: list int = const $A0 (used reg = )
16353 4A94           B8                   00A0  mov	ax,#$A0
16354 4A97           50                         push	ax
16355                                           ! Debug: list int = const $40 (used reg = )
16356 4A98           B8                   0040  mov	ax,*$40
16357 4A9B           50                         push	ax
16358                                           ! Debug: func () void = write_byte+0 (used reg = )
16359 4A9C           E8         BB7B            call	_write_byte
16360 4A9F           83C4                   06  add	sp,*6
16361                                           !BCC_EOS
16362                                           ! 2602         FLAGS &= 0xfffe;
16363                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16364 4AA2           8B46         18            mov	ax,$18[bp]
16365 4AA5           24                     FE  and	al,#$FE
16366 4AA7           8946         18            mov	$18[bp],ax
16367                                           !BCC_EOS
16368                                           ! 2603         bRegister = inb_cmos( 0xB );
16369                                           ! Debug: list int = const $B (used reg = )
16370 4AAA           B8                   000B  mov	ax,*$B
16371 4AAD           50                         push	ax
16372                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16373 4AAE           E8         BAD2            call	_inb_cmos
16374 4AB1           44                         inc	sp
16375 4AB2           44                         inc	sp
16376                                           ! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
16377 4AB3           30E4                       xor	ah,ah
16378 4AB5           8946         F0            mov	-$10[bp],ax
16379                                           !BCC_EOS
16380                                           ! 2604         outb_cmos( 0xB, bRegister & ~0x40 );
16381                                           ! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
16382 4AB8           8B46         F0            mov	ax,-$10[bp]
16383 4ABB           24                     BF  and	al,#$BF
16384                                           ! Debug: list unsigned int = ax+0 (used reg = )
16385 4ABD           50                         push	ax
16386                                           ! Debug: list int = const $B (used reg = )
16387 4ABE           B8                   000B  mov	ax,*$B
16388 4AC1           50                         push	ax
16389                                           ! Debug: func () void = outb_cmos+0 (used reg = )
16390 4AC2           E8         BAAF            call	_outb_cmos
16391 4AC5           83C4                   04  add	sp,*4
16392                                           !BCC_EOS
16393                                           ! 2605       } else {
16394 4AC8           EB           14            jmp .371
16395                       00004ACA            .36F:
16396                                           ! 2606         ;
16397                                           !BCC_EOS
16398                                           ! 2607         FLAGS |= 0x0001;
16399                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16400 4ACA           8B46         18            mov	ax,$18[bp]
16401 4ACD           0C                     01  or	al,*1
16402 4ACF           8946         18            mov	$18[bp],ax
16403                                           !BCC_EOS
16404                                           ! 2608         regs.u.r8.ah = 0x86;
16405                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16406 4AD2           B0                     86  mov	al,#$86
16407 4AD4           8846         13            mov	$13[bp],al
16408                                           !BCC_EOS
16409                                           ! 2609         regs.u.r8.al--;
16410                                           ! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
16411 4AD7           8A46         12            mov	al,$12[bp]
16412 4ADA           48                         dec	ax
16413 4ADB           8846         12            mov	$12[bp],al
16414                                           !BCC_EOS
16415                                           ! 2610       }
16416                                           ! 2611       break;
16417                       00004ADE            .371:
16418                       00004ADE            .36E:
16419 4ADE           E9         02FF            br 	.359
16420                                           !BCC_EOS
16421                                           ! 2612     }
16422                                           ! 2613     case 0x87:
16423                                           ! 2614 #asm
16424                       00004AE1            .372:
16425                                           !BCC_EOS
16426                                           !BCC_ASM
16427                       00000006            _int15_function.CX	set	6
16428                       FFFFFFF4            .int15_function.CX	set	-$C
16429                       0000002A            _int15_function.FLAGS	set	$2A
16430                       00000018            .int15_function.FLAGS	set	$18
16431                       00000001            _int15_function.irqDisable	set	1
16432                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16433                       00000028            _int15_function.DS	set	$28
16434                       00000016            .int15_function.DS	set	$16
16435                       00000004            _int15_function.DX	set	4
16436                       FFFFFFF2            .int15_function.DX	set	-$E
16437                       0000000B            _int15_function.base23_16	set	$B
16438                       FFFFFFF9            .int15_function.base23_16	set	-7
16439                       00000002            _int15_function.bRegister	set	2
16440                       FFFFFFF0            .int15_function.bRegister	set	-$10
16441                       00000026            _int15_function.ES	set	$26
16442                       00000014            .int15_function.ES	set	$14
16443                       00000010            _int15_function.ebda_seg	set	$10
16444                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16445                       0000000C            _int15_function.base15_00	set	$C
16446                       FFFFFFFA            .int15_function.base15_00	set	-6
16447                       00000008            _int15_function.ss	set	8
16448                       FFFFFFF6            .int15_function.ss	set	-$A
16449                       00000016            _int15_function.regs	set	$16
16450                       00000004            .int15_function.regs	set	4
16451                       0000000E            _int15_function.prev_a20_enable	set	$E
16452                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16453 4AE1           FA                           cli
16454                                           ! 2616 endasm
16455                                           !BCC_ENDASM
16456                                           !BCC_EOS
16457                                           ! 2617       prev_a20_enable = set_enable_a20(1);
16458                                           ! Debug: list int = const 1 (used reg = )
16459 4AE2           B8                   0001  mov	ax,*1
16460 4AE5           50                         push	ax
16461                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16462 4AE6           E8         CDF2            call	_set_enable_a20
16463 4AE9           44                         inc	sp
16464 4AEA           44                         inc	sp
16465                                           ! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
16466 4AEB           8946         FC            mov	-4[bp],ax
16467                                           !BCC_EOS
16468                                           ! 2618       base15_00 = (ES << 4) + regs.u.r16.si;
16469                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16470 4AEE           8B46         14            mov	ax,$14[bp]
16471 4AF1           B1                     04  mov	cl,*4
16472 4AF3           D3E0                       shl	ax,cl
16473                                           ! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
16474 4AF5           0346         06            add	ax,6[bp]
16475                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16476 4AF8           8946         FA            mov	-6[bp],ax
16477                                           !BCC_EOS
16478                                           ! 2619       base23_16 = ES >> 12;
16479                                           ! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
16480 4AFB           8B46         14            mov	ax,$14[bp]
16481 4AFE           88E0                       mov	al,ah
16482 4B00           30E4                       xor	ah,ah
16483 4B02           B1                     04  mov	cl,*4
16484 4B04           D3E8                       shr	ax,cl
16485                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16486 4B06           8846         F9            mov	-7[bp],al
16487                                           !BCC_EOS
16488                                           ! 2620       if (base15_00 < (ES<<4))
16489                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
16490 4B09           8B46         14            mov	ax,$14[bp]
16491 4B0C           B1                     04  mov	cl,*4
16492 4B0E           D3E0                       shl	ax,cl
16493                                           ! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16494 4B10           3B46         FA            cmp	ax,-6[bp]
16495 4B13           76           07            jbe 	.373
16496                       00004B15            .374:
16497                                           ! 2621         base23_16++;
16498                                           ! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
16499 4B15           8A46         F9            mov	al,-7[bp]
16500 4B18           40                         inc	ax
16501 4B19           8846         F9            mov	-7[bp],al
16502                                           !BCC_EOS
16503                                           ! 2622       write_word(ES, regs.u.r16.si+0x08
16504                       00004B1C            .373:
16505                                           ! 2622 +0, 47);
16506                                           ! Debug: list int = const $2F (used reg = )
16507 4B1C           B8                   002F  mov	ax,*$2F
16508 4B1F           50                         push	ax
16509                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16510 4B20           8B46         06            mov	ax,6[bp]
16511                                           ! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
16512                                           ! Debug: list unsigned int = ax+8 (used reg = )
16513 4B23           05                   0008  add	ax,*8
16514 4B26           50                         push	ax
16515                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16516 4B27           FF76         14            push	$14[bp]
16517                                           ! Debug: func () void = write_word+0 (used reg = )
16518 4B2A           E8         BB05            call	_write_word
16519 4B2D           83C4                   06  add	sp,*6
16520                                           !BCC_EOS
16521                                           ! 2623       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
16522                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16523 4B30           FF76         FA            push	-6[bp]
16524                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16525 4B33           8B46         06            mov	ax,6[bp]
16526                                           ! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
16527                                           ! Debug: list unsigned int = ax+$A (used reg = )
16528 4B36           05                   000A  add	ax,*$A
16529 4B39           50                         push	ax
16530                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16531 4B3A           FF76         14            push	$14[bp]
16532                                           ! Debug: func () void = write_word+0 (used reg = )
16533 4B3D           E8         BAF2            call	_write_word
16534 4B40           83C4                   06  add	sp,*6
16535                                           !BCC_EOS
16536                                           ! 2624       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
16537                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16538 4B43           8A46         F9            mov	al,-7[bp]
16539 4B46           30E4                       xor	ah,ah
16540 4B48           50                         push	ax
16541                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16542 4B49           8B46         06            mov	ax,6[bp]
16543                                           ! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
16544                                           ! Debug: list unsigned int = ax+$C (used reg = )
16545 4B4C           05                   000C  add	ax,*$C
16546 4B4F           50                         push	ax
16547                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16548 4B50           FF76         14            push	$14[bp]
16549                                           ! Debug: func () void = write_byte+0 (used reg = )
16550 4B53           E8         BAC4            call	_write_byte
16551 4B56           83C4                   06  add	sp,*6
16552                                           !BCC_EOS
16553                                           ! 2625       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
16554                                           ! Debug: list int = const $93 (used reg = )
16555 4B59           B8                   0093  mov	ax,#$93
16556 4B5C           50                         push	ax
16557                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16558 4B5D           8B46         06            mov	ax,6[bp]
16559                                           ! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
16560                                           ! Debug: list unsigned int = ax+$D (used reg = )
16561 4B60           05                   000D  add	ax,*$D
16562 4B63           50                         push	ax
16563                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16564 4B64           FF76         14            push	$14[bp]
16565                                           ! Debug: func () void = write_byte+0 (used reg = )
16566 4B67           E8         BAB0            call	_write_byte
16567 4B6A           83C4                   06  add	sp,*6
16568                                           !BCC_EOS
16569                                           ! 2626       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
16570                                           ! Debug: list int = const 0 (used reg = )
16571 4B6D           31C0                       xor	ax,ax
16572 4B6F           50                         push	ax
16573                                           ! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
16574 4B70           8B46         06            mov	ax,6[bp]
16575                                           ! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
16576                                           ! Debug: list unsigned int = ax+$E (used reg = )
16577 4B73           05                   000E  add	ax,*$E
16578 4B76           50                         push	ax
16579                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16580 4B77           FF76         14            push	$14[bp]
16581                                           ! Debug: func () void = write_word+0 (used reg = )
16582 4B7A           E8         BAB5            call	_write_word
16583 4B7D           83C4                   06  add	sp,*6
16584                                           !BCC_EOS
16585                                           ! 2627       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
16586                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16587 4B80           B8                   FFFF  mov	ax,#$FFFF
16588 4B83           50                         push	ax
16589                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16590 4B84           8B46         06            mov	ax,6[bp]
16591                                           ! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
16592                                           ! Debug: list unsigned int = ax+$20 (used reg = )
16593 4B87           05                   0020  add	ax,*$20
16594 4B8A           50                         push	ax
16595                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16596 4B8B           FF76         14            push	$14[bp]
16597                                           ! Debug: func () void = write_word+0 (used reg = )
16598 4B8E           E8         BAA1            call	_write_word
16599 4B91           83C4                   06  add	sp,*6
16600                                           !BCC_EOS
16601                                           ! 2628       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
16602                                           ! Debug: list int = const 0 (used reg = )
16603 4B94           31C0                       xor	ax,ax
16604 4B96           50                         push	ax
16605                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16606 4B97           8B46         06            mov	ax,6[bp]
16607                                           ! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
16608                                           ! Debug: list unsigned int = ax+$22 (used reg = )
16609 4B9A           05                   0022  add	ax,*$22
16610 4B9D           50                         push	ax
16611                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16612 4B9E           FF76         14            push	$14[bp]
16613                                           ! Debug: func () void = write_word+0 (used reg = )
16614 4BA1           E8         BA8E            call	_write_word
16615 4BA4           83C4                   06  add	sp,*6
16616                                           !BCC_EOS
16617                                           ! 2629       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
16618                                           ! Debug: list int = const $F (used reg = )
16619 4BA7           B8                   000F  mov	ax,*$F
16620 4BAA           50                         push	ax
16621                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16622 4BAB           8B46         06            mov	ax,6[bp]
16623                                           ! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
16624                                           ! Debug: list unsigned int = ax+$24 (used reg = )
16625 4BAE           05                   0024  add	ax,*$24
16626 4BB1           50                         push	ax
16627                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16628 4BB2           FF76         14            push	$14[bp]
16629                                           ! Debug: func () void = write_byte+0 (used reg = )
16630 4BB5           E8         BA62            call	_write_byte
16631 4BB8           83C4                   06  add	sp,*6
16632                                           !BCC_EOS
16633                                           ! 2630       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
16634                                           ! Debug: list int = const $9B (used reg = )
16635 4BBB           B8                   009B  mov	ax,#$9B
16636 4BBE           50                         push	ax
16637                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16638 4BBF           8B46         06            mov	ax,6[bp]
16639                                           ! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
16640                                           ! Debug: list unsigned int = ax+$25 (used reg = )
16641 4BC2           05                   0025  add	ax,*$25
16642 4BC5           50                         push	ax
16643                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16644 4BC6           FF76         14            push	$14[bp]
16645                                           ! Debug: func () void = write_byte+0 (used reg = )
16646 4BC9           E8         BA4E            call	_write_byte
16647 4BCC           83C4                   06  add	sp,*6
16648                                           !BCC_EOS
16649                                           ! 2631       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
16650                                           ! Debug: list int = const 0 (used reg = )
16651 4BCF           31C0                       xor	ax,ax
16652 4BD1           50                         push	ax
16653                                           ! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
16654 4BD2           8B46         06            mov	ax,6[bp]
16655                                           ! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
16656                                           ! Debug: list unsigned int = ax+$26 (used reg = )
16657 4BD5           05                   0026  add	ax,*$26
16658 4BD8           50                         push	ax
16659                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16660 4BD9           FF76         14            push	$14[bp]
16661                                           ! Debug: func () void = write_word+0 (used reg = )
16662 4BDC           E8         BA53            call	_write_word
16663 4BDF           83C4                   06  add	sp,*6
16664                                           !BCC_EOS
16665                                           ! 2632       ss = get_SS();
16666                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
16667 4BE2           E8         BA68            call	_get_SS
16668                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
16669 4BE5           8946         F6            mov	-$A[bp],ax
16670                                           !BCC_EOS
16671                                           ! 2633       base15_00 = ss << 4;
16672                                           ! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
16673 4BE8           8B46         F6            mov	ax,-$A[bp]
16674 4BEB           B1                     04  mov	cl,*4
16675 4BED           D3E0                       shl	ax,cl
16676                                           ! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
16677 4BEF           8946         FA            mov	-6[bp],ax
16678                                           !BCC_EOS
16679                                           ! 2634       base23_16 = ss >> 12;
16680                                           ! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
16681 4BF2           8B46         F6            mov	ax,-$A[bp]
16682 4BF5           88E0                       mov	al,ah
16683 4BF7           30E4                       xor	ah,ah
16684 4BF9           B1                     04  mov	cl,*4
16685 4BFB           D3E8                       shr	ax,cl
16686                                           ! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
16687 4BFD           8846         F9            mov	-7[bp],al
16688                                           !BCC_EOS
16689                                           ! 2635       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
16690                                           ! Debug: list unsigned int = const $FFFF (used reg = )
16691 4C00           B8                   FFFF  mov	ax,#$FFFF
16692 4C03           50                         push	ax
16693                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16694 4C04           8B46         06            mov	ax,6[bp]
16695                                           ! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
16696                                           ! Debug: list unsigned int = ax+$28 (used reg = )
16697 4C07           05                   0028  add	ax,*$28
16698 4C0A           50                         push	ax
16699                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16700 4C0B           FF76         14            push	$14[bp]
16701                                           ! Debug: func () void = write_word+0 (used reg = )
16702 4C0E           E8         BA21            call	_write_word
16703 4C11           83C4                   06  add	sp,*6
16704                                           !BCC_EOS
16705                                           ! 2636       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
16706                                           ! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
16707 4C14           FF76         FA            push	-6[bp]
16708                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16709 4C17           8B46         06            mov	ax,6[bp]
16710                                           ! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
16711                                           ! Debug: list unsigned int = ax+$2A (used reg = )
16712 4C1A           05                   002A  add	ax,*$2A
16713 4C1D           50                         push	ax
16714                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16715 4C1E           FF76         14            push	$14[bp]
16716                                           ! Debug: func () void = write_word+0 (used reg = )
16717 4C21           E8         BA0E            call	_write_word
16718 4C24           83C4                   06  add	sp,*6
16719                                           !BCC_EOS
16720                                           ! 2637       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
16721                                           ! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
16722 4C27           8A46         F9            mov	al,-7[bp]
16723 4C2A           30E4                       xor	ah,ah
16724 4C2C           50                         push	ax
16725                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16726 4C2D           8B46         06            mov	ax,6[bp]
16727                                           ! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
16728                                           ! Debug: list unsigned int = ax+$2C (used reg = )
16729 4C30           05                   002C  add	ax,*$2C
16730 4C33           50                         push	ax
16731                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16732 4C34           FF76         14            push	$14[bp]
16733                                           ! Debug: func () void = write_byte+0 (used reg = )
16734 4C37           E8         B9E0            call	_write_byte
16735 4C3A           83C4                   06  add	sp,*6
16736                                           !BCC_EOS
16737                                           ! 2638       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
16738                                           ! Debug: list int = const $93 (used reg = )
16739 4C3D           B8                   0093  mov	ax,#$93
16740 4C40           50                         push	ax
16741                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16742 4C41           8B46         06            mov	ax,6[bp]
16743                                           ! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
16744                                           ! Debug: list unsigned int = ax+$2D (used reg = )
16745 4C44           05                   002D  add	ax,*$2D
16746 4C47           50                         push	ax
16747                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16748 4C48           FF76         14            push	$14[bp]
16749                                           ! Debug: func () void = write_byte+0 (used reg = )
16750 4C4B           E8         B9CC            call	_write_byte
16751 4C4E           83C4                   06  add	sp,*6
16752                                           !BCC_EOS
16753                                           ! 2639       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
16754                                           ! Debug: list int = const 0 (used reg = )
16755 4C51           31C0                       xor	ax,ax
16756 4C53           50                         push	ax
16757                                           ! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
16758 4C54           8B46         06            mov	ax,6[bp]
16759                                           ! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
16760                                           ! Debug: list unsigned int = ax+$2E (used reg = )
16761 4C57           05                   002E  add	ax,*$2E
16762 4C5A           50                         push	ax
16763                                           ! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
16764 4C5B           FF76         14            push	$14[bp]
16765                                           ! Debug: func () void = write_word+0 (used reg = )
16766 4C5E           E8         B9D1            call	_write_word
16767 4C61           83C4                   06  add	sp,*6
16768                                           !BCC_EOS
16769                                           ! 2640       CX = regs.u.r16.cx;
16770                                           ! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
16771 4C64           8B46         10            mov	ax,$10[bp]
16772 4C67           8946         F4            mov	-$C[bp],ax
16773                                           !BCC_EOS
16774                                           ! 2641 #asm
16775                                           !BCC_EOS
16776                                           !BCC_ASM
16777                       00000006            _int15_function.CX	set	6
16778                       FFFFFFF4            .int15_function.CX	set	-$C
16779                       0000002A            _int15_function.FLAGS	set	$2A
16780                       00000018            .int15_function.FLAGS	set	$18
16781                       00000001            _int15_function.irqDisable	set	1
16782                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16783                       00000028            _int15_function.DS	set	$28
16784                       00000016            .int15_function.DS	set	$16
16785                       00000004            _int15_function.DX	set	4
16786                       FFFFFFF2            .int15_function.DX	set	-$E
16787                       0000000B            _int15_function.base23_16	set	$B
16788                       FFFFFFF9            .int15_function.base23_16	set	-7
16789                       00000002            _int15_function.bRegister	set	2
16790                       FFFFFFF0            .int15_function.bRegister	set	-$10
16791                       00000026            _int15_function.ES	set	$26
16792                       00000014            .int15_function.ES	set	$14
16793                       00000010            _int15_function.ebda_seg	set	$10
16794                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16795                       0000000C            _int15_function.base15_00	set	$C
16796                       FFFFFFFA            .int15_function.base15_00	set	-6
16797                       00000008            _int15_function.ss	set	8
16798                       FFFFFFF6            .int15_function.ss	set	-$A
16799                       00000016            _int15_function.regs	set	$16
16800                       00000004            .int15_function.regs	set	4
16801                       0000000E            _int15_function.prev_a20_enable	set	$E
16802                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16803 4C6A           89E3                             mov bx, sp
16804 4C6C           36                               SEG SS
16805 4C6D           8B4F         06                    mov cx, _int15_function.CX [bx]
16806 4C70     66    50                               push eax
16807 4C72     66    31C0                             xor eax, eax
16808 4C75           8ED8                             mov ds, ax
16809 4C77           8C16       0469                  mov 0x0469, ss
16810 4C7B           8926       0467                  mov 0x0467, sp
16811 4C7F           26                               SEG ES
16812 4C80         0F0154         08                    lgdt [si + 0x08]
16813 4C84           2E                               SEG CS
16814 4C85         0F011E       F88C                    lidt [pmode_IDT_info]
16815                                                 ;; perhaps do something with IDT here
16816                                                 ;; set PE bit in CR0
16817 4C8A         0F20C0                             mov eax, cr0
16818 4C8D           0C                     01        or al, #0x01
16819 4C8F         0F22C0                             mov cr0, eax
16820                                                 ;; far jump to flush CPU queue after transition to protected mode
16821                                                 JMP_AP(0x0020, protected_mode)
 +a   4C92                        EA              db 0xea
 +a   4C93                      4C97              dw  protected_mode
 +a   4C95                      0020              dw 0x0020
16822                       00004C97            protected_mode:
16823                                                 ;; GDT points to valid descriptor table, now load SS, DS, ES
16824 4C97           B8                   0028        mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
16825 4C9A           8ED0                             mov ss, ax
16826 4C9C           B8                   0010        mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
16827 4C9F           8ED8                             mov ds, ax
16828 4CA1           B8                   0018        mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
16829 4CA4           8EC0                             mov es, ax
16830 4CA6           31F6                             xor si, si
16831 4CA8           31FF                             xor di, di
16832 4CAA           FC                               cld
16833 4CAB           F3                               rep
16834 4CAC           A5                                 movsw ;; move CX words from DS:SI to ES:DI
16835                                                 ;; make sure DS and ES limits are 64KB
16836 4CAD           B8                   0028        mov ax, #0x28
16837 4CB0           8ED8                             mov ds, ax
16838 4CB2           8EC0                             mov es, ax
16839                                                 ;; reset PG bit in CR0 ???
16840 4CB4         0F20C0                             mov eax, cr0
16841 4CB7           24                     FE        and al, #0xFE
16842 4CB9         0F22C0                             mov cr0, eax
16843                                                 ;; far jump to flush CPU queue after transition to real mode
16844                                                 JMP_AP(0xf000, real_mode)
 +a   4CBC                        EA              db 0xea
 +a   4CBD                      4CC1              dw  real_mode
 +a   4CBF                      F000              dw 0xf000
16845                       00004CC1            real_mode:
16846                                                 ;; restore IDT to normal real-mode defaults
16847 4CC1           2E                               SEG CS
16848 4CC2         0F011E       F891                    lidt [rmode_IDT_info]
16849 4CC7           31C0                             xor ax, ax
16850 4CC9           8ED8                             mov ds, ax
16851 4CCB           8E16       0469                  mov ss, 0x0469
16852 4CCF           8B26       0467                  mov sp, 0x0467
16853 4CD3     66    58                               pop eax
16854                                           ! 2693 endasm
16855                                           !BCC_ENDASM
16856                                           !BCC_EOS
16857                                           ! 2694       set_enable_a20(prev_a20_enable);
16858                                           ! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
16859 4CD5           FF76         FC            push	-4[bp]
16860                                           ! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
16861 4CD8           E8         CC00            call	_set_enable_a20
16862 4CDB           44                         inc	sp
16863 4CDC           44                         inc	sp
16864                                           !BCC_EOS
16865                                           ! 2695 #asm
16866                                           !BCC_EOS
16867                                           !BCC_ASM
16868                       00000006            _int15_function.CX	set	6
16869                       FFFFFFF4            .int15_function.CX	set	-$C
16870                       0000002A            _int15_function.FLAGS	set	$2A
16871                       00000018            .int15_function.FLAGS	set	$18
16872                       00000001            _int15_function.irqDisable	set	1
16873                       FFFFFFEF            .int15_function.irqDisable	set	-$11
16874                       00000028            _int15_function.DS	set	$28
16875                       00000016            .int15_function.DS	set	$16
16876                       00000004            _int15_function.DX	set	4
16877                       FFFFFFF2            .int15_function.DX	set	-$E
16878                       0000000B            _int15_function.base23_16	set	$B
16879                       FFFFFFF9            .int15_function.base23_16	set	-7
16880                       00000002            _int15_function.bRegister	set	2
16881                       FFFFFFF0            .int15_function.bRegister	set	-$10
16882                       00000026            _int15_function.ES	set	$26
16883                       00000014            .int15_function.ES	set	$14
16884                       00000010            _int15_function.ebda_seg	set	$10
16885                       FFFFFFFE            .int15_function.ebda_seg	set	-2
16886                       0000000C            _int15_function.base15_00	set	$C
16887                       FFFFFFFA            .int15_function.base15_00	set	-6
16888                       00000008            _int15_function.ss	set	8
16889                       FFFFFFF6            .int15_function.ss	set	-$A
16890                       00000016            _int15_function.regs	set	$16
16891                       00000004            .int15_function.regs	set	4
16892                       0000000E            _int15_function.prev_a20_enable	set	$E
16893                       FFFFFFFC            .int15_function.prev_a20_enable	set	-4
16894 4CDD           FB                           sti
16895                                           ! 2697 endasm
16896                                           !BCC_ENDASM
16897                                           !BCC_EOS
16898                                           ! 2698       regs.u.r8.ah = 0;
16899                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16900 4CDE           30C0                       xor	al,al
16901 4CE0           8846         13            mov	$13[bp],al
16902                                           !BCC_EOS
16903                                           ! 2699       FLAGS &= 0xfffe;
16904                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16905 4CE3           8B46         18            mov	ax,$18[bp]
16906 4CE6           24                     FE  and	al,#$FE
16907 4CE8           8946         18            mov	$18[bp],ax
16908                                           !BCC_EOS
16909                                           ! 2700       break;
16910 4CEB           E9         00F2            br 	.359
16911                                           !BCC_EOS
16912                                           ! 2701     case 0x88:
16913                                           ! 2702       regs.u.r8.al = inb_cmos(0x30);
16914                       00004CEE            .375:
16915                                           ! Debug: list int = const $30 (used reg = )
16916 4CEE           B8                   0030  mov	ax,*$30
16917 4CF1           50                         push	ax
16918                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16919 4CF2           E8         B88E            call	_inb_cmos
16920 4CF5           44                         inc	sp
16921 4CF6           44                         inc	sp
16922                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
16923 4CF7           8846         12            mov	$12[bp],al
16924                                           !BCC_EOS
16925                                           ! 2703       regs.u.r8.ah = inb_cmos(0x31);
16926                                           ! Debug: list int = const $31 (used reg = )
16927 4CFA           B8                   0031  mov	ax,*$31
16928 4CFD           50                         push	ax
16929                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
16930 4CFE           E8         B882            call	_inb_cmos
16931 4D01           44                         inc	sp
16932 4D02           44                         inc	sp
16933                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
16934 4D03           8846         13            mov	$13[bp],al
16935                                           !BCC_EOS
16936                                           ! 2704       if(regs.u.r16.ax > 0xffc0)
16937                                           ! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
16938 4D06           8B46         12            mov	ax,$12[bp]
16939 4D09           3D                   FFC0  cmp	ax,#$FFC0
16940 4D0C           76           06            jbe 	.376
16941                       00004D0E            .377:
16942                                           ! 2705         regs.u.r16.ax = 0xffc0;
16943                                           ! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
16944 4D0E           B8                   FFC0  mov	ax,#$FFC0
16945 4D11           8946         12            mov	$12[bp],ax
16946                                           !BCC_EOS
16947                                           ! 2706       FLAGS &= 0xfffe;
16948                       00004D14            .376:
16949                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16950 4D14           8B46         18            mov	ax,$18[bp]
16951 4D17           24                     FE  and	al,#$FE
16952 4D19           8946         18            mov	$18[bp],ax
16953                                           !BCC_EOS
16954                                           ! 2707       break;
16955 4D1C           E9         00C1            br 	.359
16956                                           !BCC_EOS
16957                                           ! 2708     case 0x90:
16958                                           ! 2709       break;
16959                       00004D1F            .378:
16960 4D1F           E9         00BE            br 	.359
16961                                           !BCC_EOS
16962                                           ! 2710     case 0x91:
16963                                           ! 2711       break;
16964                       00004D22            .379:
16965 4D22           E9         00BB            br 	.359
16966                                           !BCC_EOS
16967                                           ! 2712     case 0xbf:
16968                                           ! 2713       ;
16969                       00004D25            .37A:
16970                                           !BCC_EOS
16971                                           ! 2714       FLAGS |= 0x0001;
16972                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
16973 4D25           8B46         18            mov	ax,$18[bp]
16974 4D28           0C                     01  or	al,*1
16975 4D2A           8946         18            mov	$18[bp],ax
16976                                           !BCC_EOS
16977                                           ! 2715       regs.u.r8.ah = 0x86;
16978                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
16979 4D2D           B0                     86  mov	al,#$86
16980 4D2F           8846         13            mov	$13[bp],al
16981                                           !BCC_EOS
16982                                           ! 2716       break;
16983 4D32           E9         00AB            br 	.359
16984                                           !BCC_EOS
16985                                           ! 2717     case 0xC0:
16986                                           ! 2718       FLAGS &= 0xfffe;
16987                       00004D35            .37B:
16988                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
16989 4D35           8B46         18            mov	ax,$18[bp]
16990 4D38           24                     FE  and	al,#$FE
16991 4D3A           8946         18            mov	$18[bp],ax
16992                                           !BCC_EOS
16993                                           ! 2719       regs.u.r8.ah = 0;
16994                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
16995 4D3D           30C0                       xor	al,al
16996 4D3F           8846         13            mov	$13[bp],al
16997                                           !BCC_EOS
16998                                           ! 2720       regs.u.r16.bx = 0xe6f5;
16999                                           ! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
17000 4D42           B8                   E6F5  mov	ax,#$E6F5
17001 4D45           8946         0C            mov	$C[bp],ax
17002                                           !BCC_EOS
17003                                           ! 2721       ES = 0xF000;
17004                                           ! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
17005 4D48           B8                   F000  mov	ax,#$F000
17006 4D4B           8946         14            mov	$14[bp],ax
17007                                           !BCC_EOS
17008                                           ! 2722       break;
17009 4D4E           E9         008F            br 	.359
17010                                           !BCC_EOS
17011                                           ! 2723     case 0xc1:
17012                                           ! 2724       ES = ebda_seg;
17013                       00004D51            .37C:
17014                                           ! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
17015 4D51           8B46         FE            mov	ax,-2[bp]
17016 4D54           8946         14            mov	$14[bp],ax
17017                                           !BCC_EOS
17018                                           ! 2725       FLAGS &= 0xfffe;
17019                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
17020 4D57           8B46         18            mov	ax,$18[bp]
17021 4D5A           24                     FE  and	al,#$FE
17022 4D5C           8946         18            mov	$18[bp],ax
17023                                           !BCC_EOS
17024                                           ! 2726       break;
17025 4D5F           E9         007E            br 	.359
17026                                           !BCC_EOS
17027                                           ! 2727     case 0xd8:
17028                                           ! 2728       bios_printf(8, "EISA BIOS not present\n");
17029                       00004D62            .37D:
17030                                           ! Debug: list * char = .37E+0 (used reg = )
17031 4D62           BB                   D2C9  mov	bx,#.37E
17032 4D65           53                         push	bx
17033                                           ! Debug: list int = const 8 (used reg = )
17034 4D66           B8                   0008  mov	ax,*8
17035 4D69           50                         push	ax
17036                                           ! Debug: func () void = bios_printf+0 (used reg = )
17037 4D6A           E8         BCAE            call	_bios_printf
17038 4D6D           83C4                   04  add	sp,*4
17039                                           !BCC_EOS
17040                                           ! 2729       FLAGS |= 0x0001;
17041                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
17042 4D70           8B46         18            mov	ax,$18[bp]
17043 4D73           0C                     01  or	al,*1
17044 4D75           8946         18            mov	$18[bp],ax
17045                                           !BCC_EOS
17046                                           ! 2730       regs.u.r8.ah = 0x86;
17047                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
17048 4D78           B0                     86  mov	al,#$86
17049 4D7A           8846         13            mov	$13[bp],al
17050                                           !BCC_EOS
17051                                           ! 2731       break;
17052 4D7D           EB           61            jmp .359
17053                                           !BCC_EOS
17054                                           ! 2732     default:
17055                                           ! 2733       ;
17056                       00004D7F            .37F:
17057                                           !BCC_EOS
17058                                           ! 2734       FLAGS |= 0x0001;
17059                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
17060 4D7F           8B46         18            mov	ax,$18[bp]
17061 4D82           0C                     01  or	al,*1
17062 4D84           8946         18            mov	$18[bp],ax
17063                                           !BCC_EOS
17064                                           ! 2735       regs.u.r8.ah = 0x86;
17065                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
17066 4D87           B0                     86  mov	al,#$86
17067 4D89           8846         13            mov	$13[bp],al
17068                                           !BCC_EOS
17069                                           ! 2736       break;
17070 4D8C           EB           52            jmp .359
17071                                           !BCC_EOS
17072                                           ! 2737     }
17073                                           ! 2738 }
17074 4D8E           EB           50            jmp .359
17075                       00004D90            .35B:
17076 4D90           2C                     24  sub	al,*$24
17077 4D92         0F84         FB71            beq 	.35C
17078 4D96           2C                     1D  sub	al,*$1D
17079 4D98         0F84         FBF9            beq 	.365
17080 4D9C           2C                     0E  sub	al,*$E
17081 4D9E         0F84         FC03            beq 	.366
17082 4DA2           2C                     03  sub	al,*3
17083 4DA4         0F84         FC08            beq 	.367
17084 4DA8           2C                     31  sub	al,*$31
17085 4DAA         0F84         FC12            beq 	.368
17086 4DAE           2C                     04  sub	al,*4
17087 4DB0         0F84         FD2D            beq 	.372
17088 4DB4           2C                     01  sub	al,*1
17089 4DB6         0F84         FF34            beq 	.375
17090 4DBA           2C                     08  sub	al,*8
17091 4DBC         0F84         FF5F            beq 	.378
17092 4DC0           2C                     01  sub	al,*1
17093 4DC2         0F84         FF5C            beq 	.379
17094 4DC6           2C                     2E  sub	al,*$2E
17095 4DC8         0F84         FF59            beq 	.37A
17096 4DCC           2C                     01  sub	al,*1
17097 4DCE         0F84         FF63            beq 	.37B
17098 4DD2           2C                     01  sub	al,*1
17099 4DD4         0F84         FF79            beq 	.37C
17100 4DD8           2C                     17  sub	al,*$17
17101 4DDA         0F84         FF84            beq 	.37D
17102 4DDE           EB           9F            jmp	.37F
17103                       00004DE0            .359:
17104                       FFFFFFEC            ..FFF7	=	-$14
17105 4DE0           89EC                       mov	sp,bp
17106 4DE2           5D                         pop	bp
17107 4DE3           C3                         ret
17108                                           ! 2739   void
17109                                           ! Register BX used in function int15_function
17110                                           ! 2740 int15_function_mouse(regs, ES, DS, FLAGS)
17111                                           ! 2741   pusha_regs_t regs;
17112                                           export	_int15_function_mouse
17113                       00004DE4            _int15_function_mouse:
17114                                           !BCC_EOS
17115                                           ! 2742   Bit16u ES, DS, FLAGS;
17116                                           !BCC_EOS
17117                                           ! 2743 {
17118                                           ! 2744   Bit16u ebda_seg=read_word(0x0040,0x000E);
17119 4DE4           55                         push	bp
17120 4DE5           89E5                       mov	bp,sp
17121 4DE7           4C                         dec	sp
17122 4DE8           4C                         dec	sp
17123                                           ! Debug: list int = const $E (used reg = )
17124 4DE9           B8                   000E  mov	ax,*$E
17125 4DEC           50                         push	ax
17126                                           ! Debug: list int = const $40 (used reg = )
17127 4DED           B8                   0040  mov	ax,*$40
17128 4DF0           50                         push	ax
17129                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
17130 4DF1           E8         B813            call	_read_word
17131 4DF4           83C4                   04  add	sp,*4
17132                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
17133 4DF7           8946         FE            mov	-2[bp],ax
17134                                           !BCC_EOS
17135                                           ! 2745   Bit8u mouse_flags_1, mouse_flags_2;
17136                                           !BCC_EOS
17137                                           ! 2746   Bit16u mouse_driver_seg;
17138                                           !BCC_EOS
17139                                           ! 2747   Bit16u mouse_driver_offset;
17140                                           !BCC_EOS
17141                                           ! 2748   Bit8u comm_byte, prev_command_byte;
17142                                           !BCC_EOS
17143                                           ! 2749   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
17144                                           !BCC_EOS
17145                                           ! 2750 ;
17146 4DFA           83C4                   F4  add	sp,*-$C
17147                                           !BCC_EOS
17148                                           ! 2751   switch (regs.u.r8.ah) {
17149 4DFD           8A46         13            mov	al,$13[bp]
17150 4E00           E9         0640            br 	.382
17151                                           ! 2752     case 0xC2:
17152                                           ! 2753       switch (regs.u.r8.al) {
17153                       00004E03            .383:
17154 4E03           8A46         12            mov	al,$12[bp]
17155 4E06           E9         0602            br 	.386
17156                                           ! 2754         case 0:
17157                                           ! 2755 ;
17158                       00004E09            .387:
17159                                           !BCC_EOS
17160                                           ! 2756           switch (regs.u.r8.bh) {
17161 4E09           8A46         0D            mov	al,$D[bp]
17162 4E0C           E9         00E9            br 	.38A
17163                                           ! 2757             case 0:
17164                                           ! 2758 ;
17165                       00004E0F            .38B:
17166                                           !BCC_EOS
17167                                           ! 2759               inhibit_mouse_int_and_events();
17168                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17169 4E0F           E8         0FB1            call	_inhibit_mouse_int_and_events
17170                                           !BCC_EOS
17171                                           ! 2760               ret = send_to_mouse_ctrl(0xF5);
17172                                           ! Debug: list int = const $F5 (used reg = )
17173 4E12           B8                   00F5  mov	ax,#$F5
17174 4E15           50                         push	ax
17175                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17176 4E16           E8         10FB            call	_send_to_mouse_ctrl
17177 4E19           44                         inc	sp
17178 4E1A           44                         inc	sp
17179                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17180 4E1B           8846         F5            mov	-$B[bp],al
17181                                           !BCC_EOS
17182                                           ! 2761               if (ret == 0) {
17183                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17184 4E1E           8A46         F5            mov	al,-$B[bp]
17185 4E21           84C0                       test	al,al
17186 4E23           75           2B            jne 	.38C
17187                       00004E25            .38D:
17188                                           ! 2762                 ret = get_mouse_data(&mouse_data1);
17189                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17190 4E25           8D5E         F4            lea	bx,-$C[bp]
17191 4E28           53                         push	bx
17192                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17193 4E29           E8         1132            call	_get_mouse_data
17194 4E2C           44                         inc	sp
17195 4E2D           44                         inc	sp
17196                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17197 4E2E           8846         F5            mov	-$B[bp],al
17198                                           !BCC_EOS
17199                                           ! 2763                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
17200                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17201 4E31           8A46         F5            mov	al,-$B[bp]
17202 4E34           84C0                       test	al,al
17203 4E36           74           07            je  	.38F
17204                       00004E38            .390:
17205                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17206 4E38           8A46         F4            mov	al,-$C[bp]
17207 4E3B           3C                     FA  cmp	al,#$FA
17208 4E3D           75           11            jne 	.38E
17209                       00004E3F            .38F:
17210                                           ! 2764                   FLAGS &= 0xfffe;
17211                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17212 4E3F           8B46         18            mov	ax,$18[bp]
17213 4E42           24                     FE  and	al,#$FE
17214 4E44           8946         18            mov	$18[bp],ax
17215                                           !BCC_EOS
17216                                           ! 2765                   regs.u.r8.ah = 0;
17217                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17218 4E47           30C0                       xor	al,al
17219 4E49           8846         13            mov	$13[bp],al
17220                                           !BCC_EOS
17221                                           ! 2766                   return;
17222 4E4C           89EC                       mov	sp,bp
17223 4E4E           5D                         pop	bp
17224 4E4F           C3                         ret
17225                                           !BCC_EOS
17226                                           ! 2767                   }
17227                                           ! 2768                 }
17228                       00004E50            .38E:
17229                                           ! 2769               FLAGS |= 0x0001;
17230                       00004E50            .38C:
17231                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17232 4E50           8B46         18            mov	ax,$18[bp]
17233 4E53           0C                     01  or	al,*1
17234 4E55           8946         18            mov	$18[bp],ax
17235                                           !BCC_EOS
17236                                           ! 2770               regs.u.r8.ah = ret;
17237                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17238 4E58           8A46         F5            mov	al,-$B[bp]
17239 4E5B           8846         13            mov	$13[bp],al
17240                                           !BCC_EOS
17241                                           ! 2771               return;
17242 4E5E           89EC                       mov	sp,bp
17243 4E60           5D                         pop	bp
17244 4E61           C3                         ret
17245                                           !BCC_EOS
17246                                           ! 2772               break;
17247 4E62           E9         00A1            br 	.388
17248                                           !BCC_EOS
17249                                           ! 2773  
17250                                           ! 2773            case 1:
17251                                           ! 2774 ;
17252                       00004E65            .391:
17253                                           !BCC_EOS
17254                                           ! 2775               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17255                                           ! Debug: list int = const $27 (used reg = )
17256 4E65           B8                   0027  mov	ax,*$27
17257 4E68           50                         push	ax
17258                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17259 4E69           FF76         FE            push	-2[bp]
17260                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17261 4E6C           E8         B785            call	_read_byte
17262 4E6F           83C4                   04  add	sp,*4
17263                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17264 4E72           8846         FC            mov	-4[bp],al
17265                                           !BCC_EOS
17266                                           ! 2776               if ( (mouse_flags_2 & 0x80) == 0 ) {
17267                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17268 4E75           8A46         FC            mov	al,-4[bp]
17269 4E78           24                     80  and	al,#$80
17270                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
17271 4E7A           84C0                       test	al,al
17272 4E7C           75           11            jne 	.392
17273                       00004E7E            .393:
17274                                           ! 2777                 ;
17275                                           !BCC_EOS
17276                                           ! 2778                 FLAGS |= 0x0001;
17277                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17278 4E7E           8B46         18            mov	ax,$18[bp]
17279 4E81           0C                     01  or	al,*1
17280 4E83           8946         18            mov	$18[bp],ax
17281                                           !BCC_EOS
17282                                           ! 2779                 regs.u.r8.ah = 5;
17283                                           ! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
17284 4E86           B0                     05  mov	al,*5
17285 4E88           8846         13            mov	$13[bp],al
17286                                           !BCC_EOS
17287                                           ! 2780                 return;
17288 4E8B           89EC                       mov	sp,bp
17289 4E8D           5D                         pop	bp
17290 4E8E           C3                         ret
17291                                           !BCC_EOS
17292                                           ! 2781                 }
17293                                           ! 2782               inhibit_mouse_int_and_events();
17294                       00004E8F            .392:
17295                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17296 4E8F           E8         0F31            call	_inhibit_mouse_int_and_events
17297                                           !BCC_EOS
17298                                           ! 2783               ret = send_to_mouse_ctrl(0xF4);
17299                                           ! Debug: list int = const $F4 (used reg = )
17300 4E92           B8                   00F4  mov	ax,#$F4
17301 4E95           50                         push	ax
17302                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17303 4E96           E8         107B            call	_send_to_mouse_ctrl
17304 4E99           44                         inc	sp
17305 4E9A           44                         inc	sp
17306                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17307 4E9B           8846         F5            mov	-$B[bp],al
17308                                           !BCC_EOS
17309                                           ! 2784               if (ret == 0) {
17310                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17311 4E9E           8A46         F5            mov	al,-$B[bp]
17312 4EA1           84C0                       test	al,al
17313 4EA3           75           2E            jne 	.394
17314                       00004EA5            .395:
17315                                           ! 2785                 ret = get_mouse_data(&mouse_data1);
17316                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17317 4EA5           8D5E         F4            lea	bx,-$C[bp]
17318 4EA8           53                         push	bx
17319                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17320 4EA9           E8         10B2            call	_get_mouse_data
17321 4EAC           44                         inc	sp
17322 4EAD           44                         inc	sp
17323                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17324 4EAE           8846         F5            mov	-$B[bp],al
17325                                           !BCC_EOS
17326                                           ! 2786                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
17327                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17328 4EB1           8A46         F5            mov	al,-$B[bp]
17329 4EB4           84C0                       test	al,al
17330 4EB6           75           1B            jne 	.396
17331                       00004EB8            .398:
17332                                           ! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17333 4EB8           8A46         F4            mov	al,-$C[bp]
17334 4EBB           3C                     FA  cmp	al,#$FA
17335 4EBD           75           14            jne 	.396
17336                       00004EBF            .397:
17337                                           ! 2787                   enable_mouse_int_and_events();
17338                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17339 4EBF           E8         0FAE            call	_enable_mouse_int_and_events
17340                                           !BCC_EOS
17341                                           ! 2788                   FLAGS &= 0xfffe;
17342                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17343 4EC2           8B46         18            mov	ax,$18[bp]
17344 4EC5           24                     FE  and	al,#$FE
17345 4EC7           8946         18            mov	$18[bp],ax
17346                                           !BCC_EOS
17347                                           ! 2789                   regs.u.r8.ah = 0;
17348                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17349 4ECA           30C0                       xor	al,al
17350 4ECC           8846         13            mov	$13[bp],al
17351                                           !BCC_EOS
17352                                           ! 2790                   return;
17353 4ECF           89EC                       mov	sp,bp
17354 4ED1           5D                         pop	bp
17355 4ED2           C3                         ret
17356                                           !BCC_EOS
17357                                           ! 2791                   }
17358                                           ! 2792                 }
17359                       00004ED3            .396:
17360                                           ! 2793               FLAGS |= 0x0001;
17361                       00004ED3            .394:
17362                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17363 4ED3           8B46         18            mov	ax,$18[bp]
17364 4ED6           0C                     01  or	al,*1
17365 4ED8           8946         18            mov	$18[bp],ax
17366                                           !BCC_EOS
17367                                           ! 2794               regs.u.r8.ah = ret;
17368                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17369 4EDB           8A46         F5            mov	al,-$B[bp]
17370 4EDE           8846         13            mov	$13[bp],al
17371                                           !BCC_EOS
17372                                           ! 2795               return;
17373 4EE1           89EC                       mov	sp,bp
17374 4EE3           5D                         pop	bp
17375 4EE4           C3                         ret
17376                                           !BCC_EOS
17377                                           ! 2796             default:
17378                                           ! 2797               ;
17379                       00004EE5            .399:
17380                                           !BCC_EOS
17381                                           ! 2798               FLAGS |= 0x0001;
17382                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17383 4EE5           8B46         18            mov	ax,$18[bp]
17384 4EE8           0C                     01  or	al,*1
17385 4EEA           8946         18            mov	$18[bp],ax
17386                                           !BCC_EOS
17387                                           ! 2799               regs.u.r8.ah = 1;
17388                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
17389 4EED           B0                     01  mov	al,*1
17390 4EEF           8846         13            mov	$13[bp],al
17391                                           !BCC_EOS
17392                                           ! 2800               return;
17393 4EF2           89EC                       mov	sp,bp
17394 4EF4           5D                         pop	bp
17395 4EF5           C3                         ret
17396                                           !BCC_EOS
17397                                           ! 2801             }
17398                                           ! 2802           break;
17399 4EF6           EB           0E            jmp .388
17400                       00004EF8            .38A:
17401 4EF8           2C                     00  sub	al,*0
17402 4EFA         0F84         FF11            beq 	.38B
17403 4EFE           2C                     01  sub	al,*1
17404 4F00         0F84         FF61            beq 	.391
17405 4F04           EB           DF            jmp	.399
17406                       00004F06            .388:
17407 4F06           E9         0527            br 	.384
17408                                           !BCC_EOS
17409                                           ! 2803         case 1:
17410                                           ! 2804         case 5:
17411                       00004F09            .39A:
17412                                           ! 2805 ;
17413                       00004F09            .39B:
17414                                           !BCC_EOS
17415                                           ! 2806           if (regs.u.r8.al == 5) {
17416                                           ! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
17417 4F09           8A46         12            mov	al,$12[bp]
17418 4F0C           3C                     05  cmp	al,*5
17419 4F0E           75           5E            jne 	.39C
17420                       00004F10            .39D:
17421                                           ! 2807             if (regs.u.r8.bh != 3) {
17422                                           ! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
17423 4F10           8A46         0D            mov	al,$D[bp]
17424 4F13           3C                     03  cmp	al,*3
17425 4F15           74           11            je  	.39E
17426                       00004F17            .39F:
17427                                           ! 2808               FLAGS |= 0x0001;
17428                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17429 4F17           8B46         18            mov	ax,$18[bp]
17430 4F1A           0C                     01  or	al,*1
17431 4F1C           8946         18            mov	$18[bp],ax
17432                                           !BCC_EOS
17433                                           ! 2809               regs.u.r8.ah = 0x02;
17434                                           ! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
17435 4F1F           B0                     02  mov	al,*2
17436 4F21           8846         13            mov	$13[bp],al
17437                                           !BCC_EOS
17438                                           ! 2810               return;
17439 4F24           89EC                       mov	sp,bp
17440 4F26           5D                         pop	bp
17441 4F27           C3                         ret
17442                                           !BCC_EOS
17443                                           ! 2811             }
17444                                           ! 2812             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
17445                       00004F28            .39E:
17446                                           ! Debug: list int = const $27 (used reg = )
17447 4F28           B8                   0027  mov	ax,*$27
17448 4F2B           50                         push	ax
17449                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
17450 4F2C           FF76         FE            push	-2[bp]
17451                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
17452 4F2F           E8         B6C2            call	_read_byte
17453 4F32           83C4                   04  add	sp,*4
17454                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17455 4F35           8846         FC            mov	-4[bp],al
17456                                           !BCC_EOS
17457                                           ! 2813             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
17458                                           ! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17459 4F38           8A46         FC            mov	al,-4[bp]
17460 4F3B           30C0                       xor	al,al
17461                                           ! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
17462 4F3D           0A46         0D            or	al,$D[bp]
17463                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17464 4F40           8846         FC            mov	-4[bp],al
17465                                           !BCC_EOS
17466                                           ! 2814             mouse_flags_1 = 0x00;
17467                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17468 4F43           30C0                       xor	al,al
17469 4F45           8846         FD            mov	-3[bp],al
17470                                           !BCC_EOS
17471                                           ! 2815             write_byte(ebda_seg, 0x0026, mouse_flags_1);
17472                                           ! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
17473 4F48           8A46         FD            mov	al,-3[bp]
17474 4F4B           30E4                       xor	ah,ah
17475 4F4D           50                         push	ax
17476                                           ! Debug: list int = const $26 (used reg = )
17477 4F4E           B8                   0026  mov	ax,*$26
17478 4F51           50                         push	ax
17479                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17480 4F52           FF76         FE            push	-2[bp]
17481                                           ! Debug: func () void = write_byte+0 (used reg = )
17482 4F55           E8         B6C2            call	_write_byte
17483 4F58           83C4                   06  add	sp,*6
17484                                           !BCC_EOS
17485                                           ! 2816             write_byte(ebda_seg, 0x0027, mouse_flags_2);
17486                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
17487 4F5B           8A46         FC            mov	al,-4[bp]
17488 4F5E           30E4                       xor	ah,ah
17489 4F60           50                         push	ax
17490                                           ! Debug: list int = const $27 (used reg = )
17491 4F61           B8                   0027  mov	ax,*$27
17492 4F64           50                         push	ax
17493                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
17494 4F65           FF76         FE            push	-2[bp]
17495                                           ! Debug: func () void = write_byte+0 (used reg = )
17496 4F68           E8         B6AF            call	_write_byte
17497 4F6B           83C4                   06  add	sp,*6
17498                                           !BCC_EOS
17499                                           ! 2817           }
17500                                           ! 2818           inhibit_mouse_int_and_events();
17501                       00004F6E            .39C:
17502                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17503 4F6E           E8         0E52            call	_inhibit_mouse_int_and_events
17504                                           !BCC_EOS
17505                                           ! 2819           ret = send_to_mouse_ctrl(0xFF);
17506                                           ! Debug: list int = const $FF (used reg = )
17507 4F71           B8                   00FF  mov	ax,#$FF
17508 4F74           50                         push	ax
17509                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17510 4F75           E8         0F9C            call	_send_to_mouse_ctrl
17511 4F78           44                         inc	sp
17512 4F79           44                         inc	sp
17513                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17514 4F7A           8846         F5            mov	-$B[bp],al
17515                                           !BCC_EOS
17516                                           ! 2820           if (ret == 0) {
17517                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17518 4F7D           8A46         F5            mov	al,-$B[bp]
17519 4F80           84C0                       test	al,al
17520 4F82         0F85         0087            bne 	.3A0
17521                       00004F86            .3A1:
17522                                           ! 2821             ret = get_mouse_data(&mouse_data3);
17523                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
17524 4F86           8D5E         F2            lea	bx,-$E[bp]
17525 4F89           53                         push	bx
17526                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17527 4F8A           E8         0FD1            call	_get_mouse_data
17528 4F8D           44                         inc	sp
17529 4F8E           44                         inc	sp
17530                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17531 4F8F           8846         F5            mov	-$B[bp],al
17532                                           !BCC_EOS
17533                                           ! 2822             if (mouse_data3 == 0xfe) {
17534                                           ! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17535 4F92           8A46         F2            mov	al,-$E[bp]
17536 4F95           3C                     FE  cmp	al,#$FE
17537 4F97           75           0C            jne 	.3A2
17538                       00004F99            .3A3:
17539                                           ! 2823               FLAGS |= 0x0001;
17540                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17541 4F99           8B46         18            mov	ax,$18[bp]
17542 4F9C           0C                     01  or	al,*1
17543 4F9E           8946         18            mov	$18[bp],ax
17544                                           !BCC_EOS
17545                                           ! 2824               return;
17546 4FA1           89EC                       mov	sp,bp
17547 4FA3           5D                         pop	bp
17548 4FA4           C3                         ret
17549                                           !BCC_EOS
17550                                           ! 2825             }
17551                                           ! 2826             if (mouse_data3 != 0xfa)
17552                       00004FA5            .3A2:
17553                                           ! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17554 4FA5           8A46         F2            mov	al,-$E[bp]
17555 4FA8           3C                     FA  cmp	al,#$FA
17556 4FAA           74           14            je  	.3A4
17557                       00004FAC            .3A5:
17558                                           ! 2827               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
17559                                           ! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
17560 4FAC           8A46         F2            mov	al,-$E[bp]
17561 4FAF           30E4                       xor	ah,ah
17562 4FB1           50                         push	ax
17563                                           ! Debug: list * char = .3A6+0 (used reg = )
17564 4FB2           BB                   D29E  mov	bx,#.3A6
17565 4FB5           53                         push	bx
17566                                           ! Debug: list int = const 7 (used reg = )
17567 4FB6           B8                   0007  mov	ax,*7
17568 4FB9           50                         push	ax
17569                                           ! Debug: func () void = bios_printf+0 (used reg = )
17570 4FBA           E8         BA5E            call	_bios_printf
17571 4FBD           83C4                   06  add	sp,*6
17572                                           !BCC_EOS
17573                                           ! 2828             if ( ret == 0 ) {
17574                       00004FC0            .3A4:
17575                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17576 4FC0           8A46         F5            mov	al,-$B[bp]
17577 4FC3           84C0                       test	al,al
17578 4FC5           75           46            jne 	.3A7
17579                       00004FC7            .3A8:
17580                                           ! 2829               ret = get_mouse_data(&mouse_data1);
17581                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17582 4FC7           8D5E         F4            lea	bx,-$C[bp]
17583 4FCA           53                         push	bx
17584                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17585 4FCB           E8         0F90            call	_get_mouse_data
17586 4FCE           44                         inc	sp
17587 4FCF           44                         inc	sp
17588                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17589 4FD0           8846         F5            mov	-$B[bp],al
17590                                           !BCC_EOS
17591                                           ! 2830               if ( ret == 0 ) {
17592                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17593 4FD3           8A46         F5            mov	al,-$B[bp]
17594 4FD6           84C0                       test	al,al
17595 4FD8           75           33            jne 	.3A9
17596                       00004FDA            .3AA:
17597                                           ! 2831                 ret = get_mouse_data(&mouse_data2);
17598                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17599 4FDA           8D5E         F3            lea	bx,-$D[bp]
17600 4FDD           53                         push	bx
17601                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17602 4FDE           E8         0F7D            call	_get_mouse_data
17603 4FE1           44                         inc	sp
17604 4FE2           44                         inc	sp
17605                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17606 4FE3           8846         F5            mov	-$B[bp],al
17607                                           !BCC_EOS
17608                                           ! 2832                 if ( ret == 0 ) {
17609                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17610 4FE6           8A46         F5            mov	al,-$B[bp]
17611 4FE9           84C0                       test	al,al
17612 4FEB           75           20            jne 	.3AB
17613                       00004FED            .3AC:
17614                                           ! 2833                   enable_mouse
17615                                           ! 2833 _int_and_events();
17616                                           ! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
17617 4FED           E8         0E80            call	_enable_mouse_int_and_events
17618                                           !BCC_EOS
17619                                           ! 2834                   FLAGS &= 0xfffe;
17620                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17621 4FF0           8B46         18            mov	ax,$18[bp]
17622 4FF3           24                     FE  and	al,#$FE
17623 4FF5           8946         18            mov	$18[bp],ax
17624                                           !BCC_EOS
17625                                           ! 2835                   regs.u.r8.ah = 0;
17626                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17627 4FF8           30C0                       xor	al,al
17628 4FFA           8846         13            mov	$13[bp],al
17629                                           !BCC_EOS
17630                                           ! 2836                   regs.u.r8.bl = mouse_data1;
17631                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
17632 4FFD           8A46         F4            mov	al,-$C[bp]
17633 5000           8846         0C            mov	$C[bp],al
17634                                           !BCC_EOS
17635                                           ! 2837                   regs.u.r8.bh = mouse_data2;
17636                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
17637 5003           8A46         F3            mov	al,-$D[bp]
17638 5006           8846         0D            mov	$D[bp],al
17639                                           !BCC_EOS
17640                                           ! 2838                   return;
17641 5009           89EC                       mov	sp,bp
17642 500B           5D                         pop	bp
17643 500C           C3                         ret
17644                                           !BCC_EOS
17645                                           ! 2839                   }
17646                                           ! 2840                 }
17647                       0000500D            .3AB:
17648                                           ! 2841               }
17649                       0000500D            .3A9:
17650                                           ! 2842             }
17651                       0000500D            .3A7:
17652                                           ! 2843           FLAGS |= 0x0001;
17653                       0000500D            .3A0:
17654                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17655 500D           8B46         18            mov	ax,$18[bp]
17656 5010           0C                     01  or	al,*1
17657 5012           8946         18            mov	$18[bp],ax
17658                                           !BCC_EOS
17659                                           ! 2844           regs.u.r8.ah = ret;
17660                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
17661 5015           8A46         F5            mov	al,-$B[bp]
17662 5018           8846         13            mov	$13[bp],al
17663                                           !BCC_EOS
17664                                           ! 2845           return;
17665 501B           89EC                       mov	sp,bp
17666 501D           5D                         pop	bp
17667 501E           C3                         ret
17668                                           !BCC_EOS
17669                                           ! 2846         case 2:
17670                                           ! 2847 ;
17671                       0000501F            .3AD:
17672                                           !BCC_EOS
17673                                           ! 2848           switch (regs.u.r8.bh) {
17674 501F           8A46         0D            mov	al,$D[bp]
17675 5022           EB           38            jmp .3B0
17676                                           ! 2849             case 0: mouse_data1 = 10; break;
17677                       00005024            .3B1:
17678                                           ! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17679 5024           B0                     0A  mov	al,*$A
17680 5026           8846         F4            mov	-$C[bp],al
17681                                           !BCC_EOS
17682 5029           EB           54            jmp .3AE
17683                                           !BCC_EOS
17684                                           ! 2850             case 1: mouse_data1 = 20; break;
17685                       0000502B            .3B2:
17686                                           ! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17687 502B           B0                     14  mov	al,*$14
17688 502D           8846         F4            mov	-$C[bp],al
17689                                           !BCC_EOS
17690 5030           EB           4D            jmp .3AE
17691                                           !BCC_EOS
17692                                           ! 2851             case 2: mouse_data1 = 40; break;
17693                       00005032            .3B3:
17694                                           ! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17695 5032           B0                     28  mov	al,*$28
17696 5034           8846         F4            mov	-$C[bp],al
17697                                           !BCC_EOS
17698 5037           EB           46            jmp .3AE
17699                                           !BCC_EOS
17700                                           ! 2852             case 3: mouse_data1 = 60; break;
17701                       00005039            .3B4:
17702                                           ! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17703 5039           B0                     3C  mov	al,*$3C
17704 503B           8846         F4            mov	-$C[bp],al
17705                                           !BCC_EOS
17706 503E           EB           3F            jmp .3AE
17707                                           !BCC_EOS
17708                                           ! 2853             case 4: mouse_data1 = 80; break;
17709                       00005040            .3B5:
17710                                           ! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17711 5040           B0                     50  mov	al,*$50
17712 5042           8846         F4            mov	-$C[bp],al
17713                                           !BCC_EOS
17714 5045           EB           38            jmp .3AE
17715                                           !BCC_EOS
17716                                           ! 2854             case 5: mouse_data1 = 100; break;
17717                       00005047            .3B6:
17718                                           ! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17719 5047           B0                     64  mov	al,*$64
17720 5049           8846         F4            mov	-$C[bp],al
17721                                           !BCC_EOS
17722 504C           EB           31            jmp .3AE
17723                                           !BCC_EOS
17724                                           ! 2855             case 6: mouse_data1 = 200; break;
17725                       0000504E            .3B7:
17726                                           ! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17727 504E           B0                     C8  mov	al,#$C8
17728 5050           8846         F4            mov	-$C[bp],al
17729                                           !BCC_EOS
17730 5053           EB           2A            jmp .3AE
17731                                           !BCC_EOS
17732                                           ! 2856             default: mouse_data1 = 0;
17733                       00005055            .3B8:
17734                                           ! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17735 5055           30C0                       xor	al,al
17736 5057           8846         F4            mov	-$C[bp],al
17737                                           !BCC_EOS
17738                                           ! 2857           }
17739                                           ! 2858           if (mouse_data1 > 0) {
17740 505A           EB           23            jmp .3AE
17741                       0000505C            .3B0:
17742 505C           2C                     00  sub	al,*0
17743 505E           72           F5            jb 	.3B8
17744 5060           3C                     06  cmp	al,*6
17745 5062           77           19            ja  	.3B9
17746 5064           30E4                       xor	ah,ah
17747 5066           D1E0                       shl	ax,*1
17748 5068           89C3                       mov	bx,ax
17749 506A           2E                         seg	cs
17750 506B           FFA7       506F            br	.3BA[bx]
17751                       0000506F            .3BA:
17752 506F                      5024            .word	.3B1
17753 5071                      502B            .word	.3B2
17754 5073                      5032            .word	.3B3
17755 5075                      5039            .word	.3B4
17756 5077                      5040            .word	.3B5
17757 5079                      5047            .word	.3B6
17758 507B                      504E            .word	.3B7
17759                       0000507D            .3B9:
17760 507D           EB           D6            jmp	.3B8
17761                       0000507F            .3AE:
17762                                           ! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17763 507F           8A46         F4            mov	al,-$C[bp]
17764 5082           84C0                       test	al,al
17765 5084           74           57            je  	.3BB
17766                       00005086            .3BC:
17767                                           ! 2859             ret = send_to_mouse_ctrl(0xF3);
17768                                           ! Debug: list int = const $F3 (used reg = )
17769 5086           B8                   00F3  mov	ax,#$F3
17770 5089           50                         push	ax
17771                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17772 508A           E8         0E87            call	_send_to_mouse_ctrl
17773 508D           44                         inc	sp
17774 508E           44                         inc	sp
17775                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17776 508F           8846         F5            mov	-$B[bp],al
17777                                           !BCC_EOS
17778                                           ! 2860             if (ret == 0) {
17779                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17780 5092           8A46         F5            mov	al,-$B[bp]
17781 5095           84C0                       test	al,al
17782 5097           75           35            jne 	.3BD
17783                       00005099            .3BE:
17784                                           ! 2861               ret = get_mouse_data(&mouse_data2);
17785                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17786 5099           8D5E         F3            lea	bx,-$D[bp]
17787 509C           53                         push	bx
17788                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17789 509D           E8         0EBE            call	_get_mouse_data
17790 50A0           44                         inc	sp
17791 50A1           44                         inc	sp
17792                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17793 50A2           8846         F5            mov	-$B[bp],al
17794                                           !BCC_EOS
17795                                           ! 2862               ret = send_to_mouse_ctrl(mouse_data1);
17796                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17797 50A5           8A46         F4            mov	al,-$C[bp]
17798 50A8           30E4                       xor	ah,ah
17799 50AA           50                         push	ax
17800                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17801 50AB           E8         0E66            call	_send_to_mouse_ctrl
17802 50AE           44                         inc	sp
17803 50AF           44                         inc	sp
17804                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17805 50B0           8846         F5            mov	-$B[bp],al
17806                                           !BCC_EOS
17807                                           ! 2863               ret = get_mouse_data(&mouse_data2);
17808                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
17809 50B3           8D5E         F3            lea	bx,-$D[bp]
17810 50B6           53                         push	bx
17811                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17812 50B7           E8         0EA4            call	_get_mouse_data
17813 50BA           44                         inc	sp
17814 50BB           44                         inc	sp
17815                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17816 50BC           8846         F5            mov	-$B[bp],al
17817                                           !BCC_EOS
17818                                           ! 2864               FLAGS &= 0xfffe;
17819                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17820 50BF           8B46         18            mov	ax,$18[bp]
17821 50C2           24                     FE  and	al,#$FE
17822 50C4           8946         18            mov	$18[bp],ax
17823                                           !BCC_EOS
17824                                           ! 2865               regs.u.r8.ah = 0;
17825                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17826 50C7           30C0                       xor	al,al
17827 50C9           8846         13            mov	$13[bp],al
17828                                           !BCC_EOS
17829                                           ! 2866             } else {
17830 50CC           EB           0D            jmp .3BF
17831                       000050CE            .3BD:
17832                                           ! 2867               FLAGS |= 0x0001;
17833                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17834 50CE           8B46         18            mov	ax,$18[bp]
17835 50D1           0C                     01  or	al,*1
17836 50D3           8946         18            mov	$18[bp],ax
17837                                           !BCC_EOS
17838                                           ! 2868               regs.u.r8.ah = 0x86;
17839                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17840 50D6           B0                     86  mov	al,#$86
17841 50D8           8846         13            mov	$13[bp],al
17842                                           !BCC_EOS
17843                                           ! 2869             }
17844                                           ! 2870           } else {
17845                       000050DB            .3BF:
17846 50DB           EB           0D            jmp .3C0
17847                       000050DD            .3BB:
17848                                           ! 2871             FLAGS |= 0x0001;
17849                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17850 50DD           8B46         18            mov	ax,$18[bp]
17851 50E0           0C                     01  or	al,*1
17852 50E2           8946         18            mov	$18[bp],ax
17853                                           !BCC_EOS
17854                                           ! 2872             regs.u.r8.ah = 0x86;
17855                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17856 50E5           B0                     86  mov	al,#$86
17857 50E7           8846         13            mov	$13[bp],al
17858                                           !BCC_EOS
17859                                           ! 2873           }
17860                                           ! 2874           break;
17861                       000050EA            .3C0:
17862 50EA           E9         0343            br 	.384
17863                                           !BCC_EOS
17864                                           ! 2875         case 3:
17865                                           ! 2876 ;
17866                       000050ED            .3C1:
17867                                           !BCC_EOS
17868                                           ! 2877           comm_byte = inhibit_mouse_int_and_events();
17869                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
17870 50ED           E8         0CD3            call	_inhibit_mouse_int_and_events
17871                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
17872 50F0           8846         F7            mov	-9[bp],al
17873                                           !BCC_EOS
17874                                           ! 2878           if (regs.u.r8.bh < 4) {
17875                                           ! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
17876 50F3           8A46         0D            mov	al,$D[bp]
17877 50F6           3C                     04  cmp	al,*4
17878 50F8         0F83         008D            bhis	.3C2
17879                       000050FC            .3C3:
17880                                           ! 2879             ret = send_to_mouse_ctrl(0xE8);
17881                                           ! Debug: list int = const $E8 (used reg = )
17882 50FC           B8                   00E8  mov	ax,#$E8
17883 50FF           50                         push	ax
17884                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17885 5100           E8         0E11            call	_send_to_mouse_ctrl
17886 5103           44                         inc	sp
17887 5104           44                         inc	sp
17888                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17889 5105           8846         F5            mov	-$B[bp],al
17890                                           !BCC_EOS
17891                                           ! 2880             if (ret == 0) {
17892                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
17893 5108           8A46         F5            mov	al,-$B[bp]
17894 510B           84C0                       test	al,al
17895 510D           75           6B            jne 	.3C4
17896                       0000510F            .3C5:
17897                                           ! 2881               ret = get_mouse_data(&mouse_data1);
17898                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17899 510F           8D5E         F4            lea	bx,-$C[bp]
17900 5112           53                         push	bx
17901                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17902 5113           E8         0E48            call	_get_mouse_data
17903 5116           44                         inc	sp
17904 5117           44                         inc	sp
17905                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17906 5118           8846         F5            mov	-$B[bp],al
17907                                           !BCC_EOS
17908                                           ! 2882               if (mouse_data1 != 0xfa)
17909                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17910 511B           8A46         F4            mov	al,-$C[bp]
17911 511E           3C                     FA  cmp	al,#$FA
17912 5120           74           14            je  	.3C6
17913                       00005122            .3C7:
17914                                           ! 2883                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
17915                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17916 5122           8A46         F4            mov	al,-$C[bp]
17917 5125           30E4                       xor	ah,ah
17918 5127           50                         push	ax
17919                                           ! Debug: list * char = .3C8+0 (used reg = )
17920 5128           BB                   D272  mov	bx,#.3C8
17921 512B           53                         push	bx
17922                                           ! Debug: list int = const 7 (used reg = )
17923 512C           B8                   0007  mov	ax,*7
17924 512F           50                         push	ax
17925                                           ! Debug: func () void = bios_printf+0 (used reg = )
17926 5130           E8         B8E8            call	_bios_printf
17927 5133           83C4                   06  add	sp,*6
17928                                           !BCC_EOS
17929                                           ! 2884               ret = send_to_mouse_ctrl(regs.u.r8.bh);
17930                       00005136            .3C6:
17931                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
17932 5136           8A46         0D            mov	al,$D[bp]
17933 5139           30E4                       xor	ah,ah
17934 513B           50                         push	ax
17935                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
17936 513C           E8         0DD5            call	_send_to_mouse_ctrl
17937 513F           44                         inc	sp
17938 5140           44                         inc	sp
17939                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17940 5141           8846         F5            mov	-$B[bp],al
17941                                           !BCC_EOS
17942                                           ! 2885               ret = get_mouse_data(&mouse_data1);
17943                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
17944 5144           8D5E         F4            lea	bx,-$C[bp]
17945 5147           53                         push	bx
17946                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
17947 5148           E8         0E13            call	_get_mouse_data
17948 514B           44                         inc	sp
17949 514C           44                         inc	sp
17950                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
17951 514D           8846         F5            mov	-$B[bp],al
17952                                           !BCC_EOS
17953                                           ! 2886               if (mouse_data1 != 0xfa)
17954                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17955 5150           8A46         F4            mov	al,-$C[bp]
17956 5153           3C                     FA  cmp	al,#$FA
17957 5155           74           14            je  	.3C9
17958                       00005157            .3CA:
17959                                           ! 2887                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
17960                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
17961 5157           8A46         F4            mov	al,-$C[bp]
17962 515A           30E4                       xor	ah,ah
17963 515C           50                         push	ax
17964                                           ! Debug: list * char = .3CB+0 (used reg = )
17965 515D           BB                   D246  mov	bx,#.3CB
17966 5160           53                         push	bx
17967                                           ! Debug: list int = const 7 (used reg = )
17968 5161           B8                   0007  mov	ax,*7
17969 5164           50                         push	ax
17970                                           ! Debug: func () void = bios_printf+0 (used reg = )
17971 5165           E8         B8B3            call	_bios_printf
17972 5168           83C4                   06  add	sp,*6
17973                                           !BCC_EOS
17974                                           ! 2888               FLAGS &= 0xfffe;
17975                       0000516B            .3C9:
17976                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
17977 516B           8B46         18            mov	ax,$18[bp]
17978 516E           24                     FE  and	al,#$FE
17979 5170           8946         18            mov	$18[bp],ax
17980                                           !BCC_EOS
17981                                           ! 2889               regs.u.r8.ah = 0;
17982                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
17983 5173           30C0                       xor	al,al
17984 5175           8846         13            mov	$13[bp],al
17985                                           !BCC_EOS
17986                                           ! 2890             } else {
17987 5178           EB           0D            jmp .3CC
17988                       0000517A            .3C4:
17989                                           ! 2891               FLAGS |= 0x0
17990                                           ! 2891 001;
17991                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
17992 517A           8B46         18            mov	ax,$18[bp]
17993 517D           0C                     01  or	al,*1
17994 517F           8946         18            mov	$18[bp],ax
17995                                           !BCC_EOS
17996                                           ! 2892               regs.u.r8.ah = 0x86;
17997                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
17998 5182           B0                     86  mov	al,#$86
17999 5184           8846         13            mov	$13[bp],al
18000                                           !BCC_EOS
18001                                           ! 2893             }
18002                                           ! 2894           } else {
18003                       00005187            .3CC:
18004 5187           EB           0D            jmp .3CD
18005                       00005189            .3C2:
18006                                           ! 2895             FLAGS |= 0x0001;
18007                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18008 5189           8B46         18            mov	ax,$18[bp]
18009 518C           0C                     01  or	al,*1
18010 518E           8946         18            mov	$18[bp],ax
18011                                           !BCC_EOS
18012                                           ! 2896             regs.u.r8.ah = 0x86;
18013                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18014 5191           B0                     86  mov	al,#$86
18015 5193           8846         13            mov	$13[bp],al
18016                                           !BCC_EOS
18017                                           ! 2897           }
18018                                           ! 2898           set_kbd_command_byte(comm_byte);
18019                       00005196            .3CD:
18020                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18021 5196           8A46         F7            mov	al,-9[bp]
18022 5199           30E4                       xor	ah,ah
18023 519B           50                         push	ax
18024                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18025 519C           E8         0E00            call	_set_kbd_command_byte
18026 519F           44                         inc	sp
18027 51A0           44                         inc	sp
18028                                           !BCC_EOS
18029                                           ! 2899           break;
18030 51A1           E9         028C            br 	.384
18031                                           !BCC_EOS
18032                                           ! 2900         case 4:
18033                                           ! 2901 ;
18034                       000051A4            .3CE:
18035                                           !BCC_EOS
18036                                           ! 2902           inhibit_mouse_int_and_events();
18037                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18038 51A4           E8         0C1C            call	_inhibit_mouse_int_and_events
18039                                           !BCC_EOS
18040                                           ! 2903           ret = send_to_mouse_ctrl(0xF2);
18041                                           ! Debug: list int = const $F2 (used reg = )
18042 51A7           B8                   00F2  mov	ax,#$F2
18043 51AA           50                         push	ax
18044                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18045 51AB           E8         0D66            call	_send_to_mouse_ctrl
18046 51AE           44                         inc	sp
18047 51AF           44                         inc	sp
18048                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18049 51B0           8846         F5            mov	-$B[bp],al
18050                                           !BCC_EOS
18051                                           ! 2904           if (ret == 0) {
18052                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18053 51B3           8A46         F5            mov	al,-$B[bp]
18054 51B6           84C0                       test	al,al
18055 51B8           75           2D            jne 	.3CF
18056                       000051BA            .3D0:
18057                                           ! 2905             ret = get_mouse_data(&mouse_data1);
18058                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18059 51BA           8D5E         F4            lea	bx,-$C[bp]
18060 51BD           53                         push	bx
18061                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18062 51BE           E8         0D9D            call	_get_mouse_data
18063 51C1           44                         inc	sp
18064 51C2           44                         inc	sp
18065                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18066 51C3           8846         F5            mov	-$B[bp],al
18067                                           !BCC_EOS
18068                                           ! 2906             ret = get_mouse_data(&mouse_data2);
18069                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18070 51C6           8D5E         F3            lea	bx,-$D[bp]
18071 51C9           53                         push	bx
18072                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18073 51CA           E8         0D91            call	_get_mouse_data
18074 51CD           44                         inc	sp
18075 51CE           44                         inc	sp
18076                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18077 51CF           8846         F5            mov	-$B[bp],al
18078                                           !BCC_EOS
18079                                           ! 2907             FLAGS &= 0xfffe;
18080                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18081 51D2           8B46         18            mov	ax,$18[bp]
18082 51D5           24                     FE  and	al,#$FE
18083 51D7           8946         18            mov	$18[bp],ax
18084                                           !BCC_EOS
18085                                           ! 2908             regs.u.r8.ah = 0;
18086                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18087 51DA           30C0                       xor	al,al
18088 51DC           8846         13            mov	$13[bp],al
18089                                           !BCC_EOS
18090                                           ! 2909             regs.u.r8.bh = mouse_data2;
18091                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
18092 51DF           8A46         F3            mov	al,-$D[bp]
18093 51E2           8846         0D            mov	$D[bp],al
18094                                           !BCC_EOS
18095                                           ! 2910           } else {
18096 51E5           EB           0D            jmp .3D1
18097                       000051E7            .3CF:
18098                                           ! 2911             FLAGS |= 0x0001;
18099                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18100 51E7           8B46         18            mov	ax,$18[bp]
18101 51EA           0C                     01  or	al,*1
18102 51EC           8946         18            mov	$18[bp],ax
18103                                           !BCC_EOS
18104                                           ! 2912             regs.u.r8.ah = 0x86;
18105                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18106 51EF           B0                     86  mov	al,#$86
18107 51F1           8846         13            mov	$13[bp],al
18108                                           !BCC_EOS
18109                                           ! 2913           }
18110                                           ! 2914           break;
18111                       000051F4            .3D1:
18112 51F4           E9         0239            br 	.384
18113                                           !BCC_EOS
18114                                           ! 2915         case 6:
18115                                           ! 2916 ;
18116                       000051F7            .3D2:
18117                                           !BCC_EOS
18118                                           ! 2917           switch (regs.u.r8.bh) {
18119 51F7           8A46         0D            mov	al,$D[bp]
18120 51FA           E9         015E            br 	.3D5
18121                                           ! 2918             case 0:
18122                                           ! 2919               comm_byte = inhibit_mouse_int_and_events();
18123                       000051FD            .3D6:
18124                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18125 51FD           E8         0BC3            call	_inhibit_mouse_int_and_events
18126                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18127 5200           8846         F7            mov	-9[bp],al
18128                                           !BCC_EOS
18129                                           ! 2920               ret = send_to_mouse_ctrl(0xE9);
18130                                           ! Debug: list int = const $E9 (used reg = )
18131 5203           B8                   00E9  mov	ax,#$E9
18132 5206           50                         push	ax
18133                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18134 5207           E8         0D0A            call	_send_to_mouse_ctrl
18135 520A           44                         inc	sp
18136 520B           44                         inc	sp
18137                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18138 520C           8846         F5            mov	-$B[bp],al
18139                                           !BCC_EOS
18140                                           ! 2921               if (ret == 0) {
18141                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18142 520F           8A46         F5            mov	al,-$B[bp]
18143 5212           84C0                       test	al,al
18144 5214         0F85         0099            bne 	.3D7
18145                       00005218            .3D8:
18146                                           ! 2922                 ret = get_mouse_data(&mouse_data1);
18147                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18148 5218           8D5E         F4            lea	bx,-$C[bp]
18149 521B           53                         push	bx
18150                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18151 521C           E8         0D3F            call	_get_mouse_data
18152 521F           44                         inc	sp
18153 5220           44                         inc	sp
18154                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18155 5221           8846         F5            mov	-$B[bp],al
18156                                           !BCC_EOS
18157                                           ! 2923                 if (mouse_data1 != 0xfa)
18158                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18159 5224           8A46         F4            mov	al,-$C[bp]
18160 5227           3C                     FA  cmp	al,#$FA
18161 5229           74           14            je  	.3D9
18162                       0000522B            .3DA:
18163                                           ! 2924                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
18164                                           ! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18165 522B           8A46         F4            mov	al,-$C[bp]
18166 522E           30E4                       xor	ah,ah
18167 5230           50                         push	ax
18168                                           ! Debug: list * char = .3DB+0 (used reg = )
18169 5231           BB                   D21A  mov	bx,#.3DB
18170 5234           53                         push	bx
18171                                           ! Debug: list int = const 7 (used reg = )
18172 5235           B8                   0007  mov	ax,*7
18173 5238           50                         push	ax
18174                                           ! Debug: func () void = bios_printf+0 (used reg = )
18175 5239           E8         B7DF            call	_bios_printf
18176 523C           83C4                   06  add	sp,*6
18177                                           !BCC_EOS
18178                                           ! 2925                 if (ret == 0) {
18179                       0000523F            .3D9:
18180                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18181 523F           8A46         F5            mov	al,-$B[bp]
18182 5242           84C0                       test	al,al
18183 5244         0F85         0069            bne 	.3DC
18184                       00005248            .3DD:
18185                                           ! 2926                   ret = get_mouse_data(&mouse_data1);
18186                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18187 5248           8D5E         F4            lea	bx,-$C[bp]
18188 524B           53                         push	bx
18189                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18190 524C           E8         0D0F            call	_get_mouse_data
18191 524F           44                         inc	sp
18192 5250           44                         inc	sp
18193                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18194 5251           8846         F5            mov	-$B[bp],al
18195                                           !BCC_EOS
18196                                           ! 2927                   if ( ret == 0 ) {
18197                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18198 5254           8A46         F5            mov	al,-$B[bp]
18199 5257           84C0                       test	al,al
18200 5259         0F85         0054            bne 	.3DE
18201                       0000525D            .3DF:
18202                                           ! 2928                     ret = get_mouse_data(&mouse_data2);
18203                                           ! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
18204 525D           8D5E         F3            lea	bx,-$D[bp]
18205 5260           53                         push	bx
18206                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18207 5261           E8         0CFA            call	_get_mouse_data
18208 5264           44                         inc	sp
18209 5265           44                         inc	sp
18210                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18211 5266           8846         F5            mov	-$B[bp],al
18212                                           !BCC_EOS
18213                                           ! 2929                     if ( ret == 0 ) {
18214                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18215 5269           8A46         F5            mov	al,-$B[bp]
18216 526C           84C0                       test	al,al
18217 526E           75           41            jne 	.3E0
18218                       00005270            .3E1:
18219                                           ! 2930                       ret = get_mouse_data(&mouse_data3);
18220                                           ! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
18221 5270           8D5E         F2            lea	bx,-$E[bp]
18222 5273           53                         push	bx
18223                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18224 5274           E8         0CE7            call	_get_mouse_data
18225 5277           44                         inc	sp
18226 5278           44                         inc	sp
18227                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18228 5279           8846         F5            mov	-$B[bp],al
18229                                           !BCC_EOS
18230                                           ! 2931                       if ( ret == 0 ) {
18231                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18232 527C           8A46         F5            mov	al,-$B[bp]
18233 527F           84C0                       test	al,al
18234 5281           75           2E            jne 	.3E2
18235                       00005283            .3E3:
18236                                           ! 2932                         FLAGS &= 0xfffe;
18237                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18238 5283           8B46         18            mov	ax,$18[bp]
18239 5286           24                     FE  and	al,#$FE
18240 5288           8946         18            mov	$18[bp],ax
18241                                           !BCC_EOS
18242                                           ! 2933                         regs.u.r8.ah = 0;
18243                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18244 528B           30C0                       xor	al,al
18245 528D           8846         13            mov	$13[bp],al
18246                                           !BCC_EOS
18247                                           ! 2934                         regs.u.r8.bl = mouse_data1;
18248                                           ! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
18249 5290           8A46         F4            mov	al,-$C[bp]
18250 5293           8846         0C            mov	$C[bp],al
18251                                           !BCC_EOS
18252                                           ! 2935                         regs.u.r8.cl = mouse_data2;
18253                                           ! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
18254 5296           8A46         F3            mov	al,-$D[bp]
18255 5299           8846         10            mov	$10[bp],al
18256                                           !BCC_EOS
18257                                           ! 2936                         regs.u.r8.dl = mouse_data3;
18258                                           ! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
18259 529C           8A46         F2            mov	al,-$E[bp]
18260 529F           8846         0E            mov	$E[bp],al
18261                                           !BCC_EOS
18262                                           ! 2937                         set_kbd_command_byte(comm_byte);
18263                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18264 52A2           8A46         F7            mov	al,-9[bp]
18265 52A5           30E4                       xor	ah,ah
18266 52A7           50                         push	ax
18267                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18268 52A8           E8         0CF4            call	_set_kbd_command_byte
18269 52AB           44                         inc	sp
18270 52AC           44                         inc	sp
18271                                           !BCC_EOS
18272                                           ! 2938                         return;
18273 52AD           89EC                       mov	sp,bp
18274 52AF           5D                         pop	bp
18275 52B0           C3                         ret
18276                                           !BCC_EOS
18277                                           ! 2939                         }
18278                                           ! 2940                       }
18279                       000052B1            .3E2:
18280                                           ! 2941                     }
18281                       000052B1            .3E0:
18282                                           ! 2942                   }
18283                       000052B1            .3DE:
18284                                           ! 2943                 }
18285                       000052B1            .3DC:
18286                                           ! 2944               FLAGS |= 0x0001;
18287                       000052B1            .3D7:
18288                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18289 52B1           8B46         18            mov	ax,$18[bp]
18290 52B4           0C                     01  or	al,*1
18291 52B6           8946         18            mov	$18[bp],ax
18292                                           !BCC_EOS
18293                                           ! 2945               regs.u.r8.ah = ret;
18294                                           ! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
18295 52B9           8A46         F5            mov	al,-$B[bp]
18296 52BC           8846         13            mov	$13[bp],al
18297                                           !BCC_EOS
18298                                           ! 2946               set_kbd_command_byte(comm_byte);
18299                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18300 52BF           8A46         F7            mov	al,-9[bp]
18301 52C2           30E4                       xor	ah,ah
18302 52C4           50                         push	ax
18303                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18304 52C5           E8         0CD7            call	_set_kbd_command_byte
18305 52C8           44                         inc	sp
18306 52C9           44                         inc	sp
18307                                           !BCC_EOS
18308                                           ! 2947               return;
18309 52CA           89EC                       mov	sp,bp
18310 52CC           5D                         pop	bp
18311 52CD           C3                         ret
18312                                           !BCC_EOS
18313                                           ! 2948             case 1:
18314                                           ! 2949             case 2:
18315                       000052CE            .3E4:
18316                                           ! 2950               comm_byte = inhibit_mouse_int_and_events();
18317                       000052CE            .3E5:
18318                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18319 52CE           E8         0AF2            call	_inhibit_mouse_int_and_events
18320                                           ! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
18321 52D1           8846         F7            mov	-9[bp],al
18322                                           !BCC_EOS
18323                                           ! 2951           
18324                                           ! 2951     if (regs.u.r8.bh == 1) {
18325                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
18326 52D4           8A46         0D            mov	al,$D[bp]
18327 52D7           3C                     01  cmp	al,*1
18328 52D9           75           0E            jne 	.3E6
18329                       000052DB            .3E7:
18330                                           ! 2952                 ret = send_to_mouse_ctrl(0xE6);
18331                                           ! Debug: list int = const $E6 (used reg = )
18332 52DB           B8                   00E6  mov	ax,#$E6
18333 52DE           50                         push	ax
18334                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18335 52DF           E8         0C32            call	_send_to_mouse_ctrl
18336 52E2           44                         inc	sp
18337 52E3           44                         inc	sp
18338                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18339 52E4           8846         F5            mov	-$B[bp],al
18340                                           !BCC_EOS
18341                                           ! 2953               } else {
18342 52E7           EB           0C            jmp .3E8
18343                       000052E9            .3E6:
18344                                           ! 2954                 ret = send_to_mouse_ctrl(0xE7);
18345                                           ! Debug: list int = const $E7 (used reg = )
18346 52E9           B8                   00E7  mov	ax,#$E7
18347 52EC           50                         push	ax
18348                                           ! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
18349 52ED           E8         0C24            call	_send_to_mouse_ctrl
18350 52F0           44                         inc	sp
18351 52F1           44                         inc	sp
18352                                           ! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18353 52F2           8846         F5            mov	-$B[bp],al
18354                                           !BCC_EOS
18355                                           ! 2955               }
18356                                           ! 2956               if (ret == 0) {
18357                       000052F5            .3E8:
18358                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18359 52F5           8A46         F5            mov	al,-$B[bp]
18360 52F8           84C0                       test	al,al
18361 52FA           75           19            jne 	.3E9
18362                       000052FC            .3EA:
18363                                           ! 2957                 get_mouse_data(&mouse_data1);
18364                                           ! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
18365 52FC           8D5E         F4            lea	bx,-$C[bp]
18366 52FF           53                         push	bx
18367                                           ! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
18368 5300           E8         0C5B            call	_get_mouse_data
18369 5303           44                         inc	sp
18370 5304           44                         inc	sp
18371                                           !BCC_EOS
18372                                           ! 2958                 ret = (mouse_data1 != 0xFA);
18373                                           ! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
18374 5305           8A46         F4            mov	al,-$C[bp]
18375 5308           3C                     FA  cmp	al,#$FA
18376 530A           74           04            je 	.3EB
18377 530C           B0                     01  mov	al,*1
18378 530E           EB           02            jmp	.3EC
18379                       00005310            .3EB:
18380 5310           30C0                       xor	al,al
18381                       00005312            .3EC:
18382                                           ! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
18383 5312           8846         F5            mov	-$B[bp],al
18384                                           !BCC_EOS
18385                                           ! 2959               }
18386                                           ! 2960               if (ret == 0) {
18387                       00005315            .3E9:
18388                                           ! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
18389 5315           8A46         F5            mov	al,-$B[bp]
18390 5318           84C0                       test	al,al
18391 531A           75           0F            jne 	.3ED
18392                       0000531C            .3EE:
18393                                           ! 2961                 FLAGS &= 0xfffe;
18394                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18395 531C           8B46         18            mov	ax,$18[bp]
18396 531F           24                     FE  and	al,#$FE
18397 5321           8946         18            mov	$18[bp],ax
18398                                           !BCC_EOS
18399                                           ! 2962                 regs.u.r8.ah = 0;
18400                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18401 5324           30C0                       xor	al,al
18402 5326           8846         13            mov	$13[bp],al
18403                                           !BCC_EOS
18404                                           ! 2963               } else {
18405 5329           EB           0D            jmp .3EF
18406                       0000532B            .3ED:
18407                                           ! 2964                 FLAGS |= 0x0001;
18408                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18409 532B           8B46         18            mov	ax,$18[bp]
18410 532E           0C                     01  or	al,*1
18411 5330           8946         18            mov	$18[bp],ax
18412                                           !BCC_EOS
18413                                           ! 2965                 regs.u.r8.ah = 0x86;
18414                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18415 5333           B0                     86  mov	al,#$86
18416 5335           8846         13            mov	$13[bp],al
18417                                           !BCC_EOS
18418                                           ! 2966               }
18419                                           ! 2967               set_kbd_command_byte(comm_byte);
18420                       00005338            .3EF:
18421                                           ! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
18422 5338           8A46         F7            mov	al,-9[bp]
18423 533B           30E4                       xor	ah,ah
18424 533D           50                         push	ax
18425                                           ! Debug: func () void = set_kbd_command_byte+0 (used reg = )
18426 533E           E8         0C5E            call	_set_kbd_command_byte
18427 5341           44                         inc	sp
18428 5342           44                         inc	sp
18429                                           !BCC_EOS
18430                                           ! 2968               break;
18431 5343           EB           2A            jmp .3D3
18432                                           !BCC_EOS
18433                                           ! 2969             default:
18434                                           ! 2970               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
18435                       00005345            .3F0:
18436                                           ! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
18437 5345           8A46         0D            mov	al,$D[bp]
18438 5348           30E4                       xor	ah,ah
18439 534A           50                         push	ax
18440                                           ! Debug: list * char = .3F1+0 (used reg = )
18441 534B           BB                   D200  mov	bx,#.3F1
18442 534E           53                         push	bx
18443                                           ! Debug: list int = const 7 (used reg = )
18444 534F           B8                   0007  mov	ax,*7
18445 5352           50                         push	ax
18446                                           ! Debug: func () void = bios_printf+0 (used reg = )
18447 5353           E8         B6C5            call	_bios_printf
18448 5356           83C4                   06  add	sp,*6
18449                                           !BCC_EOS
18450                                           ! 2971             }
18451                                           ! 2972           break;
18452 5359           EB           14            jmp .3D3
18453                       0000535B            .3D5:
18454 535B           2C                     00  sub	al,*0
18455 535D         0F84         FE9C            beq 	.3D6
18456 5361           2C                     01  sub	al,*1
18457 5363         0F84         FF67            beq 	.3E4
18458 5367           2C                     01  sub	al,*1
18459 5369         0F84         FF61            beq 	.3E5
18460 536D           EB           D6            jmp	.3F0
18461                       0000536F            .3D3:
18462 536F           E9         00BE            br 	.384
18463                                           !BCC_EOS
18464                                           ! 2973         case 7:
18465                                           ! 2974 ;
18466                       00005372            .3F2:
18467                                           !BCC_EOS
18468                                           ! 2975           mouse_driver_seg = ES;
18469                                           ! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18470 5372           8B46         14            mov	ax,$14[bp]
18471 5375           8946         FA            mov	-6[bp],ax
18472                                           !BCC_EOS
18473                                           ! 2976           mouse_driver_offset = regs.u.r16.bx;
18474                                           ! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18475 5378           8B46         0C            mov	ax,$C[bp]
18476 537B           8946         F8            mov	-8[bp],ax
18477                                           !BCC_EOS
18478                                           ! 2977           write_word(ebda_seg, 0x0022, mouse_driver_offset);
18479                                           ! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18480 537E           FF76         F8            push	-8[bp]
18481                                           ! Debug: list int = const $22 (used reg = )
18482 5381           B8                   0022  mov	ax,*$22
18483 5384           50                         push	ax
18484                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18485 5385           FF76         FE            push	-2[bp]
18486                                           ! Debug: func () void = write_word+0 (used reg = )
18487 5388           E8         B2A7            call	_write_word
18488 538B           83C4                   06  add	sp,*6
18489                                           !BCC_EOS
18490                                           ! 2978           write_word(ebda_seg, 0x0024, mouse_driver_seg);
18491                                           ! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18492 538E           FF76         FA            push	-6[bp]
18493                                           ! Debug: list int = const $24 (used reg = )
18494 5391           B8                   0024  mov	ax,*$24
18495 5394           50                         push	ax
18496                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18497 5395           FF76         FE            push	-2[bp]
18498                                           ! Debug: func () void = write_word+0 (used reg = )
18499 5398           E8         B297            call	_write_word
18500 539B           83C4                   06  add	sp,*6
18501                                           !BCC_EOS
18502                                           ! 2979           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
18503                                           ! Debug: list int = const $27 (used reg = )
18504 539E           B8                   0027  mov	ax,*$27
18505 53A1           50                         push	ax
18506                                           ! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
18507 53A2           FF76         FE            push	-2[bp]
18508                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
18509 53A5           E8         B24C            call	_read_byte
18510 53A8           83C4                   04  add	sp,*4
18511                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18512 53AB           8846         FC            mov	-4[bp],al
18513                                           !BCC_EOS
18514                                           ! 2980           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
18515                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
18516 53AE           8B46         F8            mov	ax,-8[bp]
18517 53B1           85C0                       test	ax,ax
18518 53B3           75           1D            jne 	.3F3
18519                       000053B5            .3F5:
18520                                           ! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
18521 53B5           8B46         FA            mov	ax,-6[bp]
18522 53B8           85C0                       test	ax,ax
18523 53BA           75           16            jne 	.3F3
18524                       000053BC            .3F4:
18525                                           ! 2981             if ( (mouse_flags_2 & 0x80) != 0 ) {
18526                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18527 53BC           8A46         FC            mov	al,-4[bp]
18528 53BF           24                     80  and	al,#$80
18529                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
18530 53C1           84C0                       test	al,al
18531 53C3           74           0B            je  	.3F6
18532                       000053C5            .3F7:
18533                                           ! 2982               mouse_flags_2 &= ~0x80;
18534                                           ! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18535 53C5           8A46         FC            mov	al,-4[bp]
18536 53C8           24                     7F  and	al,*$7F
18537 53CA           8846         FC            mov	-4[bp],al
18538                                           !BCC_EOS
18539                                           ! 2983               inhibit_mouse_int_and_events();
18540                                           ! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
18541 53CD           E8         09F3            call	_inhibit_mouse_int_and_events
18542                                           !BCC_EOS
18543                                           ! 2984               }
18544                                           ! 2985             }
18545                       000053D0            .3F6:
18546                                           ! 2986           else {
18547 53D0           EB           08            jmp .3F8
18548                       000053D2            .3F3:
18549                                           ! 2987             mouse_flags_2 |= 0x80;
18550                                           ! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18551 53D2           8A46         FC            mov	al,-4[bp]
18552 53D5           0C                     80  or	al,#$80
18553 53D7           8846         FC            mov	-4[bp],al
18554                                           !BCC_EOS
18555                                           ! 2988             }
18556                                           ! 2989           write_byte(ebda_seg, 0x0027, mouse_flags_2);
18557                       000053DA            .3F8:
18558                                           ! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
18559 53DA           8A46         FC            mov	al,-4[bp]
18560 53DD           30E4                       xor	ah,ah
18561 53DF           50                         push	ax
18562                                           ! Debug: list int = const $27 (used reg = )
18563 53E0           B8                   0027  mov	ax,*$27
18564 53E3           50                         push	ax
18565                                           ! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
18566 53E4           FF76         FE            push	-2[bp]
18567                                           ! Debug: func () void = write_byte+0 (used reg = )
18568 53E7           E8         B230            call	_write_byte
18569 53EA           83C4                   06  add	sp,*6
18570                                           !BCC_EOS
18571                                           ! 2990           FLAGS &= 0xfffe;
18572                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
18573 53ED           8B46         18            mov	ax,$18[bp]
18574 53F0           24                     FE  and	al,#$FE
18575 53F2           8946         18            mov	$18[bp],ax
18576                                           !BCC_EOS
18577                                           ! 2991           regs.u.r8.ah = 0;
18578                                           ! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
18579 53F5           30C0                       xor	al,al
18580 53F7           8846         13            mov	$13[bp],al
18581                                           !BCC_EOS
18582                                           ! 2992           break;
18583 53FA           EB           34            jmp .384
18584                                           !BCC_EOS
18585                                           ! 2993         default:
18586                                           ! 2994 ;
18587                       000053FC            .3F9:
18588                                           !BCC_EOS
18589                                           ! 2995           regs.u.r8.ah = 1;
18590                                           ! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
18591 53FC           B0                     01  mov	al,*1
18592 53FE           8846         13            mov	$13[bp],al
18593                                           !BCC_EOS
18594                                           ! 2996           FLAGS |= 0x0001;
18595                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18596 5401           8B46         18            mov	ax,$18[bp]
18597 5404           0C                     01  or	al,*1
18598 5406           8946         18            mov	$18[bp],ax
18599                                           !BCC_EOS
18600                                           ! 2997         }
18601                                           ! 2998       break;
18602 5409           EB           25            jmp .384
18603                       0000540B            .386:
18604 540B           2C                     00  sub	al,*0
18605 540D           72           ED            jb 	.3F9
18606 540F           3C                     07  cmp	al,*7
18607 5411           77           1B            ja  	.3FA
18608 5413           30E4                       xor	ah,ah
18609 5415           D1E0                       shl	ax,*1
18610 5417           89C3                       mov	bx,ax
18611 5419           2E                         seg	cs
18612 541A           FFA7       541E            br	.3FB[bx]
18613                       0000541E            .3FB:
18614 541E                      4E09            .word	.387
18615 5420                      4F09            .word	.39A
18616 5422                      501F            .word	.3AD
18617 5424                      50ED            .word	.3C1
18618 5426                      51A4            .word	.3CE
18619 5428                      4F09            .word	.39B
18620 542A                      51F7            .word	.3D2
18621 542C                      5372            .word	.3F2
18622                       0000542E            .3FA:
18623 542E           EB           CC            jmp	.3F9
18624                       00005430            .384:
18625 5430           EB           19            jmp .380
18626                                           !BCC_EOS
18627                                           ! 2999     default:
18628                                           ! 3000       ;
18629                       00005432            .3FC:
18630                                           !BCC_EOS
18631                                           ! 3001       FLAGS |= 0x0001;
18632                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
18633 5432           8B46         18            mov	ax,$18[bp]
18634 5435           0C                     01  or	al,*1
18635 5437           8946         18            mov	$18[bp],ax
18636                                           !BCC_EOS
18637                                           ! 3002       regs.u.r8.ah = 0x86;
18638                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
18639 543A           B0                     86  mov	al,#$86
18640 543C           8846         13            mov	$13[bp],al
18641                                           !BCC_EOS
18642                                           ! 3003       break;
18643 543F           EB           0A            jmp .380
18644                                           !BCC_EOS
18645                                           ! 3004     }
18646                                           ! 3005 }
18647 5441           EB           08            jmp .380
18648                       00005443            .382:
18649 5443           2C                     C2  sub	al,#$C2
18650 5445         0F84         F9BA            beq 	.383
18651 5449           EB           E7            jmp	.3FC
18652                       0000544B            .380:
18653                       FFFFFFF0            ..FFF6	=	-$10
18654 544B           89EC                       mov	sp,bp
18655 544D           5D                         pop	bp
18656 544E           C3                         ret
18657                                           ! 3006 void set_e820_range(ES, DI, start, end, type)
18658                                           ! Register BX used in function int15_function_mouse
18659                                           ! 3007      Bit16u ES;
18660                                           export	_set_e820_range
18661                       0000544F            _set_e820_range:
18662                                           !BCC_EOS
18663                                           ! 3008      Bit16u DI;
18664                                           !BCC_EOS
18665                                           ! 3009      Bit32u start;
18666                                           !BCC_EOS
18667                                           ! 3010      Bit32u end;
18668                                           !BCC_EOS
18669                                           ! 3011      Bit16u type;
18670                                           !BCC_EOS
18671                                           ! 3012 {
18672                                           ! 3013     write_word(ES, DI, start);
18673 544F           55                         push	bp
18674 5450           89E5                       mov	bp,sp
18675                                           ! Debug: list unsigned long start = [S+2+6] (used reg = )
18676 5452           FF76         0A            push	$A[bp]
18677 5455           FF76         08            push	8[bp]
18678                                           ! Debug: list unsigned short DI = [S+6+4] (used reg = )
18679 5458           FF76         06            push	6[bp]
18680                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18681 545B           FF76         04            push	4[bp]
18682                                           ! Debug: func () void = write_word+0 (used reg = )
18683 545E           E8         B1D1            call	_write_word
18684 5461           89EC                       mov	sp,bp
18685                                           !BCC_EOS
18686                                           ! 3014     write_word(ES, DI+2, start >> 16);
18687                                           ! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
18688 5463           8B46         08            mov	ax,8[bp]
18689 5466           8B5E         0A            mov	bx,$A[bp]
18690 5469           93                         xchg	bx,ax
18691 546A           31DB                       xor	bx,bx
18692                                           ! Debug: list unsigned long = bx+0 (used reg = )
18693 546C           53                         push	bx
18694 546D           50                         push	ax
18695                                           ! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
18696 546E           8B46         06            mov	ax,6[bp]
18697                                           ! Debug: list unsigned int = ax+2 (used reg = )
18698 5471           40                         inc	ax
18699 5472           40                         inc	ax
18700 5473           50                         push	ax
18701                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18702 5474           FF76         04            push	4[bp]
18703                                           ! Debug: func () void = write_word+0 (used reg = )
18704 5477           E8         B1B8            call	_write_word
18705 547A           89EC                       mov	sp,bp
18706                                           !BCC_EOS
18707                                           ! 3015     write_word(ES, DI+4, 0x00);
18708                                           ! Debug: list int = const 0 (used reg = )
18709 547C           31C0                       xor	ax,ax
18710 547E           50                         push	ax
18711                                           ! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
18712 547F           8B46         06            mov	ax,6[bp]
18713                                           ! Debug: list unsigned int = ax+4 (used reg = )
18714 5482           05                   0004  add	ax,*4
18715 5485           50                         push	ax
18716                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18717 5486           FF76         04            push	4[bp]
18718                                           ! Debug: func () void = write_word+0 (used reg = )
18719 5489           E8         B1A6            call	_write_word
18720 548C           89EC                       mov	sp,bp
18721                                           !BCC_EOS
18722                                           ! 3016     write_word(ES, DI+6, 0x00);
18723                                           ! Debug: list int = const 0 (used reg = )
18724 548E           31C0                       xor	ax,ax
18725 5490           50                         push	ax
18726                                           ! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
18727 5491           8B46         06            mov	ax,6[bp]
18728                                           ! Debug: list unsigned int = ax+6 (used reg = )
18729 5494           05                   0006  add	ax,*6
18730 5497           50                         push	ax
18731                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18732 5498           FF76         04            push	4[bp]
18733                                           ! Debug: func () void = write_word+0 (used reg = )
18734 549B           E8         B194            call	_write_word
18735 549E           89EC                       mov	sp,bp
18736                                           !BCC_EOS
18737                                           ! 3017     end -= start;
18738                                           ! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
18739 54A0           8B46         0C            mov	ax,$C[bp]
18740 54A3           8B5E         0E            mov	bx,$E[bp]
18741 54A6           8D7E         08            lea	di,8[bp]
18742 54A9           E8         AC35            call	lsubul
18743 54AC           8946         0C            mov	$C[bp],ax
18744 54AF           895E         0E            mov	$E[bp],bx
18745                                           !BCC_EOS
18746                                           ! 3018     write_word(ES, DI+8, end);
18747                                           ! Debug: list unsigned long end = [S+2+$A] (used reg = )
18748 54B2           FF76         0E            push	$E[bp]
18749 54B5           FF76         0C            push	$C[bp]
18750                                           ! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
18751 54B8           8B46         06            mov	ax,6[bp]
18752                                           ! Debug: list unsigned int = ax+8 (used reg = )
18753 54BB           05                   0008  add	ax,*8
18754 54BE           50                         push	ax
18755                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18756 54BF           FF76         04            push	4[bp]
18757                                           ! Debug: func () void = write_word+0 (used reg = )
18758 54C2           E8         B16D            call	_write_word
18759 54C5           89EC                       mov	sp,bp
18760                                           !BCC_EOS
18761                                           ! 3019     write_word(ES, DI+10, end >> 16);
18762                                           ! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
18763 54C7           8B46         0C            mov	ax,$C[bp]
18764 54CA           8B5E         0E            mov	bx,$E[bp]
18765 54CD           93                         xchg	bx,ax
18766 54CE           31DB                       xor	bx,bx
18767                                           ! Debug: list unsigned long = bx+0 (used reg = )
18768 54D0           53                         push	bx
18769 54D1           50                         push	ax
18770                                           ! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
18771 54D2           8B46         06            mov	ax,6[bp]
18772                                           ! Debug: list unsigned int = ax+$A (used reg = )
18773 54D5           05                   000A  add	ax,*$A
18774 54D8           50                         push	ax
18775                                           ! Debug: list unsigned short ES = [S+8+2] (used reg = )
18776 54D9           FF76         04            push	4[bp]
18777                                           ! Debug: func () void = write_word+0 (used reg = )
18778 54DC           E8         B153            call	_write_word
18779 54DF           89EC                       mov	sp,bp
18780                                           !BCC_EOS
18781                                           ! 3020     write_word(ES, DI+12, 0x0000);
18782                                           ! Debug: list int = const 0 (used reg = )
18783 54E1           31C0                       xor	ax,ax
18784 54E3           50                         push	ax
18785                                           ! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
18786 54E4           8B46         06            mov	ax,6[bp]
18787                                           ! Debug: list unsigned int = ax+$C (used reg = )
18788 54E7           05                   000C  add	ax,*$C
18789 54EA           50                         push	ax
18790                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18791 54EB           FF76         04            push	4[bp]
18792                                           ! Debug: func () void = write_word+0 (used reg = )
18793 54EE           E8         B141            call	_write_word
18794 54F1           89EC                       mov	sp,bp
18795                                           !BCC_EOS
18796                                           ! 3021     write_word(ES, DI+14, 0x0000);
18797                                           ! Debug: list int = const 0 (used reg = )
18798 54F3           31C0                       xor	ax,ax
18799 54F5           50                         push	ax
18800                                           ! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
18801 54F6           8B46         06            mov	ax,6[bp]
18802                                           ! Debug: list unsigned int = ax+$E (used reg = )
18803 54F9           05                   000E  add	ax,*$E
18804 54FC           50                         push	ax
18805                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18806 54FD           FF76         04            push	4[bp]
18807                                           ! Debug: func () void = write_word+0 (used reg = )
18808 5500           E8         B12F            call	_write_word
18809 5503           89EC                       mov	sp,bp
18810                                           !BCC_EOS
18811                                           ! 3022     write_word(ES
18812                                           ! 3022 , DI+16, type);
18813                                           ! Debug: list unsigned short type = [S+2+$E] (used reg = )
18814 5505           FF76         10            push	$10[bp]
18815                                           ! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
18816 5508           8B46         06            mov	ax,6[bp]
18817                                           ! Debug: list unsigned int = ax+$10 (used reg = )
18818 550B           05                   0010  add	ax,*$10
18819 550E           50                         push	ax
18820                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18821 550F           FF76         04            push	4[bp]
18822                                           ! Debug: func () void = write_word+0 (used reg = )
18823 5512           E8         B11D            call	_write_word
18824 5515           89EC                       mov	sp,bp
18825                                           !BCC_EOS
18826                                           ! 3023     write_word(ES, DI+18, 0x0);
18827                                           ! Debug: list int = const 0 (used reg = )
18828 5517           31C0                       xor	ax,ax
18829 5519           50                         push	ax
18830                                           ! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
18831 551A           8B46         06            mov	ax,6[bp]
18832                                           ! Debug: list unsigned int = ax+$12 (used reg = )
18833 551D           05                   0012  add	ax,*$12
18834 5520           50                         push	ax
18835                                           ! Debug: list unsigned short ES = [S+6+2] (used reg = )
18836 5521           FF76         04            push	4[bp]
18837                                           ! Debug: func () void = write_word+0 (used reg = )
18838 5524           E8         B10B            call	_write_word
18839 5527           89EC                       mov	sp,bp
18840                                           !BCC_EOS
18841                                           ! 3024 }
18842 5529           5D                         pop	bp
18843 552A           C3                         ret
18844                                           ! 3025   void
18845                                           ! Register BX used in function set_e820_range
18846                                           ! 3026 int15_function32(regs, ES, DS, FLAGS)
18847                                           ! 3027   pushad_regs_t regs;
18848                                           export	_int15_function32
18849                       0000552B            _int15_function32:
18850                                           !BCC_EOS
18851                                           ! 3028   Bit16u ES, DS, FLAGS;
18852                                           !BCC_EOS
18853                                           ! 3029 {
18854                                           ! 3030   Bit32u extended_memory_size=0;
18855 552B           55                         push	bp
18856 552C           89E5                       mov	bp,sp
18857 552E           83C4                   FC  add	sp,*-4
18858                                           ! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
18859 5531           31C0                       xor	ax,ax
18860 5533           31DB                       xor	bx,bx
18861 5535           8946         FC            mov	-4[bp],ax
18862 5538           895E         FE            mov	-2[bp],bx
18863                                           !BCC_EOS
18864                                           ! 3031   Bit16u CX,DX;
18865                                           !BCC_EOS
18866                                           ! 3032   Bit16u off, e820_table_size;
18867                                           !BCC_EOS
18868                                           ! 3033   Bit32u base, type, size;
18869                                           !BCC_EOS
18870                                           ! 3034 ;
18871 553B           83C4                   EC  add	sp,*-$14
18872                                           !BCC_EOS
18873                                           ! 3035   switch (regs.u.r8.ah) {
18874 553E           8A46         21            mov	al,$21[bp]
18875 5541           E9         0341            br 	.3FF
18876                                           ! 3036     case 0x86:
18877                                           ! 3037       CX = regs.u.r16.cx;
18878                       00005544            .400:
18879                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
18880 5544           8B46         1C            mov	ax,$1C[bp]
18881 5547           8946         FA            mov	-6[bp],ax
18882                                           !BCC_EOS
18883                                           ! 3038       DX = regs.u.r16.dx;
18884                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
18885 554A           8B46         18            mov	ax,$18[bp]
18886 554D           8946         F8            mov	-8[bp],ax
18887                                           !BCC_EOS
18888                                           ! 3039 #asm
18889                                           !BCC_EOS
18890                                           !BCC_ASM
18891                       00000012            _int15_function32.CX	set	$12
18892                       FFFFFFFA            .int15_function32.CX	set	-6
18893                       00000014            _int15_function32.extended_memory_size	set	$14
18894                       FFFFFFFC            .int15_function32.extended_memory_size	set	-4
18895                       00000040            _int15_function32.FLAGS	set	$40
18896                       00000028            .int15_function32.FLAGS	set	$28
18897                       00000004            _int15_function32.type	set	4
18898                       FFFFFFEC            .int15_function32.type	set	-$14
18899                       0000003E            _int15_function32.DS	set	$3E
18900                       00000026            .int15_function32.DS	set	$26
18901                       00000010            _int15_function32.DX	set	$10
18902                       FFFFFFF8            .int15_function32.DX	set	-8
18903                       00000000            _int15_function32.size	set	0
18904                       FFFFFFE8            .int15_function32.size	set	-$18
18905                       0000003C            _int15_function32.ES	set	$3C
18906                       00000024            .int15_function32.ES	set	$24
18907                       0000000C            _int15_function32.e820_table_size	set	$C
18908                       FFFFFFF4            .int15_function32.e820_table_size	set	-$C
18909                       00000008            _int15_function32.base	set	8
18910                       FFFFFFF0            .int15_function32.base	set	-$10
18911                       0000001C            _int15_function32.regs	set	$1C
18912                       00000004            .int15_function32.regs	set	4
18913                       0000000E            _int15_function32.off	set	$E
18914                       FFFFFFF6            .int15_function32.off	set	-$A
18915 5550           FB                               sti
18916                                                 ;; Get the count in eax
18917 5551           89E3                             mov bx, sp
18918 5553           36                         SEG SS
18919 5554           8B47         12                  mov ax, _int15_function32.CX [bx]
18920 5557     66    C1E0                   10        shl eax, #16
18921 555B           36                         SEG SS
18922 555C           8B47         10                  mov ax, _int15_function32.DX [bx]
18923                                                 ;; convert to numbers of 15usec ticks
18924 555F     66    BB               0000000F        mov ebx, #15
18925 5565     66    31D2                             xor edx, edx
18926 5568     66    F7F3                             div eax, ebx
18927 556B     66    89C1                             mov ecx, eax
18928                                                 ;; wait for ecx number of refresh requests
18929 556E           E4                     61        in al, #0x61
18930 5570           24                     10        and al,#0x10
18931 5572           88C4                             mov ah, al
18932 5574     66    09C9                             or ecx, ecx
18933 5577           74           0E                  je int1586_tick_end
18934                       00005579            int1586_tick:
18935 5579           E4                     61        in al, #0x61
18936 557B           24                     10        and al,#0x10
18937 557D           38E0                             cmp al, ah
18938 557F           74           F8                  je int1586_tick
18939 5581           88C4                             mov ah, al
18940 5583     66    49                               dec ecx
18941 5585           75           F2                  jnz int1586_tick
18942                       00005587            int1586_tick_end:
18943                                           ! 3068 endasm
18944                                           !BCC_ENDASM
18945                                           !BCC_EOS
18946                                           ! 3069       break;
18947 5587           E9         0309            br 	.3FD
18948                                           !BCC_EOS
18949                                           ! 3070     case 0xe8:
18950                                           ! 3071         switch(regs.u.r8.al)
18951                       0000558A            .401:
18952 558A           8A46         20            mov	al,$20[bp]
18953                                           ! 3072         {
18954 558D           E9         02D4            br 	.404
18955                                           ! 3073        case 0x20: {
18956                       00005590            .405:
18957                                           ! 3074             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
18958                                           ! Debug: list int = const 0 (used reg = )
18959 5590           31C0                       xor	ax,ax
18960 5592           50                         push	ax
18961                                           ! Debug: list unsigned short = const $EA10 (used reg = )
18962 5593           B8                   EA10  mov	ax,#$EA10
18963 5596           50                         push	ax
18964                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
18965 5597           E8         B06D            call	_read_word
18966 559A           83C4                   04  add	sp,*4
18967                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
18968 559D           B9                   0014  mov	cx,*$14
18969 55A0           F7E9                       imul	cx
18970                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
18971 55A2           8946         F4            mov	-$C[bp],ax
18972                                           !BCC_EOS
18973                                           ! 3075             if (regs.u.r32.edx != 0x534D4150)
18974                                           ! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
18975                                           ! Debug: expression subtree swapping
18976 55A5           B8                   4150  mov	ax,#$4150
18977 55A8           BB                   534D  mov	bx,#$534D
18978 55AB           53                         push	bx
18979 55AC           50                         push	ax
18980 55AD           8B46         18            mov	ax,$18[bp]
18981 55B0           8B5E         1A            mov	bx,$1A[bp]
18982 55B3           8D7E         E4            lea	di,-2+..FFF5[bp]
18983 55B6           E8         AB12            call	lcmpul
18984 55B9           8D66         E8            lea	sp,2+..FFF5[bp]
18985 55BC           74           06            je  	.406
18986                       000055BE            .407:
18987                                           ! 3076                 goto int15_unimplemented;
18988 55BE           83C4                   00  add	sp,#..FFF4-..FFF5
18989 55C1           E9         02B0            br 	.FFF4
18990                                           !BCC_EOS
18991                                           ! 3077             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
18992                       000055C4            .406:
18993                                           ! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
18994 55C4           8B46         14            mov	ax,$14[bp]
18995 55C7           BB                   0014  mov	bx,*$14
18996 55CA           E8         AB9C            call	idiv_u
18997                                           ! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
18998 55CD           B9                   0014  mov	cx,*$14
18999 55D0           F7E9                       imul	cx
19000                                           ! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
19001 55D2           3B46         14            cmp	ax,$14[bp]
19002 55D5         0F85         0084            bne 	.408
19003                       000055D9            .409:
19004                                           ! 3078                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
19005                                           ! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
19006 55D9           8B46         14            mov	ax,$14[bp]
19007                                           ! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
19008 55DC           05                   0014  add	ax,*$14
19009 55DF           3B46         F4            cmp	ax,-$C[bp]
19010 55E2           77           1B            ja  	.40A
19011                       000055E4            .40B:
19012                                           ! 3079                     memcpyb(ES, regs.u.r16.di,
19013                                           ! 3080                             (Bit16u)(0x000EA100 >> 4), 0x8 + regs.u.r16.bx, 0x14);
19014                                           ! Debug: list int = const $14 (used reg = )
19015 55E4           B8                   0014  mov	ax,*$14
19016 55E7           50                         push	ax
19017                                           ! Debug: add unsigned short regs = [S+$1C+$12] to int = const 8 (used reg = )
19018                                           ! Debug: expression subtree swapping
19019 55E8           8B46         14            mov	ax,$14[bp]
19020                                           ! Debug: list unsigned int = ax+8 (used reg = )
19021 55EB           05                   0008  add	ax,*8
19022 55EE           50                         push	ax
19023                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19024 55EF           B8                   EA10  mov	ax,#$EA10
19025 55F2           50                         push	ax
19026                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
19027 55F3           FF76         04            push	4[bp]
19028                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
19029 55F6           FF76         24            push	$24[bp]
19030                                           ! Debug: func () void = memcpyb+0 (used reg = )
19031 55F9           E8         AA28            call	_memcpyb
19032 55FC           83C4                   0A  add	sp,*$A
19033                                           !BCC_EOS
19034                                           ! 3081                 regs.u.r32.ebx += 0x14;
19035                       000055FF            .40A:
19036                                           ! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
19037 55FF           B8                   0014  mov	ax,*$14
19038 5602           31DB                       xor	bx,bx
19039 5604           53                         push	bx
19040 5605           50                         push	ax
19041 5606           8B46         14            mov	ax,$14[bp]
19042 5609           8B5E         16            mov	bx,$16[bp]
19043 560C           8D7E         E4            lea	di,-2+..FFF5[bp]
19044 560F           E8         AAB1            call	laddul
19045 5612           8946         14            mov	$14[bp],ax
19046 5615           895E         16            mov	$16[bp],bx
19047 5618           83C4                   04  add	sp,*4
19048                                           !BCC_EOS
19049                                           ! 3082                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
19050                                           ! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19051 561B           8B46         F4            mov	ax,-$C[bp]
19052 561E           31DB                       xor	bx,bx
19053 5620           53                         push	bx
19054 5621           50                         push	ax
19055                                           ! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
19056                                           ! Debug: expression subtree swapping
19057 5622           B8                   0014  mov	ax,*$14
19058 5625           31DB                       xor	bx,bx
19059 5627           8D7E         14            lea	di,$14[bp]
19060 562A           E8         AA96            call	laddul
19061                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
19062 562D           53                         push	bx
19063 562E           50                         push	ax
19064 562F           B8                   0001  mov	ax,*1
19065 5632           31DB                       xor	bx,bx
19066 5634           53                         push	bx
19067 5635           50                         push	ax
19068 5636           8B46         E0            mov	ax,-6+..FFF5[bp]
19069 5639           8B5E         E2            mov	bx,-4+..FFF5[bp]
19070 563C           8D7E         DC            lea	di,-$A+..FFF5[bp]
19071 563F           E8         AA9F            call	lsubul
19072 5642           83C4                   08  add	sp,*8
19073                                           ! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
19074 5645           8D7E         E4            lea	di,-2+..FFF5[bp]
19075 5648           E8         AA80            call	lcmpul
19076 564B           8D66         E8            lea	sp,2+..FFF5[bp]
19077 564E           76           0A            jbe 	.40C
19078                       00005650            .40D:
19079                                           ! 3083                     regs.u.r32.ebx = 0;
19080                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
19081 5650           31C0                       xor	ax,ax
19082 5652           31DB                       xor	bx,bx
19083 5654           8946         14            mov	$14[bp],ax
19084 5657           895E         16            mov	$16[bp],bx
19085                                           !BCC_EOS
19086                                           ! 3084             } else if (regs.u.r16.bx == 1) {
19087                       0000565A            .40C:
19088 565A           E9         00BB            br 	.40E
19089                       0000565D            .408:
19090                                           ! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
19091 565D           8B46         14            mov	ax,$14[bp]
19092 5660           3D                   0001  cmp	ax,*1
19093 5663         0F85         00AB            bne 	.40F
19094                       00005667            .410:
19095                                           ! 3085                 for (off = 0; off < e820_table_size; off += 0x14) {
19096                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
19097 5667           31C0                       xor	ax,ax
19098 5669           8946         F6            mov	-$A[bp],ax
19099                                           !BCC_EOS
19100                                           !BCC_EOS
19101 566C           EB           62            jmp .413
19102                       0000566E            .414:
19103                                           ! 3086                     base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
19104                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
19105                                           ! Debug: expression subtree swapping
19106 566E           8B46         F6            mov	ax,-$A[bp]
19107                                           ! Debug: list unsigned int = ax+8 (used reg = )
19108 5671           05                   0008  add	ax,*8
19109 5674           50                         push	ax
19110                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19111 5675           B8                   EA10  mov	ax,#$EA10
19112 5678           50                         push	ax
19113                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19114 5679           E8         AA07            call	_read_dword
19115 567C           89D3                       mov	bx,dx
19116 567E           83C4                   04  add	sp,*4
19117                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19118 5681           8946         F0            mov	-$10[bp],ax
19119 5684           895E         F2            mov	-$E[bp],bx
19120                                           !BCC_EOS
19121                                           ! 3087                     type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
19122                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
19123                                           ! Debug: expression subtree swapping
19124 5687           8B46         F6            mov	ax,-$A[bp]
19125                                           ! Debug: list unsigned int = ax+$18 (used reg = )
19126 568A           05                   0018  add	ax,*$18
19127 568D           50                         push	ax
19128                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19129 568E           B8                   EA10  mov	ax,#$EA10
19130 5691           50                         push	ax
19131                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19132 5692           E8         A9EE            call	_read_dword
19133 5695           89D3                       mov	bx,dx
19134 5697           83C4                   04  add	sp,*4
19135                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
19136 569A           8946         EC            mov	-$14[bp],ax
19137 569D           895E         EE            mov	-$12[bp],bx
19138                                           !BCC_EOS
19139                                           ! 3088                     if ((base >= 0x100000) && (type == 1))
19140                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
19141 56A0           31C0                       xor	ax,ax
19142 56A2           BB                   0010  mov	bx,*$10
19143 56A5           8D7E         F0            lea	di,-$10[bp]
19144 56A8           E8         AA20            call	lcmpul
19145 56AB           77           1A            ja  	.415
19146                       000056AD            .417:
19147                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
19148                                           ! Debug: expression subtree swapping
19149 56AD           B8                   0001  mov	ax,*1
19150 56B0           31DB                       xor	bx,bx
19151 56B2           53                         push	bx
19152 56B3           50                         push	ax
19153 56B4           8B46         EC            mov	ax,-$14[bp]
19154 56B7           8B5E         EE            mov	bx,-$12[bp]
19155 56BA           8D7E         E4            lea	di,-2+..FFF5[bp]
19156 56BD           E8         AA0B            call	lcmpul
19157 56C0           8D66         E8            lea	sp,2+..FFF5[bp]
19158 56C3           75           02            jne 	.415
19159                       000056C5            .416:
19160                                           ! 3089                         break;
19161 56C5           EB           11            jmp .411
19162                                           !BCC_EOS
19163                                           ! 3090                 }
19164                       000056C7            .415:
19165                                           ! 3091                 if (off == e820_table_size) {
19166                       000056C7            .412:
19167                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19168 56C7           8B46         F6            mov	ax,-$A[bp]
19169 56CA           05                   0014  add	ax,*$14
19170 56CD           8946         F6            mov	-$A[bp],ax
19171                       000056D0            .413:
19172                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19173 56D0           8B46         F6            mov	ax,-$A[bp]
19174 56D3           3B46         F4            cmp	ax,-$C[bp]
19175 56D6           72           96            jb 	.414
19176                       000056D8            .418:
19177                       000056D8            .411:
19178                                           ! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19179 56D8           8B46         F6            mov	ax,-$A[bp]
19180 56DB           3B46         F4            cmp	ax,-$C[bp]
19181 56DE           75           0B            jne 	.419
19182                       000056E0            .41A:
19183                                           ! 3092   
19184                                           ! 3092                   FLAGS |= 0x0001;
19185                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19186 56E0           8B46         28            mov	ax,$28[bp]
19187 56E3           0C                     01  or	al,*1
19188 56E5           8946         28            mov	$28[bp],ax
19189                                           !BCC_EOS
19190                                           ! 3093                     break;
19191 56E8           E9         0187            br 	.402
19192                                           !BCC_EOS
19193                                           ! 3094                 }
19194                                           ! 3095                 memcpyb(ES, regs.u.r16.di, (Bit16u)(0x000EA100 >> 4), 0x8 + off, 0x14);
19195                       000056EB            .419:
19196                                           ! Debug: list int = const $14 (used reg = )
19197 56EB           B8                   0014  mov	ax,*$14
19198 56EE           50                         push	ax
19199                                           ! Debug: add unsigned short off = [S+$1C-$C] to int = const 8 (used reg = )
19200                                           ! Debug: expression subtree swapping
19201 56EF           8B46         F6            mov	ax,-$A[bp]
19202                                           ! Debug: list unsigned int = ax+8 (used reg = )
19203 56F2           05                   0008  add	ax,*8
19204 56F5           50                         push	ax
19205                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19206 56F6           B8                   EA10  mov	ax,#$EA10
19207 56F9           50                         push	ax
19208                                           ! Debug: list unsigned short regs = [S+$20+2] (used reg = )
19209 56FA           FF76         04            push	4[bp]
19210                                           ! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
19211 56FD           FF76         24            push	$24[bp]
19212                                           ! Debug: func () void = memcpyb+0 (used reg = )
19213 5700           E8         A921            call	_memcpyb
19214 5703           83C4                   0A  add	sp,*$A
19215                                           !BCC_EOS
19216                                           ! 3096                 regs.u.r32.ebx = 0;
19217                                           ! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
19218 5706           31C0                       xor	ax,ax
19219 5708           31DB                       xor	bx,bx
19220 570A           8946         14            mov	$14[bp],ax
19221 570D           895E         16            mov	$16[bp],bx
19222                                           !BCC_EOS
19223                                           ! 3097             } else {
19224 5710           EB           06            jmp .41B
19225                       00005712            .40F:
19226                                           ! 3098                 goto int15_unimplemented;
19227 5712           83C4                   00  add	sp,#..FFF4-..FFF5
19228 5715           E9         015C            br 	.FFF4
19229                                           !BCC_EOS
19230                                           ! 3099             }
19231                                           ! 3100             regs.u.r32.eax = 0x534D4150;
19232                       00005718            .41B:
19233                       00005718            .40E:
19234                                           ! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
19235 5718           B8                   4150  mov	ax,#$4150
19236 571B           BB                   534D  mov	bx,#$534D
19237 571E           8946         20            mov	$20[bp],ax
19238 5721           895E         22            mov	$22[bp],bx
19239                                           !BCC_EOS
19240                                           ! 3101             regs.u.r32.ecx = 0x14;
19241                                           ! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
19242 5724           B8                   0014  mov	ax,*$14
19243 5727           31DB                       xor	bx,bx
19244 5729           8946         1C            mov	$1C[bp],ax
19245 572C           895E         1E            mov	$1E[bp],bx
19246                                           !BCC_EOS
19247                                           ! 3102             FLAGS &= 0xfffe;
19248                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19249 572F           8B46         28            mov	ax,$28[bp]
19250 5732           24                     FE  and	al,#$FE
19251 5734           8946         28            mov	$28[bp],ax
19252                                           !BCC_EOS
19253                                           ! 3103             break;
19254 5737           E9         0138            br 	.402
19255                                           !BCC_EOS
19256                                           ! 3104         }
19257                                           ! 3105         case 0x01: {
19258                       0000573A            .41C:
19259                                           ! 3106             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
19260                                           ! Debug: list int = const 0 (used reg = )
19261 573A           31C0                       xor	ax,ax
19262 573C           50                         push	ax
19263                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19264 573D           B8                   EA10  mov	ax,#$EA10
19265 5740           50                         push	ax
19266                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
19267 5741           E8         AEC3            call	_read_word
19268 5744           83C4                   04  add	sp,*4
19269                                           ! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
19270 5747           B9                   0014  mov	cx,*$14
19271 574A           F7E9                       imul	cx
19272                                           ! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
19273 574C           8946         F4            mov	-$C[bp],ax
19274                                           !BCC_EOS
19275                                           ! 3107             FLAGS &= 0xfffe;
19276                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19277 574F           8B46         28            mov	ax,$28[bp]
19278 5752           24                     FE  and	al,#$FE
19279 5754           8946         28            mov	$28[bp],ax
19280                                           !BCC_EOS
19281                                           ! 3108             regs.u.r8.cl = inb_cmos(0x30);
19282                                           ! Debug: list int = const $30 (used reg = )
19283 5757           B8                   0030  mov	ax,*$30
19284 575A           50                         push	ax
19285                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19286 575B           E8         AE25            call	_inb_cmos
19287 575E           44                         inc	sp
19288 575F           44                         inc	sp
19289                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
19290 5760           8846         1C            mov	$1C[bp],al
19291                                           !BCC_EOS
19292                                           ! 3109             regs.u.r8.ch = inb_cmos(0x31);
19293                                           ! Debug: list int = const $31 (used reg = )
19294 5763           B8                   0031  mov	ax,*$31
19295 5766           50                         push	ax
19296                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
19297 5767           E8         AE19            call	_inb_cmos
19298 576A           44                         inc	sp
19299 576B           44                         inc	sp
19300                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
19301 576C           8846         1D            mov	$1D[bp],al
19302                                           !BCC_EOS
19303                                           ! 3110             if (regs.u.r16.cx > (15*1024))
19304                                           ! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19305 576F           8B46         1C            mov	ax,$1C[bp]
19306 5772           3D                   3C00  cmp	ax,#$3C00
19307 5775           76           06            jbe 	.41D
19308                       00005777            .41E:
19309                                           ! 3111                 regs.u.r16.cx = 15*1024;
19310                                           ! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
19311 5777           B8                   3C00  mov	ax,#$3C00
19312 577A           8946         1C            mov	$1C[bp],ax
19313                                           !BCC_EOS
19314                                           ! 3112             for (off = 0; off < e820_table_size; off += 0x14) {
19315                       0000577D            .41D:
19316                                           ! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
19317 577D           31C0                       xor	ax,ax
19318 577F           8946         F6            mov	-$A[bp],ax
19319                                           !BCC_EOS
19320                                           !BCC_EOS
19321 5782           EB           62            jmp .421
19322                       00005784            .422:
19323                                           ! 3113                 base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
19324                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
19325                                           ! Debug: expression subtree swapping
19326 5784           8B46         F6            mov	ax,-$A[bp]
19327                                           ! Debug: list unsigned int = ax+8 (used reg = )
19328 5787           05                   0008  add	ax,*8
19329 578A           50                         push	ax
19330                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19331 578B           B8                   EA10  mov	ax,#$EA10
19332 578E           50                         push	ax
19333                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19334 578F           E8         A8F1            call	_read_dword
19335 5792           89D3                       mov	bx,dx
19336 5794           83C4                   04  add	sp,*4
19337                                           ! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19338 5797           8946         F0            mov	-$10[bp],ax
19339 579A           895E         F2            mov	-$E[bp],bx
19340                                           !BCC_EOS
19341                                           ! 3114                 type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
19342                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
19343                                           ! Debug: expression subtree swapping
19344 579D           8B46         F6            mov	ax,-$A[bp]
19345                                           ! Debug: list unsigned int = ax+$18 (used reg = )
19346 57A0           05                   0018  add	ax,*$18
19347 57A3           50                         push	ax
19348                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19349 57A4           B8                   EA10  mov	ax,#$EA10
19350 57A7           50                         push	ax
19351                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19352 57A8           E8         A8D8            call	_read_dword
19353 57AB           89D3                       mov	bx,dx
19354 57AD           83C4                   04  add	sp,*4
19355                                           ! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
19356 57B0           8946         EC            mov	-$14[bp],ax
19357 57B3           895E         EE            mov	-$12[bp],bx
19358                                           !BCC_EOS
19359                                           ! 3115                 if ((base >= 0x100000) && (type == 1))
19360                                           ! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
19361 57B6           31C0                       xor	ax,ax
19362 57B8           BB                   0010  mov	bx,*$10
19363 57BB           8D7E         F0            lea	di,-$10[bp]
19364 57BE           E8         A90A            call	lcmpul
19365 57C1           77           1A            ja  	.423
19366                       000057C3            .425:
19367                                           ! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
19368                                           ! Debug: expression subtree swapping
19369 57C3           B8                   0001  mov	ax,*1
19370 57C6           31DB                       xor	bx,bx
19371 57C8           53                         push	bx
19372 57C9           50                         push	ax
19373 57CA           8B46         EC            mov	ax,-$14[bp]
19374 57CD           8B5E         EE            mov	bx,-$12[bp]
19375 57D0           8D7E         E4            lea	di,-2+..FFF5[bp]
19376 57D3           E8         A8F5            call	lcmpul
19377 57D6           8D66         E8            lea	sp,2+..FFF5[bp]
19378 57D9           75           02            jne 	.423
19379                       000057DB            .424:
19380                                           ! 3116                     break;
19381 57DB           EB           11            jmp .41F
19382                                           !BCC_EOS
19383                                           ! 3117             }
19384                       000057DD            .423:
19385                                           ! 3118             regs.u.r16.dx = 0;
19386                       000057DD            .420:
19387                                           ! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
19388 57DD           8B46         F6            mov	ax,-$A[bp]
19389 57E0           05                   0014  add	ax,*$14
19390 57E3           8946         F6            mov	-$A[bp],ax
19391                       000057E6            .421:
19392                                           ! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19393 57E6           8B46         F6            mov	ax,-$A[bp]
19394 57E9           3B46         F4            cmp	ax,-$C[bp]
19395 57EC           72           96            jb 	.422
19396                       000057EE            .426:
19397                       000057EE            .41F:
19398                                           ! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
19399 57EE           31C0                       xor	ax,ax
19400 57F0           8946         18            mov	$18[bp],ax
19401                                           !BCC_EOS
19402                                           ! 3119             if (off != e820_table_size) {
19403                                           ! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
19404 57F3           8B46         F6            mov	ax,-$A[bp]
19405 57F6           3B46         F4            cmp	ax,-$C[bp]
19406 57F9           74           54            je  	.427
19407                       000057FB            .428:
19408                                           ! 3120                 size = base + read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x8 + off);
19409                                           ! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
19410                                           ! Debug: expression subtree swapping
19411 57FB           8B46         F6            mov	ax,-$A[bp]
19412                                           ! Debug: list unsigned int = ax+$10 (used reg = )
19413 57FE           05                   0010  add	ax,*$10
19414 5801           50                         push	ax
19415                                           ! Debug: list unsigned short = const $EA10 (used reg = )
19416 5802           B8                   EA10  mov	ax,#$EA10
19417 5805           50                         push	ax
19418                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
19419 5806           E8         A87A            call	_read_dword
19420 5809           89D3                       mov	bx,dx
19421 580B           83C4                   04  add	sp,*4
19422                                           ! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
19423                                           ! Debug: expression subtree swapping
19424 580E           8D7E         F0            lea	di,-$10[bp]
19425 5811           E8         A8AF            call	laddul
19426                                           ! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
19427 5814           8946         E8            mov	-$18[bp],ax
19428 5817           895E         EA            mov	-$16[bp],bx
19429                                           !BCC_EOS
19430                                           ! 3121                 if (size > 0x1000000) {
19431                                           ! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19432 581A           31C0                       xor	ax,ax
19433 581C           BB                   0100  mov	bx,#$100
19434 581F           8D7E         E8            lea	di,-$18[bp]
19435 5822           E8         A8A6            call	lcmpul
19436 5825           73           28            jae 	.429
19437                       00005827            .42A:
19438                                           ! 3122                     size -= 0x1000000;
19439                                           ! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
19440 5827           31C0                       xor	ax,ax
19441 5829           BB                   0100  mov	bx,#$100
19442 582C           53                         push	bx
19443 582D           50                         push	ax
19444 582E           8B46         E8            mov	ax,-$18[bp]
19445 5831           8B5E         EA            mov	bx,-$16[bp]
19446 5834           8D7E         E4            lea	di,-2+..FFF5[bp]
19447 5837           E8         A8A7            call	lsubul
19448 583A           8946         E8            mov	-$18[bp],ax
19449 583D           895E         EA            mov	-$16[bp],bx
19450 5840           83C4                   04  add	sp,*4
19451                                           !BCC_EOS
19452                                           ! 3123                     regs.u.r16.dx = (Bit16u)(size >> 16);
19453                                           ! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
19454 5843           8B46         E8            mov	ax,-$18[bp]
19455 5846           8B5E         EA            mov	bx,-$16[bp]
19456 5849           93                         xchg	bx,ax
19457 584A           31DB                       xor	bx,bx
19458                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
19459                                           ! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
19460 584C           8946         18            mov	$18[bp],ax
19461                                           !BCC_EOS
19462                                           ! 3124                 }
19463                                           ! 3125             }
19464                       0000584F            .429:
19465                                           ! 3126             regs.u.r16.ax = regs.u.r16.cx;
19466                       0000584F            .427:
19467                                           ! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
19468 584F           8B46         1C            mov	ax,$1C[bp]
19469 5852           8946         20            mov	$20[bp],ax
19470                                           !BCC_EOS
19471                                           ! 3127             regs.u.r16.bx = regs.u.r16.dx;
19472                                           ! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
19473 5855           8B46         18            mov	ax,$18[bp]
19474 5858           8946         14            mov	$14[bp],ax
19475                                           !BCC_EOS
19476                                           ! 3128             break;
19477 585B           EB           15            jmp .402
19478                                           !BCC_EOS
19479                                           ! 3129         }
19480                                           ! 3130         default:
19481                                           ! 3131             goto int15_unimplemented;
19482                       0000585D            .42B:
19483 585D           83C4                   00  add	sp,#..FFF4-..FFF5
19484 5860           EB           12            jmp .FFF4
19485                                           !BCC_EOS
19486                                           ! 3132         }
19487                                           ! 3133         break;
19488 5862           EB           0E            jmp .402
19489                       00005864            .404:
19490 5864           2C                     01  sub	al,*1
19491 5866         0F84         FED0            beq 	.41C
19492 586A           2C                     1F  sub	al,*$1F
19493 586C         0F84         FD20            beq 	.405
19494 5870           EB           EB            jmp	.42B
19495                       00005872            .402:
19496 5872           EB           1F            jmp .3FD
19497                                           !BCC_EOS
19498                                           ! 3134     int15_unimplemented:
19499                       00005874            .FFF4:
19500                                           ! 3135     default:
19501                                           ! 3136       ;
19502                       00005874            .42C:
19503                                           !BCC_EOS
19504                                           ! 3137       FLAGS |= 0x0001;
19505                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
19506 5874           8B46         28            mov	ax,$28[bp]
19507 5877           0C                     01  or	al,*1
19508 5879           8946         28            mov	$28[bp],ax
19509                                           !BCC_EOS
19510                                           ! 3138       regs.u.r8.ah = 0x86;
19511                                           ! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
19512 587C           B0                     86  mov	al,#$86
19513 587E           8846         21            mov	$21[bp],al
19514                                           !BCC_EOS
19515                                           ! 3139       break;
19516 5881           EB           10            jmp .3FD
19517                                           !BCC_EOS
19518                                           ! 3140     }
19519                                           ! 3141 }
19520 5883           EB           0E            jmp .3FD
19521                       00005885            .3FF:
19522 5885           2C                     86  sub	al,#$86
19523 5887         0F84         FCB9            beq 	.400
19524 588B           2C                     62  sub	al,*$62
19525 588D         0F84         FCF9            beq 	.401
19526 5891           EB           E1            jmp	.42C
19527                       00005893            .3FD:
19528                       FFFFFFE6            ..FFF5	=	-$1A
19529                       FFFFFFE6            ..FFF4	=	-$1A
19530 5893           89EC                       mov	sp,bp
19531 5895           5D                         pop	bp
19532 5896           C3                         ret
19533                                           ! 3142   void
19534                                           ! Register BX used in function int15_function32
19535                                           ! 3143 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
19536                                           ! 3144   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
19537                                           export	_int16_function
19538                       00005897            _int16_function:
19539                                           !BCC_EOS
19540                                           ! 3145 {
19541                                           ! 3146   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
19542                                           !BCC_EOS
19543                                           ! 3147   Bit16u kbd_code, max;
19544                                           !BCC_EOS
19545                                           ! 3148   ;
19546 5897           55                         push	bp
19547 5898           89E5                       mov	bp,sp
19548 589A           83C4                   F6  add	sp,*-$A
19549                                           !BCC_EOS
19550                                           ! 3149   shift_flags = read_byte(0x0040, 0x17);
19551                                           ! Debug: list int = const $17 (used reg = )
19552 589D           B8                   0017  mov	ax,*$17
19553 58A0           50                         push	ax
19554                                           ! Debug: list int = const $40 (used reg = )
19555 58A1           B8                   0040  mov	ax,*$40
19556 58A4           50                         push	ax
19557                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19558 58A5           E8         AD4C            call	_read_byte
19559 58A8           83C4                   04  add	sp,*4
19560                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
19561 58AB           8846         FD            mov	-3[bp],al
19562                                           !BCC_EOS
19563                                           ! 3150   led_flags = read_byte(0x0040, 0x97);
19564                                           ! Debug: list int = const $97 (used reg = )
19565 58AE           B8                   0097  mov	ax,#$97
19566 58B1           50                         push	ax
19567                                           ! Debug: list int = const $40 (used reg = )
19568 58B2           B8                   0040  mov	ax,*$40
19569 58B5           50                         push	ax
19570                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19571 58B6           E8         AD3B            call	_read_byte
19572 58B9           83C4                   04  add	sp,*4
19573                                           ! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
19574 58BC           8846         FC            mov	-4[bp],al
19575                                           !BCC_EOS
19576                                           ! 3151   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
19577                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
19578 58BF           8A46         FC            mov	al,-4[bp]
19579 58C2           24                     07  and	al,*7
19580 58C4           50                         push	ax
19581                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
19582 58C5           8A46         FD            mov	al,-3[bp]
19583 58C8           30E4                       xor	ah,ah
19584 58CA           B1                     04  mov	cl,*4
19585 58CC           D3E8                       shr	ax,cl
19586                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
19587 58CE           24                     07  and	al,*7
19588                                           ! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
19589 58D0           3246         F4            xor	al,-$C[bp]
19590 58D3           44                         inc	sp
19591 58D4           44                         inc	sp
19592                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
19593 58D5           84C0                       test	al,al
19594 58D7         0F84         00A3            beq 	.42D
19595                       000058DB            .42E:
19596                                           ! 3152 #asm
19597                                           !BCC_EOS
19598                                           !BCC_ASM
19599                       00000012            _int16_function.BP	set	$12
19600                       00000008            .int16_function.BP	set	8
19601                       00000005            _int16_function.count	set	5
19602                       FFFFFFFB            .int16_function.count	set	-5
19603                       0000001A            _int16_function.CX	set	$1A
19604                       00000010            .int16_function.CX	set	$10
19605                       00000008            _int16_function.ascii_code	set	8
19606                       FFFFFFFE            .int16_function.ascii_code	set	-2
19607                       0000000E            _int16_function.DI	set	$E
19608                       00000004            .int16_function.DI	set	4
19609                       0000001E            _int16_function.FLAGS	set	$1E
19610                       00000014            .int16_function.FLAGS	set	$14
19611                       00000002            _int16_function.kbd_code	set	2
19612                       FFFFFFF8            .int16_function.kbd_code	set	-8
19613                       00000009            _int16_function.scan_code	set	9
19614                       FFFFFFFF            .int16_function.scan_code	set	-1
19615                       00000018            _int16_function.DX	set	$18
19616                       0000000E            .int16_function.DX	set	$E
19617                       00000006            _int16_function.led_flags	set	6
19618                       FFFFFFFC            .int16_function.led_flags	set	-4
19619                       00000010            _int16_function.SI	set	$10
19620                       00000006            .int16_function.SI	set	6
19621                       0000001C            _int16_function.AX	set	$1C
19622                       00000012            .int16_function.AX	set	$12
19623                       00000014            _int16_function.SP	set	$14
19624                       0000000A            .int16_function.SP	set	$A
19625                       00000016            _int16_function.BX	set	$16
19626                       0000000C            .int16_function.BX	set	$C
19627                       00000007            _int16_function.shift_flags	set	7
19628                       FFFFFFFD            .int16_function.shift_flags	set	-3
19629                       00000000            _int16_function.max	set	0
19630                       FFFFFFF6            .int16_function.max	set	-$A
19631 58DB           FA                             cli
19632                                           ! 3154 endasm
19633                                           !BCC_ENDASM
19634                                           !BCC_EOS
19635                                           ! 3155     outb(0x60
19636                                           ! 3155 , 0xed);
19637                                           ! Debug: list int = const $ED (used reg = )
19638 58DC           B8                   00ED  mov	ax,#$ED
19639 58DF           50                         push	ax
19640                                           ! Debug: list int = const $60 (used reg = )
19641 58E0           B8                   0060  mov	ax,*$60
19642 58E3           50                         push	ax
19643                                           ! Debug: func () void = outb+0 (used reg = )
19644 58E4           E8         AC6D            call	_outb
19645 58E7           83C4                   04  add	sp,*4
19646                                           !BCC_EOS
19647                                           ! 3156     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
19648 58EA           EB           0E            jmp .430
19649                       000058EC            .431:
19650                                           ! Debug: list int = const $21 (used reg = )
19651 58EC           B8                   0021  mov	ax,*$21
19652 58EF           50                         push	ax
19653                                           ! Debug: list int = const $80 (used reg = )
19654 58F0           B8                   0080  mov	ax,#$80
19655 58F3           50                         push	ax
19656                                           ! Debug: func () void = outb+0 (used reg = )
19657 58F4           E8         AC5D            call	_outb
19658 58F7           83C4                   04  add	sp,*4
19659                                           !BCC_EOS
19660                                           ! 3157     if ((inb(0x60) == 0xfa)) {
19661                       000058FA            .430:
19662                                           ! Debug: list int = const $64 (used reg = )
19663 58FA           B8                   0064  mov	ax,*$64
19664 58FD           50                         push	ax
19665                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19666 58FE           E8         AC3D            call	_inb
19667 5901           44                         inc	sp
19668 5902           44                         inc	sp
19669                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19670 5903           24                     01  and	al,*1
19671                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19672 5905           84C0                       test	al,al
19673 5907           74           E3            je 	.431
19674                       00005909            .432:
19675                       00005909            .42F:
19676                                           ! Debug: list int = const $60 (used reg = )
19677 5909           B8                   0060  mov	ax,*$60
19678 590C           50                         push	ax
19679                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19680 590D           E8         AC2E            call	_inb
19681 5910           44                         inc	sp
19682 5911           44                         inc	sp
19683                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
19684 5912           3C                     FA  cmp	al,#$FA
19685 5914           75           67            jne 	.433
19686                       00005916            .434:
19687                                           ! 3158       led_flags &= 0xf8;
19688                                           ! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
19689 5916           8A46         FC            mov	al,-4[bp]
19690 5919           24                     F8  and	al,#$F8
19691 591B           8846         FC            mov	-4[bp],al
19692                                           !BCC_EOS
19693                                           ! 3159       led_flags |= ((shift_flags >> 4) & 0x07);
19694                                           ! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
19695 591E           8A46         FD            mov	al,-3[bp]
19696 5921           30E4                       xor	ah,ah
19697 5923           B1                     04  mov	cl,*4
19698 5925           D3E8                       shr	ax,cl
19699                                           ! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
19700 5927           24                     07  and	al,*7
19701                                           ! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
19702 5929           0A46         FC            or	al,-4[bp]
19703 592C           8846         FC            mov	-4[bp],al
19704                                           !BCC_EOS
19705                                           ! 3160       outb(0x60, led_flags & 0x07);
19706                                           ! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
19707 592F           8A46         FC            mov	al,-4[bp]
19708 5932           24                     07  and	al,*7
19709                                           ! Debug: list unsigned char = al+0 (used reg = )
19710 5934           30E4                       xor	ah,ah
19711 5936           50                         push	ax
19712                                           ! Debug: list int = const $60 (used reg = )
19713 5937           B8                   0060  mov	ax,*$60
19714 593A           50                         push	ax
19715                                           ! Debug: func () void = outb+0 (used reg = )
19716 593B           E8         AC16            call	_outb
19717 593E           83C4                   04  add	sp,*4
19718                                           !BCC_EOS
19719                                           ! 3161       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
19720 5941           EB           0E            jmp .436
19721                       00005943            .437:
19722                                           ! Debug: list int = const $21 (used reg = )
19723 5943           B8                   0021  mov	ax,*$21
19724 5946           50                         push	ax
19725                                           ! Debug: list int = const $80 (used reg = )
19726 5947           B8                   0080  mov	ax,#$80
19727 594A           50                         push	ax
19728                                           ! Debug: func () void = outb+0 (used reg = )
19729 594B           E8         AC06            call	_outb
19730 594E           83C4                   04  add	sp,*4
19731                                           !BCC_EOS
19732                                           ! 3162       inb(0x60);
19733                       00005951            .436:
19734                                           ! Debug: list int = const $64 (used reg = )
19735 5951           B8                   0064  mov	ax,*$64
19736 5954           50                         push	ax
19737                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19738 5955           E8         ABE6            call	_inb
19739 5958           44                         inc	sp
19740 5959           44                         inc	sp
19741                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
19742 595A           24                     01  and	al,*1
19743                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
19744 595C           84C0                       test	al,al
19745 595E           74           E3            je 	.437
19746                       00005960            .438:
19747                       00005960            .435:
19748                                           ! Debug: list int = const $60 (used reg = )
19749 5960           B8                   0060  mov	ax,*$60
19750 5963           50                         push	ax
19751                                           ! Debug: func () unsigned char = inb+0 (used reg = )
19752 5964           E8         ABD7            call	_inb
19753 5967           44                         inc	sp
19754 5968           44                         inc	sp
19755                                           !BCC_EOS
19756                                           ! 3163       write_byte(0x0040, 0x97, led_flags);
19757                                           ! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
19758 5969           8A46         FC            mov	al,-4[bp]
19759 596C           30E4                       xor	ah,ah
19760 596E           50                         push	ax
19761                                           ! Debug: list int = const $97 (used reg = )
19762 596F           B8                   0097  mov	ax,#$97
19763 5972           50                         push	ax
19764                                           ! Debug: list int = const $40 (used reg = )
19765 5973           B8                   0040  mov	ax,*$40
19766 5976           50                         push	ax
19767                                           ! Debug: func () void = write_byte+0 (used reg = )
19768 5977           E8         ACA0            call	_write_byte
19769 597A           83C4                   06  add	sp,*6
19770                                           !BCC_EOS
19771                                           ! 3164     }
19772                                           ! 3165 #asm
19773                       0000597D            .433:
19774                                           !BCC_EOS
19775                                           !BCC_ASM
19776                       00000012            _int16_function.BP	set	$12
19777                       00000008            .int16_function.BP	set	8
19778                       00000005            _int16_function.count	set	5
19779                       FFFFFFFB            .int16_function.count	set	-5
19780                       0000001A            _int16_function.CX	set	$1A
19781                       00000010            .int16_function.CX	set	$10
19782                       00000008            _int16_function.ascii_code	set	8
19783                       FFFFFFFE            .int16_function.ascii_code	set	-2
19784                       0000000E            _int16_function.DI	set	$E
19785                       00000004            .int16_function.DI	set	4
19786                       0000001E            _int16_function.FLAGS	set	$1E
19787                       00000014            .int16_function.FLAGS	set	$14
19788                       00000002            _int16_function.kbd_code	set	2
19789                       FFFFFFF8            .int16_function.kbd_code	set	-8
19790                       00000009            _int16_function.scan_code	set	9
19791                       FFFFFFFF            .int16_function.scan_code	set	-1
19792                       00000018            _int16_function.DX	set	$18
19793                       0000000E            .int16_function.DX	set	$E
19794                       00000006            _int16_function.led_flags	set	6
19795                       FFFFFFFC            .int16_function.led_flags	set	-4
19796                       00000010            _int16_function.SI	set	$10
19797                       00000006            .int16_function.SI	set	6
19798                       0000001C            _int16_function.AX	set	$1C
19799                       00000012            .int16_function.AX	set	$12
19800                       00000014            _int16_function.SP	set	$14
19801                       0000000A            .int16_function.SP	set	$A
19802                       00000016            _int16_function.BX	set	$16
19803                       0000000C            .int16_function.BX	set	$C
19804                       00000007            _int16_function.shift_flags	set	7
19805                       FFFFFFFD            .int16_function.shift_flags	set	-3
19806                       00000000            _int16_function.max	set	0
19807                       FFFFFFF6            .int16_function.max	set	-$A
19808 597D           FB                             sti
19809                                           ! 3167 endasm
19810                                           !BCC_ENDASM
19811                                           !BCC_EOS
19812                                           ! 3168   }
19813                                           ! 3169   switch (( AX >> 8 )) {
19814                       0000597E            .42D:
19815                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
19816 597E           8B46         12            mov	ax,$12[bp]
19817 5981           88E0                       mov	al,ah
19818 5983           30E4                       xor	ah,ah
19819 5985           E9         02EC            br 	.43B
19820                                           ! 3170     case 0x00:
19821                                           ! 3171       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
19822                       00005988            .43C:
19823                                           ! Debug: list int = const 1 (used reg = )
19824 5988           B8                   0001  mov	ax,*1
19825 598B           50                         push	ax
19826                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
19827 598C           8D5E         FE            lea	bx,-2[bp]
19828 598F           53                         push	bx
19829                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
19830 5990           8D5E         FF            lea	bx,-1[bp]
19831 5993           53                         push	bx
19832                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
19833 5994           E8         032B            call	_dequeue_key
19834 5997           83C4                   06  add	sp,*6
19835 599A           85C0                       test	ax,ax
19836 599C           75           0E            jne 	.43D
19837                       0000599E            .43E:
19838                                           ! 3172         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
19839                                           ! Debug: list * char = .43F+0 (used reg = )
19840 599E           BB                   D1DC  mov	bx,#.43F
19841 59A1           53                         push	bx
19842                                           ! Debug: list int = const 7 (used reg = )
19843 59A2           B8                   0007  mov	ax,*7
19844 59A5           50                         push	ax
19845                                           ! Debug: func () void = bios_printf+0 (used reg = )
19846 59A6           E8         B072            call	_bios_printf
19847 59A9           83C4                   04  add	sp,*4
19848                                           !BCC_EOS
19849                                           ! 3173         }
19850                                           ! 3174       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
19851                       000059AC            .43D:
19852                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
19853 59AC           8A46         FF            mov	al,-1[bp]
19854 59AF           84C0                       test	al,al
19855 59B1           74           0E            je  	.440
19856                       000059B3            .442:
19857                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19858 59B3           8A46         FE            mov	al,-2[bp]
19859 59B6           3C                     F0  cmp	al,#$F0
19860 59B8           75           07            jne 	.440
19861                       000059BA            .441:
19862                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19863 59BA           30C0                       xor	al,al
19864 59BC           8846         FE            mov	-2[bp],al
19865                                           !BCC_EOS
19866                                           ! 3175       else if (ascii_code == 0xE0) ascii_code = 0;
19867 59BF           EB           0C            jmp .443
19868                       000059C1            .440:
19869                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19870 59C1           8A46         FE            mov	al,-2[bp]
19871 59C4           3C                     E0  cmp	al,#$E0
19872 59C6           75           05            jne 	.444
19873                       000059C8            .445:
19874                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19875 59C8           30C0                       xor	al,al
19876 59CA           8846         FE            mov	-2[bp],al
19877                                           !BCC_EOS
19878                                           ! 3176       AX = (scan_code << 8) | ascii_code;
19879                       000059CD            .444:
19880                       000059CD            .443:
19881                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
19882 59CD           8A46         FF            mov	al,-1[bp]
19883 59D0           30E4                       xor	ah,ah
19884 59D2           88C4                       mov	ah,al
19885 59D4           30C0                       xor	al,al
19886                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
19887 59D6           0A46         FE            or	al,-2[bp]
19888                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19889 59D9           8946         12            mov	$12[bp],ax
19890                                           !BCC_EOS
19891                                           ! 3177       break;
19892 59DC           E9         02DF            br 	.439
19893                                           !BCC_EOS
19894                                           ! 3178     case 0x01:
19895                                           ! 3179       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
19896                       000059DF            .446:
19897                                           ! Debug: list int = const 0 (used reg = )
19898 59DF           31C0                       xor	ax,ax
19899 59E1           50                         push	ax
19900                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
19901 59E2           8D5E         FE            lea	bx,-2[bp]
19902 59E5           53                         push	bx
19903                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
19904 59E6           8D5E         FF            lea	bx,-1[bp]
19905 59E9           53                         push	bx
19906                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
19907 59EA           E8         02D5            call	_dequeue_key
19908 59ED           83C4                   06  add	sp,*6
19909 59F0           85C0                       test	ax,ax
19910 59F2           75           0C            jne 	.447
19911                       000059F4            .448:
19912                                           ! 3180         FLAGS |= 0x0040;
19913                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
19914 59F4           8B46         14            mov	ax,$14[bp]
19915 59F7           0C                     40  or	al,*$40
19916 59F9           8946         14            mov	$14[bp],ax
19917                                           !BCC_EOS
19918                                           ! 3181         return;
19919 59FC           89EC                       mov	sp,bp
19920 59FE           5D                         pop	bp
19921 59FF           C3                         ret
19922                                           !BCC_EOS
19923                                           ! 3182         }
19924                                           ! 3183       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
19925                       00005A00            .447:
19926                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
19927 5A00           8A46         FF            mov	al,-1[bp]
19928 5A03           84C0                       test	al,al
19929 5A05           74           0E            je  	.449
19930                       00005A07            .44B:
19931                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19932 5A07           8A46         FE            mov	al,-2[bp]
19933 5A0A           3C                     F0  cmp	al,#$F0
19934 5A0C           75           07            jne 	.449
19935                       00005A0E            .44A:
19936                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19937 5A0E           30C0                       xor	al,al
19938 5A10           8846         FE            mov	-2[bp],al
19939                                           !BCC_EOS
19940                                           ! 3184       else if (ascii_code == 0xE0) ascii_code = 0;
19941 5A13           EB           0C            jmp .44C
19942                       00005A15            .449:
19943                                           ! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19944 5A15           8A46         FE            mov	al,-2[bp]
19945 5A18           3C                     E0  cmp	al,#$E0
19946 5A1A           75           05            jne 	.44D
19947                       00005A1C            .44E:
19948                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
19949 5A1C           30C0                       xor	al,al
19950 5A1E           8846         FE            mov	-2[bp],al
19951                                           !BCC_EOS
19952                                           ! 3185       AX = (scan_code << 8) | ascii_code;
19953                       00005A21            .44D:
19954                       00005A21            .44C:
19955                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
19956 5A21           8A46         FF            mov	al,-1[bp]
19957 5A24           30E4                       xor	ah,ah
19958 5A26           88C4                       mov	ah,al
19959 5A28           30C0                       xor	al,al
19960                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
19961 5A2A           0A46         FE            or	al,-2[bp]
19962                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19963 5A2D           8946         12            mov	$12[bp],ax
19964                                           !BCC_EOS
19965                                           ! 3186       FLAGS &= 0xffbf;
19966                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
19967 5A30           8B46         14            mov	ax,$14[bp]
19968 5A33           24                     BF  and	al,#$BF
19969 5A35           8946         14            mov	$14[bp],ax
19970                                           !BCC_EOS
19971                                           ! 3187       break;
19972 5A38           E9         0283            br 	.439
19973                                           !BCC_EOS
19974                                           ! 3188     case 0x02:
19975                                           ! 3189       shift_flags = read_byte(0x0040, 0x17);
19976                       00005A3B            .44F:
19977                                           ! Debug: list int = const $17 (used reg = )
19978 5A3B           B8                   0017  mov	ax,*$17
19979 5A3E           50                         push	ax
19980                                           ! Debug: list int = const $40 (used reg = )
19981 5A3F           B8                   0040  mov	ax,*$40
19982 5A42           50                         push	ax
19983                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
19984 5A43           E8         ABAE            call	_read_byte
19985 5A46           83C4                   04  add	sp,*4
19986                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
19987 5A49           8846         FD            mov	-3[bp],al
19988                                           !BCC_EOS
19989                                           ! 3190       AX = ((AX & 0xff00) | (shift_flags));
19990                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
19991 5A4C           8B46         12            mov	ax,$12[bp]
19992 5A4F           30C0                       xor	al,al
19993                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
19994 5A51           0A46         FD            or	al,-3[bp]
19995                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
19996 5A54           8946         12            mov	$12[bp],ax
19997                                           !BCC_EOS
19998                                           ! 3191       break;
19999 5A57           E9         0264            br 	.439
20000                                           !BCC_EOS
20001                                           ! 3192     case 0x05:
20002                                           ! 3193       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
20003                       00005A5A            .450:
20004                                           ! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
20005 5A5A           8A46         10            mov	al,$10[bp]
20006                                           ! Debug: list unsigned char = al+0 (used reg = )
20007 5A5D           30E4                       xor	ah,ah
20008 5A5F           50                         push	ax
20009                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
20010 5A60           8B46         10            mov	ax,$10[bp]
20011 5A63           88E0                       mov	al,ah
20012 5A65           30E4                       xor	ah,ah
20013                                           ! Debug: list unsigned int = ax+0 (used reg = )
20014 5A67           50                         push	ax
20015                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
20016 5A68           E8         0BD5            call	_enqueue_key
20017 5A6B           83C4                   04  add	sp,*4
20018 5A6E           85C0                       test	ax,ax
20019 5A70           75           0C            jne 	.451
20020                       00005A72            .452:
20021                                           ! 3194         AX = ((AX & 0xff00) | (1));
20022                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20023 5A72           8B46         12            mov	ax,$12[bp]
20024 5A75           30C0                       xor	al,al
20025                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
20026 5A77           0C                     01  or	al,*1
20027                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20028 5A79           8946         12            mov	$12[bp],ax
20029                                           !BCC_EOS
20030                                           ! 3195         }
20031                                           ! 3196       else {
20032 5A7C           EB           0A            jmp .453
20033                       00005A7E            .451:
20034                                           ! 3197         AX = ((AX & 0xff00) | (0));
20035                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20036 5A7E           8B46         12            mov	ax,$12[bp]
20037 5A81           30C0                       xor	al,al
20038                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
20039 5A83           0C                     00  or	al,*0
20040                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20041 5A85           8946         12            mov	$12[bp],ax
20042                                           !BCC_EOS
20043                                           ! 3198         }
20044                                           ! 3199       break;
20045                       00005A88            .453:
20046 5A88           E9         0233            br 	.439
20047                                           !BCC_EOS
20048                                           ! 3200     case 0x09:
20049                                           ! 3201       AX = ((AX & 0xff00) | (0x30));
20050                       00005A8B            .454:
20051                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20052 5A8B           8B46         12            mov	ax,$12[bp]
20053 5A8E           30C0                       xor	al,al
20054                                           ! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
20055 5A90           0C                     30  or	al,*$30
20056                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20057 5A92           8946         12            mov	$12[bp],ax
20058                                           !BCC_EOS
20059                                           ! 3202       break;
20060 5A95           E9         0226            br 	.439
20061                                           !BCC_EOS
20062                                           ! 3203     case 0x0A:
20063                                           ! 3204       count = 2;
20064                       00005A98            .455:
20065                                           ! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
20066 5A98           B0                     02  mov	al,*2
20067 5A9A           8846         FB            mov	-5[bp],al
20068                                           !BCC_EOS
20069                                           ! 3205       kbd_code = 0x0;
20070                                           ! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20071 5A9D           31C0                       xor	ax,ax
20072 5A9F           8946         F8            mov	-8[bp],ax
20073                                           !BCC_EOS
20074                                           ! 3206       outb(0x60, 0xf2);
20075                                           ! Debug: list int = const $F2 (used reg = )
20076 5AA2           B8                   00F2  mov	ax,#$F2
20077 5AA5           50                         push	ax
20078                                           ! Debug: list int = const $60 (used reg = )
20079 5AA6           B8                   0060  mov	ax,*$60
20080 5AA9           50                         push	ax
20081                                           ! Debug: func () void = outb+0 (used reg = )
20082 5AAA           E8         AAA7            call	_outb
20083 5AAD           83C4                   04  add	sp,*4
20084                                           !BCC_EOS
20085                                           ! 3207       max=0xffff;
20086                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20087 5AB0           B8                   FFFF  mov	ax,#$FFFF
20088 5AB3           8946         F6            mov	-$A[bp],ax
20089                                           !BCC_EOS
20090                                           ! 3208       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20091 5AB6           EB           0D            jmp .457
20092                       00005AB8            .458:
20093                                           ! Debug: list int = const 0 (used reg = )
20094 5AB8           31C0                       xor	ax,ax
20095 5ABA           50                         push	ax
20096                                           ! Debug: list int = const $80 (used reg = )
20097 5ABB           B8                   0080  mov	ax,#$80
20098 5ABE           50                         push	ax
20099                                           ! Debug: func () void = outb+0 (used reg = )
20100 5ABF           E8         AA92            call	_outb
20101 5AC2           83C4                   04  add	sp,*4
20102                                           !BCC_EOS
20103                                           ! 3209       if (max>0x0) {
20104                       00005AC5            .457:
20105                                           ! Debug: list int = const $64 (used reg = )
20106 5AC5           B8                   0064  mov	ax,*$64
20107 5AC8           50                         push	ax
20108                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20109 5AC9           E8         AA72            call	_inb
20110 5ACC           44                         inc	sp
20111 5ACD           44                         inc	sp
20112                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20113 5ACE           24                     01  and	al,*1
20114                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20115 5AD0           84C0                       test	al,al
20116 5AD2           75           0B            jne 	.459
20117                       00005AD4            .45A:
20118                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20119 5AD4           8B46         F6            mov	ax,-$A[bp]
20120 5AD7           48                         dec	ax
20121 5AD8           8946         F6            mov	-$A[bp],ax
20122                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20123 5ADB           85C0                       test	ax,ax
20124 5ADD           75           D9            jne	.458
20125                       00005ADF            .459:
20126                       00005ADF            .456:
20127                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20128 5ADF           8B46         F6            mov	ax,-$A[bp]
20129 5AE2           85C0                       test	ax,ax
20130 5AE4           74           6D            je  	.45B
20131                       00005AE6            .45C:
20132                                           ! 3210         if ((inb(0x60) == 0xfa)) {
20133                                           ! Debug: list int = const $60 (used reg = )
20134 5AE6           B8                   0060  mov	ax,*$60
20135 5AE9           50                         push	ax
20136                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20137 5AEA           E8         AA51            call	_inb
20138 5AED           44                         inc	sp
20139 5AEE           44                         inc	sp
20140                                           ! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
20141 5AEF           3C                     FA  cmp	al,#$FA
20142 5AF1           75           60            jne 	.45D
20143                       00005AF3            .45E:
20144                                           ! 3211           do {
20145                       00005AF3            .461:
20146                                           ! 3212             max=0xffff;
20147                                           ! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
20148 5AF3           B8                   FFFF  mov	ax,#$FFFF
20149 5AF6           8946         F6            mov	-$A[bp],ax
20150                                           !BCC_EOS
20151                                           ! 3213             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
20152 5AF9           EB           0D            jmp .463
20153                       00005AFB            .464:
20154                                           ! Debug: list int = const 0 (used reg = )
20155 5AFB           31C0                       xor	ax,ax
20156 5AFD           50                         push	ax
20157                                           ! Debug: list int = const $80 (used reg = )
20158 5AFE           B8                   0080  mov	ax,#$80
20159 5B01           50                         push	ax
20160                                           ! Debug: func () void = outb+0 (used reg = )
20161 5B02           E8         AA4F            call	_outb
20162 5B05           83C4                   04  add	sp,*4
20163                                           !BCC_EOS
20164                                           ! 3214             if (max>0x0) {
20165                       00005B08            .463:
20166                                           ! Debug: list int = const $64 (used reg = )
20167 5B08           B8                   0064  mov	ax,*$64
20168 5B0B           50                         push	ax
20169                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20170 5B0C           E8         AA2F            call	_inb
20171 5B0F           44                         inc	sp
20172 5B10           44                         inc	sp
20173                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20174 5B11           24                     01  and	al,*1
20175                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
20176 5B13           84C0                       test	al,al
20177 5B15           75           0B            jne 	.465
20178                       00005B17            .466:
20179                                           ! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
20180 5B17           8B46         F6            mov	ax,-$A[bp]
20181 5B1A           48                         dec	ax
20182 5B1B           8946         F6            mov	-$A[bp],ax
20183                                           ! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
20184 5B1E           85C0                       test	ax,ax
20185 5B20           75           D9            jne	.464
20186                       00005B22            .465:
20187                       00005B22            .462:
20188                                           ! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
20189 5B22           8B46         F6            mov	ax,-$A[bp]
20190 5B25           85C0                       test	ax,ax
20191 5B27           74           1F            je  	.467
20192                       00005B29            .468:
20193                                           ! 3215               kbd_code >>= 8;
20194                                           ! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20195 5B29           8B46         F8            mov	ax,-8[bp]
20196 5B2C           88E0                       mov	al,ah
20197 5B2E           30E4                       xor	ah,ah
20198 5B30           8946         F8            mov	-8[bp],ax
20199                                           !BCC_EOS
20200                                           ! 3216               kbd_code |= (inb(0x60) << 8);
20201                                           ! Debug: list int = const $60 (used reg = )
20202 5B33           B8                   0060  mov	ax,*$60
20203 5B36           50                         push	ax
20204                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20205 5B37           E8         AA04            call	_inb
20206 5B3A           44                         inc	sp
20207 5B3B           44                         inc	sp
20208                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
20209 5B3C           30E4                       xor	ah,ah
20210 5B3E           88C4                       mov	ah,al
20211 5B40           30C0                       xor	al,al
20212                                           ! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
20213 5B42           0B46         F8            or	ax,-8[bp]
20214 5B45           8946         F8            mov	-8[bp],ax
20215                                           !BCC_EOS
20216                                           ! 3217             }
20217                                           ! 3218           } while (--count>0);
20218                       00005B48            .467:
20219                       00005B48            .460:
20220                                           ! Debug: predec unsigned char count = [S+$C-7] (used reg = )
20221 5B48           8A46         FB            mov	al,-5[bp]
20222 5B4B           48                         dec	ax
20223 5B4C           8846         FB            mov	-5[bp],al
20224                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
20225 5B4F           84C0                       test	al,al
20226 5B51           75           A0            jne	.461
20227                       00005B53            .469:
20228                                           !BCC_EOS
20229                                           ! 3219         }
20230                       00005B53            .45F:
20231                                           ! 3220       }
20232                       00005B53            .45D:
20233                                           ! 3221       BX=kbd_code;
20234                       00005B53            .45B:
20235                                           ! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
20236 5B53           8B46         F8            mov	ax,-8[bp]
20237 5B56           8946         0C            mov	$C[bp],ax
20238                                           !BCC_EOS
20239                                           ! 3222       break;
20240 5B59           E9         0162            br 	.439
20241                                           !BCC_EOS
20242                                           ! 3223     case 0x10:
20243                                           ! 3224       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
20244                       00005B5C            .46A:
20245                                           ! Debug: list int = const 1 (used reg = )
20246 5B5C           B8                   0001  mov	ax,*1
20247 5B5F           50                         push	ax
20248                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20249 5B60           8D5E         FE            lea	bx,-2[bp]
20250 5B63           53                         push	bx
20251                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20252 5B64           8D5E         FF            lea	bx,-1[bp]
20253 5B67           53                         push	bx
20254                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20255 5B68           E8         0157            call	_dequeue_key
20256 5B6B           83C4                   06  add	sp,*6
20257 5B6E           85C0                       test	ax,ax
20258 5B70           75           0E            jne 	.46B
20259                       00005B72            .46C:
20260                                           ! 3225         bios_printf((2 | 4 | 1), "KBD: int16h: out o
20261                                           ! 3225 f keyboard input\n");
20262                                           ! Debug: list * char = .46D+0 (used reg = )
20263 5B72           BB                   D1B8  mov	bx,#.46D
20264 5B75           53                         push	bx
20265                                           ! Debug: list int = const 7 (used reg = )
20266 5B76           B8                   0007  mov	ax,*7
20267 5B79           50                         push	ax
20268                                           ! Debug: func () void = bios_printf+0 (used reg = )
20269 5B7A           E8         AE9E            call	_bios_printf
20270 5B7D           83C4                   04  add	sp,*4
20271                                           !BCC_EOS
20272                                           ! 3226         }
20273                                           ! 3227       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20274                       00005B80            .46B:
20275                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20276 5B80           8A46         FF            mov	al,-1[bp]
20277 5B83           84C0                       test	al,al
20278 5B85           74           0C            je  	.46E
20279                       00005B87            .470:
20280                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20281 5B87           8A46         FE            mov	al,-2[bp]
20282 5B8A           3C                     F0  cmp	al,#$F0
20283 5B8C           75           05            jne 	.46E
20284                       00005B8E            .46F:
20285                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20286 5B8E           30C0                       xor	al,al
20287 5B90           8846         FE            mov	-2[bp],al
20288                                           !BCC_EOS
20289                                           ! 3228       AX = (scan_code << 8) | ascii_code;
20290                       00005B93            .46E:
20291                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20292 5B93           8A46         FF            mov	al,-1[bp]
20293 5B96           30E4                       xor	ah,ah
20294 5B98           88C4                       mov	ah,al
20295 5B9A           30C0                       xor	al,al
20296                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20297 5B9C           0A46         FE            or	al,-2[bp]
20298                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20299 5B9F           8946         12            mov	$12[bp],ax
20300                                           !BCC_EOS
20301                                           ! 3229       break;
20302 5BA2           E9         0119            br 	.439
20303                                           !BCC_EOS
20304                                           ! 3230     case 0x11:
20305                                           ! 3231       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
20306                       00005BA5            .471:
20307                                           ! Debug: list int = const 0 (used reg = )
20308 5BA5           31C0                       xor	ax,ax
20309 5BA7           50                         push	ax
20310                                           ! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
20311 5BA8           8D5E         FE            lea	bx,-2[bp]
20312 5BAB           53                         push	bx
20313                                           ! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
20314 5BAC           8D5E         FF            lea	bx,-1[bp]
20315 5BAF           53                         push	bx
20316                                           ! Debug: func () unsigned int = dequeue_key+0 (used reg = )
20317 5BB0           E8         010F            call	_dequeue_key
20318 5BB3           83C4                   06  add	sp,*6
20319 5BB6           85C0                       test	ax,ax
20320 5BB8           75           0C            jne 	.472
20321                       00005BBA            .473:
20322                                           ! 3232         FLAGS |= 0x0040;
20323                                           ! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
20324 5BBA           8B46         14            mov	ax,$14[bp]
20325 5BBD           0C                     40  or	al,*$40
20326 5BBF           8946         14            mov	$14[bp],ax
20327                                           !BCC_EOS
20328                                           ! 3233         return;
20329 5BC2           89EC                       mov	sp,bp
20330 5BC4           5D                         pop	bp
20331 5BC5           C3                         ret
20332                                           !BCC_EOS
20333                                           ! 3234         }
20334                                           ! 3235       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
20335                       00005BC6            .472:
20336                                           ! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
20337 5BC6           8A46         FF            mov	al,-1[bp]
20338 5BC9           84C0                       test	al,al
20339 5BCB           74           0C            je  	.474
20340                       00005BCD            .476:
20341                                           ! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20342 5BCD           8A46         FE            mov	al,-2[bp]
20343 5BD0           3C                     F0  cmp	al,#$F0
20344 5BD2           75           05            jne 	.474
20345                       00005BD4            .475:
20346                                           ! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
20347 5BD4           30C0                       xor	al,al
20348 5BD6           8846         FE            mov	-2[bp],al
20349                                           !BCC_EOS
20350                                           ! 3236       AX = (scan_code << 8) | ascii_code;
20351                       00005BD9            .474:
20352                                           ! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
20353 5BD9           8A46         FF            mov	al,-1[bp]
20354 5BDC           30E4                       xor	ah,ah
20355 5BDE           88C4                       mov	ah,al
20356 5BE0           30C0                       xor	al,al
20357                                           ! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
20358 5BE2           0A46         FE            or	al,-2[bp]
20359                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20360 5BE5           8946         12            mov	$12[bp],ax
20361                                           !BCC_EOS
20362                                           ! 3237       FLAGS &= 0xffbf;
20363                                           ! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
20364 5BE8           8B46         14            mov	ax,$14[bp]
20365 5BEB           24                     BF  and	al,#$BF
20366 5BED           8946         14            mov	$14[bp],ax
20367                                           !BCC_EOS
20368                                           ! 3238       break;
20369 5BF0           E9         00CB            br 	.439
20370                                           !BCC_EOS
20371                                           ! 3239     case 0x12:
20372                                           ! 3240       shift_flags = read_byte(0x0040, 0x17);
20373                       00005BF3            .477:
20374                                           ! Debug: list int = const $17 (used reg = )
20375 5BF3           B8                   0017  mov	ax,*$17
20376 5BF6           50                         push	ax
20377                                           ! Debug: list int = const $40 (used reg = )
20378 5BF7           B8                   0040  mov	ax,*$40
20379 5BFA           50                         push	ax
20380                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20381 5BFB           E8         A9F6            call	_read_byte
20382 5BFE           83C4                   04  add	sp,*4
20383                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20384 5C01           8846         FD            mov	-3[bp],al
20385                                           !BCC_EOS
20386                                           ! 3241       AX = ((AX & 0xff00) | (shift_flags));
20387                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
20388 5C04           8B46         12            mov	ax,$12[bp]
20389 5C07           30C0                       xor	al,al
20390                                           ! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
20391 5C09           0A46         FD            or	al,-3[bp]
20392                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20393 5C0C           8946         12            mov	$12[bp],ax
20394                                           !BCC_EOS
20395                                           ! 3242       shift_flags = read_byte(0x0040, 0x18) & 0x73;
20396                                           ! Debug: list int = const $18 (used reg = )
20397 5C0F           B8                   0018  mov	ax,*$18
20398 5C12           50                         push	ax
20399                                           ! Debug: list int = const $40 (used reg = )
20400 5C13           B8                   0040  mov	ax,*$40
20401 5C16           50                         push	ax
20402                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20403 5C17           E8         A9DA            call	_read_byte
20404 5C1A           83C4                   04  add	sp,*4
20405                                           ! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
20406 5C1D           24                     73  and	al,*$73
20407                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20408 5C1F           8846         FD            mov	-3[bp],al
20409                                           !BCC_EOS
20410                                           ! 3243       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
20411                                           ! Debug: list int = const $96 (used reg = )
20412 5C22           B8                   0096  mov	ax,#$96
20413 5C25           50                         push	ax
20414                                           ! Debug: list int = const $40 (used reg = )
20415 5C26           B8                   0040  mov	ax,*$40
20416 5C29           50                         push	ax
20417                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20418 5C2A           E8         A9C7            call	_read_byte
20419 5C2D           83C4                   04  add	sp,*4
20420                                           ! Debug: and int = const $C to unsigned char = al+0 (used reg = )
20421 5C30           24                     0C  and	al,*$C
20422                                           ! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
20423 5C32           0A46         FD            or	al,-3[bp]
20424 5C35           8846         FD            mov	-3[bp],al
20425                                           !BCC_EOS
20426                                           ! 3244       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
20427                                           ! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
20428 5C38           8A46         FD            mov	al,-3[bp]
20429 5C3B           30E4                       xor	ah,ah
20430 5C3D           88C4                       mov	ah,al
20431 5C3F           30C0                       xor	al,al
20432 5C41           50                         push	ax
20433                                           ! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
20434 5C42           8A46         12            mov	al,$12[bp]
20435                                           ! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
20436 5C45           30E4                       xor	ah,ah
20437 5C47           0B46         F4            or	ax,0+..FFF3[bp]
20438 5C4A           44                         inc	sp
20439 5C4B           44                         inc	sp
20440                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20441 5C4C           8946         12            mov	$12[bp],ax
20442                                           !BCC_EOS
20443                                           ! 3245       ;
20444                                           !BCC_EOS
20445                                           ! 3246       break;
20446 5C4F           EB           6D            jmp .439
20447                                           !BCC_EOS
20448                                           ! 3247     case 0x92:
20449                                           ! 3248       AX = ((AX & 0x00ff) | ((0x80) << 8));
20450                       00005C51            .478:
20451                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20452 5C51           8A46         12            mov	al,$12[bp]
20453                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
20454 5C54           30E4                       xor	ah,ah
20455 5C56           0D                   8000  or	ax,#-$8000
20456                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20457 5C59           8946         12            mov	$12[bp],ax
20458                                           !BCC_EOS
20459                                           ! 3249       break;
20460 5C5C           EB           60            jmp .439
20461                                           !BCC_EOS
20462                                           ! 3250     case 0xA2:
20463                                           ! 3251       break;
20464                       00005C5E            .479:
20465 5C5E           EB           5E            jmp .439
20466                                           !BCC_EOS
20467                                           ! 3252     case 0x6F:
20468                                           ! 3253       if (( AX & 0x00ff ) == 0x08)
20469                       00005C60            .47A:
20470                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20471 5C60           8A46         12            mov	al,$12[bp]
20472                                           ! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
20473 5C63           3C                     08  cmp	al,*8
20474 5C65           75           0B            jne 	.47B
20475                       00005C67            .47C:
20476                                           ! 3254         AX = ((AX & 0x00ff) | ((0x02) << 8));
20477                                           ! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
20478 5C67           8A46         12            mov	al,$12[bp]
20479                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
20480 5C6A           30E4                       xor	ah,ah
20481 5C6C           0D                   0200  or	ax,#$200
20482                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
20483 5C6F           8946         12            mov	$12[bp],ax
20484                                           !BCC_EOS
20485                                           ! 3255     default:
20486                       00005C72            .47B:
20487                                           ! 3256       ;
20488                       00005C72            .47D:
20489                                           !BCC_EOS
20490                                           ! 3257     }
20491                                           ! 3258 }
20492 5C72           EB           4A            jmp .439
20493                       00005C74            .43B:
20494 5C74           2D                   0000  sub	ax,*0
20495 5C77           7C           F9            jl 	.47D
20496 5C79           3D                   0012  cmp	ax,*$12
20497 5C7C           77           2F            ja  	.47E
20498 5C7E           D1E0                       shl	ax,*1
20499 5C80           89C3                       mov	bx,ax
20500 5C82           2E                         seg	cs
20501 5C83           FFA7       5C87            br	.47F[bx]
20502                       00005C87            .47F:
20503 5C87                      5988            .word	.43C
20504 5C89                      59DF            .word	.446
20505 5C8B                      5A3B            .word	.44F
20506 5C8D                      5C72            .word	.47D
20507 5C8F                      5C72            .word	.47D
20508 5C91                      5A5A            .word	.450
20509 5C93                      5C72            .word	.47D
20510 5C95                      5C72            .word	.47D
20511 5C97                      5C72            .word	.47D
20512 5C99                      5A8B            .word	.454
20513 5C9B                      5A98            .word	.455
20514 5C9D                      5C72            .word	.47D
20515 5C9F                      5C72            .word	.47D
20516 5CA1                      5C72            .word	.47D
20517 5CA3                      5C72            .word	.47D
20518 5CA5                      5C72            .word	.47D
20519 5CA7                      5B5C            .word	.46A
20520 5CA9                      5BA5            .word	.471
20521 5CAB                      5BF3            .word	.477
20522                       00005CAD            .47E:
20523 5CAD           2D                   006F  sub	ax,*$6F
20524 5CB0           74           AE            je 	.47A
20525 5CB2           2D                   0023  sub	ax,*$23
20526 5CB5           74           9A            je 	.478
20527 5CB7           2D                   0010  sub	ax,*$10
20528 5CBA           74           A2            je 	.479
20529 5CBC           EB           B4            jmp	.47D
20530                       00005CBE            .439:
20531                       FFFFFFF4            ..FFF3	=	-$C
20532 5CBE           89EC                       mov	sp,bp
20533 5CC0           5D                         pop	bp
20534 5CC1           C3                         ret
20535                                           ! 3259   unsigned int
20536                                           ! Register BX used in function int16_function
20537                                           ! 3260 dequeue_key(scan_code, ascii_code, incr)
20538                                           ! 3261   Bit8u *scan_code;
20539                                           export	_dequeue_key
20540                       00005CC2            _dequeue_key:
20541                                           !BCC_EOS
20542                                           ! 3262   Bit8u *ascii_code;
20543                                           !BCC_EOS
20544                                           ! 3263   unsigned int incr;
20545                                           !BCC_EOS
20546                                           ! 3264 {
20547                                           ! 3265   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
20548                                           !BCC_EOS
20549                                           ! 3266   Bit16u ss;
20550                                           !BCC_EOS
20551                                           ! 3267   Bit8u acode, scode;
20552                                           !BCC_EOS
20553                                           ! 3268   buffer_start = read_word(0x0040, 0x0080);
20554 5CC2           55                         push	bp
20555 5CC3           89E5                       mov	bp,sp
20556 5CC5           83C4                   F4  add	sp,*-$C
20557                                           ! Debug: list int = const $80 (used reg = )
20558 5CC8           B8                   0080  mov	ax,#$80
20559 5CCB           50                         push	ax
20560                                           ! Debug: list int = const $40 (used reg = )
20561 5CCC           B8                   0040  mov	ax,*$40
20562 5CCF           50                         push	ax
20563                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20564 5CD0           E8         A934            call	_read_word
20565 5CD3           83C4                   04  add	sp,*4
20566                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
20567 5CD6           8946         FE            mov	-2[bp],ax
20568                                           !BCC_EOS
20569                                           ! 3269   buffer_end = read_word(0x0040, 0x0082);
20570                                           ! Debug: list int = const $82 (used reg = )
20571 5CD9           B8                   0082  mov	ax,#$82
20572 5CDC           50                         push	ax
20573                                           ! Debug: list int = const $40 (used reg = )
20574 5CDD           B8                   0040  mov	ax,*$40
20575 5CE0           50                         push	ax
20576                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20577 5CE1           E8         A923            call	_read_word
20578 5CE4           83C4                   04  add	sp,*4
20579                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
20580 5CE7           8946         FC            mov	-4[bp],ax
20581                                           !BCC_EOS
20582                                           ! 3270   buffer_head = read_word(0x0040, 0x001a);
20583                                           ! Debug: list int = const $1A (used reg = )
20584 5CEA           B8                   001A  mov	ax,*$1A
20585 5CED           50                         push	ax
20586                                           ! Debug: list int = const $40 (used reg = )
20587 5CEE           B8                   0040  mov	ax,*$40
20588 5CF1           50                         push	ax
20589                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20590 5CF2           E8         A912            call	_read_word
20591 5CF5           83C4                   04  add	sp,*4
20592                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
20593 5CF8           8946         FA            mov	-6[bp],ax
20594                                           !BCC_EOS
20595                                           ! 3271   buffer_tail = read_word(0x0040, 0x001c);
20596                                           ! Debug: list int = const $1C (used reg = )
20597 5CFB           B8                   001C  mov	ax,*$1C
20598 5CFE           50                         push	ax
20599                                           ! Debug: list int = const $40 (used reg = )
20600 5CFF           B8                   0040  mov	ax,*$40
20601 5D02           50                         push	ax
20602                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
20603 5D03           E8         A901            call	_read_word
20604 5D06           83C4                   04  add	sp,*4
20605                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
20606 5D09           8946         F8            mov	-8[bp],ax
20607                                           !BCC_EOS
20608                                           ! 3272   if (buffer_head != buffer_tail) {
20609                                           ! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
20610 5D0C           8B46         FA            mov	ax,-6[bp]
20611 5D0F           3B46         F8            cmp	ax,-8[bp]
20612 5D12         0F84         0083            beq 	.480
20613                       00005D16            .481:
20614                                           ! 3273     ss = get_SS();
20615                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
20616 5D16           E8         A934            call	_get_SS
20617                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
20618 5D19           8946         F6            mov	-$A[bp],ax
20619                                           !BCC_EOS
20620                                           ! 3274     acode = read_byte(0x0040, buffer_head);
20621                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
20622 5D1C           FF76         FA            push	-6[bp]
20623                                           ! Debug: list int = const $40 (used reg = )
20624 5D1F           B8                   0040  mov	ax,*$40
20625 5D22           50                         push	ax
20626                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20627 5D23           E8         A8CE            call	_read_byte
20628 5D26           83C4                   04  add	sp,*4
20629                                           ! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
20630 5D29           8846         F5            mov	-$B[bp],al
20631                                           !BCC_EOS
20632                                           ! 3275     scode = read_byte(0x0040, buffer_head+1);
20633                                           ! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
20634 5D2C           8B46         FA            mov	ax,-6[bp]
20635                                           ! Debug: list unsigned int = ax+1 (used reg = )
20636 5D2F           40                         inc	ax
20637 5D30           50                         push	ax
20638                                           ! Debug: list int = const $40 (used reg = )
20639 5D31           B8                   0040  mov	ax,*$40
20640 5D34           50                         push	ax
20641                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
20642 5D35           E8         A8BC            call	_read_byte
20643 5D38           83C4                   04  add	sp,*4
20644                                           ! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
20645 5D3B           8846         F4            mov	-$C[bp],al
20646                                           !BCC_EOS
20647                                           ! 3276     write_byte(ss, ascii_code, acode);
20648                                           ! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
20649 5D3E           8A46         F5            mov	al,-$B[bp]
20650 5D41           30E4                       xor	ah,ah
20651 5D43           50                         push	ax
20652                                           ! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
20653 5D44           FF76         06            push	6[bp]
20654                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20655 5D47           FF76         F6            push	-$A[bp]
20656                                           ! Debug: func () void = write_byte+0 (used reg = )
20657 5D4A           E8         A8CD            call	_write_byte
20658 5D4D           83C4                   06  add	sp,*6
20659                                           !BCC_EOS
20660                                           ! 3277     write_byte(ss, scan_code, scode);
20661                                           ! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
20662 5D50           8A46         F4            mov	al,-$C[bp]
20663 5D53           30E4                       xor	ah,ah
20664 5D55           50                         push	ax
20665                                           ! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
20666 5D56           FF76         04            push	4[bp]
20667                                           ! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
20668 5D59           FF76         F6            push	-$A[bp]
20669                                           ! Debug: func () void = write_byte+0 (used reg = )
20670 5D5C           E8         A8BB            call	_write_byte
20671 5D5F           83C4                   06  add	sp,*6
20672                                           !BCC_EOS
20673                                           ! 3278     if (incr) {
20674 5D62           8B46         08            mov	ax,8[bp]
20675 5D65           85C0                       test	ax,ax
20676 5D67           74           27            je  	.482
20677                       00005D69            .483:
20678                                           ! 3279       buffer_head += 2;
20679                                           ! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
20680 5D69           8B46         FA            mov	ax,-6[bp]
20681 5D6C           40                         inc	ax
20682 5D6D           40                         inc	ax
20683 5D6E           8946         FA            mov	-6[bp],ax
20684                                           !BCC_EOS
20685                                           ! 3280       if (buffer_head >= buffer_end)
20686                                           ! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
20687 5D71           8B46         FA            mov	ax,-6[bp]
20688 5D74           3B46         FC            cmp	ax,-4[bp]
20689 5D77           72           06            jb  	.484
20690                       00005D79            .485:
20691                                           ! 3281         buffer_head = buffer_start;
20692                                           ! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
20693 5D79           8B46         FE            mov	ax,-2[bp]
20694 5D7C           8946         FA            mov	-6[bp],ax
20695                                           !BCC_EOS
20696                                           ! 3282       write_word(0x0040, 0x001a, buffer_head);
20697                       00005D7F            .484:
20698                                           ! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
20699 5D7F           FF76         FA            push	-6[bp]
20700                                           ! Debug: list int = const $1A (used reg = )
20701 5D82           B8                   001A  mov	ax,*$1A
20702 5D85           50                         push	ax
20703                                           ! Debug: list int = const $40 (used reg = )
20704 5D86           B8                   0040  mov	ax,*$40
20705 5D89           50                         push	ax
20706                                           ! Debug: func () void = write_word+0 (used reg = )
20707 5D8A           E8         A8A5            call	_write_word
20708 5D8D           83C4                   06  add	sp,*6
20709                                           !BCC_EOS
20710                                           ! 3283       }
20711                                           ! 3284     return(1);
20712                       00005D90            .482:
20713 5D90           B8                   0001  mov	ax,*1
20714 5D93           89EC                       mov	sp,bp
20715 5D95           5D                         pop	bp
20716 5D96           C3                         ret
20717                                           !BCC_EOS
20718                                           ! 3285     }
20719                                           ! 3286   else {
20720 5D97           EB           06            jmp .486
20721                       00005D99            .480:
20722                                           ! 3287     return(0);
20723 5D99           31C0                       xor	ax,ax
20724 5D9B           89EC                       mov	sp,bp
20725 5D9D           5D                         pop	bp
20726 5D9E           C3                         ret
20727                                           !BCC_EOS
20728                                           ! 3288     }
20729                                           ! 3289 }
20730                       00005D9F            .486:
20731 5D9F           89EC                       mov	sp,bp
20732 5DA1           5D                         pop	bp
20733 5DA2           C3                         ret
20734                                           ! 3290 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
20735                                           
20736                       00005DA3            _panic_msg_keyb_buffer_full:
20737                       00005DA3            .487:
20738 5DA3                        25            .ascii	"%s: keyboard input buffer full"
20739 5DC1                        0A            .byte	$A
20740 5DC2                        00            .byte	0
20741                                           !BCC_EOS
20742                                           ! 3291   Bit8u
20743                                           ! 3292 inhibit_mouse_int_and_events()
20744                                           ! 3293 {
20745                                           
20746                                           export	_inhibit_mouse_int_and_events
20747                       00005DC3            _inhibit_mouse_int_and_events:
20748                                           ! 3294   Bit8u command_byte, prev_command_byte;
20749                                           !BCC_EOS
20750                                           ! 3295   if ( inb(0x64) & 0x02 )
20751 5DC3           55                         push	bp
20752 5DC4           89E5                       mov	bp,sp
20753 5DC6           4C                         dec	sp
20754 5DC7           4C                         dec	sp
20755                                           ! Debug: list int = const $64 (used reg = )
20756 5DC8           B8                   0064  mov	ax,*$64
20757 5DCB           50                         push	ax
20758                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20759 5DCC           E8         A76F            call	_inb
20760 5DCF           44                         inc	sp
20761 5DD0           44                         inc	sp
20762                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20763 5DD1           24                     02  and	al,*2
20764 5DD3           84C0                       test	al,al
20765 5DD5           74           12            je  	.488
20766                       00005DD7            .489:
20767                                           ! 3296     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
20768                                           ! Debug: list * char = .48A+0 (used reg = )
20769 5DD7           BB                   D1AD  mov	bx,#.48A
20770 5DDA           53                         push	bx
20771                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20772 5DDB           BB                   5DA3  mov	bx,#_panic_msg_keyb_buffer_full
20773 5DDE           53                         push	bx
20774                                           ! Debug: list int = const 7 (used reg = )
20775 5DDF           B8                   0007  mov	ax,*7
20776 5DE2           50                         push	ax
20777                                           ! Debug: func () void = bios_printf+0 (used reg = )
20778 5DE3           E8         AC35            call	_bios_printf
20779 5DE6           83C4                   06  add	sp,*6
20780                                           !BCC_EOS
20781                                           ! 3297   outb(0x64, 0x20);
20782                       00005DE9            .488:
20783                                           ! Debug: list int = const $20 (used reg = )
20784 5DE9           B8                   0020  mov	ax,*$20
20785 5DEC           50                         push	ax
20786                                           ! Debug: list int = const $64 (used reg = )
20787 5DED           B8                   0064  mov	ax,*$64
20788 5DF0           50                         push	ax
20789                                           ! Debug: func () void = outb+0 (used reg = )
20790 5DF1           E8         A760            call	_outb
20791 5DF4           83C4                   04  add	sp,*4
20792                                           !BCC_EOS
20793                                           ! 3298   while ( (inb(0x64)
20794                                           ! 3298  & 0x01) != 0x01 );
20795 5DF7           EB           00            jmp .48C
20796                       00005DF9            .48D:
20797                                           !BCC_EOS
20798                                           ! 3299   prev_command_byte = inb(0x60);
20799                       00005DF9            .48C:
20800                                           ! Debug: list int = const $64 (used reg = )
20801 5DF9           B8                   0064  mov	ax,*$64
20802 5DFC           50                         push	ax
20803                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20804 5DFD           E8         A73E            call	_inb
20805 5E00           44                         inc	sp
20806 5E01           44                         inc	sp
20807                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20808 5E02           24                     01  and	al,*1
20809                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
20810 5E04           3C                     01  cmp	al,*1
20811 5E06           75           F1            jne	.48D
20812                       00005E08            .48E:
20813                       00005E08            .48B:
20814                                           ! Debug: list int = const $60 (used reg = )
20815 5E08           B8                   0060  mov	ax,*$60
20816 5E0B           50                         push	ax
20817                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20818 5E0C           E8         A72F            call	_inb
20819 5E0F           44                         inc	sp
20820 5E10           44                         inc	sp
20821                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
20822 5E11           8846         FE            mov	-2[bp],al
20823                                           !BCC_EOS
20824                                           ! 3300   command_byte = prev_command_byte;
20825                                           ! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
20826 5E14           8A46         FE            mov	al,-2[bp]
20827 5E17           8846         FF            mov	-1[bp],al
20828                                           !BCC_EOS
20829                                           ! 3301   if ( inb(0x64) & 0x02 )
20830                                           ! Debug: list int = const $64 (used reg = )
20831 5E1A           B8                   0064  mov	ax,*$64
20832 5E1D           50                         push	ax
20833                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20834 5E1E           E8         A71D            call	_inb
20835 5E21           44                         inc	sp
20836 5E22           44                         inc	sp
20837                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20838 5E23           24                     02  and	al,*2
20839 5E25           84C0                       test	al,al
20840 5E27           74           12            je  	.48F
20841                       00005E29            .490:
20842                                           ! 3302     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
20843                                           ! Debug: list * char = .491+0 (used reg = )
20844 5E29           BB                   D1A2  mov	bx,#.491
20845 5E2C           53                         push	bx
20846                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20847 5E2D           BB                   5DA3  mov	bx,#_panic_msg_keyb_buffer_full
20848 5E30           53                         push	bx
20849                                           ! Debug: list int = const 7 (used reg = )
20850 5E31           B8                   0007  mov	ax,*7
20851 5E34           50                         push	ax
20852                                           ! Debug: func () void = bios_printf+0 (used reg = )
20853 5E35           E8         ABE3            call	_bios_printf
20854 5E38           83C4                   06  add	sp,*6
20855                                           !BCC_EOS
20856                                           ! 3303   command_byte &= 0xfd;
20857                       00005E3B            .48F:
20858                                           ! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
20859 5E3B           8A46         FF            mov	al,-1[bp]
20860 5E3E           24                     FD  and	al,#$FD
20861 5E40           8846         FF            mov	-1[bp],al
20862                                           !BCC_EOS
20863                                           ! 3304   command_byte |= 0x20;
20864                                           ! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
20865 5E43           8A46         FF            mov	al,-1[bp]
20866 5E46           0C                     20  or	al,*$20
20867 5E48           8846         FF            mov	-1[bp],al
20868                                           !BCC_EOS
20869                                           ! 3305   outb(0x64, 0x60);
20870                                           ! Debug: list int = const $60 (used reg = )
20871 5E4B           B8                   0060  mov	ax,*$60
20872 5E4E           50                         push	ax
20873                                           ! Debug: list int = const $64 (used reg = )
20874 5E4F           B8                   0064  mov	ax,*$64
20875 5E52           50                         push	ax
20876                                           ! Debug: func () void = outb+0 (used reg = )
20877 5E53           E8         A6FE            call	_outb
20878 5E56           83C4                   04  add	sp,*4
20879                                           !BCC_EOS
20880                                           ! 3306   outb(0x60, command_byte);
20881                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
20882 5E59           8A46         FF            mov	al,-1[bp]
20883 5E5C           30E4                       xor	ah,ah
20884 5E5E           50                         push	ax
20885                                           ! Debug: list int = const $60 (used reg = )
20886 5E5F           B8                   0060  mov	ax,*$60
20887 5E62           50                         push	ax
20888                                           ! Debug: func () void = outb+0 (used reg = )
20889 5E63           E8         A6EE            call	_outb
20890 5E66           83C4                   04  add	sp,*4
20891                                           !BCC_EOS
20892                                           ! 3307   return(prev_command_byte);
20893 5E69           8A46         FE            mov	al,-2[bp]
20894 5E6C           89EC                       mov	sp,bp
20895 5E6E           5D                         pop	bp
20896 5E6F           C3                         ret
20897                                           !BCC_EOS
20898                                           ! 3308 }
20899                                           ! 3309   void
20900                                           ! Register BX used in function inhibit_mouse_int_and_events
20901                                           ! 3310 enable_mouse_int_and_events()
20902                                           ! 3311 {
20903                                           export	_enable_mouse_int_and_events
20904                       00005E70            _enable_mouse_int_and_events:
20905                                           ! 3312   Bit8u command_byte;
20906                                           !BCC_EOS
20907                                           ! 3313   if ( inb(0x64) & 0x02 )
20908 5E70           55                         push	bp
20909 5E71           89E5                       mov	bp,sp
20910 5E73           4C                         dec	sp
20911 5E74           4C                         dec	sp
20912                                           ! Debug: list int = const $64 (used reg = )
20913 5E75           B8                   0064  mov	ax,*$64
20914 5E78           50                         push	ax
20915                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20916 5E79           E8         A6C2            call	_inb
20917 5E7C           44                         inc	sp
20918 5E7D           44                         inc	sp
20919                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20920 5E7E           24                     02  and	al,*2
20921 5E80           84C0                       test	al,al
20922 5E82           74           12            je  	.492
20923                       00005E84            .493:
20924                                           ! 3314     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
20925                                           ! Debug: list * char = .494+0 (used reg = )
20926 5E84           BB                   D198  mov	bx,#.494
20927 5E87           53                         push	bx
20928                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20929 5E88           BB                   5DA3  mov	bx,#_panic_msg_keyb_buffer_full
20930 5E8B           53                         push	bx
20931                                           ! Debug: list int = const 7 (used reg = )
20932 5E8C           B8                   0007  mov	ax,*7
20933 5E8F           50                         push	ax
20934                                           ! Debug: func () void = bios_printf+0 (used reg = )
20935 5E90           E8         AB88            call	_bios_printf
20936 5E93           83C4                   06  add	sp,*6
20937                                           !BCC_EOS
20938                                           ! 3315   outb(0x64, 0x20);
20939                       00005E96            .492:
20940                                           ! Debug: list int = const $20 (used reg = )
20941 5E96           B8                   0020  mov	ax,*$20
20942 5E99           50                         push	ax
20943                                           ! Debug: list int = const $64 (used reg = )
20944 5E9A           B8                   0064  mov	ax,*$64
20945 5E9D           50                         push	ax
20946                                           ! Debug: func () void = outb+0 (used reg = )
20947 5E9E           E8         A6B3            call	_outb
20948 5EA1           83C4                   04  add	sp,*4
20949                                           !BCC_EOS
20950                                           ! 3316   while ( (inb(0x64) & 0x01) != 0x01 );
20951 5EA4           EB           00            jmp .496
20952                       00005EA6            .497:
20953                                           !BCC_EOS
20954                                           ! 3317   command_byte = inb(0x60);
20955                       00005EA6            .496:
20956                                           ! Debug: list int = const $64 (used reg = )
20957 5EA6           B8                   0064  mov	ax,*$64
20958 5EA9           50                         push	ax
20959                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20960 5EAA           E8         A691            call	_inb
20961 5EAD           44                         inc	sp
20962 5EAE           44                         inc	sp
20963                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
20964 5EAF           24                     01  and	al,*1
20965                                           ! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
20966 5EB1           3C                     01  cmp	al,*1
20967 5EB3           75           F1            jne	.497
20968                       00005EB5            .498:
20969                       00005EB5            .495:
20970                                           ! Debug: list int = const $60 (used reg = )
20971 5EB5           B8                   0060  mov	ax,*$60
20972 5EB8           50                         push	ax
20973                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20974 5EB9           E8         A682            call	_inb
20975 5EBC           44                         inc	sp
20976 5EBD           44                         inc	sp
20977                                           ! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
20978 5EBE           8846         FF            mov	-1[bp],al
20979                                           !BCC_EOS
20980                                           ! 3318   if ( inb(0x64) & 0x02 )
20981                                           ! Debug: list int = const $64 (used reg = )
20982 5EC1           B8                   0064  mov	ax,*$64
20983 5EC4           50                         push	ax
20984                                           ! Debug: func () unsigned char = inb+0 (used reg = )
20985 5EC5           E8         A676            call	_inb
20986 5EC8           44                         inc	sp
20987 5EC9           44                         inc	sp
20988                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
20989 5ECA           24                     02  and	al,*2
20990 5ECC           84C0                       test	al,al
20991 5ECE           74           12            je  	.499
20992                       00005ED0            .49A:
20993                                           ! 3319     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
20994                                           ! Debug: list * char = .49B+0 (used reg = )
20995 5ED0           BB                   D18E  mov	bx,#.49B
20996 5ED3           53                         push	bx
20997                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
20998 5ED4           BB                   5DA3  mov	bx,#_panic_msg_keyb_buffer_full
20999 5ED7           53                         push	bx
21000                                           ! Debug: list int = const 7 (used reg = )
21001 5ED8           B8                   0007  mov	ax,*7
21002 5EDB           50                         push	ax
21003                                           ! Debug: func () void = bios_printf+0 (used reg = )
21004 5EDC           E8         AB3C            call	_bios_printf
21005 5EDF           83C4                   06  add	sp,*6
21006                                           !BCC_EOS
21007                                           ! 3320   command_byte |= 0x02;
21008                       00005EE2            .499:
21009                                           ! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
21010 5EE2           8A46         FF            mov	al,-1[bp]
21011 5EE5           0C                     02  or	al,*2
21012 5EE7           8846         FF            mov	-1[bp],al
21013                                           !BCC_EOS
21014                                           ! 3321   command_byte &= 0xdf;
21015                                           ! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
21016 5EEA           8A46         FF            mov	al,-1[bp]
21017 5EED           24                     DF  and	al,#$DF
21018 5EEF           8846         FF            mov	-1[bp],al
21019                                           !BCC_EOS
21020                                           ! 3322   outb(0x64, 0x60);
21021                                           ! Debug: list int = const $60 (used reg = )
21022 5EF2           B8                   0060  mov	ax,*$60
21023 5EF5           50                         push	ax
21024                                           ! Debug: list int = const $64 (used reg = )
21025 5EF6           B8                   0064  mov	ax,*$64
21026 5EF9           50                         push	ax
21027                                           ! Debug: func () void = outb+0 (used reg = )
21028 5EFA           E8         A657            call	_outb
21029 5EFD           83C4                   04  add	sp,*4
21030                                           !BCC_EOS
21031                                           ! 3323   outb(0x60, command_byte);
21032                                           ! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
21033 5F00           8A46         FF            mov	al,-1[bp]
21034 5F03           30E4                       xor	ah,ah
21035 5F05           50                         push	ax
21036                                           ! Debug: list int = const $60 (used reg = )
21037 5F06           B8                   0060  mov	ax,*$60
21038 5F09           50                         push	ax
21039                                           ! Debug: func () void = outb+0 (used reg = )
21040 5F0A           E8         A647            call	_outb
21041 5F0D           83C4                   04  add	sp,*4
21042                                           !BCC_EOS
21043                                           ! 3324 }
21044 5F10           89EC                       mov	sp,bp
21045 5F12           5D                         pop	bp
21046 5F13           C3                         ret
21047                                           ! 3325   Bit8u
21048                                           ! Register BX used in function enable_mouse_int_and_events
21049                                           ! 3326 send_to_mouse_ctrl(sendbyte)
21050                                           ! 3327   Bit8u sendbyte;
21051                                           export	_send_to_mouse_ctrl
21052                       00005F14            _send_to_mouse_ctrl:
21053                                           !BCC_EOS
21054                                           ! 3328 {
21055                                           ! 3329   Bit8u response;
21056                                           !BCC_EOS
21057                                           ! 3330   if ( inb(0x64) & 0x02 )
21058 5F14           55                         push	bp
21059 5F15           89E5                       mov	bp,sp
21060 5F17           4C                         dec	sp
21061 5F18           4C                         dec	sp
21062                                           ! Debug: list int = const $64 (used reg = )
21063 5F19           B8                   0064  mov	ax,*$64
21064 5F1C           50                         push	ax
21065                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21066 5F1D           E8         A61E            call	_inb
21067 5F20           44                         inc	sp
21068 5F21           44                         inc	sp
21069                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21070 5F22           24                     02  and	al,*2
21071 5F24           84C0                       test	al,al
21072 5F26           74           12            je  	.49C
21073                       00005F28            .49D:
21074                                           ! 3331     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
21075                                           ! Debug: list * char = .49E+0 (used reg = )
21076 5F28           BB                   D184  mov	bx,#.49E
21077 5F2B           53                         push	bx
21078                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21079 5F2C           BB                   5DA3  mov	bx,#_panic_msg_keyb_buffer_full
21080 5F2F           53                         push	bx
21081                                           ! Debug: list int = const 7 (used reg = )
21082 5F30           B8                   0007  mov	ax,*7
21083 5F33           50                         push	ax
21084                                           ! Debug: func () void = bios_printf+0 (used reg = )
21085 5F34           E8         AAE4            call	_bios_printf
21086 5F37           83C4                   06  add	sp,*6
21087                                           !BCC_EOS
21088                                           ! 3332   outb(0x64, 0xD4);
21089                       00005F3A            .49C:
21090                                           ! Debug: list int = const $D4 (used reg = )
21091 5F3A           B8                   00D4  mov	ax,#$D4
21092 5F3D           50                         push	ax
21093                                           ! Debug: list int = const $64 (used reg = )
21094 5F3E           B8                   0064  mov	ax,*$64
21095 5F41           50                         push	ax
21096                                           ! Debug: func () void = outb+0 (used reg = )
21097 5F42           E8         A60F            call	_outb
21098 5F45           83C4                   04  add	sp,*4
21099                                           !BCC_EOS
21100                                           ! 3333   outb(0x60, sendbyte);
21101                                           ! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
21102 5F48           8A46         04            mov	al,4[bp]
21103 5F4B           30E4                       xor	ah,ah
21104 5F4D           50                         push	ax
21105                                           ! Debug: list int = const $60 (used reg = )
21106 5F4E           B8                   0060  mov	ax,*$60
21107 5F51           50                         push	ax
21108                                           ! Debug: func () void = outb+0 (used reg = )
21109 5F52           E8         A5FF            call	_outb
21110 5F55           83C4                   04  add	sp,*4
21111                                           !BCC_EOS
21112                                           ! 3334   return(0);
21113 5F58           30C0                       xor	al,al
21114 5F5A           89EC                       mov	sp,bp
21115 5F5C           5D                         pop	bp
21116 5F5D           C3                         ret
21117                                           !BCC_EOS
21118                                           ! 3335 }
21119                                           ! 3336   Bit8u
21120                                           ! Register BX used in function send_to_mouse_ctrl
21121                                           ! 3337 get_mouse_data(data)
21122                                           ! 3338   Bit8u *data;
21123                                           export	_get_mouse_data
21124                       00005F5E            _get_mouse_data:
21125                                           !BCC_EOS
21126                                           ! 3339 {
21127                                           ! 3340   Bit8u response;
21128                                           !BCC_EOS
21129                                           ! 3341   Bit16u ss;
21130                                           !BCC_EOS
21131                                           ! 3342   while ( (inb(0x64) & 0x21) != 0x21 ) {
21132 5F5E           55                         push	bp
21133 5F5F           89E5                       mov	bp,sp
21134 5F61           83C4                   FC  add	sp,*-4
21135 5F64           EB           00            jmp .4A0
21136                       00005F66            .4A1:
21137                                           ! 3343     }
21138                                           ! 3344   response = inb(0x60);
21139                       00005F66            .4A0:
21140                                           ! Debug: list int = const $64 (used reg = )
21141 5F66           B8                   0064  mov	ax,*$64
21142 5F69           50                         push	ax
21143                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21144 5F6A           E8         A5D1            call	_inb
21145 5F6D           44                         inc	sp
21146 5F6E           44                         inc	sp
21147                                           ! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
21148 5F6F           24                     21  and	al,*$21
21149                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
21150 5F71           3C                     21  cmp	al,*$21
21151 5F73           75           F1            jne	.4A1
21152                       00005F75            .4A2:
21153                       00005F75            .49F:
21154                                           ! Debug: list int = const $60 (used reg = )
21155 5F75           B8                   0060  mov	ax,*$60
21156 5F78           50                         push	ax
21157                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21158 5F79           E8         A5C2            call	_inb
21159 5F7C           44                         inc	sp
21160 5F7D           44                         inc	sp
21161                                           ! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
21162 5F7E           8846         FF            mov	-1[bp],al
21163                                           !BCC_EOS
21164                                           ! 3345   ss = get_SS();
21165                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
21166 5F81           E8         A6C9            call	_get_SS
21167                                           ! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
21168 5F84           8946         FC            mov	-4[bp],ax
21169                                           !BCC_EOS
21170                                           ! 3346   write_byte(ss, data, response);
21171                                           ! Debug: list unsigned char response = [S+6-3] (used reg = )
21172 5F87           8A46         FF            mov	al,-1[bp]
21173 5F8A           30E4                       xor	ah,ah
21174 5F8C           50                         push	ax
21175                                           ! Debug: list * unsigned char data = [S+8+2] (used reg = )
21176 5F8D           FF76         04            push	4[bp]
21177                                           ! Debug: list unsigned short ss = [S+$A-6] (used reg = )
21178 5F90           FF76         FC            push	-4[bp]
21179                                           ! Debug: func () void = write_byte+0 (used reg = )
21180 5F93           E8         A684            call	_write_byte
21181 5F96           83C4                   06  add	sp,*6
21182                                           !BCC_EOS
21183                                           ! 3347   return(0);
21184 5F99           30C0                       xor	al,al
21185 5F9B           89EC                       mov	sp,bp
21186 5F9D           5D                         pop	bp
21187 5F9E           C3                         ret
21188                                           !BCC_EOS
21189                                           ! 3348 }
21190                                           ! 3349   void
21191                                           ! 3350 set_kbd_command_byte(command_byte)
21192                                           ! 3351   Bit8u command_byte;
21193                                           export	_set_kbd_command_byte
21194                       00005F9F            _set_kbd_command_byte:
21195                                           !BCC_EOS
21196                                           ! 3352 {
21197                                           ! 3353   if ( inb(0x64) & 0x02 )
21198 5F9F           55                         push	bp
21199 5FA0           89E5                       mov	bp,sp
21200                                           ! Debug: list int = const $64 (used reg = )
21201 5FA2           B8                   0064  mov	ax,*$64
21202 5FA5           50                         push	ax
21203                                           ! Debug: func () unsigned char = inb+0 (used reg = )
21204 5FA6           E8         A595            call	_inb
21205 5FA9           89EC                       mov	sp,bp
21206                                           ! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
21207 5FAB           24                     02  and	al,*2
21208 5FAD           84C0                       test	al,al
21209 5FAF           74           11            je  	.4A3
21210                       00005FB1            .4A4:
21211                                           ! 3354     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
21212                                           ! Debug: list * char = .4A5+0 (used reg = )
21213 5FB1           BB                   D179  mov	bx,#.4A5
21214 5FB4           53                         push	bx
21215                                           ! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
21216 5FB5           BB                   5DA3  mov	bx,#_panic_msg_keyb_buffer_full
21217 5FB8           53                         push	bx
21218                                           ! Debug: list int = const 7 (used reg = )
21219 5FB9           B8                   0007  mov	ax,*7
21220 5FBC           50                         push	ax
21221                                           ! Debug: func () void = bios_printf+0 (used reg = )
21222 5FBD           E8         AA5B            call	_bios_printf
21223 5FC0           89EC                       mov	sp,bp
21224                                           !BCC_EOS
21225                                           ! 3355   outb(0x64, 0xD4);
21226                       00005FC2            .4A3:
21227                                           ! Debug: list int = const $D4 (used reg = )
21228 5FC2           B8                   00D4  mov	ax,#$D4
21229 5FC5           50                         push	ax
21230                                           ! Debug: list int = const $64 (used reg = )
21231 5FC6           B8                   0064  mov	ax,*$64
21232 5FC9           50                         push	ax
21233                                           ! Debug: func () void = outb+0 (used reg = )
21234 5FCA           E8         A587            call	_outb
21235 5FCD           89EC                       mov	sp,bp
21236                                           !BCC_EOS
21237                                           ! 3356   outb(0x64, 0x60);
21238                                           ! Debug: list int = const $60 (used reg = )
21239 5FCF           B8                   0060  mov	ax,*$60
21240 5FD2           50                         push	ax
21241                                           ! Debug: list int = const $64 (used reg = )
21242 5FD3           B8                   0064  mov	ax,*$64
21243 5FD6           50                         push	ax
21244                                           ! Debug: func () void = outb+0 (used reg = )
21245 5FD7           E8         A57A            call	_outb
21246 5FDA           89EC                       mov	sp,bp
21247                                           !BCC_EOS
21248                                           ! 3357   outb(0x60, command_byte);
21249                                           ! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
21250 5FDC           8A46         04            mov	al,4[bp]
21251 5FDF           30E4                       xor	ah,ah
21252 5FE1           50                         push	ax
21253                                           ! Debug: list int = const $60 (used reg = )
21254 5FE2           B8                   0060  mov	ax,*$60
21255 5FE5           50                         push	ax
21256                                           ! Debug: func () void = outb+0 (used reg = )
21257 5FE6           E8         A56B            call	_outb
21258 5FE9           89EC                       mov	sp,bp
21259                                           !BCC_EOS
21260                                           ! 3358 }
21261 5FEB           5D                         pop	bp
21262 5FEC           C3                         ret
21263                                           ! 3359   void
21264                                           ! Register BX used in function set_kbd_command_byte
21265                                           ! 3360 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
21266                                           ! 3361   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
21267                                           export	_int09_function
21268                       00005FED            _int09_function:
21269                                           !BCC_EOS
21270                                           ! 3362 {
21271                                           ! 3363   Bit8u scancode, asciicode, shift_flags;
21272                                           !BCC_EOS
21273                                           ! 3364   Bit8u mf2_flags, mf2_state;
21274                                           !BCC_EOS
21275                                           ! 3365   scancode = ( AX & 0x00ff );
21276 5FED           55                         push	bp
21277 5FEE           89E5                       mov	bp,sp
21278 5FF0           83C4                   FA  add	sp,*-6
21279                                           ! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
21280 5FF3           8A46         12            mov	al,$12[bp]
21281                                           ! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
21282 5FF6           8846         FF            mov	-1[bp],al
21283                                           !BCC_EOS
21284                                           ! 3366   if (scancode == 0) {
21285                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
21286 5FF9           8A46         FF            mov	al,-1[bp]
21287 5FFC           84C0                       test	al,al
21288 5FFE           75           04            jne 	.4A6
21289                       00006000            .4A7:
21290                                           ! 3367     ;
21291                                           !BCC_EOS
21292                                           ! 3368     return;
21293 6000           89EC                       mov	sp,bp
21294 6002           5D                         pop	bp
21295 6003           C3                         ret
21296                                           !BCC_EOS
21297                                           ! 3369     }
21298                                           ! 3370   shift_flags = read_byte(0x0040, 0x17);
21299                       00006004            .4A6:
21300                                           ! Debug: list int = const $17 (used reg = )
21301 6004           B8                   0017  mov	ax,*$17
21302 6007           50                         push	ax
21303                                           ! Debug: list int = const $40 (used reg = )
21304 6008           B8                   0040  mov	ax,*$40
21305 600B           50                         push	ax
21306                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21307 600C           E8         A5E5            call	_read_byte
21308 600F           83C4                   04  add	sp,*4
21309                                           ! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
21310 6012           8846         FD            mov	-3[bp],al
21311                                           !BCC_EOS
21312                                           ! 3371   mf2_flags = read_byte(0x0040, 0x18);
21313                                           ! Debug: list int = const $18 (used reg = )
21314 6015           B8                   0018  mov	ax,*$18
21315 6018           50                         push	ax
21316                                           ! Debug: list int = const $40 (used reg = )
21317 6019           B8                   0040  mov	ax,*$40
21318 601C           50                         push	ax
21319                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21320 601D           E8         A5D4            call	_read_byte
21321 6020           83C4                   04  add	sp,*4
21322                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
21323 6023           8846         FC            mov	-4[bp],al
21324                                           !BCC_EOS
21325                                           ! 3372   mf2_state = read_byte(0x0040, 0x96);
21326                                           ! Debug: list int = const $96 (used reg = )
21327 6026           B8                   0096  mov	ax,#$96
21328 6029           50                         push	ax
21329                                           ! Debug: list int = const $40 (used reg = )
21330 602A           B8                   0040  mov	ax,*$40
21331 602D           50                         push	ax
21332                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
21333 602E           E8         A5C3            call	_read_byte
21334 6031           83C4                   04  add	sp,*4
21335                                           ! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
21336 6034           8846         FB            mov	-5[bp],al
21337                                           !BCC_EOS
21338                                           ! 3373   asciicode = 0;
21339                                           ! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
21340 6037           30C0                       xor	al,al
21341 6039           8846         FE            mov	-2[bp],al
21342                                           !BCC_EOS
21343                                           ! 3374   switch (scancode) {
21344 603C           8A46         FF            mov	al,-1[bp]
21345 603F           E9         0570            br 	.4AA
21346                                           ! 3375     case 0x3a:
21347                                           ! 3376       shift_flags ^= 0x40;
21348                       00006042            .4AB:
21349                                           ! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
21350 6042           8A46         FD            mov	al,-3[bp]
21351 6045           34                     40  xor	al,*$40
21352 6047           8846         FD            mov	-3[bp],al
21353                                           !BCC_EOS
21354                                           ! 3377       write_byte(0x0040, 0x17, shift_flags);
21355                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21356 604A           8A46         FD            mov	al,-3[bp]
21357 604D           30E4                       xor	ah,ah
21358 604F           50                         push	ax
21359                                           ! Debug: list int = const $17 (used reg = )
21360 6050           B8                   0017  mov	ax,*$17
21361 6053           50                         push	ax
21362                                           ! Debug: list int = const $40 (used reg = )
21363 6054           B8                   0040  mov	ax,*$40
21364 6057           50                         push	ax
21365                                           ! Debug: func () void = write_byte+0 (used reg = )
21366 6058           E8         A5BF            call	_write_byte
21367 605B           83C4                   06  add	sp,*6
21368                                           !BCC_EOS
21369                                           ! 3378       mf2_flags |= 0x40;
21370                                           ! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
21371 605E           8A46         FC            mov	al,-4[bp]
21372 6061           0C                     40  or	al,*$40
21373 6063           8846         FC            mov	-4[bp],al
21374                                           !BCC_EOS
21375                                           ! 3379       write_byte(0x0040, 0x18, mf2_flags);
21376                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21377 6066           8A46         FC            mov	al,-4[bp]
21378 6069           30E4                       xor	ah,ah
21379 606B           50                         push	ax
21380                                           ! Debug: list int = const $18 (used reg = )
21381 606C           B8                   0018  mov	ax,*$18
21382 606F           50                         push	ax
21383                                           ! Debug: list int = const $40 (used reg = )
21384 6070           B8                   0040  mov	ax,*$40
21385 6073           50                         push	ax
21386                                           ! Debug: func () void = write_byte+0 (used reg = )
21387 6074           E8         A5A3            call	_write_byte
21388 6077           83C4                   06  add	sp,*6
21389                                           !BCC_EOS
21390                                           ! 3380       break;
21391 607A           E9         0592            br 	.4A8
21392                                           !BCC_EOS
21393                                           ! 3381     case 0xba:
21394                                           ! 3382       mf2_flags &= ~0x40;
21395                       0000607D            .4AC:
21396                                           ! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
21397 607D           8A46         FC            mov	al,-4[bp]
21398 6080           24                     BF  and	al,#$BF
21399 6082           8846         FC            mov	-4[bp],al
21400                                           !BCC_EOS
21401                                           ! 3383       
21402                                           ! 3383 write_byte(0x0040, 0x18, mf2_flags);
21403                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21404 6085           8A46         FC            mov	al,-4[bp]
21405 6088           30E4                       xor	ah,ah
21406 608A           50                         push	ax
21407                                           ! Debug: list int = const $18 (used reg = )
21408 608B           B8                   0018  mov	ax,*$18
21409 608E           50                         push	ax
21410                                           ! Debug: list int = const $40 (used reg = )
21411 608F           B8                   0040  mov	ax,*$40
21412 6092           50                         push	ax
21413                                           ! Debug: func () void = write_byte+0 (used reg = )
21414 6093           E8         A584            call	_write_byte
21415 6096           83C4                   06  add	sp,*6
21416                                           !BCC_EOS
21417                                           ! 3384       break;
21418 6099           E9         0573            br 	.4A8
21419                                           !BCC_EOS
21420                                           ! 3385     case 0x2a:
21421                                           ! 3386       shift_flags |= 0x02;
21422                       0000609C            .4AD:
21423                                           ! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
21424 609C           8A46         FD            mov	al,-3[bp]
21425 609F           0C                     02  or	al,*2
21426 60A1           8846         FD            mov	-3[bp],al
21427                                           !BCC_EOS
21428                                           ! 3387       write_byte(0x0040, 0x17, shift_flags);
21429                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21430 60A4           8A46         FD            mov	al,-3[bp]
21431 60A7           30E4                       xor	ah,ah
21432 60A9           50                         push	ax
21433                                           ! Debug: list int = const $17 (used reg = )
21434 60AA           B8                   0017  mov	ax,*$17
21435 60AD           50                         push	ax
21436                                           ! Debug: list int = const $40 (used reg = )
21437 60AE           B8                   0040  mov	ax,*$40
21438 60B1           50                         push	ax
21439                                           ! Debug: func () void = write_byte+0 (used reg = )
21440 60B2           E8         A565            call	_write_byte
21441 60B5           83C4                   06  add	sp,*6
21442                                           !BCC_EOS
21443                                           ! 3388       break;
21444 60B8           E9         0554            br 	.4A8
21445                                           !BCC_EOS
21446                                           ! 3389     case 0xaa:
21447                                           ! 3390       shift_flags &= ~0x02;
21448                       000060BB            .4AE:
21449                                           ! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
21450 60BB           8A46         FD            mov	al,-3[bp]
21451 60BE           24                     FD  and	al,#$FD
21452 60C0           8846         FD            mov	-3[bp],al
21453                                           !BCC_EOS
21454                                           ! 3391       write_byte(0x0040, 0x17, shift_flags);
21455                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21456 60C3           8A46         FD            mov	al,-3[bp]
21457 60C6           30E4                       xor	ah,ah
21458 60C8           50                         push	ax
21459                                           ! Debug: list int = const $17 (used reg = )
21460 60C9           B8                   0017  mov	ax,*$17
21461 60CC           50                         push	ax
21462                                           ! Debug: list int = const $40 (used reg = )
21463 60CD           B8                   0040  mov	ax,*$40
21464 60D0           50                         push	ax
21465                                           ! Debug: func () void = write_byte+0 (used reg = )
21466 60D1           E8         A546            call	_write_byte
21467 60D4           83C4                   06  add	sp,*6
21468                                           !BCC_EOS
21469                                           ! 3392       break;
21470 60D7           E9         0535            br 	.4A8
21471                                           !BCC_EOS
21472                                           ! 3393     case 0x36:
21473                                           ! 3394       shift_flags |= 0x01;
21474                       000060DA            .4AF:
21475                                           ! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
21476 60DA           8A46         FD            mov	al,-3[bp]
21477 60DD           0C                     01  or	al,*1
21478 60DF           8846         FD            mov	-3[bp],al
21479                                           !BCC_EOS
21480                                           ! 3395       write_byte(0x0040, 0x17, shift_flags);
21481                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21482 60E2           8A46         FD            mov	al,-3[bp]
21483 60E5           30E4                       xor	ah,ah
21484 60E7           50                         push	ax
21485                                           ! Debug: list int = const $17 (used reg = )
21486 60E8           B8                   0017  mov	ax,*$17
21487 60EB           50                         push	ax
21488                                           ! Debug: list int = const $40 (used reg = )
21489 60EC           B8                   0040  mov	ax,*$40
21490 60EF           50                         push	ax
21491                                           ! Debug: func () void = write_byte+0 (used reg = )
21492 60F0           E8         A527            call	_write_byte
21493 60F3           83C4                   06  add	sp,*6
21494                                           !BCC_EOS
21495                                           ! 3396       break;
21496 60F6           E9         0516            br 	.4A8
21497                                           !BCC_EOS
21498                                           ! 3397     case 0xb6:
21499                                           ! 3398       shift_flags &= ~0x01;
21500                       000060F9            .4B0:
21501                                           ! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
21502 60F9           8A46         FD            mov	al,-3[bp]
21503 60FC           24                     FE  and	al,#$FE
21504 60FE           8846         FD            mov	-3[bp],al
21505                                           !BCC_EOS
21506                                           ! 3399       write_byte(0x0040, 0x17, shift_flags);
21507                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21508 6101           8A46         FD            mov	al,-3[bp]
21509 6104           30E4                       xor	ah,ah
21510 6106           50                         push	ax
21511                                           ! Debug: list int = const $17 (used reg = )
21512 6107           B8                   0017  mov	ax,*$17
21513 610A           50                         push	ax
21514                                           ! Debug: list int = const $40 (used reg = )
21515 610B           B8                   0040  mov	ax,*$40
21516 610E           50                         push	ax
21517                                           ! Debug: func () void = write_byte+0 (used reg = )
21518 610F           E8         A508            call	_write_byte
21519 6112           83C4                   06  add	sp,*6
21520                                           !BCC_EOS
21521                                           ! 3400       break;
21522 6115           E9         04F7            br 	.4A8
21523                                           !BCC_EOS
21524                                           ! 3401     case 0x1d:
21525                                           ! 3402       if ((mf2_state & 0x01) == 0) {
21526                       00006118            .4B1:
21527                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21528 6118           8A46         FB            mov	al,-5[bp]
21529 611B           24                     01  and	al,*1
21530                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21531 611D           84C0                       test	al,al
21532 611F           75           5F            jne 	.4B2
21533                       00006121            .4B3:
21534                                           ! 3403         shift_flags |= 0x04;
21535                                           ! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
21536 6121           8A46         FD            mov	al,-3[bp]
21537 6124           0C                     04  or	al,*4
21538 6126           8846         FD            mov	-3[bp],al
21539                                           !BCC_EOS
21540                                           ! 3404         write_byte(0x0040, 0x17, shift_flags);
21541                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21542 6129           8A46         FD            mov	al,-3[bp]
21543 612C           30E4                       xor	ah,ah
21544 612E           50                         push	ax
21545                                           ! Debug: list int = const $17 (used reg = )
21546 612F           B8                   0017  mov	ax,*$17
21547 6132           50                         push	ax
21548                                           ! Debug: list int = const $40 (used reg = )
21549 6133           B8                   0040  mov	ax,*$40
21550 6136           50                         push	ax
21551                                           ! Debug: func () void = write_byte+0 (used reg = )
21552 6137           E8         A4E0            call	_write_byte
21553 613A           83C4                   06  add	sp,*6
21554                                           !BCC_EOS
21555                                           ! 3405         if (mf2_state & 0x02) {
21556                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21557 613D           8A46         FB            mov	al,-5[bp]
21558 6140           24                     02  and	al,*2
21559 6142           84C0                       test	al,al
21560 6144           74           1E            je  	.4B4
21561                       00006146            .4B5:
21562                                           ! 3406           mf2_state |= 0x04;
21563                                           ! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
21564 6146           8A46         FB            mov	al,-5[bp]
21565 6149           0C                     04  or	al,*4
21566 614B           8846         FB            mov	-5[bp],al
21567                                           !BCC_EOS
21568                                           ! 3407           write_byte(0x0040, 0x96, mf2_state);
21569                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21570 614E           8A46         FB            mov	al,-5[bp]
21571 6151           30E4                       xor	ah,ah
21572 6153           50                         push	ax
21573                                           ! Debug: list int = const $96 (used reg = )
21574 6154           B8                   0096  mov	ax,#$96
21575 6157           50                         push	ax
21576                                           ! Debug: list int = const $40 (used reg = )
21577 6158           B8                   0040  mov	ax,*$40
21578 615B           50                         push	ax
21579                                           ! Debug: func () void = write_byte+0 (used reg = )
21580 615C           E8         A4BB            call	_write_byte
21581 615F           83C4                   06  add	sp,*6
21582                                           !BCC_EOS
21583                                           ! 3408         } else {
21584 6162           EB           1C            jmp .4B6
21585                       00006164            .4B4:
21586                                           ! 3409           mf2_flags |= 0x01;
21587                                           ! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
21588 6164           8A46         FC            mov	al,-4[bp]
21589 6167           0C                     01  or	al,*1
21590 6169           8846         FC            mov	-4[bp],al
21591                                           !BCC_EOS
21592                                           ! 3410           write_byte(0x0040, 0x18, mf2_flags);
21593                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21594 616C           8A46         FC            mov	al,-4[bp]
21595 616F           30E4                       xor	ah,ah
21596 6171           50                         push	ax
21597                                           ! Debug: list int = const $18 (used reg = )
21598 6172           B8                   0018  mov	ax,*$18
21599 6175           50                         push	ax
21600                                           ! Debug: list int = const $40 (used reg = )
21601 6176           B8                   0040  mov	ax,*$40
21602 6179           50                         push	ax
21603                                           ! Debug: func () void = write_byte+0 (used reg = )
21604 617A           E8         A49D            call	_write_byte
21605 617D           83C4                   06  add	sp,*6
21606                                           !BCC_EOS
21607                                           ! 3411         }
21608                                           ! 3412       }
21609                       00006180            .4B6:
21610                                           ! 3413       break;
21611                       00006180            .4B2:
21612 6180           E9         048C            br 	.4A8
21613                                           !BCC_EOS
21614                                           ! 3414     case 0x9d:
21615                                           ! 3415       if ((mf2_state & 0x01) == 0) {
21616                       00006183            .4B7:
21617                                           ! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
21618 6183           8A46         FB            mov	al,-5[bp]
21619 6186           24                     01  and	al,*1
21620                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21621 6188           84C0                       test	al,al
21622 618A           75           5F            jne 	.4B8
21623                       0000618C            .4B9:
21624                                           ! 3416         shift_flags &= ~0x04;
21625                                           ! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
21626 618C           8A46         FD            mov	al,-3[bp]
21627 618F           24                     FB  and	al,#$FB
21628 6191           8846         FD            mov	-3[bp],al
21629                                           !BCC_EOS
21630                                           ! 3417         write_byte(0x0040, 0x17, shift_flags);
21631                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21632 6194           8A46         FD            mov	al,-3[bp]
21633 6197           30E4                       xor	ah,ah
21634 6199           50                         push	ax
21635                                           ! Debug: list int = const $17 (used reg = )
21636 619A           B8                   0017  mov	ax,*$17
21637 619D           50                         push	ax
21638                                           ! Debug: list int = const $40 (used reg = )
21639 619E           B8                   0040  mov	ax,*$40
21640 61A1           50                         push	ax
21641                                           ! Debug: func () void = write_byte+0 (used reg = )
21642 61A2           E8         A475            call	_write_byte
21643 61A5           83C4                   06  add	sp,*6
21644                                           !BCC_EOS
21645                                           ! 3418         if (mf2_state & 0x02) {
21646                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21647 61A8           8A46         FB            mov	al,-5[bp]
21648 61AB           24                     02  and	al,*2
21649 61AD           84C0                       test	al,al
21650 61AF           74           1E            je  	.4BA
21651                       000061B1            .4BB:
21652                                           ! 3419           mf2_state &= ~0x04;
21653                                           ! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
21654 61B1           8A46         FB            mov	al,-5[bp]
21655 61B4           24                     FB  and	al,#$FB
21656 61B6           8846         FB            mov	-5[bp],al
21657                                           !BCC_EOS
21658                                           ! 3420           write_byte(0x0040, 0x96, mf2_state);
21659                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21660 61B9           8A46         FB            mov	al,-5[bp]
21661 61BC           30E4                       xor	ah,ah
21662 61BE           50                         push	ax
21663                                           ! Debug: list int = const $96 (used reg = )
21664 61BF           B8                   0096  mov	ax,#$96
21665 61C2           50                         push	ax
21666                                           ! Debug: list int = const $40 (used reg = )
21667 61C3           B8                   0040  mov	ax,*$40
21668 61C6           50                         push	ax
21669                                           ! Debug: func () void = write_byte+0 (used reg = )
21670 61C7           E8         A450            call	_write_byte
21671 61CA           83C4                   06  add	sp,*6
21672                                           !BCC_EOS
21673                                           ! 3421         } else {
21674 61CD           EB           1C            jmp .4BC
21675                       000061CF            .4BA:
21676                                           ! 3422           mf2_flags &= ~0x01;
21677                                           ! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
21678 61CF           8A46         FC            mov	al,-4[bp]
21679 61D2           24                     FE  and	al,#$FE
21680 61D4           8846         FC            mov	-4[bp],al
21681                                           !BCC_EOS
21682                                           ! 3423           write_byte(0x0040, 0x18, mf2_flags);
21683                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21684 61D7           8A46         FC            mov	al,-4[bp]
21685 61DA           30E4                       xor	ah,ah
21686 61DC           50                         push	ax
21687                                           ! Debug: list int = const $18 (used reg = )
21688 61DD           B8                   0018  mov	ax,*$18
21689 61E0           50                         push	ax
21690                                           ! Debug: list int = const $40 (used reg = )
21691 61E1           B8                   0040  mov	ax,*$40
21692 61E4           50                         push	ax
21693                                           ! Debug: func () void = write_byte+0 (used reg = )
21694 61E5           E8         A432            call	_write_byte
21695 61E8           83C4                   06  add	sp,*6
21696                                           !BCC_EOS
21697                                           ! 3424         }
21698                                           ! 3425       }
21699                       000061EB            .4BC:
21700                                           ! 3426       break;
21701                       000061EB            .4B8:
21702 61EB           E9         0421            br 	.4A8
21703                                           !BCC_EOS
21704                                           ! 3427     case 0x38:
21705                                           ! 3428       shift_flags |= 0x08;
21706                       000061EE            .4BD:
21707                                           ! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
21708 61EE           8A46         FD            mov	al,-3[bp]
21709 61F1           0C                     08  or	al,*8
21710 61F3           8846         FD            mov	-3[bp],al
21711                                           !BCC_EOS
21712                                           ! 3429       write_byte(0x0040, 0x17, shift_flags);
21713                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21714 61F6           8A46         FD            mov	al,-3[bp]
21715 61F9           30E4                       xor	ah,ah
21716 61FB           50                         push	ax
21717                                           ! Debug: list int = const $17 (used reg = )
21718 61FC           B8                   0017  mov	ax,*$17
21719 61FF           50                         push	ax
21720                                           ! Debug: list int = const $40 (used reg = )
21721 6200           B8                   0040  mov	ax,*$40
21722 6203           50                         push	ax
21723                                           ! Debug: func () void = write_byte+0 (used reg = )
21724 6204           E8         A413            call	_write_byte
21725 6207           83C4                   06  add	sp,*6
21726                                           !BCC_EOS
21727                                           ! 3430       if (mf2_state & 0x02) {
21728                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21729 620A           8A46         FB            mov	al,-5[bp]
21730 620D           24                     02  and	al,*2
21731 620F           84C0                       test	al,al
21732 6211           74           1E            je  	.4BE
21733                       00006213            .4BF:
21734                                           ! 3431         mf2_state |= 0x08;
21735                                           ! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
21736 6213           8A46         FB            mov	al,-5[bp]
21737 6216           0C                     08  or	al,*8
21738 6218           8846         FB            mov	-5[bp],al
21739                                           !BCC_EOS
21740                                           ! 3432         write_byte(0x0040, 0x96, mf2_state);
21741                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21742 621B           8A46         FB            mov	al,-5[bp]
21743 621E           30E4                       xor	ah,ah
21744 6220           50                         push	ax
21745                                           ! Debug: list int = const $96 (used reg = )
21746 6221           B8                   0096  mov	ax,#$96
21747 6224           50                         push	ax
21748                                           ! Debug: list int = const $40 (used reg = )
21749 6225           B8                   0040  mov	ax,*$40
21750 6228           50                         push	ax
21751                                           ! Debug: func () void = write_byte+0 (used reg = )
21752 6229           E8         A3EE            call	_write_byte
21753 622C           83C4                   06  add	sp,*6
21754                                           !BCC_EOS
21755                                           ! 3433       } else {
21756 622F           EB           1C            jmp .4C0
21757                       00006231            .4BE:
21758                                           ! 3434         mf2_flags |= 0x02;
21759                                           ! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
21760 6231           8A46         FC            mov	al,-4[bp]
21761 6234           0C                     02  or	al,*2
21762 6236           8846         FC            mov	-4[bp],al
21763                                           !BCC_EOS
21764                                           ! 3435         write_byte(0x0040, 0x18, mf2_flags);
21765                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21766 6239           8A46         FC            mov	al,-4[bp]
21767 623C           30E4                       xor	ah,ah
21768 623E           50                         push	ax
21769                                           ! Debug: list int = const $18 (used reg = )
21770 623F           B8                   0018  mov	ax,*$18
21771 6242           50                         push	ax
21772                                           ! Debug: list int = const $40 (used reg = )
21773 6243           B8                   0040  mov	ax,*$40
21774 6246           50                         push	ax
21775                                           ! Debug: func () void = write_byte+0 (used reg = )
21776 6247           E8         A3D0            call	_write_byte
21777 624A           83C4                   06  add	sp,*6
21778                                           !BCC_EOS
21779                                           ! 3436       }
21780                                           ! 3437       break;
21781                       0000624D            .4C0:
21782 624D           E9         03BF            br 	.4A8
21783                                           !BCC_EOS
21784                                           ! 3438     case 0xb8:
21785                                           ! 3439       shift_flags &= ~0x08;
21786                       00006250            .4C1:
21787                                           ! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
21788 6250           8A46         FD            mov	al,-3[bp]
21789 6253           24                     F7  and	al,#$F7
21790 6255           8846         FD            mov	-3[bp],al
21791                                           !BCC_EOS
21792                                           ! 3440       write_byte(0x0040, 0x17, shift_flags);
21793                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21794 6258           8A46         FD            mov	al,-3[bp]
21795 625B           30E4                       xor	ah,ah
21796 625D           50                         push	ax
21797                                           ! Debug: list int = const $17 (used reg = )
21798 625E           B8                   0017  mov	ax,*$17
21799 6261           50                         push	ax
21800                                           ! Debug: list int = const $40 (used reg = )
21801 6262           B8                   0040  mov	ax,*$40
21802 6265           50                         push	ax
21803                                           ! Debug: func () void = write_byte+0 (used reg = )
21804 6266           E8         A3B1            call	_write_byte
21805 6269           83C4                   06  add	sp,*6
21806                                           !BCC_EOS
21807                                           ! 3441       if (mf2_state & 0x02) {
21808                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
21809 626C           8A46         FB            mov	al,-5[bp]
21810 626F           24                     02  and	al,*2
21811 6271           84C0                       test	al,al
21812 6273           74           1E            je  	.4C2
21813                       00006275            .4C3:
21814                                           ! 3442         mf2_state &= ~0x08;
21815                                           ! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
21816 6275           8A46         FB            mov	al,-5[bp]
21817 6278           24                     F7  and	al,#$F7
21818 627A           8846         FB            mov	-5[bp],al
21819                                           !BCC_EOS
21820                                           ! 3443         write_byte(0x0040, 0x96, mf2_state);
21821                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
21822 627D           8A46         FB            mov	al,-5[bp]
21823 6280           30E4                       xor	ah,ah
21824 6282           50                         push	ax
21825                                           ! Debug: list int = const $96 (used reg = )
21826 6283           B8                   0096  mov	ax,#$96
21827 6286           50                         push	ax
21828                                           ! Debug: list int = const $40 (used reg = )
21829 6287           B8                   0040  mov	ax,*$40
21830 628A           50                         push	ax
21831                                           ! Debug: func () void = write_byte+0 (used reg = )
21832 628B           E8         A38C            call	_write_byte
21833 628E           83C4                   06  add	sp,*6
21834                                           !BCC_EOS
21835                                           ! 3444       } else {
21836 6291           EB           1C            jmp .4C4
21837                       00006293            .4C2:
21838                                           ! 3445         mf2_flags &= ~0x02;
21839                                           ! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
21840 6293           8A46         FC            mov	al,-4[bp]
21841 6296           24                     FD  and	al,#$FD
21842 6298           8846         FC            mov	-4[bp],al
21843                                           !BCC_EOS
21844                                           ! 3446         write_byte(0x0040, 0x18, mf2_flags);
21845                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21846 629B           8A46         FC            mov	al,-4[bp]
21847 629E           30E4                       xor	ah,ah
21848 62A0           50                         push	ax
21849                                           ! Debug: list int = const $18 (used reg = )
21850 62A1           B8                   0018  mov	ax,*$18
21851 62A4           50                         push	ax
21852                                           ! Debug: list int = const $40 (used reg = )
21853 62A5           B8                   0040  mov	ax,*$40
21854 62A8           50                         push	ax
21855                                           ! Debug: func () void = write_byte+0 (used reg = )
21856 62A9           E8         A36E            call	_write_byte
21857 62AC           83C4                   06  add	sp,*6
21858                                           !BCC_EOS
21859                                           ! 3447       }
21860                                           ! 3448       break;
21861                       000062AF            .4C4:
21862 62AF           E9         035D            br 	.4A8
21863                                           !BCC_EOS
21864                                           ! 3449     case 0x45:
21865                                           ! 3450       if ((mf2_state & 0x03) == 0) {
21866                       000062B2            .4C5:
21867                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
21868 62B2           8A46         FB            mov	al,-5[bp]
21869 62B5           24                     03  and	al,*3
21870                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21871 62B7           84C0                       test	al,al
21872 62B9           75           38            jne 	.4C6
21873                       000062BB            .4C7:
21874                                           ! 3451         mf2_flags |= 0x20;
21875                                           ! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
21876 62BB           8A46         FC            mov	al,-4[bp]
21877 62BE           0C                     20  or	al,*$20
21878 62C0           8846         FC            mov	-4[bp],al
21879                                           !BCC_EOS
21880                                           ! 3452         write_byte(0x0040, 0x18, mf2_flags);
21881                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21882 62C3           8A46         FC            mov	al,-4[bp]
21883 62C6           30E4                       xor	ah,ah
21884 62C8           50                         push	ax
21885                                           ! Debug: list int = const $18 (used reg = )
21886 62C9           B8                   0018  mov	ax,*$18
21887 62CC           50                         push	ax
21888                                           ! Debug: list int = const $40 (used reg = )
21889 62CD           B8                   0040  mov	ax,*$40
21890 62D0           50                         push	ax
21891                                           ! Debug: func () void = write_byte+0 (used reg = )
21892 62D1           E8         A346            call	_write_byte
21893 62D4           83C4                   06  add	sp,*6
21894                                           !BCC_EOS
21895                                           ! 3453         shift_flags ^= 0x20;
21896                                           ! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
21897 62D7           8A46         FD            mov	al,-3[bp]
21898 62DA           34                     20  xor	al,*$20
21899 62DC           8846         FD            mov	-3[bp],al
21900                                           !BCC_EOS
21901                                           ! 3454         write_byte(0x0040, 0x17, shift_flags);
21902                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21903 62DF           8A46         FD            mov	al,-3[bp]
21904 62E2           30E4                       xor	ah,ah
21905 62E4           50                         push	ax
21906                                           ! Debug: list int = const $17 (used reg = )
21907 62E5           B8                   0017  mov	ax,*$17
21908 62E8           50                         push	ax
21909                                           ! Debug: list int = const $40 (used reg = )
21910 62E9           B8                   0040  mov	ax,*$40
21911 62EC           50                         push	ax
21912                                           ! Debug: func () void = write_byte+0 (used reg = )
21913 62ED           E8         A32A            call	_write_byte
21914 62F0           83C4                   06  add	sp,*6
21915                                           !BCC_EOS
21916                                           ! 3455       }
21917                                           ! 3456       break;
21918                       000062F3            .4C6:
21919 62F3           E9         0319            br 	.4A8
21920                                           !BCC_EOS
21921                                           ! 3457     case 0xc5:
21922                                           ! 3458       if ((mf2_state & 0x03) == 0) {
21923                       000062F6            .4C8:
21924                                           ! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
21925 62F6           8A46         FB            mov	al,-5[bp]
21926 62F9           24                     03  and	al,*3
21927                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
21928 62FB           84C0                       test	al,al
21929 62FD           75           1C            jne 	.4C9
21930                       000062FF            .4CA:
21931                                           ! 3459    
21932                                           ! 3459      mf2_flags &= ~0x20;
21933                                           ! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
21934 62FF           8A46         FC            mov	al,-4[bp]
21935 6302           24                     DF  and	al,#$DF
21936 6304           8846         FC            mov	-4[bp],al
21937                                           !BCC_EOS
21938                                           ! 3460         write_byte(0x0040, 0x18, mf2_flags);
21939                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21940 6307           8A46         FC            mov	al,-4[bp]
21941 630A           30E4                       xor	ah,ah
21942 630C           50                         push	ax
21943                                           ! Debug: list int = const $18 (used reg = )
21944 630D           B8                   0018  mov	ax,*$18
21945 6310           50                         push	ax
21946                                           ! Debug: list int = const $40 (used reg = )
21947 6311           B8                   0040  mov	ax,*$40
21948 6314           50                         push	ax
21949                                           ! Debug: func () void = write_byte+0 (used reg = )
21950 6315           E8         A302            call	_write_byte
21951 6318           83C4                   06  add	sp,*6
21952                                           !BCC_EOS
21953                                           ! 3461       }
21954                                           ! 3462       break;
21955                       0000631B            .4C9:
21956 631B           E9         02F1            br 	.4A8
21957                                           !BCC_EOS
21958                                           ! 3463     case 0x46:
21959                                           ! 3464       mf2_flags |= 0x10;
21960                       0000631E            .4CB:
21961                                           ! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
21962 631E           8A46         FC            mov	al,-4[bp]
21963 6321           0C                     10  or	al,*$10
21964 6323           8846         FC            mov	-4[bp],al
21965                                           !BCC_EOS
21966                                           ! 3465       write_byte(0x0040, 0x18, mf2_flags);
21967                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
21968 6326           8A46         FC            mov	al,-4[bp]
21969 6329           30E4                       xor	ah,ah
21970 632B           50                         push	ax
21971                                           ! Debug: list int = const $18 (used reg = )
21972 632C           B8                   0018  mov	ax,*$18
21973 632F           50                         push	ax
21974                                           ! Debug: list int = const $40 (used reg = )
21975 6330           B8                   0040  mov	ax,*$40
21976 6333           50                         push	ax
21977                                           ! Debug: func () void = write_byte+0 (used reg = )
21978 6334           E8         A2E3            call	_write_byte
21979 6337           83C4                   06  add	sp,*6
21980                                           !BCC_EOS
21981                                           ! 3466       shift_flags ^= 0x10;
21982                                           ! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
21983 633A           8A46         FD            mov	al,-3[bp]
21984 633D           34                     10  xor	al,*$10
21985 633F           8846         FD            mov	-3[bp],al
21986                                           !BCC_EOS
21987                                           ! 3467       write_byte(0x0040, 0x17, shift_flags);
21988                                           ! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
21989 6342           8A46         FD            mov	al,-3[bp]
21990 6345           30E4                       xor	ah,ah
21991 6347           50                         push	ax
21992                                           ! Debug: list int = const $17 (used reg = )
21993 6348           B8                   0017  mov	ax,*$17
21994 634B           50                         push	ax
21995                                           ! Debug: list int = const $40 (used reg = )
21996 634C           B8                   0040  mov	ax,*$40
21997 634F           50                         push	ax
21998                                           ! Debug: func () void = write_byte+0 (used reg = )
21999 6350           E8         A2C7            call	_write_byte
22000 6353           83C4                   06  add	sp,*6
22001                                           !BCC_EOS
22002                                           ! 3468       break;
22003 6356           E9         02B6            br 	.4A8
22004                                           !BCC_EOS
22005                                           ! 3469     case 0xc6:
22006                                           ! 3470       mf2_flags &= ~0x10;
22007                       00006359            .4CC:
22008                                           ! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
22009 6359           8A46         FC            mov	al,-4[bp]
22010 635C           24                     EF  and	al,#$EF
22011 635E           8846         FC            mov	-4[bp],al
22012                                           !BCC_EOS
22013                                           ! 3471       write_byte(0x0040, 0x18, mf2_flags);
22014                                           ! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
22015 6361           8A46         FC            mov	al,-4[bp]
22016 6364           30E4                       xor	ah,ah
22017 6366           50                         push	ax
22018                                           ! Debug: list int = const $18 (used reg = )
22019 6367           B8                   0018  mov	ax,*$18
22020 636A           50                         push	ax
22021                                           ! Debug: list int = const $40 (used reg = )
22022 636B           B8                   0040  mov	ax,*$40
22023 636E           50                         push	ax
22024                                           ! Debug: func () void = write_byte+0 (used reg = )
22025 636F           E8         A2A8            call	_write_byte
22026 6372           83C4                   06  add	sp,*6
22027                                           !BCC_EOS
22028                                           ! 3472       break;
22029 6375           E9         0297            br 	.4A8
22030                                           !BCC_EOS
22031                                           ! 3473     case 0x53:
22032                                           ! 3474         if ((shift_flags & 0x0c) == 0x0c)
22033                       00006378            .4CD:
22034                                           ! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
22035 6378           8A46         FD            mov	al,-3[bp]
22036 637B           24                     0C  and	al,*$C
22037                                           ! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
22038 637D           3C                     0C  cmp	al,*$C
22039 637F           75           03            jne 	.4CE
22040                       00006381            .4CF:
22041                                           ! 3475             machine_reset();
22042                                           ! Debug: func () void = machine_reset+0 (used reg = )
22043 6381           E8         AF43            call	_machine_reset
22044                                           !BCC_EOS
22045                                           ! 3476     default:
22046                       00006384            .4CE:
22047                                           ! 3477       if (scancode & 0x80) {
22048                       00006384            .4D0:
22049                                           ! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
22050 6384           8A46         FF            mov	al,-1[bp]
22051 6387           24                     80  and	al,#$80
22052 6389           84C0                       test	al,al
22053 638B           74           03            je  	.4D1
22054                       0000638D            .4D2:
22055                                           ! 3478         break;
22056 638D           E9         027F            br 	.4A8
22057                                           !BCC_EOS
22058                                           ! 3479       }
22059                                           ! 3480       if (scancode > 0x58) {
22060                       00006390            .4D1:
22061                                           ! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
22062 6390           8A46         FF            mov	al,-1[bp]
22063 6393           3C                     58  cmp	al,*$58
22064 6395           76           04            jbe 	.4D3
22065                       00006397            .4D4:
22066                                           ! 3481         ;
22067                                           !BCC_EOS
22068                                           ! 3482         return;
22069 6397           89EC                       mov	sp,bp
22070 6399           5D                         pop	bp
22071 639A           C3                         ret
22072                                           !BCC_EOS
22073                                           ! 3483       }
22074                                           ! 3484       if (shift_flags & 0x08) {
22075                       0000639B            .4D3:
22076                                           ! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
22077 639B           8A46         FD            mov	al,-3[bp]
22078 639E           24                     08  and	al,*8
22079 63A0           84C0                       test	al,al
22080 63A2           74           3D            je  	.4D5
22081                       000063A4            .4D6:
22082                                           ! 3485         asciicode = scan_to_scanascii[scancode].alt;
22083                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22084 63A4           8A46         FF            mov	al,-1[bp]
22085 63A7           30E4                       xor	ah,ah
22086 63A9           89C2                       mov	dx,ax
22087 63AB           D1E0                       shl	ax,*1
22088 63AD           D1E0                       shl	ax,*1
22089 63AF           01D0                       add	ax,dx
22090 63B1           D1E0                       shl	ax,*1
22091 63B3           89C3                       mov	bx,ax
22092 63B5           81C3                 01C4  add	bx,#_scan_to_scanascii
22093                                           ! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
22094 63B9           8A47         06            mov	al,6[bx]
22095 63BC           8846         FE            mov	-2[bp],al
22096                                           !BCC_EOS
22097                                           ! 3486         scancode = scan_to_scanascii[scancode].alt >> 8;
22098                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22099 63BF           8A46         FF            mov	al,-1[bp]
22100 63C2           30E4                       xor	ah,ah
22101 63C4           89C2                       mov	dx,ax
22102 63C6           D1E0                       shl	ax,*1
22103 63C8           D1E0                       shl	ax,*1
22104 63CA           01D0                       add	ax,dx
22105 63CC           D1E0                       shl	ax,*1
22106 63CE           89C3                       mov	bx,ax
22107 63D0           81C3                 01C4  add	bx,#_scan_to_scanascii
22108                                           ! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
22109 63D4           8B47         06            mov	ax,6[bx]
22110 63D7           88E0                       mov	al,ah
22111 63D9           30E4                       xor	ah,ah
22112                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22113 63DB           8846         FF            mov	-1[bp],al
22114                                           !BCC_EOS
22115                                           ! 3487       } else if (shift_flags & 0x04) {
22116 63DE           E9         01AD            br 	.4D7
22117                       000063E1            .4D5:
22118                                           ! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
22119 63E1           8A46         FD            mov	al,-3[bp]
22120 63E4           24                     04  and	al,*4
22121 63E6           84C0                       test	al,al
22122 63E8           74           3D            je  	.4D8
22123                       000063EA            .4D9:
22124                                           ! 3488         asciicode = scan_to_scanascii[scancode].control;
22125                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22126 63EA           8A46         FF            mov	al,-1[bp]
22127 63ED           30E4                       xor	ah,ah
22128 63EF           89C2                       mov	dx,ax
22129 63F1           D1E0                       shl	ax,*1
22130 63F3           D1E0                       shl	ax,*1
22131 63F5           01D0                       add	ax,dx
22132 63F7           D1E0                       shl	ax,*1
22133 63F9           89C3                       mov	bx,ax
22134 63FB           81C3                 01C4  add	bx,#_scan_to_scanascii
22135                                           ! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
22136 63FF           8A47         04            mov	al,4[bx]
22137 6402           8846         FE            mov	-2[bp],al
22138                                           !BCC_EOS
22139                                           ! 3489         scancode = scan_to_scanascii[scancode].control >> 8;
22140                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22141 6405           8A46         FF            mov	al,-1[bp]
22142 6408           30E4                       xor	ah,ah
22143 640A           89C2                       mov	dx,ax
22144 640C           D1E0                       shl	ax,*1
22145 640E           D1E0                       shl	ax,*1
22146 6410           01D0                       add	ax,dx
22147 6412           D1E0                       shl	ax,*1
22148 6414           89C3                       mov	bx,ax
22149 6416           81C3                 01C4  add	bx,#_scan_to_scanascii
22150                                           ! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
22151 641A           8B47         04            mov	ax,4[bx]
22152 641D           88E0                       mov	al,ah
22153 641F           30E4                       xor	ah,ah
22154                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22155 6421           8846         FF            mov	-1[bp],al
22156                                           !BCC_EOS
22157                                           ! 3490       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
22158 6424           E9         0167            br 	.4DA
22159                       00006427            .4D8:
22160                                           ! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
22161 6427           8A46         FB            mov	al,-5[bp]
22162 642A           24                     02  and	al,*2
22163                                           ! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
22164 642C           84C0                       test	al,al
22165 642E           74           32            je  	.4DB
22166                       00006430            .4DD:
22167                                           ! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
22168 6430           8A46         FF            mov	al,-1[bp]
22169 6433           3C                     47  cmp	al,*$47
22170 6435           72           2B            jb  	.4DB
22171                       00006437            .4DE:
22172                                           ! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
22173 6437           8A46         FF            mov	al,-1[bp]
22174 643A           3C                     53  cmp	al,*$53
22175 643C           77           24            ja  	.4DB
22176                       0000643E            .4DC:
22177                                           ! 3491         asciicode = 0xe0;
22178                                           ! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
22179 643E           B0                     E0  mov	al,#$E0
22180 6440           8846         FE            mov	-2[bp],al
22181                                           !BCC_EOS
22182                                           ! 3492         scancode = scan_to_scanascii[scancode].normal >> 8;
22183                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22184 6443           8A46         FF            mov	al,-1[bp]
22185 6446           30E4                       xor	ah,ah
22186 6448           89C2                       mov	dx,ax
22187 644A           D1E0                       shl	ax,*1
22188 644C           D1E0                       shl	ax,*1
22189 644E           01D0                       add	ax,dx
22190 6450           D1E0                       shl	ax,*1
22191 6452           89C3                       mov	bx,ax
22192                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22193 6454           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22194 6458           88E0                       mov	al,ah
22195 645A           30E4                       xor	ah,ah
22196                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22197 645C           8846         FF            mov	-1[bp],al
22198                                           !BCC_EOS
22199                                           ! 3493       } else if (shift_flags & 0x03) {
22200 645F           E9         012C            br 	.4DF
22201                       00006462            .4DB:
22202                                           ! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
22203 6462           8A46         FD            mov	al,-3[bp]
22204 6465           24                     03  and	al,*3
22205 6467           84C0                       test	al,al
22206 6469         0F84         0092            beq 	.4E0
22207                       0000646D            .4E1:
22208                                           ! 3494         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22209                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22210 646D           8A46         FF            mov	al,-1[bp]
22211 6470           30E4                       xor	ah,ah
22212 6472           89C2                       mov	dx,ax
22213 6474           D1E0                       shl	ax,*1
22214 6476           D1E0                       shl	ax,*1
22215 6478           01D0                       add	ax,dx
22216 647A           D1E0                       shl	ax,*1
22217 647C           89C3                       mov	bx,ax
22218 647E           81C3                 01C4  add	bx,#_scan_to_scanascii
22219                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22220 6482           8A46         FD            mov	al,-3[bp]
22221 6485           2247         08            and	al,8[bx]
22222 6488           84C0                       test	al,al
22223 648A           74           36            je  	.4E2
22224                       0000648C            .4E3:
22225                                           ! 3495           asciicode = scan_to_scanascii[scancode].normal;
22226                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22227 648C           8A46         FF            mov	al,-1[bp]
22228 648F           30E4                       xor	ah,ah
22229 6491           89C2                       mov	dx,ax
22230 6493           D1E0                       shl	ax,*1
22231 6495           D1E0                       shl	ax,*1
22232 6497           01D0                       add	ax,dx
22233 6499           D1E0                       shl	ax,*1
22234 649B           89C3                       mov	bx,ax
22235                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22236 649D           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22237 64A1           8846         FE            mov	-2[bp],al
22238                                           !BCC_EOS
22239                                           ! 3496           scancode = scan_to_scanascii[scancode].normal >> 8;
22240                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22241 64A4           8A46         FF            mov	al,-1[bp]
22242 64A7           30E4                       xor	ah,ah
22243 64A9           89C2                       mov	dx,ax
22244 64AB           D1E0                       shl	ax,*1
22245 64AD           D1E0                       shl	ax,*1
22246 64AF           01D0                       add	ax,dx
22247 64B1           D1E0                       shl	ax,*1
22248 64B3           89C3                       mov	bx,ax
22249                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22250 64B5           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22251 64B9           88E0                       mov	al,ah
22252 64BB           30E4                       xor	ah,ah
22253                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22254 64BD           8846         FF            mov	-1[bp],al
22255                                           !BCC_EOS
22256                                           ! 3497         } else {
22257 64C0           EB           3A            jmp .4E4
22258                       000064C2            .4E2:
22259                                           ! 3498           asciicode = scan_to_scanascii[scancode].shift;
22260                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22261 64C2           8A46         FF            mov	al,-1[bp]
22262 64C5           30E4                       xor	ah,ah
22263 64C7           89C2                       mov	dx,ax
22264 64C9           D1E0                       shl	ax,*1
22265 64CB           D1E0                       shl	ax,*1
22266 64CD           01D0                       add	ax,dx
22267 64CF           D1E0                       shl	ax,*1
22268 64D1           89C3                       mov	bx,ax
22269 64D3           81C3                 01C4  add	bx,#_scan_to_scanascii
22270                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22271 64D7           8A47         02            mov	al,2[bx]
22272 64DA           8846         FE            mov	-2[bp],al
22273                                           !BCC_EOS
22274                                           ! 3499           scancode = scan_to_scanascii[scancode].shift >> 8;
22275                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22276 64DD           8A46         FF            mov	al,-1[bp]
22277 64E0           30E4                       xor	ah,ah
22278 64E2           89C2                       mov	dx,ax
22279 64E4           D1E0                       shl	ax,*1
22280 64E6           D1E0                       shl	ax,*1
22281 64E8           01D0                       add	ax,dx
22282 64EA           D1E0                       shl	ax,*1
22283 64EC           89C3                       mov	bx,ax
22284 64EE           81C3                 01C4  add	bx,#_scan_to_scanascii
22285                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22286 64F2           8B47         02            mov	ax,2[bx]
22287 64F5           88E0                       mov	al,ah
22288 64F7           30E4                       xor	ah,ah
22289                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22290 64F9           8846         FF            mov	-1[bp],al
22291                                           !BCC_EOS
22292                                           ! 3500         }
22293                                           ! 3501       } else {
22294                       000064FC            .4E4:
22295 64FC           E9         008F            br 	.4E5
22296                       000064FF            .4E0:
22297                                           ! 3502         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
22298                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22299 64FF           8A46         FF            mov	al,-1[bp]
22300 6502           30E4                       xor	ah,ah
22301 6504           89C2                       mov	dx,ax
22302 6506           D1E0                       shl	ax,*1
22303 6508           D1E0                       shl	ax,*1
22304 650A           01D0                       add	ax,dx
22305 650C           D1E0                       shl	ax,*1
22306 650E           89C3                       mov	bx,ax
22307 6510           81C3                 01C4  add	bx,#_scan_to_scanascii
22308                                           ! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
22309 6514           8A46         FD            mov	al,-3[bp]
22310 6517           2247         08            and	al,8[bx]
22311 651A           84C0                       test	al,al
22312 651C           74           3C            je  	.4E6
22313                       0000651E            .4E7:
22314                                           ! 3503           asciicode = scan_to_scanascii[scancode].shift;
22315                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22316 651E           8A46         FF            mov	al,-1[bp]
22317 6521           30E4                       xor	ah,ah
22318 6523           89C2                       mov	dx,ax
22319 6525           D1E0                       shl	ax,*1
22320 6527           D1E0                       shl	ax,*1
22321 6529           01D0                       add	ax,dx
22322 652B           D1E0                       shl	ax,*1
22323 652D           89C3                       mov	bx,ax
22324 652F           81C3                 01C4  add	bx,#_scan_to_scanascii
22325                                           ! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
22326 6533           8A47         02            mov	al,2[bx]
22327 6536           8846         FE            mov	-2[bp],al
22328                                           !BCC_EOS
22329                                           ! 3504           scancode = scan_to_scanascii[scancode].shift >> 8;
22330                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22331 6539           8A46         FF            mov	al,-1[bp]
22332 653C           30E4                       xor	ah,ah
22333 653E           89C2                       mov	dx,ax
22334 6540           D1E0                       shl	ax,*1
22335 6542           D1E0                       shl	ax,*1
22336 6544           01D0                       add	ax,dx
22337 6546           D1E0                       shl	ax,*1
22338 6548           89C3                       mov	bx,ax
22339 654A           81C3                 01C4  add	bx,#_scan_to_scanascii
22340                                           ! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
22341 654E           8B47         02            mov	ax,2[bx]
22342 6551           88E0                       mov	al,ah
22343 6553           30E4                       xor	ah,ah
22344                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22345 6555           8846         FF            mov	-1[bp],al
22346                                           !BCC_EOS
22347                                           ! 3505         } else {
22348 6558           EB           34            jmp .4E8
22349                       0000655A            .4E6:
22350                                           ! 3506           asciicode = scan_to_scanascii[scancode].normal;
22351                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22352 655A           8A46         FF            mov	al,-1[bp]
22353 655D           30E4                       xor	ah,ah
22354 655F           89C2                       mov	dx,ax
22355 6561           D1E0                       shl	ax,*1
22356 6563           D1E0                       shl	ax,*1
22357 6565           01D0                       add	ax,dx
22358 6567           D1E0                       shl	ax,*1
22359 6569           89C3                       mov	bx,ax
22360                                           ! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
22361 656B           8A87       01C4            mov	al,_scan_to_scanascii[bx]
22362 656F           8846         FE            mov	-2[bp],al
22363                                           !BCC_EOS
22364                                           ! 3507           scancode = scan_to_scanascii[scancode].normal >> 8;
22365                                           ! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
22366 6572           8A46         FF            mov	al,-1[bp]
22367 6575           30E4                       xor	ah,ah
22368 6577           89C2                       mov	dx,ax
22369 6579           D1E0                       shl	ax,*1
22370 657B           D1E0                       shl	ax,*1
22371 657D           01D0                       add	ax,dx
22372 657F           D1E0                       shl	ax,*1
22373 6581           89C3                       mov	bx,ax
22374                                           ! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
22375 6583           8B87       01C4            mov	ax,_scan_to_scanascii[bx]
22376 6587           88E0                       mov	al,ah
22377 6589           30E4                       xor	ah,ah
22378                                           ! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
22379 658B           8846         FF            mov	-1[bp],al
22380                                           !BCC_EOS
22381                                           ! 3508         }
22382                                           ! 3509       }
22383                       0000658E            .4E8:
22384                                           ! 3510       if (scancode==0 && asciicode==0) {
22385                       0000658E            .4E5:
22386                       0000658E            .4DF:
22387                       0000658E            .4DA:
22388                       0000658E            .4D7:
22389                                           ! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
22390 658E           8A46         FF            mov	al,-1[bp]
22391 6591           84C0                       test	al,al
22392 6593           75           07            jne 	.4E9
22393                       00006595            .4EB:
22394                                           ! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
22395 6595           8A46         FE            mov	al,-2[bp]
22396 6598           84C0                       test	al,al
22397 659A           75           00            jne 	.4E9
22398                       0000659C            .4EA:
22399                                           ! 3511         ;
22400                                           !BCC_EOS
22401                                           ! 3512       }
22402                                           ! 3513       enqueue_key(scancode, asciicode);
22403                       0000659C            .4E9:
22404                                           ! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
22405 659C           8A46         FE            mov	al,-2[bp]
22406 659F           30E4                       xor	ah,ah
22407 65A1           50                         push	ax
22408                                           ! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
22409 65A2           8A46         FF            mov	al,-1[bp]
22410 65A5           30E4                       xor	ah,ah
22411 65A7           50                         push	ax
22412                                           ! Debug: func () unsigned int = enqueue_key+0 (used reg = )
22413 65A8           E8         0095            call	_enqueue_key
22414 65AB           83C4                   04  add	sp,*4
22415                                           !BCC_EOS
22416                                           ! 3514       break;
22417 65AE           EB           5F            jmp .4A8
22418                                           !BCC_EOS
22419                                           ! 3515   }
22420                                           ! 3516   if ((scancode & 0x7f) != 0x1d) {
22421 65B0           EB           5D            jmp .4A8
22422                       000065B2            .4AA:
22423 65B2           2C                     1D  sub	al,*$1D
22424 65B4         0F84         FB60            beq 	.4B1
22425 65B8           2C                     0D  sub	al,*$D
22426 65BA         0F84         FADE            beq 	.4AD
22427 65BE           2C                     0C  sub	al,*$C
22428 65C0         0F84         FB16            beq 	.4AF
22429 65C4           2C                     02  sub	al,*2
22430 65C6         0F84         FC24            beq 	.4BD
22431 65CA           2C                     02  sub	al,*2
22432 65CC         0F84         FA72            beq 	.4AB
22433 65D0           2C                     0B  sub	al,*$B
22434 65D2         0F84         FCDC            beq 	.4C5
22435 65D6           2C                     01  sub	al,*1
22436 65D8         0F84         FD42            beq 	.4CB
22437 65DC           2C                     0D  sub	al,*$D
22438 65DE         0F84         FD96            beq 	.4CD
22439 65E2           2C                     4A  sub	al,*$4A
22440 65E4         0F84         FB9B            beq 	.4B7
22441 65E8           2C                     0D  sub	al,*$D
22442 65EA         0F84         FACD            beq 	.4AE
22443 65EE           2C                     0C  sub	al,*$C
22444 65F0         0F84         FB05            beq 	.4B0
22445 65F4           2C                     02  sub	al,*2
22446 65F6         0F84         FC56            beq 	.4C1
22447 65FA           2C                     02  sub	al,*2
22448 65FC         0F84         FA7D            beq 	.4AC
22449 6600           2C                     0B  sub	al,*$B
22450 6602         0F84         FCF0            beq 	.4C8
22451 6606           2C                     01  sub	al,*1
22452 6608         0F84         FD4D            beq 	.4CC
22453 660C           E9         FD75            br 	.4D0
22454                       0000660F            .4A8:
22455                       FFFFFFF8            ..FFF2	=	-8
22456                                           ! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
22457 660F           8A46         FF            mov	al,-1[bp]
22458 6612           24                     7F  and	al,*$7F
22459                                           ! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
22460 6614           3C                     1D  cmp	al,*$1D
22461 6616           74           08            je  	.4EC
22462                       00006618            .4ED:
22463                                           ! 3517     mf2_state &= ~0x01;
22464                                           ! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
22465 6618           8A46         FB            mov	al,-5[bp]
22466 661B           24                     FE  and	al,#$FE
22467 661D           8846         FB            mov	-5[bp],al
22468                                           !BCC_EOS
22469                                           ! 3518   }
22470                                           ! 3519   mf2_state &= ~0x02;
22471                       00006620            .4EC:
22472                                           ! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
22473 6620           8A46         FB            mov	al,-5[bp]
22474 6623           24                     FD  and	al,#$FD
22475 6625           8846         FB            mov	-5[bp],al
22476                                           !BCC_EOS
22477                                           ! 3520   write_byte(0x0040, 0x96, mf2_state);
22478                                           ! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
22479 6628           8A46         FB            mov	al,-5[bp]
22480 662B           30E4                       xor	ah,ah
22481 662D           50                         push	ax
22482                                           ! Debug: list int = const $96 (used reg = )
22483 662E           B8                   0096  mov	ax,#$96
22484 6631           50                         push	ax
22485                                           ! Debug: list int = const $40 (used reg = )
22486 6632           B8                   0040  mov	ax,*$40
22487 6635           50                         push	ax
22488                                           ! Debug: func () void = write_byte+0 (used reg = )
22489 6636           E8         9FE1            call	_write_byte
22490 6639           83C4                   06  add	sp,*6
22491                                           !BCC_EOS
22492                                           ! 3521 }
22493 663C           89EC                       mov	sp,bp
22494 663E           5D                         pop	bp
22495 663F           C3                         ret
22496                                           ! 3522   unsigned int
22497                                           ! Register BX used in function int09_function
22498                                           ! 3523 enqueue_key(scan_
22499                                           ! 3523 code, ascii_code)
22500                                           ! 3524   Bit8u scan_code, ascii_code;
22501                                           export	_enqueue_key
22502                       00006640            _enqueue_key:
22503                                           !BCC_EOS
22504                                           ! 3525 {
22505                                           ! 3526   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
22506                                           !BCC_EOS
22507                                           ! 3527   buffer_start = read_word(0x0040, 0x0080);
22508 6640           55                         push	bp
22509 6641           89E5                       mov	bp,sp
22510 6643           83C4                   F6  add	sp,*-$A
22511                                           ! Debug: list int = const $80 (used reg = )
22512 6646           B8                   0080  mov	ax,#$80
22513 6649           50                         push	ax
22514                                           ! Debug: list int = const $40 (used reg = )
22515 664A           B8                   0040  mov	ax,*$40
22516 664D           50                         push	ax
22517                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22518 664E           E8         9FB6            call	_read_word
22519 6651           83C4                   04  add	sp,*4
22520                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
22521 6654           8946         FE            mov	-2[bp],ax
22522                                           !BCC_EOS
22523                                           ! 3528   buffer_end = read_word(0x0040, 0x0082);
22524                                           ! Debug: list int = const $82 (used reg = )
22525 6657           B8                   0082  mov	ax,#$82
22526 665A           50                         push	ax
22527                                           ! Debug: list int = const $40 (used reg = )
22528 665B           B8                   0040  mov	ax,*$40
22529 665E           50                         push	ax
22530                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22531 665F           E8         9FA5            call	_read_word
22532 6662           83C4                   04  add	sp,*4
22533                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
22534 6665           8946         FC            mov	-4[bp],ax
22535                                           !BCC_EOS
22536                                           ! 3529   buffer_head = read_word(0x0040, 0x001A);
22537                                           ! Debug: list int = const $1A (used reg = )
22538 6668           B8                   001A  mov	ax,*$1A
22539 666B           50                         push	ax
22540                                           ! Debug: list int = const $40 (used reg = )
22541 666C           B8                   0040  mov	ax,*$40
22542 666F           50                         push	ax
22543                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22544 6670           E8         9F94            call	_read_word
22545 6673           83C4                   04  add	sp,*4
22546                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
22547 6676           8946         FA            mov	-6[bp],ax
22548                                           !BCC_EOS
22549                                           ! 3530   buffer_tail = read_word(0x0040, 0x001C);
22550                                           ! Debug: list int = const $1C (used reg = )
22551 6679           B8                   001C  mov	ax,*$1C
22552 667C           50                         push	ax
22553                                           ! Debug: list int = const $40 (used reg = )
22554 667D           B8                   0040  mov	ax,*$40
22555 6680           50                         push	ax
22556                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22557 6681           E8         9F83            call	_read_word
22558 6684           83C4                   04  add	sp,*4
22559                                           ! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22560 6687           8946         F8            mov	-8[bp],ax
22561                                           !BCC_EOS
22562                                           ! 3531   temp_tail = buffer_tail;
22563                                           ! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
22564 668A           8B46         F8            mov	ax,-8[bp]
22565 668D           8946         F6            mov	-$A[bp],ax
22566                                           !BCC_EOS
22567                                           ! 3532   buffer_tail += 2;
22568                                           ! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22569 6690           8B46         F8            mov	ax,-8[bp]
22570 6693           40                         inc	ax
22571 6694           40                         inc	ax
22572 6695           8946         F8            mov	-8[bp],ax
22573                                           !BCC_EOS
22574                                           ! 3533   if (buffer_tail >= buffer_end)
22575                                           ! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22576 6698           8B46         F8            mov	ax,-8[bp]
22577 669B           3B46         FC            cmp	ax,-4[bp]
22578 669E           72           06            jb  	.4EE
22579                       000066A0            .4EF:
22580                                           ! 3534     buffer_tail = buffer_start;
22581                                           ! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22582 66A0           8B46         FE            mov	ax,-2[bp]
22583 66A3           8946         F8            mov	-8[bp],ax
22584                                           !BCC_EOS
22585                                           ! 3535   if (buffer_tail == buffer_head) {
22586                       000066A6            .4EE:
22587                                           ! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
22588 66A6           8B46         F8            mov	ax,-8[bp]
22589 66A9           3B46         FA            cmp	ax,-6[bp]
22590 66AC           75           06            jne 	.4F0
22591                       000066AE            .4F1:
22592                                           ! 3536     return(0);
22593 66AE           31C0                       xor	ax,ax
22594 66B0           89EC                       mov	sp,bp
22595 66B2           5D                         pop	bp
22596 66B3           C3                         ret
22597                                           !BCC_EOS
22598                                           ! 3537     }
22599                                           ! 3538    write_byte(0x0040, temp_tail, ascii_code);
22600                       000066B4            .4F0:
22601                                           ! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
22602 66B4           8A46         06            mov	al,6[bp]
22603 66B7           30E4                       xor	ah,ah
22604 66B9           50                         push	ax
22605                                           ! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
22606 66BA           FF76         F6            push	-$A[bp]
22607                                           ! Debug: list int = const $40 (used reg = )
22608 66BD           B8                   0040  mov	ax,*$40
22609 66C0           50                         push	ax
22610                                           ! Debug: func () void = write_byte+0 (used reg = )
22611 66C1           E8         9F56            call	_write_byte
22612 66C4           83C4                   06  add	sp,*6
22613                                           !BCC_EOS
22614                                           ! 3539    write_byte(0x0040, temp_tail+1, scan_code);
22615                                           ! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
22616 66C7           8A46         04            mov	al,4[bp]
22617 66CA           30E4                       xor	ah,ah
22618 66CC           50                         push	ax
22619                                           ! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
22620 66CD           8B46         F6            mov	ax,-$A[bp]
22621                                           ! Debug: list unsigned int = ax+1 (used reg = )
22622 66D0           40                         inc	ax
22623 66D1           50                         push	ax
22624                                           ! Debug: list int = const $40 (used reg = )
22625 66D2           B8                   0040  mov	ax,*$40
22626 66D5           50                         push	ax
22627                                           ! Debug: func () void = write_byte+0 (used reg = )
22628 66D6           E8         9F41            call	_write_byte
22629 66D9           83C4                   06  add	sp,*6
22630                                           !BCC_EOS
22631                                           ! 3540    write_word(0x0040, 0x001C, buffer_tail);
22632                                           ! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
22633 66DC           FF76         F8            push	-8[bp]
22634                                           ! Debug: list int = const $1C (used reg = )
22635 66DF           B8                   001C  mov	ax,*$1C
22636 66E2           50                         push	ax
22637                                           ! Debug: list int = const $40 (used reg = )
22638 66E3           B8                   0040  mov	ax,*$40
22639 66E6           50                         push	ax
22640                                           ! Debug: func () void = write_word+0 (used reg = )
22641 66E7           E8         9F48            call	_write_word
22642 66EA           83C4                   06  add	sp,*6
22643                                           !BCC_EOS
22644                                           ! 3541    return(1);
22645 66ED           B8                   0001  mov	ax,*1
22646 66F0           89EC                       mov	sp,bp
22647 66F2           5D                         pop	bp
22648 66F3           C3                         ret
22649                                           !BCC_EOS
22650                                           ! 3542 }
22651                                           ! 3543   void
22652                                           ! 3544 int74_function(make_farcall, Z, Y, X, status)
22653                                           ! 3545   Bit16u make_farcall, Z, Y, X, status;
22654                                           export	_int74_function
22655                       000066F4            _int74_function:
22656                                           !BCC_EOS
22657                                           ! 3546 {
22658                                           ! 3547   Bit16u ebda_seg=read_word(0x0040,0x000E);
22659 66F4           55                         push	bp
22660 66F5           89E5                       mov	bp,sp
22661 66F7           4C                         dec	sp
22662 66F8           4C                         dec	sp
22663                                           ! Debug: list int = const $E (used reg = )
22664 66F9           B8                   000E  mov	ax,*$E
22665 66FC           50                         push	ax
22666                                           ! Debug: list int = const $40 (used reg = )
22667 66FD           B8                   0040  mov	ax,*$40
22668 6700           50                         push	ax
22669                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22670 6701           E8         9F03            call	_read_word
22671 6704           83C4                   04  add	sp,*4
22672                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
22673 6707           8946         FE            mov	-2[bp],ax
22674                                           !BCC_EOS
22675                                           ! 3548   Bit8u in_byte, index, package_count;
22676                                           !BCC_EOS
22677                                           ! 3549   Bit8u mouse_flags_1, mouse_flags_2;
22678                                           !BCC_EOS
22679                                           ! 3550 ;
22680 670A           83C4                   FA  add	sp,*-6
22681                                           !BCC_EOS
22682                                           ! 3551   make_farcall = 0;
22683                                           ! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
22684 670D           31C0                       xor	ax,ax
22685 670F           8946         04            mov	4[bp],ax
22686                                           !BCC_EOS
22687                                           ! 3552   in_byte = inb(0x64);
22688                                           ! Debug: list int = const $64 (used reg = )
22689 6712           B8                   0064  mov	ax,*$64
22690 6715           50                         push	ax
22691                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22692 6716           E8         9E25            call	_inb
22693 6719           44                         inc	sp
22694 671A           44                         inc	sp
22695                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
22696 671B           8846         FD            mov	-3[bp],al
22697                                           !BCC_EOS
22698                                           ! 3553   if ( (in_byte & 0x21) != 0x21 ) {
22699                                           ! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
22700 671E           8A46         FD            mov	al,-3[bp]
22701 6721           24                     21  and	al,*$21
22702                                           ! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
22703 6723           3C                     21  cmp	al,*$21
22704 6725           74           04            je  	.4F2
22705                       00006727            .4F3:
22706                                           ! 3554     return;
22707 6727           89EC                       mov	sp,bp
22708 6729           5D                         pop	bp
22709 672A           C3                         ret
22710                                           !BCC_EOS
22711                                           ! 3555     }
22712                                           ! 3556   in_byte = inb(0x60);
22713                       0000672B            .4F2:
22714                                           ! Debug: list int = const $60 (used reg = )
22715 672B           B8                   0060  mov	ax,*$60
22716 672E           50                         push	ax
22717                                           ! Debug: func () unsigned char = inb+0 (used reg = )
22718 672F           E8         9E0C            call	_inb
22719 6732           44                         inc	sp
22720 6733           44                         inc	sp
22721                                           ! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
22722 6734           8846         FD            mov	-3[bp],al
22723                                           !BCC_EOS
22724                                           ! 3557 ;
22725                                           !BCC_EOS
22726                                           ! 3558   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
22727                                           ! Debug: list int = const $26 (used reg = )
22728 6737           B8                   0026  mov	ax,*$26
22729 673A           50                         push	ax
22730                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22731 673B           FF76         FE            push	-2[bp]
22732                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22733 673E           E8         9EB3            call	_read_byte
22734 6741           83C4                   04  add	sp,*4
22735                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22736 6744           8846         FA            mov	-6[bp],al
22737                                           !BCC_EOS
22738                                           ! 3559   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
22739                                           ! Debug: list int = const $27 (used reg = )
22740 6747           B8                   0027  mov	ax,*$27
22741 674A           50                         push	ax
22742                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22743 674B           FF76         FE            push	-2[bp]
22744                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22745 674E           E8         9EA3            call	_read_byte
22746 6751           83C4                   04  add	sp,*4
22747                                           ! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22748 6754           8846         F9            mov	-7[bp],al
22749                                           !BCC_EOS
22750                                           ! 3560   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
22751                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22752 6757           8A46         F9            mov	al,-7[bp]
22753 675A           24                     80  and	al,#$80
22754                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
22755 675C           3C                     80  cmp	al,#$80
22756 675E           74           04            je  	.4F4
22757                       00006760            .4F5:
22758                                           ! 3561       return;
22759 6760           89EC                       mov	sp,bp
22760 6762           5D                         pop	bp
22761 6763           C3                         ret
22762                                           !BCC_EOS
22763                                           ! 3562   }
22764                                           ! 3563   package_count = mouse_flags_2 & 0x07;
22765                       00006764            .4F4:
22766                                           ! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22767 6764           8A46         F9            mov	al,-7[bp]
22768 6767           24                     07  and	al,*7
22769                                           ! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
22770 6769           8846         FB            mov	-5[bp],al
22771                                           !BCC_EOS
22772                                           ! 3564   index = mouse_flags_1 & 0x07;
22773                                           ! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22774 676C           8A46         FA            mov	al,-6[bp]
22775 676F           24                     07  and	al,*7
22776                                           ! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
22777 6771           8846         FC            mov	-4[bp],al
22778                                           !BCC_EOS
22779                                           ! 3565   write_byte(ebda_seg, 0x28 + index, in_byte);
22780                                           ! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
22781 6774           8A46         FD            mov	al,-3[bp]
22782 6777           30E4                       xor	ah,ah
22783 6779           50                         push	ax
22784                                           ! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
22785                                           ! Debug: expression subtree swapping
22786 677A           8A46         FC            mov	al,-4[bp]
22787 677D           30E4                       xor	ah,ah
22788                                           ! Debug: list unsigned int = ax+$28 (used reg = )
22789 677F           05                   0028  add	ax,*$28
22790 6782           50                         push	ax
22791                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
22792 6783           FF76         FE            push	-2[bp]
22793                                           ! Debug: func () void = write_byte+0 (used reg = )
22794 6786           E8         9E91            call	_write_byte
22795 6789           83C4                   06  add	sp,*6
22796                                           !BCC_EOS
22797                                           ! 3566   if ( (index+1) >= package_count ) {
22798                                           ! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
22799 678C           8A46         FC            mov	al,-4[bp]
22800 678F           30E4                       xor	ah,ah
22801                                           ! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
22802 6791           40                         inc	ax
22803 6792           50                         push	ax
22804 6793           8A46         FB            mov	al,-5[bp]
22805 6796           30E4                       xor	ah,ah
22806 6798           3B46         F6            cmp	ax,-$A[bp]
22807 679B           8D66         F8            lea	sp,-8[bp]
22808 679E           77           51            ja  	.4F6
22809                       000067A0            .4F7:
22810                                           ! 3567 ;
22811                                           !BCC_EOS
22812                                           ! 3568     status = read_byte(ebda_seg, 0x0028 + 0);
22813                                           ! Debug: list int = const $28 (used reg = )
22814 67A0           B8                   0028  mov	ax,*$28
22815 67A3           50                         push	ax
22816                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22817 67A4           FF76         FE            push	-2[bp]
22818                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22819 67A7           E8         9E4A            call	_read_byte
22820 67AA           83C4                   04  add	sp,*4
22821                                           ! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
22822 67AD           30E4                       xor	ah,ah
22823 67AF           8946         0C            mov	$C[bp],ax
22824                                           !BCC_EOS
22825                                           ! 3569     X = read_byte(ebda_seg, 0x0028 + 1);
22826                                           ! Debug: list int = const $29 (used reg = )
22827 67B2           B8                   0029  mov	ax,*$29
22828 67B5           50                         push	ax
22829                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22830 67B6           FF76         FE            push	-2[bp]
22831                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22832 67B9           E8         9E38            call	_read_byte
22833 67BC           83C4                   04  add	sp,*4
22834                                           ! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
22835 67BF           30E4                       xor	ah,ah
22836 67C1           8946         0A            mov	$A[bp],ax
22837                                           !BCC_EOS
22838                                           ! 3570     Y = read_byte(ebda_seg, 0x0028 + 2);
22839                                           ! Debug: list int = const $2A (used reg = )
22840 67C4           B8                   002A  mov	ax,*$2A
22841 67C7           50                         push	ax
22842                                           ! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
22843 67C8           FF76         FE            push	-2[bp]
22844                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22845 67CB           E8         9E26            call	_read_byte
22846 67CE           83C4                   04  add	sp,*4
22847                                           ! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
22848 67D1           30E4                       xor	ah,ah
22849 67D3           8946         08            mov	8[bp],ax
22850                                           !BCC_EOS
22851                                           ! 3571     Z = 0;
22852                                           ! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
22853 67D6           31C0                       xor	ax,ax
22854 67D8           8946         06            mov	6[bp],ax
22855                                           !BCC_EOS
22856                                           ! 3572     mouse_flags_1 = 0;
22857                                           ! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22858 67DB           30C0                       xor	al,al
22859 67DD           8846         FA            mov	-6[bp],al
22860                                           !BCC_EOS
22861                                           ! 3573     if (mouse_flags_2 & 0x80)
22862                                           ! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
22863 67E0           8A46         F9            mov	al,-7[bp]
22864 67E3           24                     80  and	al,#$80
22865 67E5           84C0                       test	al,al
22866 67E7           74           06            je  	.4F8
22867                       000067E9            .4F9:
22868                                           ! 3574       make_farcall = 1;
22869                                           ! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
22870 67E9           B8                   0001  mov	ax,*1
22871 67EC           8946         04            mov	4[bp],ax
22872                                           !BCC_EOS
22873                                           ! 3575     }
22874                       000067EF            .4F8:
22875                                           ! 3576   else {
22876 67EF           EB           07            jmp .4FA
22877                       000067F1            .4F6:
22878                                           ! 3577     mouse_flags_1++;
22879                                           ! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22880 67F1           8A46         FA            mov	al,-6[bp]
22881 67F4           40                         inc	ax
22882 67F5           8846         FA            mov	-6[bp],al
22883                                           !BCC_EOS
22884                                           ! 3578     }
22885                                           ! 3579   write_byte(ebda_seg, 0x0026, mouse_flags_1);
22886                       000067F8            .4FA:
22887                                           ! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
22888 67F8           8A46         FA            mov	al,-6[bp]
22889 67FB           30E4                       xor	ah,ah
22890 67FD           50                         push	ax
22891                                           ! Debug: list int = const $26 (used reg = )
22892 67FE           B8                   0026  mov	ax,*$26
22893 6801           50                         push	ax
22894                                           ! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
22895 6802           FF76         FE            push	-2[bp]
22896                                           ! Debug: func () void = write_byte+0 (used reg = )
22897 6805           E8         9E12            call	_write_byte
22898 6808           83C4                   06  add	sp,*6
22899                                           !BCC_EOS
22900                                           ! 3580 }
22901 680B           89EC                       mov	sp,bp
22902 680D           5D                         pop	bp
22903 680E           C3                         ret
22904                                           ! 3581   void
22905                                           ! 3582 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
22906                                           ! 3583   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
22907                                           export	_int13_harddisk
22908                       0000680F            _int13_harddisk:
22909                                           !BCC_EOS
22910                                           ! 3584 {
22911                                           ! 3585   Bit32u lba_low, lba_high;
22912                                           !BCC_EOS
22913                                           ! 3586   Bit16u ebda_seg=read_word(0x0040,0x000E);
22914 680F           55                         push	bp
22915 6810           89E5                       mov	bp,sp
22916 6812           83C4                   F6  add	sp,*-$A
22917                                           ! Debug: list int = const $E (used reg = )
22918 6815           B8                   000E  mov	ax,*$E
22919 6818           50                         push	ax
22920                                           ! Debug: list int = const $40 (used reg = )
22921 6819           B8                   0040  mov	ax,*$40
22922 681C           50                         push	ax
22923                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
22924 681D           E8         9DE7            call	_read_word
22925 6820           83C4                   04  add	sp,*4
22926                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
22927 6823           8946         F6            mov	-$A[bp],ax
22928                                           !BCC_EOS
22929                                           ! 3587   Bit16u cylinder, head, sector;
22930                                           !BCC_EOS
22931                                           ! 3588   Bit16u segment, offset;
22932                                           !BCC_EOS
22933                                           ! 3589   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
22934                                           !BCC_EOS
22935                                           ! 3590   Bit16u size, count;
22936                                           !BCC_EOS
22937                                           ! 3591   Bit8u device, status;
22938                                           !BCC_EOS
22939                                           ! 3592   ;
22940 6826           83C4                   E4  add	sp,*-$1C
22941                                           !BCC_EOS
22942                                           ! 3593   write_byte(0x0040, 0x008e, 0);
22943                                           ! Debug: list int = const 0 (used reg = )
22944 6829           31C0                       xor	ax,ax
22945 682B           50                         push	ax
22946                                           ! Debug: list int = const $8E (used reg = )
22947 682C           B8                   008E  mov	ax,#$8E
22948 682F           50                         push	ax
22949                                           ! Debug: list int = const $40 (used reg = )
22950 6830           B8                   0040  mov	ax,*$40
22951 6833           50                         push	ax
22952                                           ! Debug: func () void = write_byte+0 (used reg = )
22953 6834           E8         9DE3            call	_write_byte
22954 6837           83C4                   06  add	sp,*6
22955                                           !BCC_EOS
22956                                           ! 3594   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff )
22957                                           ! 3594  >= 0x80 + (4*2)) ) {
22958                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22959 683A           8A46         10            mov	al,$10[bp]
22960                                           ! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
22961 683D           3C                     80  cmp	al,#$80
22962 683F           72           07            jb  	.4FC
22963                       00006841            .4FD:
22964                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22965 6841           8A46         10            mov	al,$10[bp]
22966                                           ! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
22967 6844           3C                     88  cmp	al,#$88
22968 6846           72           06            jb  	.4FB
22969                       00006848            .4FC:
22970                                           ! 3595     ;
22971                                           !BCC_EOS
22972                                           ! 3596     goto int13_fail;
22973 6848           83C4                   00  add	sp,#..FFF1+$28
22974 684B           E9         0E51            br 	.FFF1
22975                                           !BCC_EOS
22976                                           ! 3597     }
22977                                           ! 3598   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
22978                       0000684E            .4FB:
22979                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
22980 684E           8A46         10            mov	al,$10[bp]
22981                                           ! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
22982 6851           30E4                       xor	ah,ah
22983                                           ! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
22984 6853           05                   FF80  add	ax,*-$80
22985 6856           89C3                       mov	bx,ax
22986                                           ! Debug: address unsigned char = [bx+$233] (used reg = )
22987                                           ! Debug: list * unsigned char = bx+$233 (used reg = )
22988 6858           81C3                 0233  add	bx,#$233
22989 685C           53                         push	bx
22990                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
22991 685D           FF76         F6            push	-$A[bp]
22992                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
22993 6860           E8         9D91            call	_read_byte
22994 6863           83C4                   04  add	sp,*4
22995                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
22996 6866           8846         DB            mov	-$25[bp],al
22997                                           !BCC_EOS
22998                                           ! 3599   if (device >= (4*2)) {
22999                                           ! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
23000 6869           8A46         DB            mov	al,-$25[bp]
23001 686C           3C                     08  cmp	al,*8
23002 686E           72           06            jb  	.4FE
23003                       00006870            .4FF:
23004                                           ! 3600     ;
23005                                           !BCC_EOS
23006                                           ! 3601     goto int13_fail;
23007 6870           83C4                   00  add	sp,#..FFF1+$28
23008 6873           E9         0E29            br 	.FFF1
23009                                           !BCC_EOS
23010                                           ! 3602     }
23011                                           ! 3603   switch (( AX >> 8 )) {
23012                       00006876            .4FE:
23013                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23014 6876           8B46         18            mov	ax,$18[bp]
23015 6879           88E0                       mov	al,ah
23016 687B           30E4                       xor	ah,ah
23017 687D           E9         0D9E            br 	.502
23018                                           ! 3604     case 0x00:
23019                                           ! 3605       ata_reset (device);
23020                       00006880            .503:
23021                                           ! Debug: list unsigned char device = [S+$28-$27] (used reg = )
23022 6880           8A46         DB            mov	al,-$25[bp]
23023 6883           30E4                       xor	ah,ah
23024 6885           50                         push	ax
23025                                           ! Debug: func () void = ata_reset+0 (used reg = )
23026 6886           E8         C44A            call	_ata_reset
23027 6889           44                         inc	sp
23028 688A           44                         inc	sp
23029                                           !BCC_EOS
23030                                           ! 3606       goto int13_success;
23031 688B           83C4                   0E  add	sp,#..FFEF-..FFF0
23032 688E           E9         0E3B            br 	.FFEF
23033                                           !BCC_EOS
23034                                           ! 3607       break;
23035 6891           E9         0E08            br 	.500
23036                                           !BCC_EOS
23037                                           ! 3608     case 0x01:
23038                                           ! 3609       status = read_byte(0x0040, 0x0074);
23039                       00006894            .504:
23040                                           ! Debug: list int = const $74 (used reg = )
23041 6894           B8                   0074  mov	ax,*$74
23042 6897           50                         push	ax
23043                                           ! Debug: list int = const $40 (used reg = )
23044 6898           B8                   0040  mov	ax,*$40
23045 689B           50                         push	ax
23046                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23047 689C           E8         9D55            call	_read_byte
23048 689F           83C4                   04  add	sp,*4
23049                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23050 68A2           8846         DA            mov	-$26[bp],al
23051                                           !BCC_EOS
23052                                           ! 3610       AX = ((AX & 0x00ff) | ((status) << 8));
23053                                           ! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
23054 68A5           8A46         DA            mov	al,-$26[bp]
23055 68A8           30E4                       xor	ah,ah
23056 68AA           88C4                       mov	ah,al
23057 68AC           30C0                       xor	al,al
23058 68AE           50                         push	ax
23059                                           ! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
23060 68AF           8A46         18            mov	al,$18[bp]
23061                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23062 68B2           30E4                       xor	ah,ah
23063 68B4           0B46         CA            or	ax,0+..FFF0[bp]
23064 68B7           44                         inc	sp
23065 68B8           44                         inc	sp
23066                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23067 68B9           8946         18            mov	$18[bp],ax
23068                                           !BCC_EOS
23069                                           ! 3611       write_byte(0x0040, 0x0074, 0);
23070                                           ! Debug: list int = const 0 (used reg = )
23071 68BC           31C0                       xor	ax,ax
23072 68BE           50                         push	ax
23073                                           ! Debug: list int = const $74 (used reg = )
23074 68BF           B8                   0074  mov	ax,*$74
23075 68C2           50                         push	ax
23076                                           ! Debug: list int = const $40 (used reg = )
23077 68C3           B8                   0040  mov	ax,*$40
23078 68C6           50                         push	ax
23079                                           ! Debug: func () void = write_byte+0 (used reg = )
23080 68C7           E8         9D50            call	_write_byte
23081 68CA           83C4                   06  add	sp,*6
23082                                           !BCC_EOS
23083                                           ! 3612       if (status) goto int13_fail_nostatus;
23084 68CD           8A46         DA            mov	al,-$26[bp]
23085 68D0           84C0                       test	al,al
23086 68D2           74           08            je  	.505
23087                       000068D4            .506:
23088 68D4           83C4                   0E  add	sp,#..FFEE-..FFF0
23089 68D7           E9         0DE6            br 	.FFEE
23090                                           !BCC_EOS
23091                                           ! 3613       else goto int13_success_noah;
23092 68DA           EB           06            jmp .507
23093                       000068DC            .505:
23094 68DC           83C4                   0E  add	sp,#..FFED-..FFF0
23095 68DF           E9         0DF4            br 	.FFED
23096                                           !BCC_EOS
23097                                           ! 3614       break;
23098                       000068E2            .507:
23099 68E2           E9         0DB7            br 	.500
23100                                           !BCC_EOS
23101                                           ! 3615     case 0x02:
23102                                           ! 3616     case 0x03:
23103                       000068E5            .508:
23104                                           ! 3617     case 0x04:
23105                       000068E5            .509:
23106                                           ! 3618       count = ( AX & 0x00ff );
23107                       000068E5            .50A:
23108                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23109 68E5           8A46         18            mov	al,$18[bp]
23110                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23111 68E8           30E4                       xor	ah,ah
23112 68EA           8946         DC            mov	-$24[bp],ax
23113                                           !BCC_EOS
23114                                           ! 3619       cylinder = ( CX >> 8 );
23115                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
23116 68ED           8B46         16            mov	ax,$16[bp]
23117 68F0           88E0                       mov	al,ah
23118 68F2           30E4                       xor	ah,ah
23119                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23120 68F4           8946         F4            mov	-$C[bp],ax
23121                                           !BCC_EOS
23122                                           ! 3620       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
23123                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23124 68F7           8A46         16            mov	al,$16[bp]
23125                                           ! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
23126 68FA           30E4                       xor	ah,ah
23127                                           ! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
23128 68FC           D1E0                       shl	ax,*1
23129 68FE           D1E0                       shl	ax,*1
23130                                           ! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
23131 6900           25                   0300  and	ax,#$300
23132                                           ! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
23133 6903           0B46         F4            or	ax,-$C[bp]
23134 6906           8946         F4            mov	-$C[bp],ax
23135                                           !BCC_EOS
23136                                           ! 3621       sector = (( CX & 0x00ff ) & 0x3f);
23137                                           ! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
23138 6909           8A46         16            mov	al,$16[bp]
23139                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
23140 690C           24                     3F  and	al,*$3F
23141                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
23142 690E           30E4                       xor	ah,ah
23143 6910           8946         F0            mov	-$10[bp],ax
23144                                           !BCC_EOS
23145                                           ! 3622       head = ( DX >> 8 );
23146                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
23147 6913           8B46         14            mov	ax,$14[bp]
23148 6916           88E0                       mov	al,ah
23149 6918           30E4                       xor	ah,ah
23150                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
23151 691A           8946         F2            mov	-$E[bp],ax
23152                                           !BCC_EOS
23153                                           ! 3623       segment = ES;
23154                                           ! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
23155 691D           8B46         08            mov	ax,8[bp]
23156 6920           8946         EE            mov	-$12[bp],ax
23157                                           !BCC_EOS
23158                                           ! 3624       offset = BX;
23159                                           ! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
23160 6923           8B46         12            mov	ax,$12[bp]
23161 6926           8946         EC            mov	-$14[bp],ax
23162                                           !BCC_EOS
23163                                           ! 3625       if ((count > 128) || (count == 0) || (sector == 0)) {
23164                                           ! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
23165 6929           8B46         DC            mov	ax,-$24[bp]
23166 692C           3D                   0080  cmp	ax,#$80
23167 692F           77           0E            ja  	.50C
23168                       00006931            .50E:
23169                                           ! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
23170 6931           8B46         DC            mov	ax,-$24[bp]
23171 6934           85C0                       test	ax,ax
23172 6936           74           07            je  	.50C
23173                       00006938            .50D:
23174                                           ! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23175 6938           8B46         F0            mov	ax,-$10[bp]
23176 693B           85C0                       test	ax,ax
23177 693D           75           06            jne 	.50B
23178                       0000693F            .50C:
23179                                           ! 3626         ;
23180                                           !BCC_EOS
23181                                           ! 3627         goto int13_fail;
23182 693F           83C4                   0E  add	sp,#..FFF1-..FFF0
23183 6942           E9         0D5A            br 	.FFF1
23184                                           !BCC_EOS
23185                                           ! 3628       }
23186                                           ! 3629       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23187                       00006945            .50B:
23188                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23189 6945           8A46         DB            mov	al,-$25[bp]
23190 6948           30E4                       xor	ah,ah
23191 694A           B9                   001E  mov	cx,*$1E
23192 694D           F7E9                       imul	cx
23193 694F           89C3                       mov	bx,ax
23194                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23195                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23196 6951           81C3                 014E  add	bx,#$14E
23197 6955           53                         push	bx
23198                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23199 6956           FF76         F6            push	-$A[bp]
23200                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23201 6959           E8         9CAB            call	_read_word
23202 695C           83C4                   04  add	sp,*4
23203                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23204 695F           8946         E4            mov	-$1C[bp],ax
23205                                           !BCC_EOS
23206                                           ! 3630       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23207                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23208 6962           8A46         DB            mov	al,-$25[bp]
23209 6965           30E4                       xor	ah,ah
23210 6967           B9                   001E  mov	cx,*$1E
23211 696A           F7E9                       imul	cx
23212 696C           89C3                       mov	bx,ax
23213                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23214                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23215 696E           81C3                 014C  add	bx,#$14C
23216 6972           53                         push	bx
23217                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23218 6973           FF76         F6            push	-$A[bp]
23219                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23220 6976           E8         9C8E            call	_read_word
23221 6979           83C4                   04  add	sp,*4
23222                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23223 697C           8946         E2            mov	-$1E[bp],ax
23224                                           !BCC_EOS
23225                                           ! 3631       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23226                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23227 697F           8A46         DB            mov	al,-$25[bp]
23228 6982           30E4                       xor	ah,ah
23229 6984           B9                   001E  mov	cx,*$1E
23230 6987           F7E9                       imul	cx
23231 6989           89C3                       mov	bx,ax
23232                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23233                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23234 698B           81C3                 0150  add	bx,#$150
23235 698F           53                         push	bx
23236                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23237 6990           FF76         F6            push	-$A[bp]
23238                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23239 6993           E8         9C71            call	_read_word
23240 6996           83C4                   04  add	sp,*4
23241                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23242 6999           8946         E0            mov	-$20[bp],ax
23243                                           !BCC_EOS
23244                                           ! 3632       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
23245                                           ! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
23246 699C           8B46         F4            mov	ax,-$C[bp]
23247 699F           3B46         E4            cmp	ax,-$1C[bp]
23248 69A2           73           10            jae 	.510
23249                       000069A4            .512:
23250                                           ! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
23251 69A4           8B46         F2            mov	ax,-$E[bp]
23252 69A7           3B46         E2            cmp	ax,-$1E[bp]
23253 69AA           73           08            jae 	.510
23254                       000069AC            .511:
23255                                           ! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
23256 69AC           8B46         F0            mov	ax,-$10[bp]
23257 69AF           3B46         E0            cmp	ax,-$20[bp]
23258 69B2           76           06            jbe 	.50F
23259                       000069B4            .510:
23260                                           ! 3633         ;
23261                                           !BCC_EOS
23262                                           ! 3634         goto int13_fail;
23263 69B4           83C4                   0E  add	sp,#..FFF1-..FFF0
23264 69B7           E9         0CE5            br 	.FFF1
23265                                           !BCC_EOS
23266                                           ! 3635         }
23267                                           ! 3636       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
23268                       000069BA            .50F:
23269                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23270 69BA           8B46         18            mov	ax,$18[bp]
23271 69BD           88E0                       mov	al,ah
23272 69BF           30E4                       xor	ah,ah
23273                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
23274 69C1           3D                   0004  cmp	ax,*4
23275 69C4           75           06            jne 	.513
23276                       000069C6            .514:
23277 69C6           83C4                   0E  add	sp,#..FFEF-..FFF0
23278 69C9           E9         0D00            br 	.FFEF
23279                                           !BCC_EOS
23280                                           ! 3637       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
23281                       000069CC            .513:
23282                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23283 69CC           8A46         DB            mov	al,-$25[bp]
23284 69CF           30E4                       xor	ah,ah
23285 69D1           B9                   001E  mov	cx,*$1E
23286 69D4           F7E9                       imul	cx
23287 69D6           89C3                       mov	bx,ax
23288                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
23289                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
23290 69D8           81C3                 0152  add	bx,#$152
23291 69DC           53                         push	bx
23292                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23293 69DD           FF76         F6            push	-$A[bp]
23294                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23295 69E0           E8         9C24            call	_read_word
23296 69E3           83C4                   04  add	sp,*4
23297                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
23298 69E6           8946         E8            mov	-$18[bp],ax
23299                                           !BCC_EOS
23300                                           ! 3638       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
23301                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23302 69E9           8A46         DB            mov	al,-$25[bp]
23303 69EC           30E4                       xor	ah,ah
23304 69EE           B9                   001E  mov	cx,*$1E
23305 69F1           F7E9                       imul	cx
23306 69F3           89C3                       mov	bx,ax
23307                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
23308                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
23309 69F5           81C3                 0156  add	bx,#$156
23310 69F9           53                         push	bx
23311                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23312 69FA           FF76         F6            push	-$A[bp]
23313                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23314 69FD           E8         9C07            call	_read_word
23315 6A00           83C4                   04  add	sp,*4
23316                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
23317 6A03           8946         E6            mov	-$1A[bp],ax
23318                                           !BCC_EOS
23319                                           ! 3639       if ( (nph != nlh) || (npspt != nlspt)) {
23320                                           ! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
23321 6A06           8B46         E8            mov	ax,-$18[bp]
23322 6A09           3B46         E2            cmp	ax,-$1E[bp]
23323 6A0C           75           08            jne 	.516
23324                       00006A0E            .517:
23325                                           ! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
23326 6A0E           8B46         E6            mov	ax,-$1A[bp]
23327 6A11           3B46         E0            cmp	ax,-$20[bp]
23328 6A14           74           72            je  	.515
23329                       00006A16            .516:
23330                                           ! 3640         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
23331                                           ! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23332 6A16           8B46         F0            mov	ax,-$10[bp]
23333 6A19           31DB                       xor	bx,bx
23334 6A1B           53                         push	bx
23335 6A1C           50                         push	ax
23336                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
23337 6A1D           8B46         E0            mov	ax,-$20[bp]
23338 6A20           31DB                       xor	bx,bx
23339 6A22           53                         push	bx
23340 6A23           50                         push	ax
23341                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
23342 6A24           8B46         F2            mov	ax,-$E[bp]
23343 6A27           31DB                       xor	bx,bx
23344 6A29           53                         push	bx
23345 6A2A           50                         push	ax
23346                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
23347 6A2B           8B46         E2            mov	ax,-$1E[bp]
23348 6A2E           31DB                       xor	bx,bx
23349 6A30           53                         push	bx
23350 6A31           50                         push	ax
23351                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
23352 6A32           8B46         F4            mov	ax,-$C[bp]
23353 6A35           31DB                       xor	bx,bx
23354                                           ! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
23355 6A37           8D7E         BC            lea	di,-$E+..FFF0[bp]
23356 6A3A           E8         96AC            call	lmulul
23357 6A3D           83C4                   04  add	sp,*4
23358                                           ! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
23359 6A40           8D7E         C0            lea	di,-$A+..FFF0[bp]
23360 6A43           E8         967D            call	laddul
23361 6A46           83C4                   04  add	sp,*4
23362                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23363 6A49           8D7E         C4            lea	di,-6+..FFF0[bp]
23364 6A4C           E8         969A            call	lmulul
23365 6A4F           83C4                   04  add	sp,*4
23366                                           ! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23367 6A52           8D7E         C8            lea	di,-2+..FFF0[bp]
23368 6A55           E8         966B            call	laddul
23369 6A58           83C4                   04  add	sp,*4
23370                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
23371 6A5B           53                         push	bx
23372 6A5C           50                         push	ax
23373 6A5D           B8                   0001  mov	ax,*1
23374 6A60           31DB                       xor	bx,bx
23375 6A62           53                         push	bx
23376 6A63           50                         push	ax
23377 6A64           8B46         C8            mov	ax,-2+..FFF0[bp]
23378 6A67           8B5E         CA            mov	bx,0+..FFF0[bp]
23379 6A6A           8D7E         C4            lea	di,-6+..FFF0[bp]
23380 6A6D           E8         9671            call	lsubul
23381 6A70           83C4                   08  add	sp,*8
23382                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23383 6A73           8946         FC            mov	-4[bp],ax
23384 6A76           895E         FE            mov	-2[bp],bx
23385                                           !BCC_EOS
23386                                           ! 3641         lba_high = 0;
23387                                           ! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23388 6A79           31C0                       xor	ax,ax
23389 6A7B           31DB                       xor	bx,bx
23390 6A7D           8946         F8            mov	-8[bp],ax
23391 6A80           895E         FA            mov	-6[bp],bx
23392                                           !BCC_EOS
23393                                           ! 3642         sector = 0;
23394                                           ! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
23395 6A83           31C0                       xor	ax,ax
23396 6A85           8946         F0            mov	-$10[bp],ax
23397                                           !BCC_EOS
23398                                           ! 3643         }
23399                                           ! 3644       if ( ( AX >> 8 ) == 0x02 )
23400                       00006A88            .515:
23401                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
23402 6A88           8B46         18            mov	ax,$18[bp]
23403 6A8B           88E0                       mov	al,ah
23404 6A8D           30E4                       xor	ah,ah
23405                                           ! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
23406 6A8F           3D                   0002  cmp	ax,*2
23407 6A92           75           33            jne 	.518
23408                       00006A94            .519:
23409                                           ! 3645         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
23410                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23411 6A94           FF76         EC            push	-$14[bp]
23412                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23413 6A97           FF76         EE            push	-$12[bp]
23414                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23415 6A9A           FF76         FA            push	-6[bp]
23416 6A9D           FF76         F8            push	-8[bp]
23417                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23418 6AA0           FF76         FE            push	-2[bp]
23419 6AA3           FF76         FC            push	-4[bp]
23420                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23421 6AA6           FF76         F0            push	-$10[bp]
23422                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23423 6AA9           FF76         F2            push	-$E[bp]
23424                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23425 6AAC           FF76         F4            push	-$C[bp]
23426                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23427 6AAF           FF76         DC            push	-$24[bp]
23428                                           ! Debug: list int = const $20 (used reg = )
23429 6AB2           B8                   0020  mov	ax,*$20
23430 6AB5           50                         push	ax
23431                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23432 6AB6           8A46         DB            mov	al,-$25[bp]
23433 6AB9           30E4                       xor	ah,ah
23434 6ABB           50                         push	ax
23435                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
23436 6ABC           E8         C368            call	_ata_cmd_data_in
23437 6ABF           83C4                   18  add	sp,*$18
23438                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23439 6AC2           8846         DA            mov	-$26[bp],al
23440                                           !BCC_EOS
23441                                           ! 3646       else
23442                                           ! 3647         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
23443 6AC5           EB           31            jmp .51A
23444                       00006AC7            .518:
23445                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
23446 6AC7           FF76         EC            push	-$14[bp]
23447                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
23448 6ACA           FF76         EE            push	-$12[bp]
23449                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
23450 6ACD           FF76         FA            push	-6[bp]
23451 6AD0           FF76         F8            push	-8[bp]
23452                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
23453 6AD3           FF76         FE            push	-2[bp]
23454 6AD6           FF76         FC            push	-4[bp]
23455                                           ! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
23456 6AD9           FF76         F0            push	-$10[bp]
23457                                           ! Debug: list unsigned short head = [S+$36-$10] (used reg = )
23458 6ADC           FF76         F2            push	-$E[bp]
23459                                           ! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
23460 6ADF           FF76         F4            push	-$C[bp]
23461                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
23462 6AE2           FF76         DC            push	-$24[bp]
23463                                           ! Debug: list int = const $30 (used reg = )
23464 6AE5           B8                   0030  mov	ax,*$30
23465 6AE8           50                         push	ax
23466                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
23467 6AE9           8A46         DB            mov	al,-$25[bp]
23468 6AEC           30E4                       xor	ah,ah
23469 6AEE           50                         push	ax
23470                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
23471 6AEF           E8         C706            call	_ata_cmd_data_out
23472 6AF2           83C4                   18  add	sp,*$18
23473                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
23474 6AF5           8846         DA            mov	-$26[bp],al
23475                                           !BCC_EOS
23476                                           ! 3648       AX = ((AX & 0xff00) | (read_word(ebda_seg,
23477                       00006AF8            .51A:
23478                                           ! 3648  &((ebda_data_t *) 0)->ata.trsfsectors)));
23479                                           ! Debug: list * unsigned short = const $254 (used reg = )
23480 6AF8           B8                   0254  mov	ax,#$254
23481 6AFB           50                         push	ax
23482                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23483 6AFC           FF76         F6            push	-$A[bp]
23484                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23485 6AFF           E8         9B05            call	_read_word
23486 6B02           83C4                   04  add	sp,*4
23487 6B05           50                         push	ax
23488                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
23489 6B06           8B46         18            mov	ax,$18[bp]
23490 6B09           30C0                       xor	al,al
23491                                           ! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
23492 6B0B           0B46         CA            or	ax,0+..FFF0[bp]
23493 6B0E           44                         inc	sp
23494 6B0F           44                         inc	sp
23495                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23496 6B10           8946         18            mov	$18[bp],ax
23497                                           !BCC_EOS
23498                                           ! 3649       if (status != 0) {
23499                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
23500 6B13           8A46         DA            mov	al,-$26[bp]
23501 6B16           84C0                       test	al,al
23502 6B18           74           11            je  	.51B
23503                       00006B1A            .51C:
23504                                           ! 3650         ;
23505                                           !BCC_EOS
23506                                           ! 3651         AX = ((AX & 0x00ff) | ((0x0c) << 8));
23507                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23508 6B1A           8A46         18            mov	al,$18[bp]
23509                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
23510 6B1D           30E4                       xor	ah,ah
23511 6B1F           0D                   0C00  or	ax,#$C00
23512                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23513 6B22           8946         18            mov	$18[bp],ax
23514                                           !BCC_EOS
23515                                           ! 3652         goto int13_fail_noah;
23516 6B25           83C4                   0E  add	sp,#..FFEC-..FFF0
23517 6B28           E9         0B7F            br 	.FFEC
23518                                           !BCC_EOS
23519                                           ! 3653         }
23520                                           ! 3654       goto int13_success;
23521                       00006B2B            .51B:
23522 6B2B           83C4                   0E  add	sp,#..FFEF-..FFF0
23523 6B2E           E9         0B9B            br 	.FFEF
23524                                           !BCC_EOS
23525                                           ! 3655       break;
23526 6B31           E9         0B68            br 	.500
23527                                           !BCC_EOS
23528                                           ! 3656     case 0x05:
23529                                           ! 3657       ;
23530                       00006B34            .51D:
23531                                           !BCC_EOS
23532                                           ! 3658       goto int13_success;
23533 6B34           83C4                   0E  add	sp,#..FFEF-..FFF0
23534 6B37           E9         0B92            br 	.FFEF
23535                                           !BCC_EOS
23536                                           ! 3659       return;
23537 6B3A           89EC                       mov	sp,bp
23538 6B3C           5D                         pop	bp
23539 6B3D           C3                         ret
23540                                           !BCC_EOS
23541                                           ! 3660       break;
23542 6B3E           E9         0B5B            br 	.500
23543                                           !BCC_EOS
23544                                           ! 3661     case 0x08:
23545                                           ! 3662       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23546                       00006B41            .51E:
23547                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23548 6B41           8A46         DB            mov	al,-$25[bp]
23549 6B44           30E4                       xor	ah,ah
23550 6B46           B9                   001E  mov	cx,*$1E
23551 6B49           F7E9                       imul	cx
23552 6B4B           89C3                       mov	bx,ax
23553                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23554                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23555 6B4D           81C3                 014E  add	bx,#$14E
23556 6B51           53                         push	bx
23557                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23558 6B52           FF76         F6            push	-$A[bp]
23559                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23560 6B55           E8         9AAF            call	_read_word
23561 6B58           83C4                   04  add	sp,*4
23562                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23563 6B5B           8946         E4            mov	-$1C[bp],ax
23564                                           !BCC_EOS
23565                                           ! 3663       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23566                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23567 6B5E           8A46         DB            mov	al,-$25[bp]
23568 6B61           30E4                       xor	ah,ah
23569 6B63           B9                   001E  mov	cx,*$1E
23570 6B66           F7E9                       imul	cx
23571 6B68           89C3                       mov	bx,ax
23572                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23573                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23574 6B6A           81C3                 014C  add	bx,#$14C
23575 6B6E           53                         push	bx
23576                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23577 6B6F           FF76         F6            push	-$A[bp]
23578                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23579 6B72           E8         9A92            call	_read_word
23580 6B75           83C4                   04  add	sp,*4
23581                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23582 6B78           8946         E2            mov	-$1E[bp],ax
23583                                           !BCC_EOS
23584                                           ! 3664       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23585                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23586 6B7B           8A46         DB            mov	al,-$25[bp]
23587 6B7E           30E4                       xor	ah,ah
23588 6B80           B9                   001E  mov	cx,*$1E
23589 6B83           F7E9                       imul	cx
23590 6B85           89C3                       mov	bx,ax
23591                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23592                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23593 6B87           81C3                 0150  add	bx,#$150
23594 6B8B           53                         push	bx
23595                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23596 6B8C           FF76         F6            push	-$A[bp]
23597                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23598 6B8F           E8         9A75            call	_read_word
23599 6B92           83C4                   04  add	sp,*4
23600                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23601 6B95           8946         E0            mov	-$20[bp],ax
23602                                           !BCC_EOS
23603                                           ! 3665       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
23604                                           ! Debug: list * unsigned char = const $232 (used reg = )
23605 6B98           B8                   0232  mov	ax,#$232
23606 6B9B           50                         push	ax
23607                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23608 6B9C           FF76         F6            push	-$A[bp]
23609                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
23610 6B9F           E8         9A52            call	_read_byte
23611 6BA2           83C4                   04  add	sp,*4
23612                                           ! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
23613 6BA5           30E4                       xor	ah,ah
23614 6BA7           8946         DC            mov	-$24[bp],ax
23615                                           !BCC_EOS
23616                                           ! 3666       nlc = nlc - 2;
23617                                           ! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
23618 6BAA           8B46         E4            mov	ax,-$1C[bp]
23619                                           ! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
23620 6BAD           48                         dec	ax
23621 6BAE           48                         dec	ax
23622 6BAF           8946         E4            mov	-$1C[bp],ax
23623                                           !BCC_EOS
23624                                           ! 3667       AX = ((AX & 0xff00) | (0));
23625                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
23626 6BB2           8B46         18            mov	ax,$18[bp]
23627 6BB5           30C0                       xor	al,al
23628                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
23629 6BB7           0C                     00  or	al,*0
23630                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23631 6BB9           8946         18            mov	$18[bp],ax
23632                                           !BCC_EOS
23633                                           ! 3668       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
23634                                           ! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
23635 6BBC           8A46         E4            mov	al,-$1C[bp]
23636                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
23637 6BBF           30E4                       xor	ah,ah
23638 6BC1           88C4                       mov	ah,al
23639 6BC3           30C0                       xor	al,al
23640 6BC5           50                         push	ax
23641                                           ! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
23642 6BC6           8A46         16            mov	al,$16[bp]
23643                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23644 6BC9           30E4                       xor	ah,ah
23645 6BCB           0B46         CA            or	ax,0+..FFF0[bp]
23646 6BCE           44                         inc	sp
23647 6BCF           44                         inc	sp
23648                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
23649 6BD0           8946         16            mov	$16[bp],ax
23650                                           !BCC_EOS
23651                                           ! 3669       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
23652                                           ! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
23653 6BD3           8A46         E0            mov	al,-$20[bp]
23654 6BD6           24                     3F  and	al,*$3F
23655 6BD8           50                         push	ax
23656                                           ! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
23657 6BD9           8B46         E4            mov	ax,-$1C[bp]
23658 6BDC           D1E8                       shr	ax,*1
23659 6BDE           D1E8                       shr	ax,*1
23660                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
23661 6BE0           24                     C0  and	al,#$C0
23662                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23663 6BE2           0A46         CA            or	al,0+..FFF0[bp]
23664 6BE5           44                         inc	sp
23665 6BE6           44                         inc	sp
23666 6BE7           50                         push	ax
23667                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
23668 6BE8           8B46         16            mov	ax,$16[bp]
23669 6BEB           30C0                       xor	al,al
23670                                           ! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
23671 6BED           0A46         CA            or	al,0+..FFF0[bp]
23672 6BF0           44                         inc	sp
23673 6BF1           44                         inc	sp
23674                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
23675 6BF2           8946         16            mov	$16[bp],ax
23676                                           !BCC_EOS
23677                                           ! 3670       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
23678                                           ! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
23679 6BF5           8B46         E2            mov	ax,-$1E[bp]
23680                                           ! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
23681 6BF8           48                         dec	ax
23682 6BF9           88C4                       mov	ah,al
23683 6BFB           30C0                       xor	al,al
23684 6BFD           50                         push	ax
23685                                           ! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
23686 6BFE           8A46         14            mov	al,$14[bp]
23687                                           ! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
23688 6C01           30E4                       xor	ah,ah
23689 6C03           0B46         CA            or	ax,0+..FFF0[bp]
23690 6C06           44                         inc	sp
23691 6C07           44                         inc	sp
23692                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
23693 6C08           8946         14            mov	$14[bp],ax
23694                                           !BCC_EOS
23695                                           ! 3671       DX = ((DX & 0xff00) | (count));
23696                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
23697 6C0B           8B46         14            mov	ax,$14[bp]
23698 6C0E           30C0                       xor	al,al
23699                                           ! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
23700 6C10           0B46         DC            or	ax,-$24[bp]
23701                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
23702 6C13           8946         14            mov	$14[bp],ax
23703                                           !BCC_EOS
23704                                           ! 3672       goto int13_success;
23705 6C16           83C4                   0E  add	sp,#..FFEF-..FFF0
23706 6C19           E9         0AB0            br 	.FFEF
23707                                           !BCC_EOS
23708                                           ! 3673       break;
23709 6C1C           E9         0A7D            br 	.500
23710                                           !BCC_EOS
23711                                           ! 3674     case 0x10:
23712                                           ! 3675       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
23713                       00006C1F            .51F:
23714                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
23715 6C1F           8A46         DB            mov	al,-$25[bp]
23716 6C22           30E4                       xor	ah,ah
23717 6C24           D1E8                       shr	ax,*1
23718                                           ! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
23719 6C26           B1                     03  mov	cl,*3
23720 6C28           D3E0                       shl	ax,cl
23721 6C2A           89C3                       mov	bx,ax
23722                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
23723                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
23724 6C2C           81C3                 0124  add	bx,#$124
23725 6C30           53                         push	bx
23726                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23727 6C31           FF76         F6            push	-$A[bp]
23728                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23729 6C34           E8         99D0            call	_read_word
23730 6C37           83C4                   04  add	sp,*4
23731                                           ! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
23732                                           ! Debug: list unsigned int = ax+7 (used reg = )
23733 6C3A           05                   0007  add	ax,*7
23734 6C3D           50                         push	ax
23735                                           ! Debug: func () unsigned char = inb+0 (used reg = )
23736 6C3E           E8         98FD            call	_inb
23737 6C41           44                         inc	sp
23738 6C42           44                         inc	sp
23739                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
23740 6C43           8846         DA            mov	-$26[bp],al
23741                                           !BCC_EOS
23742                                           ! 3676       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
23743                                           ! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
23744 6C46           8A46         DA            mov	al,-$26[bp]
23745 6C49           24                     C0  and	al,#$C0
23746                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
23747 6C4B           3C                     40  cmp	al,*$40
23748 6C4D           75           08            jne 	.520
23749                       00006C4F            .521:
23750                                           ! 3677         goto int13_success;
23751 6C4F           83C4                   0E  add	sp,#..FFEF-..FFF0
23752 6C52           E9         0A77            br 	.FFEF
23753                                           !BCC_EOS
23754                                           ! 3678         }
23755                                           ! 3679       else {
23756 6C55           EB           11            jmp .522
23757                       00006C57            .520:
23758                                           ! 3680         AX = ((AX & 0x00ff) | ((0xAA) << 8));
23759                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23760 6C57           8A46         18            mov	al,$18[bp]
23761                                           ! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
23762 6C5A           30E4                       xor	ah,ah
23763 6C5C           0D                   AA00  or	ax,#-$5600
23764                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23765 6C5F           8946         18            mov	$18[bp],ax
23766                                           !BCC_EOS
23767                                           ! 3681         goto int13_fail_noah;
23768 6C62           83C4                   0E  add	sp,#..FFEC-..FFF0
23769 6C65           E9         0A42            br 	.FFEC
23770                                           !BCC_EOS
23771                                           ! 3682         }
23772                                           ! 3683       break;
23773                       00006C68            .522:
23774 6C68           E9         0A31            br 	.500
23775                                           !BCC_EOS
23776                                           ! 3684     case 0x15:
23777                                           ! 3685       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
23778                       00006C6B            .523:
23779                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23780 6C6B           8A46         DB            mov	al,-$25[bp]
23781 6C6E           30E4                       xor	ah,ah
23782 6C70           B9                   001E  mov	cx,*$1E
23783 6C73           F7E9                       imul	cx
23784 6C75           89C3                       mov	bx,ax
23785                                           ! Debug: address unsigned short = [bx+$14E] (used reg = )
23786                                           ! Debug: list * unsigned short = bx+$14E (used reg = )
23787 6C77           81C3                 014E  add	bx,#$14E
23788 6C7B           53                         push	bx
23789                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23790 6C7C           FF76         F6            push	-$A[bp]
23791                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23792 6C7F           E8         9985            call	_read_word
23793 6C82           83C4                   04  add	sp,*4
23794                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
23795 6C85           8946         E4            mov	-$1C[bp],ax
23796                                           !BCC_EOS
23797                                           ! 3686       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
23798                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23799 6C88           8A46         DB            mov	al,-$25[bp]
23800 6C8B           30E4                       xor	ah,ah
23801 6C8D           B9                   001E  mov	cx,*$1E
23802 6C90           F7E9                       imul	cx
23803 6C92           89C3                       mov	bx,ax
23804                                           ! Debug: address unsigned short = [bx+$14C] (used reg = )
23805                                           ! Debug: list * unsigned short = bx+$14C (used reg = )
23806 6C94           81C3                 014C  add	bx,#$14C
23807 6C98           53                         push	bx
23808                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23809 6C99           FF76         F6            push	-$A[bp]
23810                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23811 6C9C           E8         9968            call	_read_word
23812 6C9F           83C4                   04  add	sp,*4
23813                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
23814 6CA2           8946         E2            mov	-$1E[bp],ax
23815                                           !BCC_EOS
23816                                           ! 3687       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
23817                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23818 6CA5           8A46         DB            mov	al,-$25[bp]
23819 6CA8           30E4                       xor	ah,ah
23820 6CAA           B9                   001E  mov	cx,*$1E
23821 6CAD           F7E9                       imul	cx
23822 6CAF           89C3                       mov	bx,ax
23823                                           ! Debug: address unsigned short = [bx+$150] (used reg = )
23824                                           ! Debug: list * unsigned short = bx+$150 (used reg = )
23825 6CB1           81C3                 0150  add	bx,#$150
23826 6CB5           53                         push	bx
23827                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
23828 6CB6           FF76         F6            push	-$A[bp]
23829                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23830 6CB9           E8         994B            call	_read_word
23831 6CBC           83C4                   04  add	sp,*4
23832                                           ! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23833 6CBF           8946         E0            mov	-$20[bp],ax
23834                                           !BCC_EOS
23835                                           ! 3688       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
23836                                           ! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
23837 6CC2           8B46         E0            mov	ax,-$20[bp]
23838 6CC5           31DB                       xor	bx,bx
23839 6CC7           53                         push	bx
23840 6CC8           50                         push	ax
23841                                           ! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
23842 6CC9           8B46         E2            mov	ax,-$1E[bp]
23843 6CCC           31DB                       xor	bx,bx
23844 6CCE           53                         push	bx
23845 6CCF           50                         push	ax
23846                                           ! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
23847 6CD0           8B46         E4            mov	ax,-$1C[bp]
23848                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
23849 6CD3           48                         dec	ax
23850 6CD4           31DB                       xor	bx,bx
23851                                           ! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
23852 6CD6           8D7E         C4            lea	di,-6+..FFF0[bp]
23853 6CD9           E8         940D            call	lmulul
23854 6CDC           83C4                   04  add	sp,*4
23855                                           ! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
23856 6CDF           8D7E         C8            lea	di,-2+..FFF0[bp]
23857 6CE2           E8         9404            call	lmulul
23858 6CE5           83C4                   04  add	sp,*4
23859                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
23860 6CE8           8946         FC            mov	-4[bp],ax
23861 6CEB           895E         FE            mov	-2[bp],bx
23862                                           !BCC_EOS
23863                                           ! 3689       CX = lba_low >> 16;
23864                                           ! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
23865 6CEE           8B46         FC            mov	ax,-4[bp]
23866 6CF1           8B5E         FE            mov	bx,-2[bp]
23867 6CF4           93                         xchg	bx,ax
23868 6CF5           31DB                       xor	bx,bx
23869                                           ! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
23870 6CF7           8946         16            mov	$16[bp],ax
23871                                           !BCC_EOS
23872                                           ! 3690       DX = lba_low & 0xffff;
23873                                           ! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
23874                                           ! Debug: expression subtree swapping
23875 6CFA           B8                   FFFF  mov	ax,#$FFFF
23876 6CFD           31DB                       xor	bx,bx
23877 6CFF           8D7E         FC            lea	di,-4[bp]
23878 6D02           E8         93B6            call	landul
23879                                           ! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
23880 6D05           8946         14            mov	$14[bp],ax
23881                                           !BCC_EOS
23882                                           ! 3691       AX = ((AX & 0x00ff) | ((3) << 8));
23883                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23884 6D08           8A46         18            mov	al,$18[bp]
23885                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
23886 6D0B           30E4                       xor	ah,ah
23887 6D0D           0D                   0300  or	ax,#$300
23888                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23889 6D10           8946         18            mov	$18[bp],ax
23890                                           !BCC_EOS
23891                                           ! 3692       goto int13_success_noah;
23892 6D13           83C4                   0E  add	sp,#..FFED-..FFF0
23893 6D16           E9         09BD            br 	.FFED
23894                                           !BCC_EOS
23895                                           ! 3693       break;
23896 6D19           E9         0980            br 	.500
23897                                           !BCC_EOS
23898                                           ! 3694     case 0x41:
23899                                           ! 3695       BX=0xaa55;
23900                       00006D1C            .524:
23901                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
23902 6D1C           B8                   AA55  mov	ax,#$AA55
23903 6D1F           8946         12            mov	$12[bp],ax
23904                                           !BCC_EOS
23905                                           ! 3696       AX = ((AX & 0x00ff) | ((0x30) << 8));
23906                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
23907 6D22           8A46         18            mov	al,$18[bp]
23908                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
23909 6D25           30E4                       xor	ah,ah
23910 6D27           0D                   3000  or	ax,#$3000
23911                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
23912 6D2A           8946         18            mov	$18[bp],ax
23913                                           !BCC_EOS
23914                                           ! 3697       CX=0x0007;
23915                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
23916 6D2D           B8                   0007  mov	ax,*7
23917 6D30           8946         16            mov	$16[bp],ax
23918                                           !BCC_EOS
23919                                           ! 3698       goto int13_success_noah;
23920 6D33           83C4                   0E  add	sp,#..FFED-..FFF0
23921 6D36           E9         099D            br 	.FFED
23922                                           !BCC_EOS
23923                                           ! 3699       break;
23924 6D39           E9         0960            br 	.500
23925                                           !BCC_EOS
23926                                           ! 3700     case 0x42:
23927                                           ! 3701     case 0x43:
23928                       00006D3C            .525:
23929                                           ! 3702     case 0x44:
23930                       00006D3C            .526:
23931                                           ! 3703     case 0x47:
23932                       00006D3C            .527:
23933                                           ! 3704       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
23934                       00006D3C            .528:
23935                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
23936 6D3C           8B46         0C            mov	ax,$C[bp]
23937                                           ! Debug: list unsigned int = ax+2 (used reg = )
23938 6D3F           40                         inc	ax
23939 6D40           40                         inc	ax
23940 6D41           50                         push	ax
23941                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23942 6D42           FF76         06            push	6[bp]
23943                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23944 6D45           E8         98BF            call	_read_word
23945 6D48           83C4                   04  add	sp,*4
23946                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
23947 6D4B           8946         DC            mov	-$24[bp],ax
23948                                           !BCC_EOS
23949                                           ! 3705       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)-
23950                                           ! 3705 >segment);
23951                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
23952 6D4E           8B46         0C            mov	ax,$C[bp]
23953                                           ! Debug: list unsigned int = ax+6 (used reg = )
23954 6D51           05                   0006  add	ax,*6
23955 6D54           50                         push	ax
23956                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23957 6D55           FF76         06            push	6[bp]
23958                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23959 6D58           E8         98AC            call	_read_word
23960 6D5B           83C4                   04  add	sp,*4
23961                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
23962 6D5E           8946         EE            mov	-$12[bp],ax
23963                                           !BCC_EOS
23964                                           ! 3706       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
23965                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
23966 6D61           8B46         0C            mov	ax,$C[bp]
23967                                           ! Debug: list unsigned int = ax+4 (used reg = )
23968 6D64           05                   0004  add	ax,*4
23969 6D67           50                         push	ax
23970                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23971 6D68           FF76         06            push	6[bp]
23972                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
23973 6D6B           E8         9899            call	_read_word
23974 6D6E           83C4                   04  add	sp,*4
23975                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
23976 6D71           8946         EC            mov	-$14[bp],ax
23977                                           !BCC_EOS
23978                                           ! 3707       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
23979                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
23980 6D74           8B46         0C            mov	ax,$C[bp]
23981                                           ! Debug: list unsigned int = ax+$C (used reg = )
23982 6D77           05                   000C  add	ax,*$C
23983 6D7A           50                         push	ax
23984                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
23985 6D7B           FF76         06            push	6[bp]
23986                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
23987 6D7E           E8         9302            call	_read_dword
23988 6D81           89D3                       mov	bx,dx
23989 6D83           83C4                   04  add	sp,*4
23990                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
23991 6D86           8946         F8            mov	-8[bp],ax
23992 6D89           895E         FA            mov	-6[bp],bx
23993                                           !BCC_EOS
23994                                           ! 3708       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
23995                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
23996 6D8C           8A46         DB            mov	al,-$25[bp]
23997 6D8F           30E4                       xor	ah,ah
23998 6D91           B9                   001E  mov	cx,*$1E
23999 6D94           F7E9                       imul	cx
24000 6D96           89C3                       mov	bx,ax
24001                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24002                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24003 6D98           81C3                 015C  add	bx,#$15C
24004 6D9C           53                         push	bx
24005                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24006 6D9D           FF76         F6            push	-$A[bp]
24007                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24008 6DA0           E8         92E0            call	_read_dword
24009 6DA3           89D3                       mov	bx,dx
24010 6DA5           83C4                   04  add	sp,*4
24011                                           ! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24012 6DA8           8D7E         F8            lea	di,-8[bp]
24013 6DAB           E8         931D            call	lcmpul
24014 6DAE           73           06            jae 	.529
24015                       00006DB0            .52A:
24016                                           ! 3709         ;
24017                                           !BCC_EOS
24018                                           ! 3710         goto int13_fail;
24019 6DB0           83C4                   0E  add	sp,#..FFF1-..FFF0
24020 6DB3           E9         08E9            br 	.FFF1
24021                                           !BCC_EOS
24022                                           ! 3711         }
24023                                           ! 3712       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
24024                       00006DB6            .529:
24025                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
24026 6DB6           8B46         0C            mov	ax,$C[bp]
24027                                           ! Debug: list unsigned int = ax+8 (used reg = )
24028 6DB9           05                   0008  add	ax,*8
24029 6DBC           50                         push	ax
24030                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24031 6DBD           FF76         06            push	6[bp]
24032                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24033 6DC0           E8         92C0            call	_read_dword
24034 6DC3           89D3                       mov	bx,dx
24035 6DC5           83C4                   04  add	sp,*4
24036                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24037 6DC8           8946         FC            mov	-4[bp],ax
24038 6DCB           895E         FE            mov	-2[bp],bx
24039                                           !BCC_EOS
24040                                           ! 3713       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
24041                                           ! 3714           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
24042                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24043 6DCE           8A46         DB            mov	al,-$25[bp]
24044 6DD1           30E4                       xor	ah,ah
24045 6DD3           B9                   001E  mov	cx,*$1E
24046 6DD6           F7E9                       imul	cx
24047 6DD8           89C3                       mov	bx,ax
24048                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24049                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24050 6DDA           81C3                 015C  add	bx,#$15C
24051 6DDE           53                         push	bx
24052                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24053 6DDF           FF76         F6            push	-$A[bp]
24054                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24055 6DE2           E8         929E            call	_read_dword
24056 6DE5           89D3                       mov	bx,dx
24057 6DE7           83C4                   04  add	sp,*4
24058                                           ! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
24059                                           ! Debug: expression subtree swapping
24060 6DEA           8D7E         F8            lea	di,-8[bp]
24061 6DED           E8         92DB            call	lcmpul
24062 6DF0           75           2A            jne 	.52B
24063                       00006DF2            .52D:
24064                                           ! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
24065 6DF2           8A46         DB            mov	al,-$25[bp]
24066 6DF5           30E4                       xor	ah,ah
24067 6DF7           B9                   001E  mov	cx,*$1E
24068 6DFA           F7E9                       imul	cx
24069 6DFC           89C3                       mov	bx,ax
24070                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24071                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24072 6DFE           81C3                 0158  add	bx,#$158
24073 6E02           53                         push	bx
24074                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24075 6E03           FF76         F6            push	-$A[bp]
24076                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24077 6E06           E8         927A            call	_read_dword
24078 6E09           89D3                       mov	bx,dx
24079 6E0B           83C4                   04  add	sp,*4
24080                                           ! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
24081 6E0E           8D7E         FC            lea	di,-4[bp]
24082 6E11           E8         92B7            call	lcmpul
24083 6E14           77           06            ja  	.52B
24084                       00006E16            .52C:
24085                                           ! 3715         ;
24086                                           !BCC_EOS
24087                                           ! 3716         goto int13_fail;
24088 6E16           83C4                   0E  add	sp,#..FFF1-..FFF0
24089 6E19           E9         0883            br 	.FFF1
24090                                           !BCC_EOS
24091                                           ! 3717         }
24092                                           ! 3718       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
24093                       00006E1C            .52B:
24094                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24095 6E1C           8B46         18            mov	ax,$18[bp]
24096 6E1F           88E0                       mov	al,ah
24097 6E21           30E4                       xor	ah,ah
24098                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
24099 6E23           3D                   0044  cmp	ax,*$44
24100 6E26           74           0C            je  	.52F
24101                       00006E28            .530:
24102                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24103 6E28           8B46         18            mov	ax,$18[bp]
24104 6E2B           88E0                       mov	al,ah
24105 6E2D           30E4                       xor	ah,ah
24106                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
24107 6E2F           3D                   0047  cmp	ax,*$47
24108 6E32           75           06            jne 	.52E
24109                       00006E34            .52F:
24110                                           ! 3719         goto int13_success;
24111 6E34           83C4                   0E  add	sp,#..FFEF-..FFF0
24112 6E37           E9         0892            br 	.FFEF
24113                                           !BCC_EOS
24114                                           ! 3720       if ( ( AX >> 8 ) == 0x42 )
24115                       00006E3A            .52E:
24116                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
24117 6E3A           8B46         18            mov	ax,$18[bp]
24118 6E3D           88E0                       mov	al,ah
24119 6E3F           30E4                       xor	ah,ah
24120                                           ! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
24121 6E41           3D                   0042  cmp	ax,*$42
24122 6E44           75           33            jne 	.531
24123                       00006E46            .532:
24124                                           ! 3721         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24125                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24126 6E46           FF76         EC            push	-$14[bp]
24127                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24128 6E49           FF76         EE            push	-$12[bp]
24129                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24130 6E4C           FF76         FA            push	-6[bp]
24131 6E4F           FF76         F8            push	-8[bp]
24132                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24133 6E52           FF76         FE            push	-2[bp]
24134 6E55           FF76         FC            push	-4[bp]
24135                                           ! Debug: list int = const 0 (used reg = )
24136 6E58           31C0                       xor	ax,ax
24137 6E5A           50                         push	ax
24138                                           ! Debug: list int = const 0 (used reg = )
24139 6E5B           31C0                       xor	ax,ax
24140 6E5D           50                         push	ax
24141                                           ! Debug: list int = const 0 (used reg = )
24142 6E5E           31C0                       xor	ax,ax
24143 6E60           50                         push	ax
24144                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24145 6E61           FF76         DC            push	-$24[bp]
24146                                           ! Debug: list int = const $20 (used reg = )
24147 6E64           B8                   0020  mov	ax,*$20
24148 6E67           50                         push	ax
24149                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24150 6E68           8A46         DB            mov	al,-$25[bp]
24151 6E6B           30E4                       xor	ah,ah
24152 6E6D           50                         push	ax
24153                                           ! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
24154 6E6E           E8         BFB6            call	_ata_cmd_data_in
24155 6E71           83C4                   18  add	sp,*$18
24156                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24157 6E74           8846         DA            mov	-$26[bp],al
24158                                           !BCC_EOS
24159                                           ! 3722       else
24160                                           ! 3723         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
24161 6E77           EB           31            jmp .533
24162                       00006E79            .531:
24163                                           ! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
24164 6E79           FF76         EC            push	-$14[bp]
24165                                           ! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
24166 6E7C           FF76         EE            push	-$12[bp]
24167                                           ! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
24168 6E7F           FF76         FA            push	-6[bp]
24169 6E82           FF76         F8            push	-8[bp]
24170                                           ! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
24171 6E85           FF76         FE            push	-2[bp]
24172 6E88           FF76         FC            push	-4[bp]
24173                                           ! Debug: list int = const 0 (used reg = )
24174 6E8B           31C0                       xor	ax,ax
24175 6E8D           50                         push	ax
24176                                           ! Debug: list int = const 0 (used reg = )
24177 6E8E           31C0                       xor	ax,ax
24178 6E90           50                         push	ax
24179                                           ! Debug: list int = const 0 (used reg = )
24180 6E91           31C0                       xor	ax,ax
24181 6E93           50                         push	ax
24182                                           ! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
24183 6E94           FF76         DC            push	-$24[bp]
24184                                           ! Debug: list int = const $30 (used reg = )
24185 6E97           B8                   0030  mov	ax,*$30
24186 6E9A           50                         push	ax
24187                                           ! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
24188 6E9B           8A46         DB            mov	al,-$25[bp]
24189 6E9E           30E4                       xor	ah,ah
24190 6EA0           50                         push	ax
24191                                           ! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
24192 6EA1           E8         C354            call	_ata_cmd_data_out
24193 6EA4           83C4                   18  add	sp,*$18
24194                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
24195 6EA7           8846         DA            mov	-$26[bp],al
24196                                           !BCC_EOS
24197                                           ! 3724       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
24198                       00006EAA            .533:
24199                                           ! Debug: list * unsigned short = const $254 (used reg = )
24200 6EAA           B8                   0254  mov	ax,#$254
24201 6EAD           50                         push	ax
24202                                           ! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
24203 6EAE           FF76         F6            push	-$A[bp]
24204                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24205 6EB1           E8         9753            call	_read_word
24206 6EB4           83C4                   04  add	sp,*4
24207                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
24208 6EB7           8946         DC            mov	-$24[bp],ax
24209                                           !BCC_EOS
24210                                           ! 3725       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
24211                                           ! Debug: list unsigned short count = [S+$28-$26] (used reg = )
24212 6EBA           FF76         DC            push	-$24[bp]
24213                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
24214 6EBD           8B46         0C            mov	ax,$C[bp]
24215                                           ! Debug: list unsigned int = ax+2 (used reg = )
24216 6EC0           40                         inc	ax
24217 6EC1           40                         inc	ax
24218 6EC2           50                         push	ax
24219                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
24220 6EC3           FF76         06            push	6[bp]
24221                                           ! Debug: func () void = write_word+0 (used reg = )
24222 6EC6           E8         9769            call	_write_word
24223 6EC9           83C4                   06  add	sp,*6
24224                                           !BCC_EOS
24225                                           ! 3726       if (status != 0) {
24226                                           ! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
24227 6ECC           8A46         DA            mov	al,-$26[bp]
24228 6ECF           84C0                       test	al,al
24229 6ED1           74           11            je  	.534
24230                       00006ED3            .535:
24231                                           ! 3727         ;
24232                                           !BCC_EOS
24233                                           ! 3728         AX = ((AX & 0x00ff) | ((0x0c) << 8));
24234                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24235 6ED3           8A46         18            mov	al,$18[bp]
24236                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
24237 6ED6           30E4                       xor	ah,ah
24238 6ED8           0D                   0C00  or	ax,#$C00
24239                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24240 6EDB           8946         18            mov	$18[bp],ax
24241                                           !BCC_EOS
24242                                           ! 3729         goto int13_fail_noah;
24243 6EDE           83C4                   0E  add	sp,#..FFEC-..FFF0
24244 6EE1           E9         07C6            br 	.FFEC
24245                                           !BCC_EOS
24246                                           ! 3730         }
24247                                           ! 3731       goto int13_success;
24248                       00006EE4            .534:
24249 6EE4           83C4                   0E  add	sp,#..FFEF-..FFF0
24250 6EE7           E9         07E2            br 	.FFEF
24251                                           !BCC_EOS
24252                                           ! 3732       break;
24253 6EEA           E9         07AF            br 	.500
24254                                           !BCC_EOS
24255                                           ! 3733     case 0x45:
24256                                           ! 3734     case 0x49:
24257                       00006EED            .536:
24258                                           ! 3735       goto int13_success;
24259                       00006EED            .537:
24260 6EED           83C4                   0E  add	sp,#..FFEF-..FFF0
24261 6EF0           E9         07D9            br 	.FFEF
24262                                           !BCC_EOS
24263                                           ! 3736       break;
24264 6EF3           E9         07A6            br 	.500
24265                                           !BCC_EOS
24266                                           ! 3737     case 0x46:
24267                                           ! 3738       AX = ((AX & 0x00ff) | ((0xb2) << 8));
24268                       00006EF6            .538:
24269                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
24270 6EF6           8A46         18            mov	al,$18[bp]
24271                                           ! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
24272 6EF9           30E4                       xor	ah,ah
24273 6EFB           0D                   B200  or	ax,#-$4E00
24274                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
24275 6EFE           8946         18            mov	$18[bp],ax
24276                                           !BCC_EOS
24277                                           ! 3739       goto int13_fail_noah;
24278 6F01           83C4                   0E  add	sp,#..FFEC-..FFF0
24279 6F04           E9         07A3            br 	.FFEC
24280                                           !BCC_EOS
24281                                           ! 3740       break;
24282 6F07           E9         0792            br 	.500
24283                                           !BCC_EOS
24284                                           ! 3741     case 0x48:
24285                                           ! 3742       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
24286                       00006F0A            .539:
24287                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
24288 6F0A           8B46         0C            mov	ax,$C[bp]
24289                                           ! Debug: list unsigned int = ax+0 (used reg = )
24290 6F0D           50                         push	ax
24291                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
24292 6F0E           FF76         06            push	6[bp]
24293                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24294 6F11           E8         96F3            call	_read_word
24295 6F14           83C4                   04  add	sp,*4
24296                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
24297 6F17           8946         DE            mov	-$22[bp],ax
24298                                           !BCC_EOS
24299                                           ! 3743       if(size < 0x1a)
24300                                           ! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24301 6F1A           8B46         DE            mov	ax,-$22[bp]
24302 6F1D           3D                   001A  cmp	ax,*$1A
24303 6F20           73           06            jae 	.53A
24304                       00006F22            .53B:
24305                                           ! 3744         goto int13_fail;
24306 6F22           83C4                   0E  add	sp,#..FFF1-..FFF0
24307 6F25           E9         0777            br 	.FFF1
24308                                           !BCC_EOS
24309                                           ! 3745       if(size >= 0x1a) {
24310                       00006F28            .53A:
24311                                           ! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
24312 6F28           8B46         DE            mov	ax,-$22[bp]
24313 6F2B           3D                   001A  cmp	ax,*$1A
24314 6F2E         0F82         01E3            blo 	.53C
24315                       00006F32            .53D:
24316                                           ! 3746         Bit16u blksize;
24317                                           !BCC_EOS
24318                                           ! 3747         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
24319                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24320 6F32           8A46         DB            mov	al,-$25[bp]
24321 6F35           30E4                       xor	ah,ah
24322 6F37           B9                   001E  mov	cx,*$1E
24323 6F3A           F7E9                       imul	cx
24324 6F3C           89C3                       mov	bx,ax
24325                                           ! Debug: address unsigned short = [bx+$154] (used reg = )
24326                                           ! Debug: list * unsigned short = bx+$154 (used reg = )
24327 6F3E           81C3                 0154  add	bx,#$154
24328 6F42           53                         push	bx
24329                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24330 6F43           FF76         F6            push	-$A[bp]
24331                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24332 6F46           E8         96BE            call	_read_word
24333 6F49           83C4                   04  add	sp,*4
24334                                           ! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
24335 6F4C           8946         EA            mov	-$16[bp],ax
24336                                           !BCC_EOS
24337                                           ! 3748         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
24338                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24339 6F4F           8A46         DB            mov	al,-$25[bp]
24340 6F52           30E4                       xor	ah,ah
24341 6F54           B9                   001E  mov	cx,*$1E
24342 6F57           F7E9                       imul	cx
24343 6F59           89C3                       mov	bx,ax
24344                                           ! Debug: address unsigned short = [bx+$152] (used reg = )
24345                                           ! Debug: list * unsigned short = bx+$152 (used reg = )
24346 6F5B           81C3                 0152  add	bx,#$152
24347 6F5F           53                         push	bx
24348                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24349 6F60           FF76         F6            push	-$A[bp]
24350                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24351 6F63           E8         96A1            call	_read_word
24352 6F66           83C4                   04  add	sp,*4
24353                                           ! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24354 6F69           8946         E8            mov	-$18[bp],ax
24355                                           !BCC_EOS
24356                                           ! 3749         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
24357                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24358 6F6C           8A46         DB            mov	al,-$25[bp]
24359 6F6F           30E4                       xor	ah,ah
24360 6F71           B9                   001E  mov	cx,*$1E
24361 6F74           F7E9                       imul	cx
24362 6F76           89C3                       mov	bx,ax
24363                                           ! Debug: address unsigned short = [bx+$156] (used reg = )
24364                                           ! Debug: list * unsigned short = bx+$156 (used reg = )
24365 6F78           81C3                 0156  add	bx,#$156
24366 6F7C           53                         push	bx
24367                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24368 6F7D           FF76         F6            push	-$A[bp]
24369                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24370 6F80           E8         9684            call	_read_word
24371 6F83           83C4                   04  add	sp,*4
24372                                           ! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
24373 6F86           8946         E6            mov	-$1A[bp],ax
24374                                           !BCC_EOS
24375                                           ! 3750         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
24376                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24377 6F89           8A46         DB            mov	al,-$25[bp]
24378 6F8C           30E4                       xor	ah,ah
24379 6F8E           B9                   001E  mov	cx,*$1E
24380 6F91           F7E9                       imul	cx
24381 6F93           89C3                       mov	bx,ax
24382                                           ! Debug: address unsigned long = [bx+$158] (used reg = )
24383                                           ! Debug: list * unsigned long = bx+$158 (used reg = )
24384 6F95           81C3                 0158  add	bx,#$158
24385 6F99           53                         push	bx
24386                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24387 6F9A           FF76         F6            push	-$A[bp]
24388                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24389 6F9D           E8         90E3            call	_read_dword
24390 6FA0           89D3                       mov	bx,dx
24391 6FA2           83C4                   04  add	sp,*4
24392                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
24393 6FA5           8946         FC            mov	-4[bp],ax
24394 6FA8           895E         FE            mov	-2[bp],bx
24395                                           !BCC_EOS
24396                                           ! 3751         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
24397                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24398 6FAB           8A46         DB            mov	al,-$25[bp]
24399 6FAE           30E4                       xor	ah,ah
24400 6FB0           B9                   001E  mov	cx,*$1E
24401 6FB3           F7E9                       imul	cx
24402 6FB5           89C3                       mov	bx,ax
24403                                           ! Debug: address unsigned long = [bx+$15C] (used reg = )
24404                                           ! Debug: list * unsigned long = bx+$15C (used reg = )
24405 6FB7           81C3                 015C  add	bx,#$15C
24406 6FBB           53                         push	bx
24407                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24408 6FBC           FF76         F6            push	-$A[bp]
24409                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
24410 6FBF           E8         90C1            call	_read_dword
24411 6FC2           89D3                       mov	bx,dx
24412 6FC4           83C4                   04  add	sp,*4
24413                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
24414 6FC7           8946         F8            mov	-8[bp],ax
24415 6FCA           895E         FA            mov	-6[bp],bx
24416                                           !BCC_EOS
24417                                           ! 3752      
24418                                           ! 3752    blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
24419                                           ! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
24420 6FCD           8A46         DB            mov	al,-$25[bp]
24421 6FD0           30E4                       xor	ah,ah
24422 6FD2           B9                   001E  mov	cx,*$1E
24423 6FD5           F7E9                       imul	cx
24424 6FD7           89C3                       mov	bx,ax
24425                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
24426                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
24427 6FD9           81C3                 0148  add	bx,#$148
24428 6FDD           53                         push	bx
24429                                           ! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
24430 6FDE           FF76         F6            push	-$A[bp]
24431                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24432 6FE1           E8         9623            call	_read_word
24433 6FE4           83C4                   04  add	sp,*4
24434                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
24435 6FE7           8946         D8            mov	-$28[bp],ax
24436                                           !BCC_EOS
24437                                           ! 3753         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
24438                                           ! Debug: list int = const $1A (used reg = )
24439 6FEA           B8                   001A  mov	ax,*$1A
24440 6FED           50                         push	ax
24441                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
24442 6FEE           8B46         0C            mov	ax,$C[bp]
24443                                           ! Debug: list unsigned int = ax+0 (used reg = )
24444 6FF1           50                         push	ax
24445                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24446 6FF2           FF76         06            push	6[bp]
24447                                           ! Debug: func () void = write_word+0 (used reg = )
24448 6FF5           E8         963A            call	_write_word
24449 6FF8           83C4                   06  add	sp,*6
24450                                           !BCC_EOS
24451                                           ! 3754         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
24452 6FFB           8B46         F8            mov	ax,-8[bp]
24453 6FFE           8B5E         FA            mov	bx,-6[bp]
24454 7001           E8         9110            call	ltstl
24455 7004           75           50            jne 	.53F
24456                       00007006            .540:
24457                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24458 7006           8B46         E8            mov	ax,-$18[bp]
24459 7009           31DB                       xor	bx,bx
24460 700B           53                         push	bx
24461 700C           50                         push	ax
24462                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
24463 700D           8B46         E6            mov	ax,-$1A[bp]
24464 7010           31DB                       xor	bx,bx
24465                                           ! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
24466 7012           53                         push	bx
24467 7013           50                         push	ax
24468 7014           8B46         FC            mov	ax,-4[bp]
24469 7017           8B5E         FE            mov	bx,-2[bp]
24470 701A           8D7E         C4            lea	di,-6+..FFF0[bp]
24471 701D           E8         914E            call	ldivul
24472 7020           83C4                   04  add	sp,*4
24473                                           ! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
24474 7023           8D7E         C8            lea	di,-2+..FFF0[bp]
24475 7026           E8         9145            call	ldivul
24476 7029           83C4                   04  add	sp,*4
24477                                           ! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
24478 702C           53                         push	bx
24479 702D           50                         push	ax
24480 702E           B8                   3FFF  mov	ax,#$3FFF
24481 7031           31DB                       xor	bx,bx
24482 7033           53                         push	bx
24483 7034           50                         push	ax
24484 7035           8B46         C8            mov	ax,-2+..FFF0[bp]
24485 7038           8B5E         CA            mov	bx,0+..FFF0[bp]
24486 703B           8D7E         C4            lea	di,-6+..FFF0[bp]
24487 703E           E8         908A            call	lcmpul
24488 7041           76           04            jbe	.541
24489 7043           B0                     01  mov	al,*1
24490 7045           EB           02            jmp	.542
24491                       00007047            .541:
24492 7047           30C0                       xor	al,al
24493                       00007049            .542:
24494 7049           83C4                   08  add	sp,*8
24495                                           ! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
24496 704C           30E4                       xor	ah,ah
24497 704E           99                         cwd
24498 704F           89D3                       mov	bx,dx
24499 7051           E8         90C0            call	ltstl
24500 7054           74           28            je  	.53E
24501                       00007056            .53F:
24502                                           ! 3755         {
24503                                           ! 3756           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
24504                                           ! Debug: list int = const 0 (used reg = )
24505 7056           31C0                       xor	ax,ax
24506 7058           50                         push	ax
24507                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
24508 7059           8B46         0C            mov	ax,$C[bp]
24509                                           ! Debug: list unsigned int = ax+2 (used reg = )
24510 705C           40                         inc	ax
24511 705D           40                         inc	ax
24512 705E           50                         push	ax
24513                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24514 705F           FF76         06            push	6[bp]
24515                                           ! Debug: func () void = write_word+0 (used reg = )
24516 7062           E8         95CD            call	_write_word
24517 7065           83C4                   06  add	sp,*6
24518                                           !BCC_EOS
24519                                           ! 3757           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
24520                                           ! Debug: list int = const $3FFF (used reg = )
24521 7068           B8                   3FFF  mov	ax,#$3FFF
24522 706B           50                         push	ax
24523                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
24524 706C           8B46         0C            mov	ax,$C[bp]
24525                                           ! Debug: list unsigned int = ax+4 (used reg = )
24526 706F           05                   0004  add	ax,*4
24527 7072           50                         push	ax
24528                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24529 7073           FF76         06            push	6[bp]
24530                                           ! Debug: func () void = write_dword+0 (used reg = )
24531 7076           E8         9022            call	_write_dword
24532 7079           83C4                   06  add	sp,*6
24533                                           !BCC_EOS
24534                                           ! 3758         }
24535                                           ! 3759         else
24536                                           ! 3760         {
24537 707C           EB           2A            jmp .544
24538                       0000707E            .53E:
24539                                           ! 3761           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
24540                                           ! Debug: list int = const 2 (used reg = )
24541 707E           B8                   0002  mov	ax,*2
24542 7081           50                         push	ax
24543                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
24544 7082           8B46         0C            mov	ax,$C[bp]
24545                                           ! Debug: list unsigned int = ax+2 (used reg = )
24546 7085           40                         inc	ax
24547 7086           40                         inc	ax
24548 7087           50                         push	ax
24549                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24550 7088           FF76         06            push	6[bp]
24551                                           ! Debug: func () void = write_word+0 (used reg = )
24552 708B           E8         95A4            call	_write_word
24553 708E           83C4                   06  add	sp,*6
24554                                           !BCC_EOS
24555                                           ! 3762           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
24556                                           ! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
24557 7091           8B46         EA            mov	ax,-$16[bp]
24558 7094           31DB                       xor	bx,bx
24559                                           ! Debug: list unsigned long = bx+0 (used reg = )
24560 7096           53                         push	bx
24561 7097           50                         push	ax
24562                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
24563 7098           8B46         0C            mov	ax,$C[bp]
24564                                           ! Debug: list unsigned int = ax+4 (used reg = )
24565 709B           05                   0004  add	ax,*4
24566 709E           50                         push	ax
24567                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24568 709F           FF76         06            push	6[bp]
24569                                           ! Debug: func () void = write_dword+0 (used reg = )
24570 70A2           E8         8FF6            call	_write_dword
24571 70A5           83C4                   08  add	sp,*8
24572                                           !BCC_EOS
24573                                           ! 3763         }
24574                                           ! 3764         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
24575                       000070A8            .544:
24576                                           ! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
24577 70A8           8B46         E8            mov	ax,-$18[bp]
24578 70AB           31DB                       xor	bx,bx
24579                                           ! Debug: list unsigned long = bx+0 (used reg = )
24580 70AD           53                         push	bx
24581 70AE           50                         push	ax
24582                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
24583 70AF           8B46         0C            mov	ax,$C[bp]
24584                                           ! Debug: list unsigned int = ax+8 (used reg = )
24585 70B2           05                   0008  add	ax,*8
24586 70B5           50                         push	ax
24587                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24588 70B6           FF76         06            push	6[bp]
24589                                           ! Debug: func () void = write_dword+0 (used reg = )
24590 70B9           E8         8FDF            call	_write_dword
24591 70BC           83C4                   08  add	sp,*8
24592                                           !BCC_EOS
24593                                           ! 3765         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
24594                                           ! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
24595 70BF           8B46         E6            mov	ax,-$1A[bp]
24596 70C2           31DB                       xor	bx,bx
24597                                           ! Debug: list unsigned long = bx+0 (used reg = )
24598 70C4           53                         push	bx
24599 70C5           50                         push	ax
24600                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
24601 70C6           8B46         0C            mov	ax,$C[bp]
24602                                           ! Debug: list unsigned int = ax+$C (used reg = )
24603 70C9           05                   000C  add	ax,*$C
24604 70CC           50                         push	ax
24605                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24606 70CD           FF76         06            push	6[bp]
24607                                           ! Debug: func () void = write_dword+0 (used reg = )
24608 70D0           E8         8FC8            call	_write_dword
24609 70D3           83C4                   08  add	sp,*8
24610                                           !BCC_EOS
24611                                           ! 3766         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
24612                                           ! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
24613 70D6           FF76         FE            push	-2[bp]
24614 70D9           FF76         FC            push	-4[bp]
24615                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
24616 70DC           8B46         0C            mov	ax,$C[bp]
24617                                           ! Debug: list unsigned int = ax+$10 (used reg = )
24618 70DF           05                   0010  add	ax,*$10
24619 70E2           50                         push	ax
24620                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24621 70E3           FF76         06            push	6[bp]
24622                                           ! Debug: func () void = write_dword+0 (used reg = )
24623 70E6           E8         8FB2            call	_write_dword
24624 70E9           83C4                   08  add	sp,*8
24625                                           !BCC_EOS
24626                                           ! 3767         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
24627                                           ! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
24628 70EC           FF76         FA            push	-6[bp]
24629 70EF           FF76         F8            push	-8[bp]
24630                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
24631 70F2           8B46         0C            mov	ax,$C[bp]
24632                                           ! Debug: list unsigned int = ax+$14 (used reg = )
24633 70F5           05                   0014  add	ax,*$14
24634 70F8           50                         push	ax
24635                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
24636 70F9           FF76         06            push	6[bp]
24637                                           ! Debug: func () void = write_dword+0 (used reg = )
24638 70FC           E8         8F9C            call	_write_dword
24639 70FF           83C4                   08  add	sp,*8
24640                                           !BCC_EOS
24641                                           ! 3768         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
24642                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
24643 7102           FF76         D8            push	-$28[bp]
24644                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
24645 7105           8B46         0C            mov	ax,$C[bp]
24646                                           ! Debug: list unsigned int = ax+$18 (used reg = )
24647 7108           05                   0018  add	ax,*$18
24648 710B           50                         push	ax
24649                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
24650 710C           FF76         06            push	6[bp]
24651                                           ! Debug: func () void = write_word+0 (used reg = )
24652 710F           E8         9520            call	_write_word
24653 7112           83C4                   06  add	sp,*6
24654                                           !BCC_EOS
24655                                           ! 3769         }
24656                                           ! 3770       if(size >= 0x1e) {
24657                       00007115            .53C:
24658                                           ! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
24659 7115           8B46         DE            mov	ax,-$22[bp]
24660 7118           3D                   001E  cmp	ax,*$1E
24661 711B         0F82         0273            blo 	.545
24662                       0000711F            .546:
24663                                           ! 3771         Bit8u channel, dev, irq, mode, checksum, i, translation;
24664                                           !BCC_EOS
24665                                           ! 3772         Bit16u iobase1, iobase2, options;
24666                                           !BCC_EOS
24667                                           ! 3773         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
24668                                           ! Debug: list int = const $1E (used reg = )
24669 711F           B8                   001E  mov	ax,*$1E
24670 7122           50                         push	ax
24671                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
24672 7123           8B46         0C            mov	ax,$C[bp]
24673                                           ! Debug: list unsigned int = ax+0 (used reg = )
24674 7126           50                         push	ax
24675                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24676 7127           FF76         06            push	6[bp]
24677                                           ! Debug: func () void = write_word+0 (used reg = )
24678 712A           E8         9505            call	_write_word
24679 712D           83C4                   06  add	sp,*6
24680                                           !BCC_EOS
24681                                           ! 3774         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
24682                                           ! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
24683 7130           FF76         F6            push	-$A[bp]
24684                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
24685 7133           8B46         0C            mov	ax,$C[bp]
24686                                           ! Debug: list unsigned int = ax+$1C (used reg = )
24687 7136           05                   001C  add	ax,*$1C
24688 7139           50                         push	ax
24689                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24690 713A           FF76         06            push	6[bp]
24691                                           ! Debug: func () void = write_word+0 (used reg = )
24692 713D           E8         94F2            call	_write_word
24693 7140           83C4                   06  add	sp,*6
24694                                           !BCC_EOS
24695                                           ! 3775         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
24696                                           ! Debug: list * struct  = const $244 (used reg = )
24697 7143           B8                   0244  mov	ax,#$244
24698 7146           50                         push	ax
24699                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
24700 7147           8B46         0C            mov	ax,$C[bp]
24701                                           ! Debug: list unsigned int = ax+$1A (used reg = )
24702 714A           05                   001A  add	ax,*$1A
24703 714D           50                         push	ax
24704                                           ! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
24705 714E           FF76         06            push	6[bp]
24706                                           ! Debug: func () void = write_word+0 (used reg = )
24707 7151           E8         94DE            call	_write_word
24708 7154           83C4                   06  add	sp,*6
24709                                           !BCC_EOS
24710                                           ! 3776         channel = device / 2;
24711                                           ! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
24712 7157           8A46         DB            mov	al,-$25[bp]
24713 715A           30E4                       xor	ah,ah
24714 715C           D1E8                       shr	ax,*1
24715                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
24716 715E           8846         D9            mov	-$27[bp],al
24717                                           !BCC_EOS
24718                                           ! 3777         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
24719                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24720 7161           8A46         D9            mov	al,-$27[bp]
24721 7164           30E4                       xor	ah,ah
24722 7166           B1                     03  mov	cl,*3
24723 7168           D3E0                       shl	ax,cl
24724 716A           89C3                       mov	bx,ax
24725                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
24726                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
24727 716C           81C3                 0124  add	bx,#$124
24728 7170           53                         push	bx
24729                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24730 7171           FF76         F6            push	-$A[bp]
24731                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24732 7174           E8         9490            call	_read_word
24733 7177           83C4                   04  add	sp,*4
24734                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
24735 717A           8946         D0            mov	-$30[bp],ax
24736                                           !BCC_EOS
24737                                           ! 3778         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
24738                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24739 717D           8A46         D9            mov	al,-$27[bp]
24740 7180           30E4                       xor	ah,ah
24741 7182           B1                     03  mov	cl,*3
24742 7184           D3E0                       shl	ax,cl
24743 7186           89C3                       mov	bx,ax
24744                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
24745                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
24746 7188           81C3                 0126  add	bx,#$126
24747 718C           53                         push	bx
24748                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24749 718D           FF76         F6            push	-$A[bp]
24750                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
24751 7190           E8         9474            call	_read_word
24752 7193           83C4                   04  add	sp,*4
24753                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
24754 7196           8946         CE            mov	-$32[bp],ax
24755                                           !BCC_EOS
24756                                           ! 3779         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
24757                                           ! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
24758 7199           8A46         D9            mov	al,-$27[bp]
24759 719C           30E4                       xor	ah,ah
24760 719E           B1                     03  mov	cl,*3
24761 71A0           D3E0                       shl	ax,cl
24762 71A2           89C3                       mov	bx,ax
24763                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
24764                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
24765 71A4           81C3                 0128  add	bx,#$128
24766 71A8           53                         push	bx
24767                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24768 71A9           FF76         F6            push	-$A[bp]
24769                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24770 71AC           E8         9445            call	_read_byte
24771 71AF           83C4                   04  add	sp,*4
24772                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
24773 71B2           8846         D7            mov	-$29[bp],al
24774                                           !BCC_EOS
24775                                           ! 3780         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
24776                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
24777 71B5           8A46         DB            mov	al,-$25[bp]
24778 71B8           30E4                       xor	ah,ah
24779 71BA           B9                   001E  mov	cx,*$1E
24780 71BD           F7E9                       imul	cx
24781 71BF           89C3                       mov	bx,ax
24782                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
24783                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
24784 71C1           81C3                 0146  add	bx,#$146
24785 71C5           53                         push	bx
24786                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24787 71C6           FF76         F6            push	-$A[bp]
24788                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24789 71C9           E8         9428            call	_read_byte
24790 71CC           83C4                   04  add	sp,*4
24791                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
24792 71CF           8846         D6            mov	-$2A[bp],al
24793                                           !BCC_EOS
24794                                           ! 3781         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
24795                                           ! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
24796 71D2           8A46         DB            mov	al,-$25[bp]
24797 71D5           30E4                       xor	ah,ah
24798 71D7           B9                   001E  mov	cx,*$1E
24799 71DA           F7E9                       imul	cx
24800 71DC           89C3                       mov	bx,ax
24801                                           ! Debug: address unsigned char = [bx+$14A] (used reg = )
24802                                           ! Debug: list * unsigned char = bx+$14A (used reg = )
24803 71DE           81C3                 014A  add	bx,#$14A
24804 71E2           53                         push	bx
24805                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
24806 71E3           FF76         F6            push	-$A[bp]
24807                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
24808 71E6           E8         940B            call	_read_byte
24809 71E9           83C4                   04  add	sp,*4
24810                                           ! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
24811 71EC           8846         D3            mov	-$2D[bp],al
24812                                           !BCC_EOS
24813                                           ! 3782         options = (translation==0?0:1)<<3;
24814                                           ! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
24815 71EF           8A46         D3            mov	al,-$2D[bp]
24816 71F2           84C0                       test	al,al
24817 71F4           75           04            jne 	.547
24818                       000071F6            .548:
24819 71F6           30C0                       xor	al,al
24820 71F8           EB           02            jmp .549
24821                       000071FA            .547:
24822 71FA           B0                     01  mov	al,*1
24823                       000071FC            .549:
24824                                           ! Debug: sl int = const 3 to char = al+0 (used reg = )
24825 71FC           30E4                       xor	ah,ah
24826 71FE           B1                     03  mov	cl,*3
24827 7200           D3E0                       shl	ax,cl
24828                                           ! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24829 7202           8946         CC            mov	-$34[bp],ax
24830                                           !BCC_EOS
24831                                           ! 3783         options |= (1<<4);
24832                                           ! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
24833 7205           8B46         CC            mov	ax,-$34[bp]
24834 7208           0C                     10  or	al,*$10
24835 720A           8946         CC            mov	-$34[bp],ax
24836                                           !BCC_EOS
24837                                           ! 3784         options |= (mode==0x01?1:0)<<7;
24838                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
24839 720D           8A46         D6            mov	al,-$2A[bp]
24840 7210           3C                     01  cmp	al,*1
24841 7212           75           04            jne 	.54A
24842                       00007214            .54B:
24843 7214           B0                     01  mov	al,*1
24844 7216           EB           02            jmp .54C
24845                       00007218            .54A:
24846 7218           30C0                       xor	al,al
24847                       0000721A            .54C:
24848                                           ! Debug: sl int = const 7 to char = al+0 (used reg = )
24849 721A           30E4                       xor	ah,ah
24850 721C           B1                     07  mov	cl,*7
24851 721E           D3E0                       shl	ax,cl
24852                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24853 7220           0B46         CC            or	ax,-$34[bp]
24854 7223           8946         CC            mov	-$34[bp],ax
24855                                           !BCC_EOS
24856                                           ! 3785         options |= (translation==1?1:0)<<9;
24857                                           ! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
24858 7226           8A46         D3            mov	al,-$2D[bp]
24859 7229           3C                     01  cmp	al,*1
24860 722B           75           04            jne 	.54D
24861                       0000722D            .54E:
24862 722D           B0                     01  mov	al,*1
24863 722F           EB           02            jmp .54F
24864                       00007231            .54D:
24865 7231           30C0                       xor	al,al
24866                       00007233            .54F:
24867                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
24868 7233           30E4                       xor	ah,ah
24869 7235           88C4                       mov	ah,al
24870 7237           30C0                       xor	al,al
24871 7239           D1E0                       shl	ax,*1
24872                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24873 723B           0B46         CC            or	ax,-$34[bp]
24874 723E           8946         CC            mov	-$34[bp],ax
24875                                           !BCC_EOS
24876                                           ! 3786         options |= (translation==3?3:0)<<9;
24877                                           ! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
24878 7241           8A46         D3            mov	al,-$2D[bp]
24879 7244           3C                     03  cmp	al,*3
24880 7246           75           04            jne 	.550
24881                       00007248            .551:
24882 7248           B0                     03  mov	al,*3
24883 724A           EB           02            jmp .552
24884                       0000724C            .550:
24885 724C           30C0                       xor	al,al
24886                       0000724E            .552:
24887                                           ! Debug: sl int = const 9 to char = al+0 (used reg = )
24888 724E           30E4                       xor	ah,ah
24889 7250           88C4                       mov	ah,al
24890 7252           30C0                       xor	al,al
24891 7254           D1E0                       shl	ax,*1
24892                                           ! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
24893 7256           0B46         CC            or	ax,-$34[bp]
24894 7259           8946         CC            mov	-$34[bp],ax
24895                                           !BCC_EOS
24896                                           ! 3787         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
24897                                           ! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
24898 725C           FF76         D0            push	-$30[bp]
24899                                           ! Debug: list * unsigned short = const $244 (used reg = )
24900 725F           B8                   0244  mov	ax,#$244
24901 7262           50                         push	ax
24902                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24903 7263           FF76         F6            push	-$A[bp]
24904                                           ! Debug: func () void = write_word+0 (used reg = )
24905 7266           E8         93C9            call	_write_word
24906 7269           83C4                   06  add	sp,*6
24907                                           !BCC_EOS
24908                                           ! 3788         wri
24909                                           ! 3788 te_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
24910                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
24911 726C           8B46         CE            mov	ax,-$32[bp]
24912                                           ! Debug: list unsigned int = ax+6 (used reg = )
24913 726F           05                   0006  add	ax,*6
24914 7272           50                         push	ax
24915                                           ! Debug: list * unsigned short = const $246 (used reg = )
24916 7273           B8                   0246  mov	ax,#$246
24917 7276           50                         push	ax
24918                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24919 7277           FF76         F6            push	-$A[bp]
24920                                           ! Debug: func () void = write_word+0 (used reg = )
24921 727A           E8         93B5            call	_write_word
24922 727D           83C4                   06  add	sp,*6
24923                                           !BCC_EOS
24924                                           ! 3789         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
24925                                           ! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
24926 7280           8A46         DB            mov	al,-$25[bp]
24927 7283           30E4                       xor	ah,ah
24928 7285           24                     01  and	al,*1
24929                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
24930                                           ! Debug: expression subtree swapping
24931 7287           0C                     0E  or	al,*$E
24932                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
24933 7289           30E4                       xor	ah,ah
24934 728B           B1                     04  mov	cl,*4
24935 728D           D3E0                       shl	ax,cl
24936                                           ! Debug: list unsigned int = ax+0 (used reg = )
24937 728F           50                         push	ax
24938                                           ! Debug: list * unsigned char = const $248 (used reg = )
24939 7290           B8                   0248  mov	ax,#$248
24940 7293           50                         push	ax
24941                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24942 7294           FF76         F6            push	-$A[bp]
24943                                           ! Debug: func () void = write_byte+0 (used reg = )
24944 7297           E8         9380            call	_write_byte
24945 729A           83C4                   06  add	sp,*6
24946                                           !BCC_EOS
24947                                           ! 3790         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
24948                                           ! Debug: list int = const $CB (used reg = )
24949 729D           B8                   00CB  mov	ax,#$CB
24950 72A0           50                         push	ax
24951                                           ! Debug: list * unsigned char = const $249 (used reg = )
24952 72A1           B8                   0249  mov	ax,#$249
24953 72A4           50                         push	ax
24954                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24955 72A5           FF76         F6            push	-$A[bp]
24956                                           ! Debug: func () void = write_byte+0 (used reg = )
24957 72A8           E8         936F            call	_write_byte
24958 72AB           83C4                   06  add	sp,*6
24959                                           !BCC_EOS
24960                                           ! 3791         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
24961                                           ! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
24962 72AE           8A46         D7            mov	al,-$29[bp]
24963 72B1           30E4                       xor	ah,ah
24964 72B3           50                         push	ax
24965                                           ! Debug: list * unsigned char = const $24A (used reg = )
24966 72B4           B8                   024A  mov	ax,#$24A
24967 72B7           50                         push	ax
24968                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24969 72B8           FF76         F6            push	-$A[bp]
24970                                           ! Debug: func () void = write_byte+0 (used reg = )
24971 72BB           E8         935C            call	_write_byte
24972 72BE           83C4                   06  add	sp,*6
24973                                           !BCC_EOS
24974                                           ! 3792         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
24975                                           ! Debug: list int = const 1 (used reg = )
24976 72C1           B8                   0001  mov	ax,*1
24977 72C4           50                         push	ax
24978                                           ! Debug: list * unsigned char = const $24B (used reg = )
24979 72C5           B8                   024B  mov	ax,#$24B
24980 72C8           50                         push	ax
24981                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24982 72C9           FF76         F6            push	-$A[bp]
24983                                           ! Debug: func () void = write_byte+0 (used reg = )
24984 72CC           E8         934B            call	_write_byte
24985 72CF           83C4                   06  add	sp,*6
24986                                           !BCC_EOS
24987                                           ! 3793         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
24988                                           ! Debug: list int = const 0 (used reg = )
24989 72D2           31C0                       xor	ax,ax
24990 72D4           50                         push	ax
24991                                           ! Debug: list * unsigned char = const $24C (used reg = )
24992 72D5           B8                   024C  mov	ax,#$24C
24993 72D8           50                         push	ax
24994                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
24995 72D9           FF76         F6            push	-$A[bp]
24996                                           ! Debug: func () void = write_byte+0 (used reg = )
24997 72DC           E8         933B            call	_write_byte
24998 72DF           83C4                   06  add	sp,*6
24999                                           !BCC_EOS
25000                                           ! 3794         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
25001                                           ! Debug: list int = const 0 (used reg = )
25002 72E2           31C0                       xor	ax,ax
25003 72E4           50                         push	ax
25004                                           ! Debug: list * unsigned char = const $24D (used reg = )
25005 72E5           B8                   024D  mov	ax,#$24D
25006 72E8           50                         push	ax
25007                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25008 72E9           FF76         F6            push	-$A[bp]
25009                                           ! Debug: func () void = write_byte+0 (used reg = )
25010 72EC           E8         932B            call	_write_byte
25011 72EF           83C4                   06  add	sp,*6
25012                                           !BCC_EOS
25013                                           ! 3795         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
25014                                           ! Debug: list unsigned short options = [S+$36-$36] (used reg = )
25015 72F2           FF76         CC            push	-$34[bp]
25016                                           ! Debug: list * unsigned short = const $24E (used reg = )
25017 72F5           B8                   024E  mov	ax,#$24E
25018 72F8           50                         push	ax
25019                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25020 72F9           FF76         F6            push	-$A[bp]
25021                                           ! Debug: func () void = write_word+0 (used reg = )
25022 72FC           E8         9333            call	_write_word
25023 72FF           83C4                   06  add	sp,*6
25024                                           !BCC_EOS
25025                                           ! 3796         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
25026                                           ! Debug: list int = const 0 (used reg = )
25027 7302           31C0                       xor	ax,ax
25028 7304           50                         push	ax
25029                                           ! Debug: list * unsigned short = const $250 (used reg = )
25030 7305           B8                   0250  mov	ax,#$250
25031 7308           50                         push	ax
25032                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25033 7309           FF76         F6            push	-$A[bp]
25034                                           ! Debug: func () void = write_word+0 (used reg = )
25035 730C           E8         9323            call	_write_word
25036 730F           83C4                   06  add	sp,*6
25037                                           !BCC_EOS
25038                                           ! 3797         if (size >=0x42)
25039                                           ! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
25040 7312           8B46         DE            mov	ax,-$22[bp]
25041 7315           3D                   0042  cmp	ax,*$42
25042 7318           72           13            jb  	.553
25043                       0000731A            .554:
25044                                           ! 3798           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
25045                                           ! Debug: list int = const $11 (used reg = )
25046 731A           B8                   0011  mov	ax,*$11
25047 731D           50                         push	ax
25048                                           ! Debug: list * unsigned char = const $252 (used reg = )
25049 731E           B8                   0252  mov	ax,#$252
25050 7321           50                         push	ax
25051                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25052 7322           FF76         F6            push	-$A[bp]
25053                                           ! Debug: func () void = write_byte+0 (used reg = )
25054 7325           E8         92F2            call	_write_byte
25055 7328           83C4                   06  add	sp,*6
25056                                           !BCC_EOS
25057                                           ! 3799         else
25058                                           ! 3800           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
25059 732B           EB           11            jmp .555
25060                       0000732D            .553:
25061                                           ! Debug: list int = const $10 (used reg = )
25062 732D           B8                   0010  mov	ax,*$10
25063 7330           50                         push	ax
25064                                           ! Debug: list * unsigned char = const $252 (used reg = )
25065 7331           B8                   0252  mov	ax,#$252
25066 7334           50                         push	ax
25067                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25068 7335           FF76         F6            push	-$A[bp]
25069                                           ! Debug: func () void = write_byte+0 (used reg = )
25070 7338           E8         92DF            call	_write_byte
25071 733B           83C4                   06  add	sp,*6
25072                                           !BCC_EOS
25073                                           ! 3801         checksum=0;
25074                       0000733E            .555:
25075                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25076 733E           30C0                       xor	al,al
25077 7340           8846         D5            mov	-$2B[bp],al
25078                                           !BCC_EOS
25079                                           ! 3802         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
25080                                           ! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
25081 7343           30C0                       xor	al,al
25082 7345           8846         D4            mov	-$2C[bp],al
25083                                           !BCC_EOS
25084                                           !BCC_EOS
25085 7348           EB           24            jmp .558
25086                       0000734A            .559:
25087                                           ! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
25088 734A           8A46         D4            mov	al,-$2C[bp]
25089 734D           30E4                       xor	ah,ah
25090                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
25091 734F           05                   0244  add	ax,#$244
25092 7352           50                         push	ax
25093                                           ! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
25094 7353           FF76         F6            push	-$A[bp]
25095                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25096 7356           E8         929B            call	_read_byte
25097 7359           83C4                   04  add	sp,*4
25098                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25099 735C           30E4                       xor	ah,ah
25100 735E           0246         D5            add	al,-$2B[bp]
25101 7361           80D4                   00  adc	ah,*0
25102 7364           8846         D5            mov	-$2B[bp],al
25103                                           !BCC_EOS
25104                                           ! 3803         checksum = ~checksum;
25105                       00007367            .557:
25106                                           ! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
25107 7367           8A46         D4            mov	al,-$2C[bp]
25108 736A           40                         inc	ax
25109 736B           8846         D4            mov	-$2C[bp],al
25110                       0000736E            .558:
25111                                           ! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
25112 736E           8A46         D4            mov	al,-$2C[bp]
25113 7371           3C                     0F  cmp	al,*$F
25114 7373           72           D5            jb 	.559
25115                       00007375            .55A:
25116                       00007375            .556:
25117                                           ! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
25118 7375           8A46         D5            mov	al,-$2B[bp]
25119 7378           30E4                       xor	ah,ah
25120 737A           F7D0                       not	ax
25121                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
25122 737C           8846         D5            mov	-$2B[bp],al
25123                                           !BCC_EOS
25124                                           ! 3804         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
25125                                           ! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
25126 737F           8A46         D5            mov	al,-$2B[bp]
25127 7382           30E4                       xor	ah,ah
25128 7384           50                         push	ax
25129                                           ! Debug: list * unsigned char = const $253 (used reg = )
25130 7385           B8                   0253  mov	ax,#$253
25131 7388           50                         push	ax
25132                                           ! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
25133 7389           FF76         F6            push	-$A[bp]
25134                                           ! Debug: func () void = write_byte+0 (used reg = )
25135 738C           E8         928B            call	_write_byte
25136 738F           83C4                   06  add	sp,*6
25137                                           !BCC_EOS
25138                                           ! 3805         }
25139                                           ! 3806       if(size >= 0x42) {
25140                       00007392            .545:
25141                                           ! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
25142 7392           8B46         DE            mov	ax,-$22[bp]
25143 7395           3D                   0042  cmp	ax,*$42
25144 7398         0F82         023B            blo 	.55B
25145                       0000739C            .55C:
25146                                           ! 3807         Bit8u channel, iface, checksum, i;
25147                                           !BCC_EOS
25148                                           ! 3808         Bit16u iobase1;
25149                                           !BCC_EOS
25150                                           ! 3809         channel = device / 2;
25151                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25152 739C           8A46         DB            mov	al,-$25[bp]
25153 739F           30E4                       xor	ah,ah
25154 73A1           D1E8                       shr	ax,*1
25155                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
25156 73A3           8846         D9            mov	-$27[bp],al
25157                                           !BCC_EOS
25158                                           ! 3810         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
25159                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25160 73A6           8A46         D9            mov	al,-$27[bp]
25161 73A9           30E4                       xor	ah,ah
25162 73AB           B1                     03  mov	cl,*3
25163 73AD           D3E0                       shl	ax,cl
25164 73AF           89C3                       mov	bx,ax
25165                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
25166                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
25167 73B1           81C3                 0122  add	bx,#$122
25168 73B5           53                         push	bx
25169                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25170 73B6           FF76         F6            push	-$A[bp]
25171                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25172 73B9           E8         9238            call	_read_byte
25173 73BC           83C4                   04  add	sp,*4
25174                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25175 73BF           8846         D8            mov	-$28[bp],al
25176                                           !BCC_EOS
25177                                           ! 3811         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
25178                                           ! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
25179 73C2           8A46         D9            mov	al,-$27[bp]
25180 73C5           30E4                       xor	ah,ah
25181 73C7           B1                     03  mov	cl,*3
25182 73C9           D3E0                       shl	ax,cl
25183 73CB           89C3                       mov	bx,ax
25184                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
25185                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
25186 73CD           81C3                 0124  add	bx,#$124
25187 73D1           53                         push	bx
25188                                           ! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
25189 73D2           FF76         F6            push	-$A[bp]
25190                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25191 73D5           E8         922F            call	_read_word
25192 73D8           83C4                   04  add	sp,*4
25193                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25194 73DB           8946         D4            mov	-$2C[bp],ax
25195                                           !BCC_EOS
25196                                           ! 3812         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
25197                                           ! Debug: list int = const $42 (used reg = )
25198 73DE           B8                   0042  mov	ax,*$42
25199 73E1           50                         push	ax
25200                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
25201 73E2           8B46         0C            mov	ax,$C[bp]
25202                                           ! Debug: list unsigned int = ax+0 (used reg = )
25203 73E5           50                         push	ax
25204                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25205 73E6           FF76         06            push	6[bp]
25206                                           ! Debug: func () void = write_word+0 (used reg = )
25207 73E9           E8         9246            call	_write_word
25208 73EC           83C4                   06  add	sp,*6
25209                                           !BCC_EOS
25210                                           ! 3813         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
25211                                           ! Debug: list unsigned int = const $BEDD (used reg = )
25212 73EF           B8                   BEDD  mov	ax,#$BEDD
25213 73F2           50                         push	ax
25214                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
25215 73F3           8B46         0C            mov	ax,$C[bp]
25216                                           ! Debug: list unsigned int = ax+$1E (used reg = )
25217 73F6           05                   001E  add	ax,*$1E
25218 73F9           50                         push	ax
25219                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25220 73FA           FF76         06            push	6[bp]
25221                                           ! Debug: func () void = write_word+0 (used reg = )
25222 73FD           E8         9232            call	_write_word
25223 7400           83C4                   06  add	sp,*6
25224                                           !BCC_EOS
25225                                           ! 3814         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
25226                                           ! Debug: list int = const $24 (used reg = )
25227 7403           B8                   0024  mov	ax,*$24
25228 7406           50                         push	ax
25229                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
25230 7407           8B46         0C            mov	ax,$C[bp]
25231                                           ! Debug: list unsigned int = ax+$20 (used reg = )
25232 740A           05                   0020  add	ax,*$20
25233 740D           50                         push	ax
25234                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25235 740E           FF76         06            push	6[bp]
25236                                           ! Debug: func () void = write_byte+0 (used reg = )
25237 7411           E8         9206            call	_write_byte
25238 7414           83C4                   06  add	sp,*6
25239                                           !BCC_EOS
25240                                           ! 3815         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
25241                                           ! Debug: list int = const 0 (used reg = )
25242 7417           31C0                       xor	ax,ax
25243 7419           50                         push	ax
25244                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
25245 741A           8B46         0C            mov	ax,$C[bp]
25246                                           ! Debug: list unsigned int = ax+$21 (used reg = )
25247 741D           05                   0021  add	ax,*$21
25248 7420           50                         push	ax
25249                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25250 7421           FF76         06            push	6[bp]
25251                                           ! Debug: func () void = write_byte+0 (used reg = )
25252 7424           E8         91F3            call	_write_byte
25253 7427           83C4                   06  add	sp,*6
25254                                           !BCC_EOS
25255                                           ! 3816         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
25256                                           ! Debug: list int = const 0 (used reg = )
25257 742A           31C0                       xor	ax,ax
25258 742C           50                         push	ax
25259                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
25260 742D           8B46         0C            mov	ax,$C[bp]
25261                                           ! Debug: list unsigned int = ax+$22 (used reg = )
25262 7430           05                   0022  add	ax,*$22
25263 7433           50                         push	ax
25264                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25265 7434           FF76         06            push	6[bp]
25266                                           ! Debug: func () void = write_word+0 (used reg = )
25267 7437           E8         91F8            call	_write_word
25268 743A           83C4                   06  add	sp,*6
25269                                           !BCC_EOS
25270                                           ! 3817         if (iface==0x00) {
25271                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25272 743D           8A46         D8            mov	al,-$28[bp]
25273 7440           84C0                       test	al,al
25274 7442           75           51            jne 	.55D
25275                       00007444            .55E:
25276                                           ! 3818           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
25277                                           ! Debug: list int = const $49 (used reg = )
25278 7444           B8                   0049  mov	ax,*$49
25279 7447           50                         push	ax
25280                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
25281 7448           8B46         0C            mov	ax,$C[bp]
25282                                           ! Debug: list unsigned int = ax+$24 (used reg = )
25283 744B           05                   0024  add	ax,*$24
25284 744E           50                         push	ax
25285                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25286 744F           FF76         06            push	6[bp]
25287                                           ! Debug: func () void = write_byte+0 (used reg = )
25288 7452           E8         91C5            call	_write_byte
25289 7455           83C4                   06  add	sp,*6
25290                                           !BCC_EOS
25291                                           ! 3819           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
25292                                           ! Debug: list int = const $53 (used reg = )
25293 7458           B8                   0053  mov	ax,*$53
25294 745B           50                         push	ax
25295                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
25296 745C           8B46         0C            mov	ax,$C[bp]
25297                                           ! Debug: list unsigned int = ax+$25 (used reg = )
25298 745F           05                   0025  add	ax,*$25
25299 7462           50                         push	ax
25300                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25301 7463           FF76         06            push	6[bp]
25302                                           ! Debug: func () void = write_byte+0 (used reg = )
25303 7466           E8         91B1            call	_write_byte
25304 7469           83C4                   06  add	sp,*6
25305                                           !BCC_EOS
25306                                           ! 3820           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
25307                                           ! Debug: list int = const $41 (used reg = )
25308 746C           B8                   0041  mov	ax,*$41
25309 746F           50                         push	ax
25310                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
25311 7470           8B46         0C            mov	ax,$C[bp]
25312                                           ! Debug: list unsigned int = ax+$26 (used reg = )
25313 7473           05                   0026  add	ax,*$26
25314 7476           50                         push	ax
25315                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25316 7477           FF76         06            push	6[bp]
25317                                           ! Debug: func () void = write_byte+0 (used reg = )
25318 747A           E8         919D            call	_write_byte
25319 747D           83C4                   06  add	sp,*6
25320                                           !BCC_EOS
25321                                           ! 3821           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->
25322                                           ! 3821 host_bus[3], 0);
25323                                           ! Debug: list int = const 0 (used reg = )
25324 7480           31C0                       xor	ax,ax
25325 7482           50                         push	ax
25326                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
25327 7483           8B46         0C            mov	ax,$C[bp]
25328                                           ! Debug: list unsigned int = ax+$27 (used reg = )
25329 7486           05                   0027  add	ax,*$27
25330 7489           50                         push	ax
25331                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25332 748A           FF76         06            push	6[bp]
25333                                           ! Debug: func () void = write_byte+0 (used reg = )
25334 748D           E8         918A            call	_write_byte
25335 7490           83C4                   06  add	sp,*6
25336                                           !BCC_EOS
25337                                           ! 3822           }
25338                                           ! 3823         else {
25339 7493           EB           00            jmp .55F
25340                       00007495            .55D:
25341                                           ! 3824           }
25342                                           ! 3825         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
25343                       00007495            .55F:
25344                                           ! Debug: list int = const $41 (used reg = )
25345 7495           B8                   0041  mov	ax,*$41
25346 7498           50                         push	ax
25347                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
25348 7499           8B46         0C            mov	ax,$C[bp]
25349                                           ! Debug: list unsigned int = ax+$28 (used reg = )
25350 749C           05                   0028  add	ax,*$28
25351 749F           50                         push	ax
25352                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25353 74A0           FF76         06            push	6[bp]
25354                                           ! Debug: func () void = write_byte+0 (used reg = )
25355 74A3           E8         9174            call	_write_byte
25356 74A6           83C4                   06  add	sp,*6
25357                                           !BCC_EOS
25358                                           ! 3826         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
25359                                           ! Debug: list int = const $54 (used reg = )
25360 74A9           B8                   0054  mov	ax,*$54
25361 74AC           50                         push	ax
25362                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
25363 74AD           8B46         0C            mov	ax,$C[bp]
25364                                           ! Debug: list unsigned int = ax+$29 (used reg = )
25365 74B0           05                   0029  add	ax,*$29
25366 74B3           50                         push	ax
25367                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25368 74B4           FF76         06            push	6[bp]
25369                                           ! Debug: func () void = write_byte+0 (used reg = )
25370 74B7           E8         9160            call	_write_byte
25371 74BA           83C4                   06  add	sp,*6
25372                                           !BCC_EOS
25373                                           ! 3827         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
25374                                           ! Debug: list int = const $41 (used reg = )
25375 74BD           B8                   0041  mov	ax,*$41
25376 74C0           50                         push	ax
25377                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
25378 74C1           8B46         0C            mov	ax,$C[bp]
25379                                           ! Debug: list unsigned int = ax+$2A (used reg = )
25380 74C4           05                   002A  add	ax,*$2A
25381 74C7           50                         push	ax
25382                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25383 74C8           FF76         06            push	6[bp]
25384                                           ! Debug: func () void = write_byte+0 (used reg = )
25385 74CB           E8         914C            call	_write_byte
25386 74CE           83C4                   06  add	sp,*6
25387                                           !BCC_EOS
25388                                           ! 3828         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
25389                                           ! Debug: list int = const 0 (used reg = )
25390 74D1           31C0                       xor	ax,ax
25391 74D3           50                         push	ax
25392                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
25393 74D4           8B46         0C            mov	ax,$C[bp]
25394                                           ! Debug: list unsigned int = ax+$2B (used reg = )
25395 74D7           05                   002B  add	ax,*$2B
25396 74DA           50                         push	ax
25397                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25398 74DB           FF76         06            push	6[bp]
25399                                           ! Debug: func () void = write_byte+0 (used reg = )
25400 74DE           E8         9139            call	_write_byte
25401 74E1           83C4                   06  add	sp,*6
25402                                           !BCC_EOS
25403                                           ! 3829         if (iface==0x00) {
25404                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
25405 74E4           8A46         D8            mov	al,-$28[bp]
25406 74E7           84C0                       test	al,al
25407 74E9           75           3E            jne 	.560
25408                       000074EB            .561:
25409                                           ! 3830           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
25410                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
25411 74EB           FF76         D4            push	-$2C[bp]
25412                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
25413 74EE           8B46         0C            mov	ax,$C[bp]
25414                                           ! Debug: list unsigned int = ax+$30 (used reg = )
25415 74F1           05                   0030  add	ax,*$30
25416 74F4           50                         push	ax
25417                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25418 74F5           FF76         06            push	6[bp]
25419                                           ! Debug: func () void = write_word+0 (used reg = )
25420 74F8           E8         9137            call	_write_word
25421 74FB           83C4                   06  add	sp,*6
25422                                           !BCC_EOS
25423                                           ! 3831           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
25424                                           ! Debug: list int = const 0 (used reg = )
25425 74FE           31C0                       xor	ax,ax
25426 7500           50                         push	ax
25427                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
25428 7501           8B46         0C            mov	ax,$C[bp]
25429                                           ! Debug: list unsigned int = ax+$32 (used reg = )
25430 7504           05                   0032  add	ax,*$32
25431 7507           50                         push	ax
25432                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25433 7508           FF76         06            push	6[bp]
25434                                           ! Debug: func () void = write_word+0 (used reg = )
25435 750B           E8         9124            call	_write_word
25436 750E           83C4                   06  add	sp,*6
25437                                           !BCC_EOS
25438                                           ! 3832           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
25439                                           ! Debug: list long = const 0 (used reg = )
25440 7511           31C0                       xor	ax,ax
25441 7513           31DB                       xor	bx,bx
25442 7515           53                         push	bx
25443 7516           50                         push	ax
25444                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
25445 7517           8B46         0C            mov	ax,$C[bp]
25446                                           ! Debug: list unsigned int = ax+$34 (used reg = )
25447 751A           05                   0034  add	ax,*$34
25448 751D           50                         push	ax
25449                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
25450 751E           FF76         06            push	6[bp]
25451                                           ! Debug: func () void = write_dword+0 (used reg = )
25452 7521           E8         8B77            call	_write_dword
25453 7524           83C4                   08  add	sp,*8
25454                                           !BCC_EOS
25455                                           ! 3833           }
25456                                           ! 3834         else {
25457 7527           EB           00            jmp .562
25458                       00007529            .560:
25459                                           ! 3835           }
25460                                           ! 3836         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
25461                       00007529            .562:
25462                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
25463 7529           8A46         DB            mov	al,-$25[bp]
25464 752C           30E4                       xor	ah,ah
25465 752E           24                     01  and	al,*1
25466                                           ! Debug: list unsigned char = al+0 (used reg = )
25467 7530           30E4                       xor	ah,ah
25468 7532           50                         push	ax
25469                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
25470 7533           8B46         0C            mov	ax,$C[bp]
25471                                           ! Debug: list unsigned int = ax+$38 (used reg = )
25472 7536           05                   0038  add	ax,*$38
25473 7539           50                         push	ax
25474                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25475 753A           FF76         06            push	6[bp]
25476                                           ! Debug: func () void = write_byte+0 (used reg = )
25477 753D           E8         90DA            call	_write_byte
25478 7540           83C4                   06  add	sp,*6
25479                                           !BCC_EOS
25480                                           ! 3837         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
25481                                           ! Debug: list int = const 0 (used reg = )
25482 7543           31C0                       xor	ax,ax
25483 7545           50                         push	ax
25484                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
25485 7546           8B46         0C            mov	ax,$C[bp]
25486                                           ! Debug: list unsigned int = ax+$39 (used reg = )
25487 7549           05                   0039  add	ax,*$39
25488 754C           50                         push	ax
25489                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25490 754D           FF76         06            push	6[bp]
25491                                           ! Debug: func () void = write_byte+0 (used reg = )
25492 7550           E8         90C7            call	_write_byte
25493 7553           83C4                   06  add	sp,*6
25494                                           !BCC_EOS
25495                                           ! 3838         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
25496                                           ! Debug: list int = const 0 (used reg = )
25497 7556           31C0                       xor	ax,ax
25498 7558           50                         push	ax
25499                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
25500 7559           8B46         0C            mov	ax,$C[bp]
25501                                           ! Debug: list unsigned int = ax+$3A (used reg = )
25502 755C           05                   003A  add	ax,*$3A
25503 755F           50                         push	ax
25504                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25505 7560           FF76         06            push	6[bp]
25506                                           ! Debug: func () void = write_word+0 (used reg = )
25507 7563           E8         90CC            call	_write_word
25508 7566           83C4                   06  add	sp,*6
25509                                           !BCC_EOS
25510                                           ! 3839         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
25511                                           ! Debug: list long = const 0 (used reg = )
25512 7569           31C0                       xor	ax,ax
25513 756B           31DB                       xor	bx,bx
25514 756D           53                         push	bx
25515 756E           50                         push	ax
25516                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
25517 756F           8B46         0C            mov	ax,$C[bp]
25518                                           ! Debug: list unsigned int = ax+$3C (used reg = )
25519 7572           05                   003C  add	ax,*$3C
25520 7575           50                         push	ax
25521                                           ! Debug: list unsigned short DS = [S+$34+4] (used reg = )
25522 7576           FF76         06            push	6[bp]
25523                                           ! Debug: func () void = write_dword+0 (used reg = )
25524 7579           E8         8B1F            call	_write_dword
25525 757C           83C4                   08  add	sp,*8
25526                                           !BCC_EOS
25527                                           ! 3840         checksum=0;
25528                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25529 757F           30C0                       xor	al,al
25530 7581           8846         D7            mov	-$29[bp],al
25531                                           !BCC_EOS
25532                                           ! 3841         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
25533                                           ! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
25534 7584           B0                     1E  mov	al,*$1E
25535 7586           8846         D6            mov	-$2A[bp],al
25536                                           !BCC_EOS
25537                                           !BCC_EOS
25538 7589           EB           25            jmp .565
25539                       0000758B            .566:
25540                                           ! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
25541 758B           8B46         0C            mov	ax,$C[bp]
25542 758E           0246         D6            add	al,-$2A[bp]
25543 7591           80D4                   00  adc	ah,*0
25544                                           ! Debug: list unsigned int = ax+0 (used reg = )
25545 7594           50                         push	ax
25546                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
25547 7595           FF76         06            push	6[bp]
25548                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25549 7598           E8         9059            call	_read_byte
25550 759B           83C4                   04  add	sp,*4
25551                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25552 759E           30E4                       xor	ah,ah
25553 75A0           0246         D7            add	al,-$29[bp]
25554 75A3           80D4                   00  adc	ah,*0
25555 75A6           8846         D7            mov	-$29[bp],al
25556                                           !BCC_EOS
25557                                           ! 3842         checksum = ~checksum;
25558                       000075A9            .564:
25559                                           ! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
25560 75A9           8A46         D6            mov	al,-$2A[bp]
25561 75AC           40                         inc	ax
25562 75AD           8846         D6            mov	-$2A[bp],al
25563                       000075B0            .565:
25564                                           ! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
25565 75B0           8A46         D6            mov	al,-$2A[bp]
25566 75B3           3C                     40  cmp	al,*$40
25567 75B5           72           D4            jb 	.566
25568                       000075B7            .567:
25569                       000075B7            .563:
25570                                           ! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
25571 75B7           8A46         D7            mov	al,-$29[bp]
25572 75BA           30E4                       xor	ah,ah
25573 75BC           F7D0                       not	ax
25574                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
25575 75BE           8846         D7            mov	-$29[bp],al
25576                                           !BCC_EOS
25577                                           ! 3843         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
25578                                           ! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
25579 75C1           8A46         D7            mov	al,-$29[bp]
25580 75C4           30E4                       xor	ah,ah
25581 75C6           50                         push	ax
25582                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
25583 75C7           8B46         0C            mov	ax,$C[bp]
25584                                           ! Debug: list unsigned int = ax+$41 (used reg = )
25585 75CA           05                   0041  add	ax,*$41
25586 75CD           50                         push	ax
25587                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
25588 75CE           FF76         06            push	6[bp]
25589                                           ! Debug: func () void = write_byte+0 (used reg = )
25590 75D1           E8         9046            call	_write_byte
25591 75D4           83C4                   06  add	sp,*6
25592                                           !BCC_EOS
25593                                           ! 3844         }
25594                                           ! 3845       goto int13_success;
25595                       000075D7            .55B:
25596 75D7           83C4                   0E  add	sp,#..FFEF-..FFF0
25597 75DA           E9         00EF            br 	.FFEF
25598                                           !BCC_EOS
25599                                           ! 3846       break;
25600 75DD           E9         00BC            br 	.500
25601                                           !BCC_EOS
25602                                           ! 3847     case 0x4e:
25603                                           ! 3848       switch (( AX & 0x00ff )) {
25604                       000075E0            .568:
25605                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25606 75E0           8A46         18            mov	al,$18[bp]
25607 75E3           EB           10            jmp .56B
25608                                           ! 3849         case 0x01:
25609                                           ! 3850         case 0x03:
25610                       000075E5            .56C:
25611                                           ! 3851         case 0x04:
25612                       000075E5            .56D:
25613                                           ! 3852         case 0x06:
25614                       000075E5            .56E:
25615                                           ! 3853           goto int13_success;
25616                       000075E5            .56F:
25617 75E5           83C4                   0E  add	sp,#..FFEF-..FFF0
25618 75E8           E9         00E1            br 	.FFEF
25619                                           !BCC_EOS
25620                                           ! 3854           break;
25621 75EB           EB           1A            jmp .569
25622                                           !BCC_EOS
25623                                           ! 3855         default :
25624                                           ! 3856           goto int13_fail;
25625                       000075ED            .570:
25626 75ED           83C4                   0E  add	sp,#..FFF1-..FFF0
25627 75F0           E9         00AC            br 	.FFF1
25628                                           !BCC_EOS
25629                                           ! 3857         }
25630                                           ! 3858       break;
25631 75F3           EB           12            jmp .569
25632                       000075F5            .56B:
25633 75F5           2C                     01  sub	al,*1
25634 75F7           74           EC            je 	.56C
25635 75F9           2C                     02  sub	al,*2
25636 75FB           74           E8            je 	.56D
25637 75FD           2C                     01  sub	al,*1
25638 75FF           74           E4            je 	.56E
25639 7601           2C                     02  sub	al,*2
25640 7603           74           E0            je 	.56F
25641 7605           EB           E6            jmp	.570
25642                       00007607            .569:
25643 7607           E9         0092            br 	.500
25644                                           !BCC_EOS
25645                                           ! 3859     case 0x09:
25646                                           ! 3860     case 0x0c:
25647                       0000760A            .571:
25648                                           ! 3861     case 0x0d:
25649                       0000760A            .572:
25650                                           ! 3862     case 0x11:
25651                       0000760A            .573:
25652                                           ! 3863     case 0x14:
25653                       0000760A            .574:
25654                                           ! 3864       ;
25655                       0000760A            .575:
25656                                           !BCC_EOS
25657                                           ! 3865       goto int13_success;
25658 760A           83C4                   0E  add	sp,#..FFEF-..FFF0
25659 760D           E9         00BC            br 	.FFEF
25660                                           !BCC_EOS
25661                                           ! 3866       break;
25662 7610           E9         0089            br 	.500
25663                                           !BCC_EOS
25664                                           ! 3867     case 0x0a:
25665                                           ! 3868     case 0x0b:
25666                       00007613            .576:
25667                                           ! 3869     case 0x18:
25668                       00007613            .577:
25669                                           ! 3870     case 0x50:
25670                       00007613            .578:
25671                                           ! 3871     default:
25672                       00007613            .579:
25673                                           ! 3872       ;
25674                       00007613            .57A:
25675                                           !BCC_EOS
25676                                           ! 3873       goto int13_fail;
25677 7613           83C4                   0E  add	sp,#..FFF1-..FFF0
25678 7616           E9         0086            br 	.FFF1
25679                                           !BCC_EOS
25680                                           ! 3874       break;
25681 7619           E9         0080            br 	.500
25682                                           !BCC_EOS
25683                                           ! 3875     }
25684                                           ! 3876 int13_fail:
25685 761C           EB           7E            jmp .500
25686                       0000761E            .502:
25687 761E           83C4                   F2  add	sp,*-$E
25688 7621           2D                   0000  sub	ax,*0
25689 7624           7C           ED            jl 	.57A
25690 7626           3D                   0018  cmp	ax,*$18
25691 7629           77           3B            ja  	.57B
25692 762B           D1E0                       shl	ax,*1
25693 762D           89C3                       mov	bx,ax
25694 762F           2E                         seg	cs
25695 7630           FFA7       7634            br	.57C[bx]
25696                       00007634            .57C:
25697 7634                      6880            .word	.503
25698 7636                      6894            .word	.504
25699 7638                      68E5            .word	.508
25700 763A                      68E5            .word	.509
25701 763C                      68E5            .word	.50A
25702 763E                      6B34            .word	.51D
25703 7640                      7613            .word	.57A
25704 7642                      7613            .word	.57A
25705 7644                      6B41            .word	.51E
25706 7646                      760A            .word	.571
25707 7648                      7613            .word	.576
25708 764A                      7613            .word	.577
25709 764C                      760A            .word	.572
25710 764E                      760A            .word	.573
25711 7650                      7613            .word	.57A
25712 7652                      7613            .word	.57A
25713 7654                      6C1F            .word	.51F
25714 7656                      760A            .word	.574
25715 7658                      7613            .word	.57A
25716 765A                      7613            .word	.57A
25717 765C                      760A            .word	.575
25718 765E                      6C6B            .word	.523
25719 7660                      7613            .word	.57A
25720 7662                      7613            .word	.57A
25721 7664                      7613            .word	.578
25722                       00007666            .57B:
25723 7666           2D                   0041  sub	ax,*$41
25724 7669           72           A8            jb 	.57A
25725 766B           3D                   000F  cmp	ax,*$F
25726 766E           77           29            ja  	.57D
25727 7670           D1E0                       shl	ax,*1
25728 7672           89C3                       mov	bx,ax
25729 7674           2E                         seg	cs
25730 7675           FFA7       7679            br	.57E[bx]
25731                       00007679            .57E:
25732 7679                      6D1C            .word	.524
25733 767B                      6D3C            .word	.525
25734 767D                      6D3C            .word	.526
25735 767F                      6D3C            .word	.527
25736 7681                      6EED            .word	.536
25737 7683                      6EF6            .word	.538
25738 7685                      6D3C            .word	.528
25739 7687                      6F0A            .word	.539
25740 7689                      6EED            .word	.537
25741 768B                      7613            .word	.57A
25742 768D                      7613            .word	.57A
25743 768F                      7613            .word	.57A
25744 7691                      7613            .word	.57A
25745 7693                      75E0            .word	.568
25746 7695                      7613            .word	.57A
25747 7697                      7613            .word	.579
25748                       00007699            .57D:
25749 7699           E9         FF77            br 	.57A
25750                       0000769C            .500:
25751                       FFFFFFCA            ..FFF0	=	-$36
25752 769C           83C4                   0E  add	sp,*$E
25753                       0000769F            .FFF1:
25754                       FFFFFFD8            ..FFF1	=	-$28
25755                                           ! 3877     AX = ((AX & 0x00ff) | ((0x01) << 8));
25756                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25757 769F           8A46         18            mov	al,$18[bp]
25758                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
25759 76A2           30E4                       xor	ah,ah
25760 76A4           0D                   0100  or	ax,#$100
25761                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
25762 76A7           8946         18            mov	$18[bp],ax
25763                                           !BCC_EOS
25764                                           ! 3878 int13_fail_noah:
25765                       000076AA            .FFEC:
25766                       FFFFFFD8            ..FFEC	=	-$28
25767                                           ! 3879     write_byte(0x0040, 0x0074, ( AX >> 8 ));
25768                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
25769 76AA           8B46         18            mov	ax,$18[bp]
25770 76AD           88E0                       mov	al,ah
25771 76AF           30E4                       xor	ah,ah
25772                                           ! Debug: list unsigned int = ax+0 (used reg = )
25773 76B1           50                         push	ax
25774                                           ! Debug: list int = const $74 (used reg = )
25775 76B2           B8                   0074  mov	ax,*$74
25776 76B5           50                         push	ax
25777                                           ! Debug: list int = const $40 (used reg = )
25778 76B6           B8                   0040  mov	ax,*$40
25779 76B9           50                         push	ax
25780                                           ! Debug: func () void = write_byte+0 (used reg = )
25781 76BA           E8         8F5D            call	_write_byte
25782 76BD           83C4                   06  add	sp,*6
25783                                           !BCC_EOS
25784                                           ! 3880 int13_fail_nostatus:
25785                       000076C0            .FFEE:
25786                       FFFFFFD8            ..FFEE	=	-$28
25787                                           ! 3881     FLAGS |= 0x0001;
25788                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
25789 76C0           8B46         1E            mov	ax,$1E[bp]
25790 76C3           0C                     01  or	al,*1
25791 76C5           8946         1E            mov	$1E[bp],ax
25792                                           !BCC_EOS
25793                                           ! 3882     return;
25794 76C8           89EC                       mov	sp,bp
25795 76CA           5D                         pop	bp
25796 76CB           C3                         ret
25797                                           !BCC_EOS
25798                                           ! 3883 int13_success:
25799                       000076CC            .FFEF:
25800                       FFFFFFD8            ..FFEF	=	-$28
25801                                           ! 3884     AX = ((AX & 0x00ff) | ((0x00) << 8));
25802                                           ! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
25803 76CC           8A46         18            mov	al,$18[bp]
25804                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
25805 76CF           0C                     00  or	al,*0
25806                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
25807 76D1           30E4                       xor	ah,ah
25808 76D3           8946         18            mov	$18[bp],ax
25809                                           !BCC_EOS
25810                                           ! 3885 int13_success_noah:
25811                       000076D6            .FFED:
25812                       FFFFFFD8            ..FFED	=	-$28
25813                                           ! 3886     write_byte(0x0040, 0x0074, 0x00);
25814                                           ! Debug: list int = const 0 (used reg = )
25815 76D6           31C0                       xor	ax,ax
25816 76D8           50                         push	ax
25817                                           ! Debug: list int = const $74 (used reg = )
25818 76D9           B8                   0074  mov	ax,*$74
25819 76DC           50                         push	ax
25820                                           ! Debug: list int = const $40 (used reg = )
25821 76DD           B8                   0040  mov	ax,*$40
25822 76E0           50                         push	ax
25823                                           ! Debug: func () void = write_byte+0 (used reg = )
25824 76E1           E8         8F36            call	_write_byte
25825 76E4           83C4                   06  add	sp,*6
25826                                           !BCC_EOS
25827                                           ! 3887     FLAGS &= 0xfffe;
25828                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
25829 76E7           8B46         1E            mov	ax,$1E[bp]
25830 76EA           24                     FE  and	al,#$FE
25831 76EC           8946         1E            mov	$1E[bp],ax
25832                                           !BCC_EOS
25833                                           ! 3888     return;
25834 76EF           89EC                       mov	sp,bp
25835 76F1           5D                         pop	bp
25836 76F2           C3                         ret
25837                                           !BCC_EOS
25838                                           ! 3889 }
25839                                           ! 3890   void
25840                                           ! Register BX used in function int13_harddisk
25841                                           ! 3891 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
25842                                           ! 3892   Bit16u EHBX, 
25843                                           export	_int13_cdrom
25844                       000076F3            _int13_cdrom:
25845                                           ! 3892 DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
25846                                           !BCC_EOS
25847                                           ! 3893 {
25848                                           ! 3894   Bit16u ebda_seg=read_word(0x0040,0x000E);
25849 76F3           55                         push	bp
25850 76F4           89E5                       mov	bp,sp
25851 76F6           4C                         dec	sp
25852 76F7           4C                         dec	sp
25853                                           ! Debug: list int = const $E (used reg = )
25854 76F8           B8                   000E  mov	ax,*$E
25855 76FB           50                         push	ax
25856                                           ! Debug: list int = const $40 (used reg = )
25857 76FC           B8                   0040  mov	ax,*$40
25858 76FF           50                         push	ax
25859                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
25860 7700           E8         8F04            call	_read_word
25861 7703           83C4                   04  add	sp,*4
25862                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
25863 7706           8946         FE            mov	-2[bp],ax
25864                                           !BCC_EOS
25865                                           ! 3895   Bit8u device, status, locks;
25866                                           !BCC_EOS
25867                                           ! 3896   Bit8u atacmd[12];
25868                                           !BCC_EOS
25869                                           ! 3897   Bit32u lba;
25870                                           !BCC_EOS
25871                                           ! 3898   Bit16u count, segment, offset, i, size;
25872                                           !BCC_EOS
25873                                           ! 3899   ;
25874 7709           83C4                   E2  add	sp,*-$1E
25875                                           !BCC_EOS
25876                                           ! 3900   write_byte(0x0040, 0x0074, 0x00);
25877                                           ! Debug: list int = const 0 (used reg = )
25878 770C           31C0                       xor	ax,ax
25879 770E           50                         push	ax
25880                                           ! Debug: list int = const $74 (used reg = )
25881 770F           B8                   0074  mov	ax,*$74
25882 7712           50                         push	ax
25883                                           ! Debug: list int = const $40 (used reg = )
25884 7713           B8                   0040  mov	ax,*$40
25885 7716           50                         push	ax
25886                                           ! Debug: func () void = write_byte+0 (used reg = )
25887 7717           E8         8F00            call	_write_byte
25888 771A           83C4                   06  add	sp,*6
25889                                           !BCC_EOS
25890                                           ! 3901   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
25891                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25892 771D           8A46         10            mov	al,$10[bp]
25893                                           ! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
25894 7720           3C                     E0  cmp	al,#$E0
25895 7722           72           07            jb  	.580
25896                       00007724            .581:
25897                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25898 7724           8A46         10            mov	al,$10[bp]
25899                                           ! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
25900 7727           3C                     E8  cmp	al,#$E8
25901 7729           72           06            jb  	.57F
25902                       0000772B            .580:
25903                                           ! 3902     ;
25904                                           !BCC_EOS
25905                                           ! 3903     goto int13_fail;
25906 772B           83C4                   00  add	sp,#..FFEB+$22
25907 772E           E9         0A33            br 	.FFEB
25908                                           !BCC_EOS
25909                                           ! 3904     }
25910                                           ! 3905   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
25911                       00007731            .57F:
25912                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
25913 7731           8A46         10            mov	al,$10[bp]
25914                                           ! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
25915 7734           30E4                       xor	ah,ah
25916                                           ! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
25917 7736           05                   FF20  add	ax,#-$E0
25918 7739           89C3                       mov	bx,ax
25919                                           ! Debug: address unsigned char = [bx+$23C] (used reg = )
25920                                           ! Debug: list * unsigned char = bx+$23C (used reg = )
25921 773B           81C3                 023C  add	bx,#$23C
25922 773F           53                         push	bx
25923                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
25924 7740           FF76         FE            push	-2[bp]
25925                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
25926 7743           E8         8EAE            call	_read_byte
25927 7746           83C4                   04  add	sp,*4
25928                                           ! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
25929 7749           8846         FD            mov	-3[bp],al
25930                                           !BCC_EOS
25931                                           ! 3906   if (device >= (4*2)) {
25932                                           ! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
25933 774C           8A46         FD            mov	al,-3[bp]
25934 774F           3C                     08  cmp	al,*8
25935 7751           72           06            jb  	.582
25936                       00007753            .583:
25937                                           ! 3907     ;
25938                                           !BCC_EOS
25939                                           ! 3908     goto int13_fail;
25940 7753           83C4                   00  add	sp,#..FFEB+$22
25941 7756           E9         0A0B            br 	.FFEB
25942                                           !BCC_EOS
25943                                           ! 3909     }
25944                                           ! 3910   switch (( AX >> 8 )) {
25945                       00007759            .582:
25946                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
25947 7759           8B46         18            mov	ax,$18[bp]
25948 775C           88E0                       mov	al,ah
25949 775E           30E4                       xor	ah,ah
25950 7760           E9         0980            br 	.586
25951                                           ! 3911     case 0x00:
25952                                           ! 3912     case 0x09:
25953                       00007763            .587:
25954                                           ! 3913     case 0x0c:
25955                       00007763            .588:
25956                                           ! 3914     case 0x0d:
25957                       00007763            .589:
25958                                           ! 3915     case 0x10:
25959                       00007763            .58A:
25960                                           ! 3916     case 0x11:
25961                       00007763            .58B:
25962                                           ! 3917     case 0x14:
25963                       00007763            .58C:
25964                                           ! 3918     case 0x16:
25965                       00007763            .58D:
25966                                           ! 3919       goto int13_success;
25967                       00007763            .58E:
25968 7763           83C4                   0C  add	sp,#..FFE9-..FFEA
25969 7766           E9         0A28            br 	.FFE9
25970                                           !BCC_EOS
25971                                           ! 3920       break;
25972 7769           E9         09F5            br 	.584
25973                                           !BCC_EOS
25974                                           ! 3921     case 0x03:
25975                                           ! 3922     case 0x05:
25976                       0000776C            .58F:
25977                                           ! 3923     case 0x43:
25978                       0000776C            .590:
25979                                           ! 3924       AX = ((AX & 0x00ff) | ((0x03) << 8));
25980                       0000776C            .591:
25981                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
25982 776C           8A46         18            mov	al,$18[bp]
25983                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
25984 776F           30E4                       xor	ah,ah
25985 7771           0D                   0300  or	ax,#$300
25986                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
25987 7774           8946         18            mov	$18[bp],ax
25988                                           !BCC_EOS
25989                                           ! 3925       goto int13_fail_noah;
25990 7777           83C4                   0C  add	sp,#..FFE8-..FFEA
25991 777A           E9         09F2            br 	.FFE8
25992                                           !BCC_EOS
25993                                           ! 3926       break;
25994 777D           E9         09E1            br 	.584
25995                                           !BCC_EOS
25996                                           ! 3927     case 0x01:
25997                                           ! 3928       status = read_byte(0x0040, 0x0074);
25998                       00007780            .592:
25999                                           ! Debug: list int = const $74 (used reg = )
26000 7780           B8                   0074  mov	ax,*$74
26001 7783           50                         push	ax
26002                                           ! Debug: list int = const $40 (used reg = )
26003 7784           B8                   0040  mov	ax,*$40
26004 7787           50                         push	ax
26005                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26006 7788           E8         8E69            call	_read_byte
26007 778B           83C4                   04  add	sp,*4
26008                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
26009 778E           8846         FC            mov	-4[bp],al
26010                                           !BCC_EOS
26011                                           ! 3929       AX = ((AX & 0x00ff) | ((status) << 8));
26012                                           ! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
26013 7791           8A46         FC            mov	al,-4[bp]
26014 7794           30E4                       xor	ah,ah
26015 7796           88C4                       mov	ah,al
26016 7798           30C0                       xor	al,al
26017 779A           50                         push	ax
26018                                           ! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
26019 779B           8A46         18            mov	al,$18[bp]
26020                                           ! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
26021 779E           30E4                       xor	ah,ah
26022 77A0           0B46         D2            or	ax,0+..FFEA[bp]
26023 77A3           44                         inc	sp
26024 77A4           44                         inc	sp
26025                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26026 77A5           8946         18            mov	$18[bp],ax
26027                                           !BCC_EOS
26028                                           ! 3930       write_byte(0x0040, 0x0074, 0);
26029                                           ! Debug: list int = const 0 (used reg = )
26030 77A8           31C0                       xor	ax,ax
26031 77AA           50                         push	ax
26032                                           ! Debug: list int = const $74 (used reg = )
26033 77AB           B8                   0074  mov	ax,*$74
26034 77AE           50                         push	ax
26035                                           ! Debug: list int = const $40 (used reg = )
26036 77AF           B8                   0040  mov	ax,*$40
26037 77B2           50                         push	ax
26038                                           ! Debug: func () void = write_byte+0 (used reg = )
26039 77B3           E8         8E64            call	_write_byte
26040 77B6           83C4                   06  add	sp,*6
26041                                           !BCC_EOS
26042                                           ! 3931       if (status) goto int13_fail_nostatus;
26043 77B9           8A46         FC            mov	al,-4[bp]
26044 77BC           84C0                       test	al,al
26045 77BE           74           08            je  	.593
26046                       000077C0            .594:
26047 77C0           83C4                   0C  add	sp,#..FFE7-..FFEA
26048 77C3           E9         09BF            br 	.FFE7
26049                                           !BCC_EOS
26050                                           ! 3932       else goto int13_success_noah;
26051 77C6           EB           06            jmp .595
26052                       000077C8            .593:
26053 77C8           83C4                   0C  add	sp,#..FFE6-..FFEA
26054 77CB           E9         09CD            br 	.FFE6
26055                                           !BCC_EOS
26056                                           ! 3933       break;
26057                       000077CE            .595:
26058 77CE           E9         0990            br 	.584
26059                                           !BCC_EOS
26060                                           ! 3934     case 0x15:
26061                                           ! 3935       AX = ((AX & 0x00ff) | ((0x02) << 8));
26062                       000077D1            .596:
26063                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26064 77D1           8A46         18            mov	al,$18[bp]
26065                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
26066 77D4           30E4                       xor	ah,ah
26067 77D6           0D                   0200  or	ax,#$200
26068                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26069 77D9           8946         18            mov	$18[bp],ax
26070                                           !BCC_EOS
26071                                           ! 3936       goto int13_fail_noah;
26072 77DC           83C4                   0C  add	sp,#..FFE8-..FFEA
26073 77DF           E9         098D            br 	.FFE8
26074                                           !BCC_EOS
26075                                           ! 3937       break;
26076 77E2           E9         097C            br 	.584
26077                                           !BCC_EOS
26078                                           ! 3938     case 0x41:
26079                                           ! 3939       BX=0xaa55;
26080                       000077E5            .597:
26081                                           ! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
26082 77E5           B8                   AA55  mov	ax,#$AA55
26083 77E8           8946         12            mov	$12[bp],ax
26084                                           !BCC_EOS
26085                                           ! 3940       AX = ((AX & 0x00ff) | ((0x30) << 8));
26086                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26087 77EB           8A46         18            mov	al,$18[bp]
26088                                           ! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
26089 77EE           30E4                       xor	ah,ah
26090 77F0           0D                   3000  or	ax,#$3000
26091                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26092 77F3           8946         18            mov	$18[bp],ax
26093                                           !BCC_EOS
26094                                           ! 3941       CX=0x0007;
26095                                           ! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
26096 77F6           B8                   0007  mov	ax,*7
26097 77F9           8946         16            mov	$16[bp],ax
26098                                           !BCC_EOS
26099                                           ! 3942       goto int13_success_noah;
26100 77FC           83C4                   0C  add	sp,#..FFE6-..FFEA
26101 77FF           E9         0999            br 	.FFE6
26102                                           !BCC_EOS
26103                                           ! 3943       break;
26104 7802           E9         095C            br 	.584
26105                                           !BCC_EOS
26106                                           ! 3944     case 0x42:
26107                                           ! 3945     case 0x44:
26108                       00007805            .598:
26109                                           ! 3946     case 0x47:
26110                       00007805            .599:
26111                                           ! 3947       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
26112                       00007805            .59A:
26113                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
26114 7805           8B46         0C            mov	ax,$C[bp]
26115                                           ! Debug: list unsigned int = ax+2 (used reg = )
26116 7808           40                         inc	ax
26117 7809           40                         inc	ax
26118 780A           50                         push	ax
26119                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26120 780B           FF76         06            push	6[bp]
26121                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26122 780E           E8         8DF6            call	_read_word
26123 7811           83C4                   04  add	sp,*4
26124                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26125 7814           8946         E8            mov	-$18[bp],ax
26126                                           !BCC_EOS
26127                                           ! 3948       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
26128                                           ! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
26129 7817           8B46         0C            mov	ax,$C[bp]
26130                                           ! Debug: list unsigned int = ax+6 (used reg = )
26131 781A           05                   0006  add	ax,*6
26132 781D           50                         push	ax
26133                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26134 781E           FF76         06            push	6[bp]
26135                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26136 7821           E8         8DE3            call	_read_word
26137 7824           83C4                   04  add	sp,*4
26138                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
26139 7827           8946         E6            mov	-$1A[bp],ax
26140                                           !BCC_EOS
26141                                           ! 3949       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
26142                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
26143 782A           8B46         0C            mov	ax,$C[bp]
26144                                           ! Debug: list unsigned int = ax+4 (used reg = )
26145 782D           05                   0004  add	ax,*4
26146 7830           50                         push	ax
26147                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26148 7831           FF76         06            push	6[bp]
26149                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26150 7834           E8         8DD0            call	_read_word
26151 7837           83C4                   04  add	sp,*4
26152                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
26153 783A           8946         E4            mov	-$1C[bp],ax
26154                                           !BCC_EOS
26155                                           ! 3950       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
26156                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
26157 783D           8B46         0C            mov	ax,$C[bp]
26158                                           ! Debug: list unsigned int = ax+$C (used reg = )
26159 7840           05                   000C  add	ax,*$C
26160 7843           50                         push	ax
26161                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26162 7844           FF76         06            push	6[bp]
26163                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26164 7847           E8         8839            call	_read_dword
26165 784A           89D3                       mov	bx,dx
26166 784C           83C4                   04  add	sp,*4
26167                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26168 784F           8946         EA            mov	-$16[bp],ax
26169 7852           895E         EC            mov	-$14[bp],bx
26170                                           !BCC_EOS
26171                                           ! 3951       if (lba != 0L) {
26172                                           ! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
26173                                           ! Debug: expression subtree swapping
26174 7855           31C0                       xor	ax,ax
26175 7857           31DB                       xor	bx,bx
26176 7859           53                         push	bx
26177 785A           50                         push	ax
26178 785B           8B46         EA            mov	ax,-$16[bp]
26179 785E           8B5E         EC            mov	bx,-$14[bp]
26180 7861           8D7E         D0            lea	di,-2+..FFEA[bp]
26181 7864           E8         8864            call	lcmpul
26182 7867           8D66         D4            lea	sp,2+..FFEA[bp]
26183 786A           74           1C            je  	.59B
26184                       0000786C            .59C:
26185                                           ! 3952         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
26186                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26187 786C           8B46         18            mov	ax,$18[bp]
26188 786F           88E0                       mov	al,ah
26189 7871           30E4                       xor	ah,ah
26190                                           ! Debug: list unsigned int = ax+0 (used reg = )
26191 7873           50                         push	ax
26192                                           ! Debug: list * char = .59D+0 (used reg = )
26193 7874           BB                   D147  mov	bx,#.59D
26194 7877           53                         push	bx
26195                                           ! Debug: list int = const 7 (used reg = )
26196 7878           B8                   0007  mov	ax,*7
26197 787B           50                         push	ax
26198                                           ! Debug: func () void = bios_printf+0 (used reg = )
26199 787C           E8         919C            call	_bios_printf
26200 787F           83C4                   06  add	sp,*6
26201                                           !BCC_EOS
26202                                           ! 3953         goto int13_fail;
26203 7882           83C4                   0C  add	sp,#..FFEB-..FFEA
26204 7885           E9         08DC            br 	.FFEB
26205                                           !BCC_EOS
26206                                           ! 3954         }
26207                                           ! 3955       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
26208                       00007888            .59B:
26209                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
26210 7888           8B46         0C            mov	ax,$C[bp]
26211                                           ! Debug: list unsigned int = ax+8 (used reg = )
26212 788B           05                   0008  add	ax,*8
26213 788E           50                         push	ax
26214                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26215 788F           FF76         06            push	6[bp]
26216                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26217 7892           E8         87EE            call	_read_dword
26218 7895           89D3                       mov	bx,dx
26219 7897           83C4                   04  add	sp,*4
26220                                           ! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
26221 789A           8946         EA            mov	-$16[bp],ax
26222 789D           895E         EC            mov	-$14[bp],bx
26223                                           !BCC_EOS
26224                                           ! 3956       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
26225                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26226 78A0           8B46         18            mov	ax,$18[bp]
26227 78A3           88E0                       mov	al,ah
26228 78A5           30E4                       xor	ah,ah
26229                                           ! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
26230 78A7           3D                   0044  cmp	ax,*$44
26231 78AA           74           0C            je  	.59F
26232                       000078AC            .5A0:
26233                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
26234 78AC           8B46         18            mov	ax,$18[bp]
26235 78AF           88E0                       mov	al,ah
26236 78B1           30E4                       xor	ah,ah
26237                                           ! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
26238 78B3           3D                   0047  cmp	ax,*$47
26239 78B6           75           06            jne 	.59E
26240                       000078B8            .59F:
26241                                           ! 3957         goto int13_success;
26242 78B8           83C4                   0C  add	sp,#..FFE9-..FFEA
26243 78BB           E9         08D3            br 	.FFE9
26244                                           !BCC_EOS
26245                                           ! 3958       memsetb(get_SS(),atacmd,0,12);
26246                       000078BE            .59E:
26247                                           ! Debug: list int = const $C (used reg = )
26248 78BE           B8                   000C  mov	ax,*$C
26249 78C1           50                         push	ax
26250                                           ! Debug: list int = const 0 (used reg = )
26251 78C2           31C0                       xor	ax,ax
26252 78C4           50                         push	ax
26253                                           ! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
26254 78C5           8D5E         EF            lea	bx,-$11[bp]
26255 78C8           53                         push	bx
26256                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26257 78C9           E8         8D81            call	_get_SS
26258                                           ! Debug: list unsigned short = ax+0 (used reg = )
26259 78CC           50                         push	ax
26260                                           ! Debug: func () void = memsetb+0 (used reg = )
26261 78CD           E8         8730            call	_memsetb
26262 78D0           83C4                   08  add	sp,*8
26263                                           !BCC_EOS
26264                                           ! 3959       atacmd[0]=0x28;
26265                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
26266 78D3           B0                     28  mov	al,*$28
26267 78D5           8846         EF            mov	-$11[bp],al
26268                                           !BCC_EOS
26269                                           ! 3960       atacmd[7]=(count & 0xff00) >> 8;
26270                                           ! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
26271 78D8           8B46         E8            mov	ax,-$18[bp]
26272 78DB           30C0                       xor	al,al
26273                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
26274 78DD           88E0                       mov	al,ah
26275 78DF           30E4                       xor	ah,ah
26276                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
26277 78E1           8846         F6            mov	-$A[bp],al
26278                                           !BCC_EOS
26279                                           ! 3961       atacmd[8]=(count & 0x00ff);
26280                                           ! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
26281 78E4           8A46         E8            mov	al,-$18[bp]
26282                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
26283 78E7           8846         F7            mov	-9[bp],al
26284                                           !BCC_EOS
26285                                           ! 3962     
26286                                           ! 3962   atacmd[2]=(lba & 0xff000000) >> 24;
26287                                           ! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
26288                                           ! Debug: expression subtree swapping
26289 78EA           31C0                       xor	ax,ax
26290 78EC           BB                   FF00  mov	bx,#$FF00
26291 78EF           8D7E         EA            lea	di,-$16[bp]
26292 78F2           E8         87C6            call	landul
26293                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
26294 78F5           93                         xchg	bx,ax
26295 78F6           88E0                       mov	al,ah
26296 78F8           30E4                       xor	ah,ah
26297 78FA           31DB                       xor	bx,bx
26298                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
26299 78FC           8846         F1            mov	-$F[bp],al
26300                                           !BCC_EOS
26301                                           ! 3963       atacmd[3]=(lba & 0x00ff0000) >> 16;
26302                                           ! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
26303                                           ! Debug: expression subtree swapping
26304 78FF           31C0                       xor	ax,ax
26305 7901           BB                   00FF  mov	bx,#$FF
26306 7904           8D7E         EA            lea	di,-$16[bp]
26307 7907           E8         87B1            call	landul
26308                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
26309 790A           93                         xchg	bx,ax
26310 790B           31DB                       xor	bx,bx
26311                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
26312 790D           8846         F2            mov	-$E[bp],al
26313                                           !BCC_EOS
26314                                           ! 3964       atacmd[4]=(lba & 0x0000ff00) >> 8;
26315                                           ! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
26316                                           ! Debug: expression subtree swapping
26317 7910           B8                   FF00  mov	ax,#$FF00
26318 7913           31DB                       xor	bx,bx
26319 7915           8D7E         EA            lea	di,-$16[bp]
26320 7918           E8         87A0            call	landul
26321                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
26322 791B           88E0                       mov	al,ah
26323 791D           88DC                       mov	ah,bl
26324 791F           88FB                       mov	bl,bh
26325 7921           28FF                       sub	bh,bh
26326                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
26327 7923           8846         F3            mov	-$D[bp],al
26328                                           !BCC_EOS
26329                                           ! 3965       atacmd[5]=(lba & 0x000000ff);
26330                                           ! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
26331                                           ! Debug: expression subtree swapping
26332 7926           B8                   00FF  mov	ax,#$FF
26333 7929           31DB                       xor	bx,bx
26334 792B           8D7E         EA            lea	di,-$16[bp]
26335 792E           E8         878A            call	landul
26336                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
26337 7931           8846         F4            mov	-$C[bp],al
26338                                           !BCC_EOS
26339                                           ! 3966       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
26340                                           ! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
26341 7934           FF76         E4            push	-$1C[bp]
26342                                           ! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
26343 7937           FF76         E6            push	-$1A[bp]
26344                                           ! Debug: list int = const 1 (used reg = )
26345 793A           B8                   0001  mov	ax,*1
26346 793D           50                         push	ax
26347                                           ! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
26348 793E           8B46         E8            mov	ax,-$18[bp]
26349 7941           31DB                       xor	bx,bx
26350                                           ! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
26351 7943           53                         push	bx
26352 7944           50                         push	ax
26353 7945           B8                   0800  mov	ax,#$800
26354 7948           31DB                       xor	bx,bx
26355 794A           53                         push	bx
26356 794B           50                         push	ax
26357 794C           8B46         CA            mov	ax,-8+..FFEA[bp]
26358 794F           8B5E         CC            mov	bx,-6+..FFEA[bp]
26359 7952           8D7E         C6            lea	di,-$C+..FFEA[bp]
26360 7955           E8         8791            call	lmulul
26361 7958           83C4                   08  add	sp,*8
26362                                           ! Debug: list unsigned long = bx+0 (used reg = )
26363 795B           53                         push	bx
26364 795C           50                         push	ax
26365                                           ! Debug: list int = const 0 (used reg = )
26366 795D           31C0                       xor	ax,ax
26367 795F           50                         push	ax
26368                                           ! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
26369 7960           8D5E         EF            lea	bx,-$11[bp]
26370 7963           53                         push	bx
26371                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
26372 7964           E8         8CE6            call	_get_SS
26373                                           ! Debug: list unsigned short = ax+0 (used reg = )
26374 7967           50                         push	ax
26375                                           ! Debug: list int = const $C (used reg = )
26376 7968           B8                   000C  mov	ax,*$C
26377 796B           50                         push	ax
26378                                           ! Debug: list unsigned char device = [S+$34-5] (used reg = )
26379 796C           8A46         FD            mov	al,-3[bp]
26380 796F           30E4                       xor	ah,ah
26381 7971           50                         push	ax
26382                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
26383 7972           E8         BC56            call	_ata_cmd_packet
26384 7975           83C4                   14  add	sp,*$14
26385                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
26386 7978           8846         FC            mov	-4[bp],al
26387                                           !BCC_EOS
26388                                           ! 3967       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
26389                                           ! Debug: list * unsigned long = const $256 (used reg = )
26390 797B           B8                   0256  mov	ax,#$256
26391 797E           50                         push	ax
26392                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26393 797F           FF76         FE            push	-2[bp]
26394                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
26395 7982           E8         86FE            call	_read_dword
26396 7985           89D3                       mov	bx,dx
26397 7987           83C4                   04  add	sp,*4
26398                                           ! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
26399 798A           88E0                       mov	al,ah
26400 798C           88DC                       mov	ah,bl
26401 798E           88FB                       mov	bl,bh
26402 7990           28FF                       sub	bh,bh
26403 7992           BF                   0003  mov	di,*3
26404 7995           E8         8791            call	lsrul
26405                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
26406                                           ! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
26407 7998           8946         E8            mov	-$18[bp],ax
26408                                           !BCC_EOS
26409                                           ! 3968       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
26410                                           ! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
26411 799B           FF76         E8            push	-$18[bp]
26412                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
26413 799E           8B46         0C            mov	ax,$C[bp]
26414                                           ! Debug: list unsigned int = ax+2 (used reg = )
26415 79A1           40                         inc	ax
26416 79A2           40                         inc	ax
26417 79A3           50                         push	ax
26418                                           ! Debug: list unsigned short DS = [S+$26+4] (used reg = )
26419 79A4           FF76         06            push	6[bp]
26420                                           ! Debug: func () void = write_word+0 (used reg = )
26421 79A7           E8         8C88            call	_write_word
26422 79AA           83C4                   06  add	sp,*6
26423                                           !BCC_EOS
26424                                           ! 3969       if (status != 0) {
26425                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
26426 79AD           8A46         FC            mov	al,-4[bp]
26427 79B0           84C0                       test	al,al
26428 79B2           74           11            je  	.5A1
26429                       000079B4            .5A2:
26430                                           ! 3970         ;
26431                                           !BCC_EOS
26432                                           ! 3971         AX = ((AX & 0x00ff) | ((0x0c) << 8));
26433                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26434 79B4           8A46         18            mov	al,$18[bp]
26435                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
26436 79B7           30E4                       xor	ah,ah
26437 79B9           0D                   0C00  or	ax,#$C00
26438                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26439 79BC           8946         18            mov	$18[bp],ax
26440                                           !BCC_EOS
26441                                           ! 3972         goto int13_fail_noah;
26442 79BF           83C4                   0C  add	sp,#..FFE8-..FFEA
26443 79C2           E9         07AA            br 	.FFE8
26444                                           !BCC_EOS
26445                                           ! 3973         }
26446                                           ! 3974       goto int13_success;
26447                       000079C5            .5A1:
26448 79C5           83C4                   0C  add	sp,#..FFE9-..FFEA
26449 79C8           E9         07C6            br 	.FFE9
26450                                           !BCC_EOS
26451                                           ! 3975       break;
26452 79CB           E9         0793            br 	.584
26453                                           !BCC_EOS
26454                                           ! 3976     case 0x45:
26455                                           ! 3977       if (( AX & 0x00ff ) > 2) goto int13_fail;
26456                       000079CE            .5A3:
26457                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26458 79CE           8A46         18            mov	al,$18[bp]
26459                                           ! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
26460 79D1           3C                     02  cmp	al,*2
26461 79D3           76           06            jbe 	.5A4
26462                       000079D5            .5A5:
26463 79D5           83C4                   0C  add	sp,#..FFEB-..FFEA
26464 79D8           E9         0789            br 	.FFEB
26465                                           !BCC_EOS
26466                                           ! 3978       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
26467                       000079DB            .5A4:
26468                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
26469 79DB           8A46         FD            mov	al,-3[bp]
26470 79DE           30E4                       xor	ah,ah
26471 79E0           B9                   001E  mov	cx,*$1E
26472 79E3           F7E9                       imul	cx
26473 79E5           89C3                       mov	bx,ax
26474                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26475                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26476 79E7           81C3                 0145  add	bx,#$145
26477 79EB           53                         push	bx
26478                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26479 79EC           FF76         FE            push	-2[bp]
26480                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26481 79EF           E8         8C02            call	_read_byte
26482 79F2           83C4                   04  add	sp,*4
26483                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
26484 79F5           8846         FB            mov	-5[bp],al
26485                                           !BCC_EOS
26486                                           ! 3979       switch (( AX & 0x00ff )) {
26487                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26488 79F8           8A46         18            mov	al,$18[bp]
26489 79FB           E9         00D5            br 	.5A8
26490                                           ! 3980         case 0 :
26491                                           ! 3981           if (locks == 0xff) {
26492                       000079FE            .5A9:
26493                                           ! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
26494 79FE           8A46         FB            mov	al,-5[bp]
26495 7A01           3C                     FF  cmp	al,#$FF
26496 7A03           75           1B            jne 	.5AA
26497                       00007A05            .5AB:
26498                                           ! 3982             AX = ((AX & 0x00ff) | ((0xb4) << 8));
26499                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26500 7A05           8A46         18            mov	al,$18[bp]
26501                                           ! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
26502 7A08           30E4                       xor	ah,ah
26503 7A0A           0D                   B400  or	ax,#-$4C00
26504                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26505 7A0D           8946         18            mov	$18[bp],ax
26506                                           !BCC_EOS
26507                                           ! 3983             AX = ((AX & 0xff00) | (1));
26508                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26509 7A10           8B46         18            mov	ax,$18[bp]
26510 7A13           30C0                       xor	al,al
26511                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
26512 7A15           0C                     01  or	al,*1
26513                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26514 7A17           8946         18            mov	$18[bp],ax
26515                                           !BCC_EOS
26516                                           ! 3984             goto int13_fail_noah;
26517 7A1A           83C4                   0C  add	sp,#..FFE8-..FFEA
26518 7A1D           E9         074F            br 	.FFE8
26519                                           !BCC_EOS
26520                                           ! 3985             }
26521                                           ! 3986           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
26522                       00007A20            .5AA:
26523                                           ! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
26524 7A20           8A46         FB            mov	al,-5[bp]
26525 7A23           40                         inc	ax
26526 7A24           8846         FB            mov	-5[bp],al
26527                                           ! Debug: list unsigned char = al+0 (used reg = )
26528 7A27           30E4                       xor	ah,ah
26529 7A29           50                         push	ax
26530                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
26531 7A2A           8A46         FD            mov	al,-3[bp]
26532 7A2D           30E4                       xor	ah,ah
26533 7A2F           B9                   001E  mov	cx,*$1E
26534 7A32           F7E9                       imul	cx
26535 7A34           89C3                       mov	bx,ax
26536                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26537                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26538 7A36           81C3                 0145  add	bx,#$145
26539 7A3A           53                         push	bx
26540                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
26541 7A3B           FF76         FE            push	-2[bp]
26542                                           ! Debug: func () void = write_byte+0 (used reg = )
26543 7A3E           E8         8BD9            call	_write_byte
26544 7A41           83C4                   06  add	sp,*6
26545                                           !BCC_EOS
26546                                           ! 3987           AX = ((AX & 0xff00) | (1));
26547                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26548 7A44           8B46         18            mov	ax,$18[bp]
26549 7A47           30C0                       xor	al,al
26550                                           ! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
26551 7A49           0C                     01  or	al,*1
26552                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26553 7A4B           8946         18            mov	$18[bp],ax
26554                                           !BCC_EOS
26555                                           ! 3988           break;
26556 7A4E           E9         0092            br 	.5A6
26557                                           !BCC_EOS
26558                                           ! 3989         case 1 :
26559                                           ! 3990           if (locks == 0x00) {
26560                       00007A51            .5AC:
26561                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26562 7A51           8A46         FB            mov	al,-5[bp]
26563 7A54           84C0                       test	al,al
26564 7A56           75           1B            jne 	.5AD
26565                       00007A58            .5AE:
26566                                           ! 3991             AX = ((AX & 0x00ff) | ((0xb0) << 8));
26567                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26568 7A58           8A46         18            mov	al,$18[bp]
26569                                           ! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
26570 7A5B           30E4                       xor	ah,ah
26571 7A5D           0D                   B000  or	ax,#-$5000
26572                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26573 7A60           8946         18            mov	$18[bp],ax
26574                                           !BCC_EOS
26575                                           ! 3992             AX = ((AX & 0xff00) | (0));
26576                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
26577 7A63           8B46         18            mov	ax,$18[bp]
26578 7A66           30C0                       xor	al,al
26579                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
26580 7A68           0C                     00  or	al,*0
26581                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26582 7A6A           8946         18            mov	$18[bp],ax
26583                                           !BCC_EOS
26584                                           ! 3993             goto int13_fail_noah;
26585 7A6D           83C4                   0C  add	sp,#..FFE8-..FFEA
26586 7A70           E9         06FC            br 	.FFE8
26587                                           !BCC_EOS
26588                                           ! 3994             }
26589                                           ! 3995           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
26590                       00007A73            .5AD:
26591                                           ! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
26592 7A73           8A46         FB            mov	al,-5[bp]
26593 7A76           48                         dec	ax
26594 7A77           8846         FB            mov	-5[bp],al
26595                                           ! Debug: list unsigned char = al+0 (used reg = )
26596 7A7A           30E4                       xor	ah,ah
26597 7A7C           50                         push	ax
26598                                           ! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
26599 7A7D           8A46         FD            mov	al,-3[bp]
26600 7A80           30E4                       xor	ah,ah
26601 7A82           B9                   001E  mov	cx,*$1E
26602 7A85           F7E9                       imul	cx
26603 7A87           89C3                       mov	bx,ax
26604                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26605                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26606 7A89           81C3                 0145  add	bx,#$145
26607 7A8D           53                         push	bx
26608                                           ! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
26609 7A8E           FF76         FE            push	-2[bp]
26610                                           ! Debug: func () void = write_byte+0 (used reg = )
26611 7A91           E8         8B86            call	_write_byte
26612 7A94           83C4                   06  add	sp,*6
26613                                           !BCC_EOS
26614                                           ! 3996           AX = ((AX & 0xff00) | (locks==0?0:1));
26615                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26616 7A97           8A46         FB            mov	al,-5[bp]
26617 7A9A           84C0                       test	al,al
26618 7A9C           75           04            jne 	.5AF
26619                       00007A9E            .5B0:
26620 7A9E           30C0                       xor	al,al
26621 7AA0           EB           02            jmp .5B1
26622                       00007AA2            .5AF:
26623 7AA2           B0                     01  mov	al,*1
26624                       00007AA4            .5B1:
26625 7AA4           50                         push	ax
26626                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
26627 7AA5           8B46         18            mov	ax,$18[bp]
26628 7AA8           30C0                       xor	al,al
26629                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
26630 7AAA           0A46         D2            or	al,0+..FFEA[bp]
26631 7AAD           44                         inc	sp
26632 7AAE           44                         inc	sp
26633                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26634 7AAF           8946         18            mov	$18[bp],ax
26635                                           !BCC_EOS
26636                                           ! 3997           break;
26637 7AB2           EB           2F            jmp .5A6
26638                                           !BCC_EOS
26639                                           ! 3998         case 2 :
26640                                           ! 3999           AX = ((AX & 0xff00) | (locks==0?0:1));
26641                       00007AB4            .5B2:
26642                                           ! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26643 7AB4           8A46         FB            mov	al,-5[bp]
26644 7AB7           84C0                       test	al,al
26645 7AB9           75           04            jne 	.5B3
26646                       00007ABB            .5B4:
26647 7ABB           30C0                       xor	al,al
26648 7ABD           EB           02            jmp .5B5
26649                       00007ABF            .5B3:
26650 7ABF           B0                     01  mov	al,*1
26651                       00007AC1            .5B5:
26652 7AC1           50                         push	ax
26653                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
26654 7AC2           8B46         18            mov	ax,$18[bp]
26655 7AC5           30C0                       xor	al,al
26656                                           ! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
26657 7AC7           0A46         D2            or	al,0+..FFEA[bp]
26658 7ACA           44                         inc	sp
26659 7ACB           44                         inc	sp
26660                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26661 7ACC           8946         18            mov	$18[bp],ax
26662                                           !BCC_EOS
26663                                           ! 4000           break;
26664 7ACF           EB           12            jmp .5A6
26665                                           !BCC_EOS
26666                                           ! 4001         }
26667                                           ! 4002       goto int13_success;
26668 7AD1           EB           10            jmp .5A6
26669                       00007AD3            .5A8:
26670 7AD3           2C                     00  sub	al,*0
26671 7AD5         0F84         FF25            beq 	.5A9
26672 7AD9           2C                     01  sub	al,*1
26673 7ADB         0F84         FF72            beq 	.5AC
26674 7ADF           2C                     01  sub	al,*1
26675 7AE1           74           D1            je 	.5B2
26676                       00007AE3            .5A6:
26677 7AE3           83C4                   0C  add	sp,#..FFE9-..FFEA
26678 7AE6           E9         06A8            br 	.FFE9
26679                                           !BCC_EOS
26680                                           ! 4003       break;
26681 7AE9           E9         0675            br 	.584
26682                                           !BCC_EOS
26683                                           ! 4004     case 0x46:
26684                                           ! 4005       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
26685                       00007AEC            .5B6:
26686                                           ! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
26687 7AEC           8A46         FD            mov	al,-3[bp]
26688 7AEF           30E4                       xor	ah,ah
26689 7AF1           B9                   001E  mov	cx,*$1E
26690 7AF4           F7E9                       imul	cx
26691 7AF6           89C3                       mov	bx,ax
26692                                           ! Debug: address unsigned char = [bx+$145] (used reg = )
26693                                           ! Debug: list * unsigned char = bx+$145 (used reg = )
26694 7AF8           81C3                 0145  add	bx,#$145
26695 7AFC           53                         push	bx
26696                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
26697 7AFD           FF76         FE            push	-2[bp]
26698                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
26699 7B00           E8         8AF1            call	_read_byte
26700 7B03           83C4                   04  add	sp,*4
26701                                           ! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
26702 7B06           8846         FB            mov	-5[bp],al
26703                                           !BCC_EOS
26704                                           ! 4006       if (locks != 0) {
26705                                           ! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
26706 7B09           8A46         FB            mov	al,-5[bp]
26707 7B0C           84C0                       test	al,al
26708 7B0E           74           11            je  	.5B7
26709                       00007B10            .5B8:
26710                                           ! 4007         AX = ((AX & 0x00ff) | ((0xb1) << 8));
26711                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26712 7B10           8A46         18            mov	al,$18[bp]
26713                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
26714 7B13           30E4                       xor	ah,ah
26715 7B15           0D                   B100  or	ax,#-$4F00
26716                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26717 7B18           8946         18            mov	$18[bp],ax
26718                                           !BCC_EOS
26719                                           ! 4008         goto int13_fail_noah;
26720 7B1B           83C4                   0C  add	sp,#..FFE8-..FFEA
26721 7B1E           E9         064E            br 	.FFE8
26722                                           !BCC_EOS
26723                                           ! 4009         }
26724                                           ! 4010 #asm
26725                       00007B21            .5B7:
26726                                           !BCC_EOS
26727                                           !BCC_ASM
26728                       0000002E            _int13_cdrom.BP	set	$2E
26729                       0000000E            .int13_cdrom.BP	set	$E
26730                       00000024            _int13_cdrom.EHBX	set	$24
26731                       00000004            .int13_cdrom.EHBX	set	4
26732                       0000003C            _int13_cdrom.CS	set	$3C
26733                       0000001C            .int13_cdrom.CS	set	$1C
26734                       00000008            _int13_cdrom.count	set	8
26735                       FFFFFFE8            .int13_cdrom.count	set	-$18
26736                       00000036            _int13_cdrom.CX	set	$36
26737                       00000016            .int13_cdrom.CX	set	$16
26738                       00000006            _int13_cdrom.segment	set	6
26739                       FFFFFFE6            .int13_cdrom.segment	set	-$1A
26740                       0000002A            _int13_cdrom.DI	set	$2A
26741                       0000000A            .int13_cdrom.DI	set	$A
26742                       0000003E            _int13_cdrom.FLAGS	set	$3E
26743                       0000001E            .int13_cdrom.FLAGS	set	$1E
26744                       00000026            _int13_cdrom.DS	set	$26
26745                       00000006            .int13_cdrom.DS	set	6
26746                       00000030            _int13_cdrom.ELDX	set	$30
26747                       00000010            .int13_cdrom.ELDX	set	$10
26748                       00000034            _int13_cdrom.DX	set	$34
26749                       00000014            .int13_cdrom.DX	set	$14
26750                       00000000            _int13_cdrom.size	set	0
26751                       FFFFFFE0            .int13_cdrom.size	set	-$20
26752                       00000002            _int13_cdrom.i	set	2
26753                       FFFFFFE2            .int13_cdrom.i	set	-$1E
26754                       0000001D            _int13_cdrom.device	set	$1D
26755                       FFFFFFFD            .int13_cdrom.device	set	-3
26756                       00000028            _int13_cdrom.ES	set	$28
26757                       00000008            .int13_cdrom.ES	set	8
26758                       0000001E            _int13_cdrom.ebda_seg	set	$1E
26759                       FFFFFFFE            .int13_cdrom.ebda_seg	set	-2
26760                       0000002C            _int13_cdrom.SI	set	$2C
26761                       0000000C            .int13_cdrom.SI	set	$C
26762                       0000003A            _int13_cdrom.IP	set	$3A
26763                       0000001A            .int13_cdrom.IP	set	$1A
26764                       0000000A            _int13_cdrom.lba	set	$A
26765                       FFFFFFEA            .int13_cdrom.lba	set	-$16
26766                       0000001C            _int13_cdrom.status	set	$1C
26767                       FFFFFFFC            .int13_cdrom.status	set	-4
26768                       0000000F            _int13_cdrom.atacmd	set	$F
26769                       FFFFFFEF            .int13_cdrom.atacmd	set	-$11
26770                       00000038            _int13_cdrom.AX	set	$38
26771                       00000018            .int13_cdrom.AX	set	$18
26772                       00000004            _int13_cdrom.offset	set	4
26773                       FFFFFFE4            .int13_cdrom.offset	set	-$1C
26774                       00000032            _int13_cdrom.BX	set	$32
26775                       00000012            .int13_cdrom.BX	set	$12
26776                       0000001B            _int13_cdrom.locks	set	$1B
26777                       FFFFFFFB            .int13_cdrom.locks	set	-5
26778 7B21           55                                 push bp
26779 7B22           89E5                               mov bp, sp
26780 7B24           B4                     52          mov ah, #0x52
26781 7B26           CD                     15          int #0x15
26782 7B28           8866         1E                    mov _int13_cdrom.status + 2[bp], ah
26783 7B2B           73           06                    jnc int13_cdrom_rme_end
26784 7B2D           C706       001C      0001          mov _int13_cdrom.status, #1
26785                       00007B33            int13_cdrom_rme_end:
26786 7B33           5D                                 pop bp
26787                                           ! 4020 endasm
26788                                           !BCC_ENDASM
26789                                           !BCC_EOS
26790                                           ! 4021       if (status != 0) {
26791                                           ! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
26792 7B34           8A46         FC            mov	al,-4[bp]
26793 7B37           84C0                       test	al,al
26794 7B39           74           11            je  	.5B9
26795                       00007B3B            .5BA:
26796                                           ! 4022         AX = ((AX & 0x00
26797                                           ! 4022 ff) | ((0xb1) << 8));
26798                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
26799 7B3B           8A46         18            mov	al,$18[bp]
26800                                           ! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
26801 7B3E           30E4                       xor	ah,ah
26802 7B40           0D                   B100  or	ax,#-$4F00
26803                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
26804 7B43           8946         18            mov	$18[bp],ax
26805                                           !BCC_EOS
26806                                           ! 4023         goto int13_fail_noah;
26807 7B46           83C4                   0C  add	sp,#..FFE8-..FFEA
26808 7B49           E9         0623            br 	.FFE8
26809                                           !BCC_EOS
26810                                           ! 4024       }
26811                                           ! 4025       goto int13_success;
26812                       00007B4C            .5B9:
26813 7B4C           83C4                   0C  add	sp,#..FFE9-..FFEA
26814 7B4F           E9         063F            br 	.FFE9
26815                                           !BCC_EOS
26816                                           ! 4026       break;
26817 7B52           E9         060C            br 	.584
26818                                           !BCC_EOS
26819                                           ! 4027     case 0x48:
26820                                           ! 4028       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
26821                       00007B55            .5BB:
26822                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
26823 7B55           8B46         0C            mov	ax,$C[bp]
26824                                           ! Debug: list unsigned int = ax+0 (used reg = )
26825 7B58           50                         push	ax
26826                                           ! Debug: list unsigned short DS = [S+$24+4] (used reg = )
26827 7B59           FF76         06            push	6[bp]
26828                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26829 7B5C           E8         8AA8            call	_read_word
26830 7B5F           83C4                   04  add	sp,*4
26831                                           ! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
26832 7B62           8946         E0            mov	-$20[bp],ax
26833                                           !BCC_EOS
26834                                           ! 4029       if(size < 0x1a)
26835                                           ! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
26836 7B65           8B46         E0            mov	ax,-$20[bp]
26837 7B68           3D                   001A  cmp	ax,*$1A
26838 7B6B           73           06            jae 	.5BC
26839                       00007B6D            .5BD:
26840                                           ! 4030         goto int13_fail;
26841 7B6D           83C4                   0C  add	sp,#..FFEB-..FFEA
26842 7B70           E9         05F1            br 	.FFEB
26843                                           !BCC_EOS
26844                                           ! 4031       if(size >= 0x1a) {
26845                       00007B73            .5BC:
26846                                           ! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
26847 7B73           8B46         E0            mov	ax,-$20[bp]
26848 7B76           3D                   001A  cmp	ax,*$1A
26849 7B79         0F82         00CC            blo 	.5BE
26850                       00007B7D            .5BF:
26851                                           ! 4032         Bit16u cylinders, heads, spt, blksize;
26852                                           !BCC_EOS
26853                                           ! 4033         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
26854                                           ! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
26855 7B7D           8A46         FD            mov	al,-3[bp]
26856 7B80           30E4                       xor	ah,ah
26857 7B82           B9                   001E  mov	cx,*$1E
26858 7B85           F7E9                       imul	cx
26859 7B87           89C3                       mov	bx,ax
26860                                           ! Debug: address unsigned short = [bx+$148] (used reg = )
26861                                           ! Debug: list * unsigned short = bx+$148 (used reg = )
26862 7B89           81C3                 0148  add	bx,#$148
26863 7B8D           53                         push	bx
26864                                           ! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
26865 7B8E           FF76         FE            push	-2[bp]
26866                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
26867 7B91           E8         8A73            call	_read_word
26868 7B94           83C4                   04  add	sp,*4
26869                                           ! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
26870 7B97           8946         D8            mov	-$28[bp],ax
26871                                           !BCC_EOS
26872                                           ! 4034         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
26873                                           ! Debug: list int = const $1A (used reg = )
26874 7B9A           B8                   001A  mov	ax,*$1A
26875 7B9D           50                         push	ax
26876                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
26877 7B9E           8B46         0C            mov	ax,$C[bp]
26878                                           ! Debug: list unsigned int = ax+0 (used reg = )
26879 7BA1           50                         push	ax
26880                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26881 7BA2           FF76         06            push	6[bp]
26882                                           ! Debug: func () void = write_word+0 (used reg = )
26883 7BA5           E8         8A8A            call	_write_word
26884 7BA8           83C4                   06  add	sp,*6
26885                                           !BCC_EOS
26886                                           ! 4035         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
26887                                           ! Debug: list int = const $74 (used reg = )
26888 7BAB           B8                   0074  mov	ax,*$74
26889 7BAE           50                         push	ax
26890                                           ! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
26891 7BAF           8B46         0C            mov	ax,$C[bp]
26892                                           ! Debug: list unsigned int = ax+2 (used reg = )
26893 7BB2           40                         inc	ax
26894 7BB3           40                         inc	ax
26895 7BB4           50                         push	ax
26896                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26897 7BB5           FF76         06            push	6[bp]
26898                                           ! Debug: func () void = write_word+0 (used reg = )
26899 7BB8           E8         8A77            call	_write_word
26900 7BBB           83C4                   06  add	sp,*6
26901                                           !BCC_EOS
26902                                           ! 4036         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
26903                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26904 7BBE           B8                   FFFF  mov	ax,#$FFFF
26905 7BC1           BB                   FFFF  mov	bx,#$FFFF
26906 7BC4           53                         push	bx
26907 7BC5           50                         push	ax
26908                                           ! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
26909 7BC6           8B46         0C            mov	ax,$C[bp]
26910                                           ! Debug: list unsigned int = ax+4 (used reg = )
26911 7BC9           05                   0004  add	ax,*4
26912 7BCC           50                         push	ax
26913                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26914 7BCD           FF76         06            push	6[bp]
26915                                           ! Debug: func () void = write_dword+0 (used reg = )
26916 7BD0           E8         84C8            call	_write_dword
26917 7BD3           83C4                   08  add	sp,*8
26918                                           !BCC_EOS
26919                                           ! 4037         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
26920                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26921 7BD6           B8                   FFFF  mov	ax,#$FFFF
26922 7BD9           BB                   FFFF  mov	bx,#$FFFF
26923 7BDC           53                         push	bx
26924 7BDD           50                         push	ax
26925                                           ! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
26926 7BDE           8B46         0C            mov	ax,$C[bp]
26927                                           ! Debug: list unsigned int = ax+8 (used reg = )
26928 7BE1           05                   0008  add	ax,*8
26929 7BE4           50                         push	ax
26930                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26931 7BE5           FF76         06            push	6[bp]
26932                                           ! Debug: func () void = write_dword+0 (used reg = )
26933 7BE8           E8         84B0            call	_write_dword
26934 7BEB           83C4                   08  add	sp,*8
26935                                           !BCC_EOS
26936                                           ! 4038         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
26937                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26938 7BEE           B8                   FFFF  mov	ax,#$FFFF
26939 7BF1           BB                   FFFF  mov	bx,#$FFFF
26940 7BF4           53                         push	bx
26941 7BF5           50                         push	ax
26942                                           ! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
26943 7BF6           8B46         0C            mov	ax,$C[bp]
26944                                           ! Debug: list unsigned int = ax+$C (used reg = )
26945 7BF9           05                   000C  add	ax,*$C
26946 7BFC           50                         push	ax
26947                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26948 7BFD           FF76         06            push	6[bp]
26949                                           ! Debug: func () void = write_dword+0 (used reg = )
26950 7C00           E8         8498            call	_write_dword
26951 7C03           83C4                   08  add	sp,*8
26952                                           !BCC_EOS
26953                                           ! 4039         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
26954                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26955 7C06           B8                   FFFF  mov	ax,#$FFFF
26956 7C09           BB                   FFFF  mov	bx,#$FFFF
26957 7C0C           53                         push	bx
26958 7C0D           50                         push	ax
26959                                           ! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
26960 7C0E           8B46         0C            mov	ax,$C[bp]
26961                                           ! Debug: list unsigned int = ax+$10 (used reg = )
26962 7C11           05                   0010  add	ax,*$10
26963 7C14           50                         push	ax
26964                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26965 7C15           FF76         06            push	6[bp]
26966                                           ! Debug: func () void = write_dword+0 (used reg = )
26967 7C18           E8         8480            call	_write_dword
26968 7C1B           83C4                   08  add	sp,*8
26969                                           !BCC_EOS
26970                                           ! 4040         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
26971                                           ! Debug: list unsigned long = const $FFFFFFFF (used reg = )
26972 7C1E           B8                   FFFF  mov	ax,#$FFFF
26973 7C21           BB                   FFFF  mov	bx,#$FFFF
26974 7C24           53                         push	bx
26975 7C25           50                         push	ax
26976                                           ! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
26977 7C26           8B46         0C            mov	ax,$C[bp]
26978                                           ! Debug: list unsigned int = ax+$14 (used reg = )
26979 7C29           05                   0014  add	ax,*$14
26980 7C2C           50                         push	ax
26981                                           ! Debug: list unsigned short DS = [S+$30+4] (used reg = )
26982 7C2D           FF76         06            push	6[bp]
26983                                           ! Debug: func () void = write_dword+0 (used reg = )
26984 7C30           E8         8468            call	_write_dword
26985 7C33           83C4                   08  add	sp,*8
26986                                           !BCC_EOS
26987                                           ! 4041         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
26988                                           ! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
26989 7C36           FF76         D8            push	-$28[bp]
26990                                           ! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
26991 7C39           8B46         0C            mov	ax,$C[bp]
26992                                           ! Debug: list unsigned int = ax+$18 (used reg = )
26993 7C3C           05                   0018  add	ax,*$18
26994 7C3F           50                         push	ax
26995                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
26996 7C40           FF76         06            push	6[bp]
26997                                           ! Debug: func () void = write_word+0 (used reg = )
26998 7C43           E8         89EC            call	_write_word
26999 7C46           83C4                   06  add	sp,*6
27000                                           !BCC_EOS
27001                                           ! 4042         }
27002                                           ! 4043       if(size >= 0x1e) {
27003                       00007C49            .5BE:
27004                                           ! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
27005 7C49           8B46         E0            mov	ax,-$20[bp]
27006 7C4C           3D                   001E  cmp	ax,*$1E
27007 7C4F         0F82         01F9            blo 	.5C0
27008                       00007C53            .5C1:
27009                                           ! 4044         Bit8u channel, dev, irq, mode, checksum, i;
27010                                           !BCC_EOS
27011                                           ! 4045         Bit16u iobase1, iobase2, options;
27012                                           !BCC_EOS
27013                                           ! 4046         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
27014                                           ! Debug: list int = const $1E (used reg = )
27015 7C53           B8                   001E  mov	ax,*$1E
27016 7C56           50                         push	ax
27017                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
27018 7C57           8B46         0C            mov	ax,$C[bp]
27019                                           ! Debug: list unsigned int = ax+0 (used reg = )
27020 7C5A           50                         push	ax
27021                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27022 7C5B           FF76         06            push	6[bp]
27023                                           ! Debug: func () void = write_word+0 (used reg = )
27024 7C5E           E8         89D1            call	_write_word
27025 7C61           83C4                   06  add	sp,*6
27026                                           !BCC_EOS
27027                                           ! 4047         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
27028                                           ! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
27029 7C64           FF76         FE            push	-2[bp]
27030                                           ! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
27031 7C67           8B46         0C            mov	ax,$C[bp]
27032                                           ! Debug: list unsigned int = ax+$1C (used reg = )
27033 7C6A           05                   001C  add	ax,*$1C
27034 7C6D           50                         push	ax
27035                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27036 7C6E           FF76         06            push	6[bp]
27037                                           ! Debug: func () void = write_word+0 (used reg = )
27038 7C71           E8         89BE            call	_write_word
27039 7C74           83C4                   06  add	sp,*6
27040                                           !BCC_EOS
27041                                           ! 4048         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
27042                                           ! Debug: list * struct  = const $244 (used reg = )
27043 7C77           B8                   0244  mov	ax,#$244
27044 7C7A           50                         push	ax
27045                                           ! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
27046 7C7B           8B46         0C            mov	ax,$C[bp]
27047                                           ! Debug: list unsigned int = ax+$1A (used reg = )
27048 7C7E           05                   001A  add	ax,*$1A
27049 7C81           50                         push	ax
27050                                           ! Debug: list unsigned short DS = [S+$32+4] (used reg = )
27051 7C82           FF76         06            push	6[bp]
27052                                           ! Debug: func () void = write_word+0 (used reg = )
27053 7C85           E8         89AA            call	_write_word
27054 7C88           83C4                   06  add	sp,*6
27055                                           !BCC_EOS
27056                                           ! 4049         channel = device / 2;
27057                                           ! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27058 7C8B           8A46         FD            mov	al,-3[bp]
27059 7C8E           30E4                       xor	ah,ah
27060 7C90           D1E8                       shr	ax,*1
27061                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
27062 7C92           8846         DF            mov	-$21[bp],al
27063                                           !BCC_EOS
27064                                           ! 4050         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27065                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27066 7C95           8A46         DF            mov	al,-$21[bp]
27067 7C98           30E4                       xor	ah,ah
27068 7C9A           B1                     03  mov	cl,*3
27069 7C9C           D3E0                       shl	ax,cl
27070 7C9E           89C3                       mov	bx,ax
27071                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27072                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27073 7CA0           81C3                 0124  add	bx,#$124
27074 7CA4           53                         push	bx
27075                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27076 7CA5           FF76         FE            push	-2[bp]
27077                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27078 7CA8           E8         895C            call	_read_word
27079 7CAB           83C4                   04  add	sp,*4
27080                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27081 7CAE           8946         D8            mov	-$28[bp],ax
27082                                           !BCC_EOS
27083                                           ! 4051         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
27084                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27085 7CB1           8A46         DF            mov	al,-$21[bp]
27086 7CB4           30E4                       xor	ah,ah
27087 7CB6           B1                     03  mov	cl,*3
27088 7CB8           D3E0                       shl	ax,cl
27089 7CBA           89C3                       mov	bx,ax
27090                                           ! Debug: address unsigned short = [bx+$126] (used reg = )
27091                                           ! Debug: list * unsigned short = bx+$126 (used reg = )
27092 7CBC           81C3                 0126  add	bx,#$126
27093 7CC0           53                         push	bx
27094                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27095 7CC1           FF76         FE            push	-2[bp]
27096                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27097 7CC4           E8         8940            call	_read_word
27098 7CC7           83C4                   04  add	sp,*4
27099                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27100 7CCA           8946         D6            mov	-$2A[bp],ax
27101                                           !BCC_EOS
27102                                           ! 4052         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
27103                                           ! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
27104 7CCD           8A46         DF            mov	al,-$21[bp]
27105 7CD0           30E4                       xor	ah,ah
27106 7CD2           B1                     03  mov	cl,*3
27107 7CD4           D3E0                       shl	ax,cl
27108 7CD6           89C3                       mov	bx,ax
27109                                           ! Debug: address unsigned char = [bx+$128] (used reg = )
27110                                           ! Debug: list * unsigned char = bx+$128 (used reg = )
27111 7CD8           81C3                 0128  add	bx,#$128
27112 7CDC           53                         push	bx
27113                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27114 7CDD           FF76         FE            push	-2[bp]
27115                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27116 7CE0           E8         8911            call	_read_byte
27117 7CE3           83C4                   04  add	sp,*4
27118                                           ! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
27119 7CE6           8846         DD            mov	-$23[bp],al
27120                                           !BCC_EOS
27121                                           ! 4053         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
27122                                           ! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
27123 7CE9           8A46         FD            mov	al,-3[bp]
27124 7CEC           30E4                       xor	ah,ah
27125 7CEE           B9                   001E  mov	cx,*$1E
27126 7CF1           F7E9                       imul	cx
27127 7CF3           89C3                       mov	bx,ax
27128                                           ! Debug: address unsigned char = [bx+$146] (used reg = )
27129                                           ! Debug: list * unsigned char = bx+$146 (used reg = )
27130 7CF5           81C3                 0146  add	bx,#$146
27131 7CF9           53                         push	bx
27132                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27133 7CFA           FF76         FE            push	-2[bp]
27134                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27135 7CFD           E8         88F4            call	_read_byte
27136 7D00           83C4                   04  add	sp,*4
27137                                           ! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
27138 7D03           8846         DC            mov	-$24[bp],al
27139                                           !BCC_EOS
27140                                           ! 4054         options = (1<<4);
27141                                           ! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
27142 7D06           B8                   0010  mov	ax,*$10
27143 7D09           8946         D4            mov	-$2C[bp],ax
27144                                           !BCC_EOS
27145                                           ! 4055         options |= (1<<5);
27146                                           ! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
27147 7D0C           8B46         D4            mov	ax,-$2C[bp]
27148 7D0F           0C                     20  or	al,*$20
27149 7D11           8946         D4            mov	-$2C[bp],ax
27150                                           !BCC_EOS
27151                                           ! 4056         options |= (1<<6);
27152                                           ! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
27153 7D14           8B46         D4            mov	ax,-$2C[bp]
27154 7D17           0C                     40  or	al,*$40
27155 7D19           8946         D4            mov	-$2C[bp],ax
27156                                           !BCC_EOS
27157                                           ! 4057         options |= (mode==0x01?1:0<<7);
27158                                           ! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
27159 7D1C           8A46         DC            mov	al,-$24[bp]
27160 7D1F           3C                     01  cmp	al,*1
27161 7D21           75           04            jne 	.5C2
27162                       00007D23            .5C3:
27163 7D23           B0                     01  mov	al,*1
27164 7D25           EB           02            jmp .5C4
27165                       00007D27            .5C2:
27166 7D27           30C0                       xor	al,al
27167                       00007D29            .5C4:
27168                                           ! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
27169 7D29           30E4                       xor	ah,ah
27170 7D2B           0B46         D4            or	ax,-$2C[bp]
27171 7D2E           8946         D4            mov	-$2C[bp],ax
27172                                           !BCC_EOS
27173                                           ! 4058         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
27174                                           ! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
27175 7D31           FF76         D8            push	-$28[bp]
27176                                           ! Debug: list * unsigned short = const $244 (used reg = )
27177 7D34           B8                   0244  mov	ax,#$244
27178 7D37           50                         push	ax
27179                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27180 7D38           FF76         FE            push	-2[bp]
27181                                           ! Debug: func () void = write_word+0 (used reg = )
27182 7D3B           E8         88F4            call	_write_word
27183 7D3E           83C4                   06  add	sp,*6
27184                                           !BCC_EOS
27185                                           ! 4059         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
27186                                           ! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
27187 7D41           8B46         D6            mov	ax,-$2A[bp]
27188                                           ! Debug: list unsigned int = ax+6 (used reg = )
27189 7D44           05                   0006  add	ax,*6
27190 7D47           50                         push	ax
27191                                           ! Debug: list * unsigned short = const $246 (used reg = )
27192 7D48           B8                   0246  mov	ax,#$246
27193 7D4B           50                         push	ax
27194                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27195 7D4C           FF76         FE            push	-2[bp]
27196                                           ! Debug: func () void = write_word+0 (used reg = )
27197 7D4F           E8         88E0            call	_write_word
27198 7D52           83C4                   06  add	sp,*6
27199                                           !BCC_EOS
27200                                           ! 4060         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pref
27201                                           ! 4060 ix, (0xe | (device % 2))<<4 );
27202                                           ! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
27203 7D55           8A46         FD            mov	al,-3[bp]
27204 7D58           30E4                       xor	ah,ah
27205 7D5A           24                     01  and	al,*1
27206                                           ! Debug: or unsigned char = al+0 to int = const $E (used reg = )
27207                                           ! Debug: expression subtree swapping
27208 7D5C           0C                     0E  or	al,*$E
27209                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
27210 7D5E           30E4                       xor	ah,ah
27211 7D60           B1                     04  mov	cl,*4
27212 7D62           D3E0                       shl	ax,cl
27213                                           ! Debug: list unsigned int = ax+0 (used reg = )
27214 7D64           50                         push	ax
27215                                           ! Debug: list * unsigned char = const $248 (used reg = )
27216 7D65           B8                   0248  mov	ax,#$248
27217 7D68           50                         push	ax
27218                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27219 7D69           FF76         FE            push	-2[bp]
27220                                           ! Debug: func () void = write_byte+0 (used reg = )
27221 7D6C           E8         88AB            call	_write_byte
27222 7D6F           83C4                   06  add	sp,*6
27223                                           !BCC_EOS
27224                                           ! 4061         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
27225                                           ! Debug: list int = const $CB (used reg = )
27226 7D72           B8                   00CB  mov	ax,#$CB
27227 7D75           50                         push	ax
27228                                           ! Debug: list * unsigned char = const $249 (used reg = )
27229 7D76           B8                   0249  mov	ax,#$249
27230 7D79           50                         push	ax
27231                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27232 7D7A           FF76         FE            push	-2[bp]
27233                                           ! Debug: func () void = write_byte+0 (used reg = )
27234 7D7D           E8         889A            call	_write_byte
27235 7D80           83C4                   06  add	sp,*6
27236                                           !BCC_EOS
27237                                           ! 4062         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
27238                                           ! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
27239 7D83           8A46         DD            mov	al,-$23[bp]
27240 7D86           30E4                       xor	ah,ah
27241 7D88           50                         push	ax
27242                                           ! Debug: list * unsigned char = const $24A (used reg = )
27243 7D89           B8                   024A  mov	ax,#$24A
27244 7D8C           50                         push	ax
27245                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27246 7D8D           FF76         FE            push	-2[bp]
27247                                           ! Debug: func () void = write_byte+0 (used reg = )
27248 7D90           E8         8887            call	_write_byte
27249 7D93           83C4                   06  add	sp,*6
27250                                           !BCC_EOS
27251                                           ! 4063         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
27252                                           ! Debug: list int = const 1 (used reg = )
27253 7D96           B8                   0001  mov	ax,*1
27254 7D99           50                         push	ax
27255                                           ! Debug: list * unsigned char = const $24B (used reg = )
27256 7D9A           B8                   024B  mov	ax,#$24B
27257 7D9D           50                         push	ax
27258                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27259 7D9E           FF76         FE            push	-2[bp]
27260                                           ! Debug: func () void = write_byte+0 (used reg = )
27261 7DA1           E8         8876            call	_write_byte
27262 7DA4           83C4                   06  add	sp,*6
27263                                           !BCC_EOS
27264                                           ! 4064         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
27265                                           ! Debug: list int = const 0 (used reg = )
27266 7DA7           31C0                       xor	ax,ax
27267 7DA9           50                         push	ax
27268                                           ! Debug: list * unsigned char = const $24C (used reg = )
27269 7DAA           B8                   024C  mov	ax,#$24C
27270 7DAD           50                         push	ax
27271                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27272 7DAE           FF76         FE            push	-2[bp]
27273                                           ! Debug: func () void = write_byte+0 (used reg = )
27274 7DB1           E8         8866            call	_write_byte
27275 7DB4           83C4                   06  add	sp,*6
27276                                           !BCC_EOS
27277                                           ! 4065         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
27278                                           ! Debug: list int = const 0 (used reg = )
27279 7DB7           31C0                       xor	ax,ax
27280 7DB9           50                         push	ax
27281                                           ! Debug: list * unsigned char = const $24D (used reg = )
27282 7DBA           B8                   024D  mov	ax,#$24D
27283 7DBD           50                         push	ax
27284                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27285 7DBE           FF76         FE            push	-2[bp]
27286                                           ! Debug: func () void = write_byte+0 (used reg = )
27287 7DC1           E8         8856            call	_write_byte
27288 7DC4           83C4                   06  add	sp,*6
27289                                           !BCC_EOS
27290                                           ! 4066         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
27291                                           ! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
27292 7DC7           FF76         D4            push	-$2C[bp]
27293                                           ! Debug: list * unsigned short = const $24E (used reg = )
27294 7DCA           B8                   024E  mov	ax,#$24E
27295 7DCD           50                         push	ax
27296                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27297 7DCE           FF76         FE            push	-2[bp]
27298                                           ! Debug: func () void = write_word+0 (used reg = )
27299 7DD1           E8         885E            call	_write_word
27300 7DD4           83C4                   06  add	sp,*6
27301                                           !BCC_EOS
27302                                           ! 4067         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
27303                                           ! Debug: list int = const 0 (used reg = )
27304 7DD7           31C0                       xor	ax,ax
27305 7DD9           50                         push	ax
27306                                           ! Debug: list * unsigned short = const $250 (used reg = )
27307 7DDA           B8                   0250  mov	ax,#$250
27308 7DDD           50                         push	ax
27309                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27310 7DDE           FF76         FE            push	-2[bp]
27311                                           ! Debug: func () void = write_word+0 (used reg = )
27312 7DE1           E8         884E            call	_write_word
27313 7DE4           83C4                   06  add	sp,*6
27314                                           !BCC_EOS
27315                                           ! 4068         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
27316                                           ! Debug: list int = const $11 (used reg = )
27317 7DE7           B8                   0011  mov	ax,*$11
27318 7DEA           50                         push	ax
27319                                           ! Debug: list * unsigned char = const $252 (used reg = )
27320 7DEB           B8                   0252  mov	ax,#$252
27321 7DEE           50                         push	ax
27322                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27323 7DEF           FF76         FE            push	-2[bp]
27324                                           ! Debug: func () void = write_byte+0 (used reg = )
27325 7DF2           E8         8825            call	_write_byte
27326 7DF5           83C4                   06  add	sp,*6
27327                                           !BCC_EOS
27328                                           ! 4069         checksum=0;
27329                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27330 7DF8           30C0                       xor	al,al
27331 7DFA           8846         DB            mov	-$25[bp],al
27332                                           !BCC_EOS
27333                                           ! 4070         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
27334                                           ! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
27335 7DFD           30C0                       xor	al,al
27336 7DFF           8846         DA            mov	-$26[bp],al
27337                                           !BCC_EOS
27338                                           !BCC_EOS
27339 7E02           EB           24            jmp .5C7
27340                       00007E04            .5C8:
27341                                           ! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
27342 7E04           8A46         DA            mov	al,-$26[bp]
27343 7E07           30E4                       xor	ah,ah
27344                                           ! Debug: list * unsigned char = ax+$244 (used reg = )
27345 7E09           05                   0244  add	ax,#$244
27346 7E0C           50                         push	ax
27347                                           ! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
27348 7E0D           FF76         FE            push	-2[bp]
27349                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27350 7E10           E8         87E1            call	_read_byte
27351 7E13           83C4                   04  add	sp,*4
27352                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27353 7E16           30E4                       xor	ah,ah
27354 7E18           0246         DB            add	al,-$25[bp]
27355 7E1B           80D4                   00  adc	ah,*0
27356 7E1E           8846         DB            mov	-$25[bp],al
27357                                           !BCC_EOS
27358                                           ! 4071         checksum = ~checksum;
27359                       00007E21            .5C6:
27360                                           ! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
27361 7E21           8A46         DA            mov	al,-$26[bp]
27362 7E24           40                         inc	ax
27363 7E25           8846         DA            mov	-$26[bp],al
27364                       00007E28            .5C7:
27365                                           ! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
27366 7E28           8A46         DA            mov	al,-$26[bp]
27367 7E2B           3C                     0F  cmp	al,*$F
27368 7E2D           72           D5            jb 	.5C8
27369                       00007E2F            .5C9:
27370                       00007E2F            .5C5:
27371                                           ! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
27372 7E2F           8A46         DB            mov	al,-$25[bp]
27373 7E32           30E4                       xor	ah,ah
27374 7E34           F7D0                       not	ax
27375                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
27376 7E36           8846         DB            mov	-$25[bp],al
27377                                           !BCC_EOS
27378                                           ! 4072         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
27379                                           ! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
27380 7E39           8A46         DB            mov	al,-$25[bp]
27381 7E3C           30E4                       xor	ah,ah
27382 7E3E           50                         push	ax
27383                                           ! Debug: list * unsigned char = const $253 (used reg = )
27384 7E3F           B8                   0253  mov	ax,#$253
27385 7E42           50                         push	ax
27386                                           ! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
27387 7E43           FF76         FE            push	-2[bp]
27388                                           ! Debug: func () void = write_byte+0 (used reg = )
27389 7E46           E8         87D1            call	_write_byte
27390 7E49           83C4                   06  add	sp,*6
27391                                           !BCC_EOS
27392                                           ! 4073         }
27393                                           ! 4074       if(size >= 0x42) {
27394                       00007E4C            .5C0:
27395                                           ! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
27396 7E4C           8B46         E0            mov	ax,-$20[bp]
27397 7E4F           3D                   0042  cmp	ax,*$42
27398 7E52         0F82         023B            blo 	.5CA
27399                       00007E56            .5CB:
27400                                           ! 4075         Bit8u channel, iface, checksum, i;
27401                                           !BCC_EOS
27402                                           ! 4076         Bit16u iobase1;
27403                                           !BCC_EOS
27404                                           ! 4077         channel = device / 2;
27405                                           ! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
27406 7E56           8A46         FD            mov	al,-3[bp]
27407 7E59           30E4                       xor	ah,ah
27408 7E5B           D1E8                       shr	ax,*1
27409                                           ! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
27410 7E5D           8846         DF            mov	-$21[bp],al
27411                                           !BCC_EOS
27412                                           ! 4078         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
27413                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
27414 7E60           8A46         DF            mov	al,-$21[bp]
27415 7E63           30E4                       xor	ah,ah
27416 7E65           B1                     03  mov	cl,*3
27417 7E67           D3E0                       shl	ax,cl
27418 7E69           89C3                       mov	bx,ax
27419                                           ! Debug: address unsigned char = [bx+$122] (used reg = )
27420                                           ! Debug: list * unsigned char = bx+$122 (used reg = )
27421 7E6B           81C3                 0122  add	bx,#$122
27422 7E6F           53                         push	bx
27423                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
27424 7E70           FF76         FE            push	-2[bp]
27425                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27426 7E73           E8         877E            call	_read_byte
27427 7E76           83C4                   04  add	sp,*4
27428                                           ! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
27429 7E79           8846         DE            mov	-$22[bp],al
27430                                           !BCC_EOS
27431                                           ! 4079         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
27432                                           ! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
27433 7E7C           8A46         DF            mov	al,-$21[bp]
27434 7E7F           30E4                       xor	ah,ah
27435 7E81           B1                     03  mov	cl,*3
27436 7E83           D3E0                       shl	ax,cl
27437 7E85           89C3                       mov	bx,ax
27438                                           ! Debug: address unsigned short = [bx+$124] (used reg = )
27439                                           ! Debug: list * unsigned short = bx+$124 (used reg = )
27440 7E87           81C3                 0124  add	bx,#$124
27441 7E8B           53                         push	bx
27442                                           ! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
27443 7E8C           FF76         FE            push	-2[bp]
27444                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
27445 7E8F           E8         8775            call	_read_word
27446 7E92           83C4                   04  add	sp,*4
27447                                           ! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
27448 7E95           8946         DA            mov	-$26[bp],ax
27449                                           !BCC_EOS
27450                                           ! 4080         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
27451                                           ! Debug: list int = const $42 (used reg = )
27452 7E98           B8                   0042  mov	ax,*$42
27453 7E9B           50                         push	ax
27454                                           ! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
27455 7E9C           8B46         0C            mov	ax,$C[bp]
27456                                           ! Debug: list unsigned int = ax+0 (used reg = )
27457 7E9F           50                         push	ax
27458                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27459 7EA0           FF76         06            push	6[bp]
27460                                           ! Debug: func () void = write_word+0 (used reg = )
27461 7EA3           E8         878C            call	_write_word
27462 7EA6           83C4                   06  add	sp,*6
27463                                           !BCC_EOS
27464                                           ! 4081         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
27465                                           ! Debug: list unsigned int = const $BEDD (used reg = )
27466 7EA9           B8                   BEDD  mov	ax,#$BEDD
27467 7EAC           50                         push	ax
27468                                           ! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
27469 7EAD           8B46         0C            mov	ax,$C[bp]
27470                                           ! Debug: list unsigned int = ax+$1E (used reg = )
27471 7EB0           05                   001E  add	ax,*$1E
27472 7EB3           50                         push	ax
27473                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27474 7EB4           FF76         06            push	6[bp]
27475                                           ! Debug: func () void = write_word+0 (used reg = )
27476 7EB7           E8         8778            call	_write_word
27477 7EBA           83C4                   06  add	sp,*6
27478                                           !BCC_EOS
27479                                           ! 4082         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
27480                                           ! Debug: list int = const $24 (used reg = )
27481 7EBD           B8                   0024  mov	ax,*$24
27482 7EC0           50                         push	ax
27483                                           ! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
27484 7EC1           8B46         0C            mov	ax,$C[bp]
27485                                           ! Debug: list unsigned int = ax+$20 (used reg = )
27486 7EC4           05                   0020  add	ax,*$20
27487 7EC7           50                         push	ax
27488                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27489 7EC8           FF76         06            push	6[bp]
27490                                           ! Debug: func () void = write_byte+0 (used reg = )
27491 7ECB           E8         874C            call	_write_byte
27492 7ECE           83C4                   06  add	sp,*6
27493                                           !BCC_EOS
27494                                           ! 4083         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
27495                                           ! Debug: list int = const 0 (used reg = )
27496 7ED1           31C0                       xor	ax,ax
27497 7ED3           50                         push	ax
27498                                           ! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
27499 7ED4           8B46         0C            mov	ax,$C[bp]
27500                                           ! Debug: list unsigned int = ax+$21 (used reg = )
27501 7ED7           05                   0021  add	ax,*$21
27502 7EDA           50                         push	ax
27503                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27504 7EDB           FF76         06            push	6[bp]
27505                                           ! Debug: func () void = write_byte+0 (used reg = )
27506 7EDE           E8         8739            call	_write_byte
27507 7EE1           83C4                   06  add	sp,*6
27508                                           !BCC_EOS
27509                                           ! 4084         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
27510                                           ! Debug: list int = const 0 (used reg = )
27511 7EE4           31C0                       xor	ax,ax
27512 7EE6           50                         push	ax
27513                                           ! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
27514 7EE7           8B46         0C            mov	ax,$C[bp]
27515                                           ! Debug: list unsigned int = ax+$22 (used reg = )
27516 7EEA           05                   0022  add	ax,*$22
27517 7EED           50                         push	ax
27518                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27519 7EEE           FF76         06            push	6[bp]
27520                                           ! Debug: func () void = write_word+0 (used reg = )
27521 7EF1           E8         873E            call	_write_word
27522 7EF4           83C4                   06  add	sp,*6
27523                                           !BCC_EOS
27524                                           ! 4085         if (iface==0x00) {
27525                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
27526 7EF7           8A46         DE            mov	al,-$22[bp]
27527 7EFA           84C0                       test	al,al
27528 7EFC           75           51            jne 	.5CC
27529                       00007EFE            .5CD:
27530                                           ! 4086           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
27531                                           ! Debug: list int = const $49 (used reg = )
27532 7EFE           B8                   0049  mov	ax,*$49
27533 7F01           50                         push	ax
27534                                           ! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
27535 7F02           8B46         0C            mov	ax,$C[bp]
27536                                           ! Debug: list unsigned int = ax+$24 (used reg = )
27537 7F05           05                   0024  add	ax,*$24
27538 7F08           50                         push	ax
27539                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27540 7F09           FF76         06            push	6[bp]
27541                                           ! Debug: func () void = write_byte+0 (used reg = )
27542 7F0C           E8         870B            call	_write_byte
27543 7F0F           83C4                   06  add	sp,*6
27544                                           !BCC_EOS
27545                                           ! 4087           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
27546                                           ! Debug: list int = const $53 (used reg = )
27547 7F12           B8                   0053  mov	ax,*$53
27548 7F15           50                         push	ax
27549                                           ! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
27550 7F16           8B46         0C            mov	ax,$C[bp]
27551                                           ! Debug: list unsigned int = ax+$25 (used reg = )
27552 7F19           05                   0025  add	ax,*$25
27553 7F1C           50                         push	ax
27554                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27555 7F1D           FF76         06            push	6[bp]
27556                                           ! Debug: func () void = write_byte+0 (used reg = )
27557 7F20           E8         86F7            call	_write_byte
27558 7F23           83C4                   06  add	sp,*6
27559                                           !BCC_EOS
27560                                           ! 4088           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
27561                                           ! Debug: list int = const $41 (used reg = )
27562 7F26           B8                   0041  mov	ax,*$41
27563 7F29           50                         push	ax
27564                                           ! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
27565 7F2A           8B46         0C            mov	ax,$C[bp]
27566                                           ! Debug: list unsigned int = ax+$26 (used reg = )
27567 7F2D           05                   0026  add	ax,*$26
27568 7F30           50                         push	ax
27569                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27570 7F31           FF76         06            push	6[bp]
27571                                           ! Debug: func () void = write_byte+0 (used reg = )
27572 7F34           E8         86E3            call	_write_byte
27573 7F37           83C4                   06  add	sp,*6
27574                                           !BCC_EOS
27575                                           ! 4089           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
27576                                           ! Debug: list int = const 0 (used reg = )
27577 7F3A           31C0                       xor	ax,ax
27578 7F3C           50                         push	ax
27579                                           ! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
27580 7F3D           8B46         0C            mov	ax,$C[bp]
27581                                           ! Debug: list unsigned int = ax+$27 (used reg = )
27582 7F40           05                   0027  add	ax,*$27
27583 7F43           50                         push	ax
27584                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27585 7F44           FF76         06            push	6[bp]
27586                                           ! Debug: func () void = write_byte+0 (used reg = )
27587 7F47           E8         86D0            call	_write_byte
27588 7F4A           83C4                   06  add	sp,*6
27589                                           !BCC_EOS
27590                                           ! 4090           }
27591                                           ! 4091         else {
27592 7F4D           EB           00            jmp .5CE
27593                       00007F4F            .5CC:
27594                                           ! 4092           }
27595                                           ! 4093         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
27596                       00007F4F            .5CE:
27597                                           ! Debug: list int = const $41 (used reg = )
27598 7F4F           B8                   0041  mov	ax,*$41
27599 7F52           50                         push	ax
27600                                           ! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
27601 7F53           8B46         0C            mov	ax,$C[bp]
27602                                           ! Debug: list unsigned int = ax+$28 (used reg = )
27603 7F56           05                   0028  add	ax,*$28
27604 7F59           50                         push	ax
27605                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27606 7F5A           FF76         06            push	6[bp]
27607                                           ! Debug: func () void = write_byte+0 (used reg = )
27608 7F5D           E8         86BA            call	_write_byte
27609 7F60           83C4                   06  add	sp,*6
27610                                           !BCC_EOS
27611                                           ! 4094         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
27612                                           ! Debug: list int = const $54 (used reg = )
27613 7F63           B8                   0054  mov	ax,*$54
27614 7F66           50                         push	ax
27615                                           ! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
27616 7F67           8B46         0C            mov	ax,$C[bp]
27617                                           ! Debug: list unsigned int = ax+$29 (used reg = )
27618 7F6A           05                   0029  add	ax,*$29
27619 7F6D           50                         push	ax
27620                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27621 7F6E           FF76         06            push	6[bp]
27622                                           ! Debug: func () void = write_byte+0 (used reg = )
27623 7F71           E8         86A6            call	_write_byte
27624 7F74           83C4                   06  add	sp,*6
27625                                           !BCC_EOS
27626                                           ! 4095         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_t
27627                                           ! 4095 ype[2], 'A');
27628                                           ! Debug: list int = const $41 (used reg = )
27629 7F77           B8                   0041  mov	ax,*$41
27630 7F7A           50                         push	ax
27631                                           ! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
27632 7F7B           8B46         0C            mov	ax,$C[bp]
27633                                           ! Debug: list unsigned int = ax+$2A (used reg = )
27634 7F7E           05                   002A  add	ax,*$2A
27635 7F81           50                         push	ax
27636                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27637 7F82           FF76         06            push	6[bp]
27638                                           ! Debug: func () void = write_byte+0 (used reg = )
27639 7F85           E8         8692            call	_write_byte
27640 7F88           83C4                   06  add	sp,*6
27641                                           !BCC_EOS
27642                                           ! 4096         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
27643                                           ! Debug: list int = const 0 (used reg = )
27644 7F8B           31C0                       xor	ax,ax
27645 7F8D           50                         push	ax
27646                                           ! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
27647 7F8E           8B46         0C            mov	ax,$C[bp]
27648                                           ! Debug: list unsigned int = ax+$2B (used reg = )
27649 7F91           05                   002B  add	ax,*$2B
27650 7F94           50                         push	ax
27651                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27652 7F95           FF76         06            push	6[bp]
27653                                           ! Debug: func () void = write_byte+0 (used reg = )
27654 7F98           E8         867F            call	_write_byte
27655 7F9B           83C4                   06  add	sp,*6
27656                                           !BCC_EOS
27657                                           ! 4097         if (iface==0x00) {
27658                                           ! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
27659 7F9E           8A46         DE            mov	al,-$22[bp]
27660 7FA1           84C0                       test	al,al
27661 7FA3           75           3E            jne 	.5CF
27662                       00007FA5            .5D0:
27663                                           ! 4098           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
27664                                           ! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
27665 7FA5           FF76         DA            push	-$26[bp]
27666                                           ! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
27667 7FA8           8B46         0C            mov	ax,$C[bp]
27668                                           ! Debug: list unsigned int = ax+$30 (used reg = )
27669 7FAB           05                   0030  add	ax,*$30
27670 7FAE           50                         push	ax
27671                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27672 7FAF           FF76         06            push	6[bp]
27673                                           ! Debug: func () void = write_word+0 (used reg = )
27674 7FB2           E8         867D            call	_write_word
27675 7FB5           83C4                   06  add	sp,*6
27676                                           !BCC_EOS
27677                                           ! 4099           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
27678                                           ! Debug: list int = const 0 (used reg = )
27679 7FB8           31C0                       xor	ax,ax
27680 7FBA           50                         push	ax
27681                                           ! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
27682 7FBB           8B46         0C            mov	ax,$C[bp]
27683                                           ! Debug: list unsigned int = ax+$32 (used reg = )
27684 7FBE           05                   0032  add	ax,*$32
27685 7FC1           50                         push	ax
27686                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27687 7FC2           FF76         06            push	6[bp]
27688                                           ! Debug: func () void = write_word+0 (used reg = )
27689 7FC5           E8         866A            call	_write_word
27690 7FC8           83C4                   06  add	sp,*6
27691                                           !BCC_EOS
27692                                           ! 4100           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
27693                                           ! Debug: list long = const 0 (used reg = )
27694 7FCB           31C0                       xor	ax,ax
27695 7FCD           31DB                       xor	bx,bx
27696 7FCF           53                         push	bx
27697 7FD0           50                         push	ax
27698                                           ! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
27699 7FD1           8B46         0C            mov	ax,$C[bp]
27700                                           ! Debug: list unsigned int = ax+$34 (used reg = )
27701 7FD4           05                   0034  add	ax,*$34
27702 7FD7           50                         push	ax
27703                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27704 7FD8           FF76         06            push	6[bp]
27705                                           ! Debug: func () void = write_dword+0 (used reg = )
27706 7FDB           E8         80BD            call	_write_dword
27707 7FDE           83C4                   08  add	sp,*8
27708                                           !BCC_EOS
27709                                           ! 4101           }
27710                                           ! 4102         else {
27711 7FE1           EB           00            jmp .5D1
27712                       00007FE3            .5CF:
27713                                           ! 4103           }
27714                                           ! 4104         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
27715                       00007FE3            .5D1:
27716                                           ! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
27717 7FE3           8A46         FD            mov	al,-3[bp]
27718 7FE6           30E4                       xor	ah,ah
27719 7FE8           24                     01  and	al,*1
27720                                           ! Debug: list unsigned char = al+0 (used reg = )
27721 7FEA           30E4                       xor	ah,ah
27722 7FEC           50                         push	ax
27723                                           ! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
27724 7FED           8B46         0C            mov	ax,$C[bp]
27725                                           ! Debug: list unsigned int = ax+$38 (used reg = )
27726 7FF0           05                   0038  add	ax,*$38
27727 7FF3           50                         push	ax
27728                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27729 7FF4           FF76         06            push	6[bp]
27730                                           ! Debug: func () void = write_byte+0 (used reg = )
27731 7FF7           E8         8620            call	_write_byte
27732 7FFA           83C4                   06  add	sp,*6
27733                                           !BCC_EOS
27734                                           ! 4105         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
27735                                           ! Debug: list int = const 0 (used reg = )
27736 7FFD           31C0                       xor	ax,ax
27737 7FFF           50                         push	ax
27738                                           ! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
27739 8000           8B46         0C            mov	ax,$C[bp]
27740                                           ! Debug: list unsigned int = ax+$39 (used reg = )
27741 8003           05                   0039  add	ax,*$39
27742 8006           50                         push	ax
27743                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27744 8007           FF76         06            push	6[bp]
27745                                           ! Debug: func () void = write_byte+0 (used reg = )
27746 800A           E8         860D            call	_write_byte
27747 800D           83C4                   06  add	sp,*6
27748                                           !BCC_EOS
27749                                           ! 4106         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
27750                                           ! Debug: list int = const 0 (used reg = )
27751 8010           31C0                       xor	ax,ax
27752 8012           50                         push	ax
27753                                           ! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
27754 8013           8B46         0C            mov	ax,$C[bp]
27755                                           ! Debug: list unsigned int = ax+$3A (used reg = )
27756 8016           05                   003A  add	ax,*$3A
27757 8019           50                         push	ax
27758                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27759 801A           FF76         06            push	6[bp]
27760                                           ! Debug: func () void = write_word+0 (used reg = )
27761 801D           E8         8612            call	_write_word
27762 8020           83C4                   06  add	sp,*6
27763                                           !BCC_EOS
27764                                           ! 4107         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
27765                                           ! Debug: list long = const 0 (used reg = )
27766 8023           31C0                       xor	ax,ax
27767 8025           31DB                       xor	bx,bx
27768 8027           53                         push	bx
27769 8028           50                         push	ax
27770                                           ! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
27771 8029           8B46         0C            mov	ax,$C[bp]
27772                                           ! Debug: list unsigned int = ax+$3C (used reg = )
27773 802C           05                   003C  add	ax,*$3C
27774 802F           50                         push	ax
27775                                           ! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
27776 8030           FF76         06            push	6[bp]
27777                                           ! Debug: func () void = write_dword+0 (used reg = )
27778 8033           E8         8065            call	_write_dword
27779 8036           83C4                   08  add	sp,*8
27780                                           !BCC_EOS
27781                                           ! 4108         checksum=0;
27782                                           ! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
27783 8039           30C0                       xor	al,al
27784 803B           8846         DD            mov	-$23[bp],al
27785                                           !BCC_EOS
27786                                           ! 4109         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
27787                                           ! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
27788 803E           B0                     1E  mov	al,*$1E
27789 8040           8846         DC            mov	-$24[bp],al
27790                                           !BCC_EOS
27791                                           !BCC_EOS
27792 8043           EB           25            jmp .5D4
27793                       00008045            .5D5:
27794                                           ! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
27795 8045           8B46         0C            mov	ax,$C[bp]
27796 8048           0246         DC            add	al,-$24[bp]
27797 804B           80D4                   00  adc	ah,*0
27798                                           ! Debug: list unsigned int = ax+0 (used reg = )
27799 804E           50                         push	ax
27800                                           ! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
27801 804F           FF76         06            push	6[bp]
27802                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
27803 8052           E8         859F            call	_read_byte
27804 8055           83C4                   04  add	sp,*4
27805                                           ! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
27806 8058           30E4                       xor	ah,ah
27807 805A           0246         DD            add	al,-$23[bp]
27808 805D           80D4                   00  adc	ah,*0
27809 8060           8846         DD            mov	-$23[bp],al
27810                                           !BCC_EOS
27811                                           ! 4110         checksum = ~checksum;
27812                       00008063            .5D3:
27813                                           ! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
27814 8063           8A46         DC            mov	al,-$24[bp]
27815 8066           40                         inc	ax
27816 8067           8846         DC            mov	-$24[bp],al
27817                       0000806A            .5D4:
27818                                           ! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
27819 806A           8A46         DC            mov	al,-$24[bp]
27820 806D           3C                     40  cmp	al,*$40
27821 806F           72           D4            jb 	.5D5
27822                       00008071            .5D6:
27823                       00008071            .5D2:
27824                                           ! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
27825 8071           8A46         DD            mov	al,-$23[bp]
27826 8074           30E4                       xor	ah,ah
27827 8076           F7D0                       not	ax
27828                                           ! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
27829 8078           8846         DD            mov	-$23[bp],al
27830                                           !BCC_EOS
27831                                           ! 4111         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
27832                                           ! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
27833 807B           8A46         DD            mov	al,-$23[bp]
27834 807E           30E4                       xor	ah,ah
27835 8080           50                         push	ax
27836                                           ! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
27837 8081           8B46         0C            mov	ax,$C[bp]
27838                                           ! Debug: list unsigned int = ax+$41 (used reg = )
27839 8084           05                   0041  add	ax,*$41
27840 8087           50                         push	ax
27841                                           ! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
27842 8088           FF76         06            push	6[bp]
27843                                           ! Debug: func () void = write_byte+0 (used reg = )
27844 808B           E8         858C            call	_write_byte
27845 808E           83C4                   06  add	sp,*6
27846                                           !BCC_EOS
27847                                           ! 4112         }
27848                                           ! 4113       goto int13_success;
27849                       00008091            .5CA:
27850 8091           83C4                   0C  add	sp,#..FFE9-..FFEA
27851 8094           E9         00FA            br 	.FFE9
27852                                           !BCC_EOS
27853                                           ! 4114       break;
27854 8097           E9         00C7            br 	.584
27855                                           !BCC_EOS
27856                                           ! 4115     case 0x49:
27857                                           ! 4116       AX = ((AX & 0x00ff) | ((06) << 8));
27858                       0000809A            .5D7:
27859                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27860 809A           8A46         18            mov	al,$18[bp]
27861                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
27862 809D           30E4                       xor	ah,ah
27863 809F           0D                   0600  or	ax,#$600
27864                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
27865 80A2           8946         18            mov	$18[bp],ax
27866                                           !BCC_EOS
27867                                           ! 4117       goto int13_fail_nostatus;
27868 80A5           83C4                   0C  add	sp,#..FFE7-..FFEA
27869 80A8           E9         00DA            br 	.FFE7
27870                                           !BCC_EOS
27871                                           ! 4118       break;
27872 80AB           E9         00B3            br 	.584
27873                                           !BCC_EOS
27874                                           ! 4119     case 0x4e:
27875                                           ! 4120       switch (( AX & 0x00ff )) {
27876                       000080AE            .5D8:
27877                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
27878 80AE           8A46         18            mov	al,$18[bp]
27879 80B1           EB           10            jmp .5DB
27880                                           ! 4121         case 0x01:
27881                                           ! 4122         case 0x03:
27882                       000080B3            .5DC:
27883                                           ! 4123         case 0x04:
27884                       000080B3            .5DD:
27885                                           ! 4124         case 0x06:
27886                       000080B3            .5DE:
27887                                           ! 4125           goto int13_success;
27888                       000080B3            .5DF:
27889 80B3           83C4                   0C  add	sp,#..FFE9-..FFEA
27890 80B6           E9         00D8            br 	.FFE9
27891                                           !BCC_EOS
27892                                           ! 4126           break;
27893 80B9           EB           1A            jmp .5D9
27894                                           !BCC_EOS
27895                                           ! 4127         default :
27896                                           ! 4128           goto int13_fail;
27897                       000080BB            .5E0:
27898 80BB           83C4                   0C  add	sp,#..FFEB-..FFEA
27899 80BE           E9         00A3            br 	.FFEB
27900                                           !BCC_EOS
27901                                           ! 4129         }
27902                                           ! 4130       break;
27903 80C1           EB           12            jmp .5D9
27904                       000080C3            .5DB:
27905 80C3           2C                     01  sub	al,*1
27906 80C5           74           EC            je 	.5DC
27907 80C7           2C                     02  sub	al,*2
27908 80C9           74           E8            je 	.5DD
27909 80CB           2C                     01  sub	al,*1
27910 80CD           74           E4            je 	.5DE
27911 80CF           2C                     02  sub	al,*2
27912 80D1           74           E0            je 	.5DF
27913 80D3           EB           E6            jmp	.5E0
27914                       000080D5            .5D9:
27915 80D5           E9         0089            br 	.584
27916                                           !BCC_EOS
27917                                           ! 4131     case 0x02:
27918                                           ! 4132     case 0x04:
27919                       000080D8            .5E1:
27920                                           ! 4133     case 0x08:
27921                       000080D8            .5E2:
27922                                           ! 4134     case 0x0a:
27923                       000080D8            .5E3:
27924                                           ! 4135     case 0x0b:
27925                       000080D8            .5E4:
27926                                           ! 4136     case 0x18:
27927                       000080D8            .5E5:
27928                                           ! 4137     case 0x50:
27929                       000080D8            .5E6:
27930                                           ! 4138     default:
27931                       000080D8            .5E7:
27932                                           ! 4139       ;
27933                       000080D8            .5E8:
27934                                           !BCC_EOS
27935                                           ! 4140       goto int13_fail;
27936 80D8           83C4                   0C  add	sp,#..FFEB-..FFEA
27937 80DB           E9         0086            br 	.FFEB
27938                                           !BCC_EOS
27939                                           ! 4141       break;
27940 80DE           E9         0080            br 	.584
27941                                           !BCC_EOS
27942                                           ! 4142     }
27943                                           ! 4143 int13_fail:
27944 80E1           EB           7E            jmp .584
27945                       000080E3            .586:
27946 80E3           83C4                   F4  add	sp,*-$C
27947 80E6           2D                   0000  sub	ax,*0
27948 80E9           7C           ED            jl 	.5E8
27949 80EB           3D                   0018  cmp	ax,*$18
27950 80EE           77           3B            ja  	.5E9
27951 80F0           D1E0                       shl	ax,*1
27952 80F2           89C3                       mov	bx,ax
27953 80F4           2E                         seg	cs
27954 80F5           FFA7       80F9            br	.5EA[bx]
27955                       000080F9            .5EA:
27956 80F9                      7763            .word	.587
27957 80FB                      7780            .word	.592
27958 80FD                      80D8            .word	.5E1
27959 80FF                      776C            .word	.58F
27960 8101                      80D8            .word	.5E2
27961 8103                      776C            .word	.590
27962 8105                      80D8            .word	.5E8
27963 8107                      80D8            .word	.5E8
27964 8109                      80D8            .word	.5E3
27965 810B                      7763            .word	.588
27966 810D                      80D8            .word	.5E4
27967 810F                      80D8            .word	.5E5
27968 8111                      7763            .word	.589
27969 8113                      7763            .word	.58A
27970 8115                      80D8            .word	.5E8
27971 8117                      80D8            .word	.5E8
27972 8119                      7763            .word	.58B
27973 811B                      7763            .word	.58C
27974 811D                      80D8            .word	.5E8
27975 811F                      80D8            .word	.5E8
27976 8121                      7763            .word	.58D
27977 8123                      77D1            .word	.596
27978 8125                      7763            .word	.58E
27979 8127                      80D8            .word	.5E8
27980 8129                      80D8            .word	.5E6
27981                       0000812B            .5E9:
27982 812B           2D                   0041  sub	ax,*$41
27983 812E           72           A8            jb 	.5E8
27984 8130           3D                   000F  cmp	ax,*$F
27985 8133           77           29            ja  	.5EB
27986 8135           D1E0                       shl	ax,*1
27987 8137           89C3                       mov	bx,ax
27988 8139           2E                         seg	cs
27989 813A           FFA7       813E            br	.5EC[bx]
27990                       0000813E            .5EC:
27991 813E                      77E5            .word	.597
27992 8140                      7805            .word	.598
27993 8142                      776C            .word	.591
27994 8144                      7805            .word	.599
27995 8146                      79CE            .word	.5A3
27996 8148                      7AEC            .word	.5B6
27997 814A                      7805            .word	.59A
27998 814C                      7B55            .word	.5BB
27999 814E                      809A            .word	.5D7
28000 8150                      80D8            .word	.5E8
28001 8152                      80D8            .word	.5E8
28002 8154                      80D8            .word	.5E8
28003 8156                      80D8            .word	.5E8
28004 8158                      80AE            .word	.5D8
28005 815A                      80D8            .word	.5E8
28006 815C                      80D8            .word	.5E7
28007                       0000815E            .5EB:
28008 815E           E9         FF77            br 	.5E8
28009                       00008161            .584:
28010                       FFFFFFD2            ..FFEA	=	-$2E
28011 8161           83C4                   0C  add	sp,*$C
28012                       00008164            .FFEB:
28013                       FFFFFFDE            ..FFEB	=	-$22
28014                                           ! 4144     AX = ((AX & 0x00ff) | ((0x01) << 8));
28015                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28016 8164           8A46         18            mov	al,$18[bp]
28017                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28018 8167           30E4                       xor	ah,ah
28019 8169           0D                   0100  or	ax,#$100
28020                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
28021 816C           8946         18            mov	$18[bp],ax
28022                                           !BCC_EOS
28023                                           ! 4145 int13_fail_noah:
28024                       0000816F            .FFE8:
28025                       FFFFFFDE            ..FFE8	=	-$22
28026                                           ! 4146     write_byte(0x0040, 0x0074, ( AX >> 8 ));
28027                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
28028 816F           8B46         18            mov	ax,$18[bp]
28029 8172           88E0                       mov	al,ah
28030 8174           30E4                       xor	ah,ah
28031                                           ! Debug: list unsigned int = ax+0 (used reg = )
28032 8176           50                         push	ax
28033                                           ! Debug: list int = const $74 (used reg = )
28034 8177           B8                   0074  mov	ax,*$74
28035 817A           50                         push	ax
28036                                           ! Debug: list int = const $40 (used reg = )
28037 817B           B8                   0040  mov	ax,*$40
28038 817E           50                         push	ax
28039                                           ! Debug: func () void = write_byte+0 (used reg = )
28040 817F           E8         8498            call	_write_byte
28041 8182           83C4                   06  add	sp,*6
28042                                           !BCC_EOS
28043                                           ! 4147 int13_fail_nostatus:
28044                       00008185            .FFE7:
28045                       FFFFFFDE            ..FFE7	=	-$22
28046                                           ! 4148     FLAGS |= 0x0001;
28047                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28048 8185           8B46         1E            mov	ax,$1E[bp]
28049 8188           0C                     01  or	al,*1
28050 818A           8946         1E            mov	$1E[bp],ax
28051                                           !BCC_EOS
28052                                           ! 4149     return;
28053 818D           89EC                       mov	sp,bp
28054 818F           5D                         pop	bp
28055 8190           C3                         ret
28056                                           !BCC_EOS
28057                                           ! 4150 int13_success:
28058                       00008191            .FFE9:
28059                       FFFFFFDE            ..FFE9	=	-$22
28060                                           ! 4151     AX = ((AX & 0x00ff) | ((0x00) << 8));
28061                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
28062 8191           8A46         18            mov	al,$18[bp]
28063                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28064 8194           0C                     00  or	al,*0
28065                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
28066 8196           30E4                       xor	ah,ah
28067 8198           8946         18            mov	$18[bp],ax
28068                                           !BCC_EOS
28069                                           ! 4152 int13_success_noah:
28070                       0000819B            .FFE6:
28071                       FFFFFFDE            ..FFE6	=	-$22
28072                                           ! 4153     write_byte(0x0040, 0x0074, 0x00);
28073                                           ! Debug: list int = const 0 (used reg = )
28074 819B           31C0                       xor	ax,ax
28075 819D           50                         push	ax
28076                                           ! Debug: list int = const $74 (used reg = )
28077 819E           B8                   0074  mov	ax,*$74
28078 81A1           50                         push	ax
28079                                           ! Debug: list int = const $40 (used reg = )
28080 81A2           B8                   0040  mov	ax,*$40
28081 81A5           50                         push	ax
28082                                           ! Debug: func () void = write_byte+0 (used reg = )
28083 81A6           E8         8471            call	_write_byte
28084 81A9           83C4                   06  add	sp,*6
28085                                           !BCC_EOS
28086                                           ! 4154     FLAGS &= 0xfffe;
28087                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
28088 81AC           8B46         1E            mov	ax,$1E[bp]
28089 81AF           24                     FE  and	al,#$FE
28090 81B1           8946         1E            mov	$1E[bp],ax
28091                                           !BCC_EOS
28092                                           ! 4155     return;
28093 81B4           89EC                       mov	sp,bp
28094 81B6           5D                         pop	bp
28095 81B7           C3                         ret
28096                                           !BCC_EOS
28097                                           ! 4156 }
28098                                           ! 4157   void
28099                                           ! Register BX used in function int13_cdrom
28100                                           ! 4158 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28101                                           ! 4159   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28102                                           export	_int13_eltorito
28103                       000081B8            _int13_eltorito:
28104                                           !BCC_EOS
28105                                           ! 4160 {
28106                                           ! 4161   Bit16u ebda_seg=read_word(0x0040,0x000E);
28107 81B8           55                         push	bp
28108 81B9           89E5                       mov	bp,sp
28109 81BB           4C                         dec	sp
28110 81BC           4C                         dec	sp
28111                                           ! Debug: list int = const $E (used reg = )
28112 81BD           B8                   000E  mov	ax,*$E
28113 81C0           50                         push	ax
28114                                           ! Debug: list int = const $40 (used reg = )
28115 81C1           B8                   0040  mov	ax,*$40
28116 81C4           50                         push	ax
28117                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28118 81C5           E8         843F            call	_read_word
28119 81C8           83C4                   04  add	sp,*4
28120                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28121 81CB           8946         FE            mov	-2[bp],ax
28122                                           !BCC_EOS
28123                                           ! 4162   ;
28124                                           !BCC_EOS
28125                                           ! 4163   switch (( AX >> 8 )) {
28126                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28127 81CE           8B46         16            mov	ax,$16[bp]
28128 81D1           88E0                       mov	al,ah
28129 81D3           30E4                       xor	ah,ah
28130 81D5           E9         01A8            br 	.5EF
28131                                           ! 4164     case 0x4a:
28132                                           ! 4165     case 0x4c:
28133                       000081D8            .5F0:
28134                                           ! 4166     case 0x4d:
28135                       000081D8            .5F1:
28136                                           ! 4167       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. 
28137                       000081D8            .5F2:
28138                                           ! 4167 Please report\n",AX);
28139                                           ! Debug: list unsigned short AX = [S+4+$14] (used reg = )
28140 81D8           FF76         16            push	$16[bp]
28141                                           ! Debug: list * char = .5F3+0 (used reg = )
28142 81DB           BB                   D116  mov	bx,#.5F3
28143 81DE           53                         push	bx
28144                                           ! Debug: list int = const 7 (used reg = )
28145 81DF           B8                   0007  mov	ax,*7
28146 81E2           50                         push	ax
28147                                           ! Debug: func () void = bios_printf+0 (used reg = )
28148 81E3           E8         8835            call	_bios_printf
28149 81E6           83C4                   06  add	sp,*6
28150                                           !BCC_EOS
28151                                           ! 4168       goto int13_fail;
28152 81E9           83C4                   00  add	sp,#..FFE4-..FFE5
28153 81EC           E9         01AF            br 	.FFE4
28154                                           !BCC_EOS
28155                                           ! 4169       break;
28156 81EF           E9         01AC            br 	.5ED
28157                                           !BCC_EOS
28158                                           ! 4170     case 0x4b:
28159                                           ! 4171       write_byte(DS,SI+0x00,0x13);
28160                       000081F2            .5F4:
28161                                           ! Debug: list int = const $13 (used reg = )
28162 81F2           B8                   0013  mov	ax,*$13
28163 81F5           50                         push	ax
28164                                           ! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
28165 81F6           8B46         0A            mov	ax,$A[bp]
28166                                           ! Debug: list unsigned int = ax+0 (used reg = )
28167 81F9           50                         push	ax
28168                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28169 81FA           FF76         04            push	4[bp]
28170                                           ! Debug: func () void = write_byte+0 (used reg = )
28171 81FD           E8         841A            call	_write_byte
28172 8200           83C4                   06  add	sp,*6
28173                                           !BCC_EOS
28174                                           ! 4172       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
28175                                           ! Debug: list * unsigned char = const $25B (used reg = )
28176 8203           B8                   025B  mov	ax,#$25B
28177 8206           50                         push	ax
28178                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28179 8207           FF76         FE            push	-2[bp]
28180                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28181 820A           E8         83E7            call	_read_byte
28182 820D           83C4                   04  add	sp,*4
28183                                           ! Debug: list unsigned char = al+0 (used reg = )
28184 8210           30E4                       xor	ah,ah
28185 8212           50                         push	ax
28186                                           ! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
28187 8213           8B46         0A            mov	ax,$A[bp]
28188                                           ! Debug: list unsigned int = ax+1 (used reg = )
28189 8216           40                         inc	ax
28190 8217           50                         push	ax
28191                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28192 8218           FF76         04            push	4[bp]
28193                                           ! Debug: func () void = write_byte+0 (used reg = )
28194 821B           E8         83FC            call	_write_byte
28195 821E           83C4                   06  add	sp,*6
28196                                           !BCC_EOS
28197                                           ! 4173       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
28198                                           ! Debug: list * unsigned char = const $25C (used reg = )
28199 8221           B8                   025C  mov	ax,#$25C
28200 8224           50                         push	ax
28201                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28202 8225           FF76         FE            push	-2[bp]
28203                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28204 8228           E8         83C9            call	_read_byte
28205 822B           83C4                   04  add	sp,*4
28206                                           ! Debug: list unsigned char = al+0 (used reg = )
28207 822E           30E4                       xor	ah,ah
28208 8230           50                         push	ax
28209                                           ! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
28210 8231           8B46         0A            mov	ax,$A[bp]
28211                                           ! Debug: list unsigned int = ax+2 (used reg = )
28212 8234           40                         inc	ax
28213 8235           40                         inc	ax
28214 8236           50                         push	ax
28215                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28216 8237           FF76         04            push	4[bp]
28217                                           ! Debug: func () void = write_byte+0 (used reg = )
28218 823A           E8         83DD            call	_write_byte
28219 823D           83C4                   06  add	sp,*6
28220                                           !BCC_EOS
28221                                           ! 4174       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
28222                                           ! Debug: list * unsigned char = const $25D (used reg = )
28223 8240           B8                   025D  mov	ax,#$25D
28224 8243           50                         push	ax
28225                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28226 8244           FF76         FE            push	-2[bp]
28227                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28228 8247           E8         83AA            call	_read_byte
28229 824A           83C4                   04  add	sp,*4
28230                                           ! Debug: list unsigned char = al+0 (used reg = )
28231 824D           30E4                       xor	ah,ah
28232 824F           50                         push	ax
28233                                           ! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
28234 8250           8B46         0A            mov	ax,$A[bp]
28235                                           ! Debug: list unsigned int = ax+3 (used reg = )
28236 8253           05                   0003  add	ax,*3
28237 8256           50                         push	ax
28238                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28239 8257           FF76         04            push	4[bp]
28240                                           ! Debug: func () void = write_byte+0 (used reg = )
28241 825A           E8         83BD            call	_write_byte
28242 825D           83C4                   06  add	sp,*6
28243                                           !BCC_EOS
28244                                           ! 4175       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
28245                                           ! Debug: list * unsigned long = const $260 (used reg = )
28246 8260           B8                   0260  mov	ax,#$260
28247 8263           50                         push	ax
28248                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28249 8264           FF76         FE            push	-2[bp]
28250                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
28251 8267           E8         7E19            call	_read_dword
28252 826A           89D3                       mov	bx,dx
28253 826C           83C4                   04  add	sp,*4
28254                                           ! Debug: list unsigned long = bx+0 (used reg = )
28255 826F           53                         push	bx
28256 8270           50                         push	ax
28257                                           ! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
28258 8271           8B46         0A            mov	ax,$A[bp]
28259                                           ! Debug: list unsigned int = ax+4 (used reg = )
28260 8274           05                   0004  add	ax,*4
28261 8277           50                         push	ax
28262                                           ! Debug: list unsigned short DS = [S+$A+2] (used reg = )
28263 8278           FF76         04            push	4[bp]
28264                                           ! Debug: func () void = write_dword+0 (used reg = )
28265 827B           E8         7E1D            call	_write_dword
28266 827E           83C4                   08  add	sp,*8
28267                                           !BCC_EOS
28268                                           ! 4176       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
28269                                           ! Debug: list * unsigned short = const $25E (used reg = )
28270 8281           B8                   025E  mov	ax,#$25E
28271 8284           50                         push	ax
28272                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28273 8285           FF76         FE            push	-2[bp]
28274                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28275 8288           E8         837C            call	_read_word
28276 828B           83C4                   04  add	sp,*4
28277                                           ! Debug: list unsigned short = ax+0 (used reg = )
28278 828E           50                         push	ax
28279                                           ! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
28280 828F           8B46         0A            mov	ax,$A[bp]
28281                                           ! Debug: list unsigned int = ax+8 (used reg = )
28282 8292           05                   0008  add	ax,*8
28283 8295           50                         push	ax
28284                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28285 8296           FF76         04            push	4[bp]
28286                                           ! Debug: func () void = write_word+0 (used reg = )
28287 8299           E8         8396            call	_write_word
28288 829C           83C4                   06  add	sp,*6
28289                                           !BCC_EOS
28290                                           ! 4177       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
28291                                           ! Debug: list * unsigned short = const $264 (used reg = )
28292 829F           B8                   0264  mov	ax,#$264
28293 82A2           50                         push	ax
28294                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28295 82A3           FF76         FE            push	-2[bp]
28296                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28297 82A6           E8         835E            call	_read_word
28298 82A9           83C4                   04  add	sp,*4
28299                                           ! Debug: list unsigned short = ax+0 (used reg = )
28300 82AC           50                         push	ax
28301                                           ! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
28302 82AD           8B46         0A            mov	ax,$A[bp]
28303                                           ! Debug: list unsigned int = ax+$A (used reg = )
28304 82B0           05                   000A  add	ax,*$A
28305 82B3           50                         push	ax
28306                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28307 82B4           FF76         04            push	4[bp]
28308                                           ! Debug: func () void = write_word+0 (used reg = )
28309 82B7           E8         8378            call	_write_word
28310 82BA           83C4                   06  add	sp,*6
28311                                           !BCC_EOS
28312                                           ! 4178       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
28313                                           ! Debug: list * unsigned short = const $266 (used reg = )
28314 82BD           B8                   0266  mov	ax,#$266
28315 82C0           50                         push	ax
28316                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28317 82C1           FF76         FE            push	-2[bp]
28318                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28319 82C4           E8         8340            call	_read_word
28320 82C7           83C4                   04  add	sp,*4
28321                                           ! Debug: list unsigned short = ax+0 (used reg = )
28322 82CA           50                         push	ax
28323                                           ! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
28324 82CB           8B46         0A            mov	ax,$A[bp]
28325                                           ! Debug: list unsigned int = ax+$C (used reg = )
28326 82CE           05                   000C  add	ax,*$C
28327 82D1           50                         push	ax
28328                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28329 82D2           FF76         04            push	4[bp]
28330                                           ! Debug: func () void = write_word+0 (used reg = )
28331 82D5           E8         835A            call	_write_word
28332 82D8           83C4                   06  add	sp,*6
28333                                           !BCC_EOS
28334                                           ! 4179       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
28335                                           ! Debug: list * unsigned short = const $268 (used reg = )
28336 82DB           B8                   0268  mov	ax,#$268
28337 82DE           50                         push	ax
28338                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28339 82DF           FF76         FE            push	-2[bp]
28340                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28341 82E2           E8         8322            call	_read_word
28342 82E5           83C4                   04  add	sp,*4
28343                                           ! Debug: list unsigned short = ax+0 (used reg = )
28344 82E8           50                         push	ax
28345                                           ! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
28346 82E9           8B46         0A            mov	ax,$A[bp]
28347                                           ! Debug: list unsigned int = ax+$E (used reg = )
28348 82EC           05                   000E  add	ax,*$E
28349 82EF           50                         push	ax
28350                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28351 82F0           FF76         04            push	4[bp]
28352                                           ! Debug: func () void = write_word+0 (used reg = )
28353 82F3           E8         833C            call	_write_word
28354 82F6           83C4                   06  add	sp,*6
28355                                           !BCC_EOS
28356                                           ! 4180       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
28357                                           ! Debug: list * unsigned short = const $26C (used reg = )
28358 82F9           B8                   026C  mov	ax,#$26C
28359 82FC           50                         push	ax
28360                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28361 82FD           FF76         FE            push	-2[bp]
28362                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28363 8300           E8         82F1            call	_read_byte
28364 8303           83C4                   04  add	sp,*4
28365                                           ! Debug: list unsigned char = al+0 (used reg = )
28366 8306           30E4                       xor	ah,ah
28367 8308           50                         push	ax
28368                                           ! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
28369 8309           8B46         0A            mov	ax,$A[bp]
28370                                           ! Debug: list unsigned int = ax+$10 (used reg = )
28371 830C           05                   0010  add	ax,*$10
28372 830F           50                         push	ax
28373                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28374 8310           FF76         04            push	4[bp]
28375                                           ! Debug: func () void = write_byte+0 (used reg = )
28376 8313           E8         8304            call	_write_byte
28377 8316           83C4                   06  add	sp,*6
28378                                           !BCC_EOS
28379                                           ! 4181       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
28380                                           ! Debug: list * unsigned short = const $26E (used reg = )
28381 8319           B8                   026E  mov	ax,#$26E
28382 831C           50                         push	ax
28383                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28384 831D           FF76         FE            push	-2[bp]
28385                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28386 8320           E8         82D1            call	_read_byte
28387 8323           83C4                   04  add	sp,*4
28388                                           ! Debug: list unsigned char = al+0 (used reg = )
28389 8326           30E4                       xor	ah,ah
28390 8328           50                         push	ax
28391                                           ! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
28392 8329           8B46         0A            mov	ax,$A[bp]
28393                                           ! Debug: list unsigned int = ax+$11 (used reg = )
28394 832C           05                   0011  add	ax,*$11
28395 832F           50                         push	ax
28396                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28397 8330           FF76         04            push	4[bp]
28398                                           ! Debug: func () void = write_byte+0 (used reg = )
28399 8333           E8         82E4            call	_write_byte
28400 8336           83C4                   06  add	sp,*6
28401                                           !BCC_EOS
28402                                           ! 4182       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
28403                                           ! Debug: list * unsigned short = const $26A (used reg = )
28404 8339           B8                   026A  mov	ax,#$26A
28405 833C           50                         push	ax
28406                                           ! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
28407 833D           FF76         FE            push	-2[bp]
28408                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28409 8340           E8         82B1            call	_read_byte
28410 8343           83C4                   04  add	sp,*4
28411                                           ! Debug: list unsigned char = al+0 (used reg = )
28412 8346           30E4                       xor	ah,ah
28413 8348           50                         push	ax
28414                                           ! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
28415 8349           8B46         0A            mov	ax,$A[bp]
28416                                           ! Debug: list unsigned int = ax+$12 (used reg = )
28417 834C           05                   0012  add	ax,*$12
28418 834F           50                         push	ax
28419                                           ! Debug: list unsigned short DS = [S+8+2] (used reg = )
28420 8350           FF76         04            push	4[bp]
28421                                           ! Debug: func () void = write_byte+0 (used reg = )
28422 8353           E8         82C4            call	_write_byte
28423 8356           83C4                   06  add	sp,*6
28424                                           !BCC_EOS
28425                                           ! 4183       if(( AX & 0x00ff ) == 0x00) {
28426                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28427 8359           8A46         16            mov	al,$16[bp]
28428                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
28429 835C           84C0                       test	al,al
28430 835E           75           10            jne 	.5F5
28431                       00008360            .5F6:
28432                                           ! 4184         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
28433                                           ! Debug: list int = const 0 (used reg = )
28434 8360           31C0                       xor	ax,ax
28435 8362           50                         push	ax
28436                                           ! Debug: list * unsigned char = const $25A (used reg = )
28437 8363           B8                   025A  mov	ax,#$25A
28438 8366           50                         push	ax
28439                                           ! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
28440 8367           FF76         FE            push	-2[bp]
28441                                           ! Debug: func () void = write_byte+0 (used reg = )
28442 836A           E8         82AD            call	_write_byte
28443 836D           83C4                   06  add	sp,*6
28444                                           !BCC_EOS
28445                                           ! 4185         }
28446                                           ! 4186       goto int13_success;
28447                       00008370            .5F5:
28448 8370           83C4                   00  add	sp,#..FFE3-..FFE5
28449 8373           EB           56            jmp .FFE3
28450                                           !BCC_EOS
28451                                           ! 4187       break;
28452 8375           EB           27            jmp .5ED
28453                                           !BCC_EOS
28454                                           ! 4188     default:
28455                                           ! 4189       ;
28456                       00008377            .5F7:
28457                                           !BCC_EOS
28458                                           ! 4190       goto int13_fail;
28459 8377           83C4                   00  add	sp,#..FFE4-..FFE5
28460 837A           EB           22            jmp .FFE4
28461                                           !BCC_EOS
28462                                           ! 4191       break;
28463 837C           EB           20            jmp .5ED
28464                                           !BCC_EOS
28465                                           ! 4192     }
28466                                           ! 4193 int13_fail:
28467 837E           EB           1E            jmp .5ED
28468                       00008380            .5EF:
28469 8380           2D                   004A  sub	ax,*$4A
28470 8383         0F84         FE51            beq 	.5F0
28471 8387           2D                   0001  sub	ax,*1
28472 838A         0F84         FE64            beq 	.5F4
28473 838E           2D                   0001  sub	ax,*1
28474 8391         0F84         FE43            beq 	.5F1
28475 8395           2D                   0001  sub	ax,*1
28476 8398         0F84         FE3C            beq 	.5F2
28477 839C           EB           D9            jmp	.5F7
28478                       0000839E            .5ED:
28479                       FFFFFFFC            ..FFE5	=	-4
28480                       0000839E            .FFE4:
28481                       FFFFFFFC            ..FFE4	=	-4
28482                                           ! 4194     AX = ((AX & 0x00ff) | ((0x01) << 8));
28483                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28484 839E           8A46         16            mov	al,$16[bp]
28485                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
28486 83A1           30E4                       xor	ah,ah
28487 83A3           0D                   0100  or	ax,#$100
28488                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
28489 83A6           8946         16            mov	$16[bp],ax
28490                                           !BCC_EOS
28491                                           ! 4195     write_byte(0x0040, 0x0074, ( AX >> 8 ));
28492                                           ! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
28493 83A9           8B46         16            mov	ax,$16[bp]
28494 83AC           88E0                       mov	al,ah
28495 83AE           30E4                       xor	ah,ah
28496                                           ! Debug: list unsigned int = ax+0 (used reg = )
28497 83B0           50                         push	ax
28498                                           ! Debug: list int = const $74 (used reg = )
28499 83B1           B8                   0074  mov	ax,*$74
28500 83B4           50                         push	ax
28501                                           ! Debug: list int = const $40 (used reg = )
28502 83B5           B8                   0040  mov	ax,*$40
28503 83B8           50                         push	ax
28504                                           ! Debug: func () void = write_byte+0 (used reg = )
28505 83B9           E8         825E            call	_write_byte
28506 83BC           83C4                   06  add	sp,*6
28507                                           !BCC_EOS
28508                                           ! 4196     FLAGS |= 0x0001;
28509                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
28510 83BF           8B46         1C            mov	ax,$1C[bp]
28511 83C2           0C                     01  or	al,*1
28512 83C4           8946         1C            mov	$1C[bp],ax
28513                                           !BCC_EOS
28514                                           ! 4197     return;
28515 83C7           89EC                       mov	sp,bp
28516 83C9           5D                         pop	bp
28517 83CA           C3                         ret
28518                                           !BCC_EOS
28519                                           ! 4198 int13_success:
28520                       000083CB            .FFE3:
28521                       FFFFFFFC            ..FFE3	=	-4
28522                                           ! 4199     AX = ((AX & 0x00ff) | ((0x00) << 8));
28523                                           ! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
28524 83CB           8A46         16            mov	al,$16[bp]
28525                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
28526 83CE           0C                     00  or	al,*0
28527                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
28528 83D0           30E4                       xor	ah,ah
28529 83D2           8946         16            mov	$16[bp],ax
28530                                           !BCC_EOS
28531                                           ! 4200     write_byte(0x0040, 0x0074, 0x00);
28532                                           ! Debug: list int = const 0 (used reg = )
28533 83D5           31C0                       xor	ax,ax
28534 83D7           50                         push	ax
28535                                           ! Debug: list int = const $74 (used reg = )
28536 83D8           B8                   0074  mov	ax,*$74
28537 83DB           50                         push	ax
28538                                           ! Debug: list int = const $40 (used reg = )
28539 83DC           B8                   0040  mov	ax,*$40
28540 83DF           50                         push	ax
28541                                           ! Debug: func () void = write_byte+0 (used reg = )
28542 83E0           E8         8237            call	_write_byte
28543 83E3           83C4                   06  add	sp,*6
28544                                           !BCC_EOS
28545                                           ! 4201     FLAGS &= 0xfffe;
28546                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
28547 83E6           8B46         1C            mov	ax,$1C[bp]
28548 83E9           24                     FE  and	al,#$FE
28549 83EB           8946         1C            mov	$1C[bp],ax
28550                                           !BCC_EOS
28551                                           ! 4202     return;
28552 83EE           89EC                       mov	sp,bp
28553 83F0           5D                         pop	bp
28554 83F1           C3                         ret
28555                                           !BCC_EOS
28556                                           ! 4203 }
28557                                           ! 4204   void
28558                                           ! Register BX used in function int13_eltorito
28559                                           ! 4205 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
28560                                           ! 4206   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
28561                                           export	_int13_cdemu
28562                       000083F2            _int13_cdemu:
28563                                           !BCC_EOS
28564                                           ! 4207 {
28565                                           ! 4208   Bit16u ebda_seg=read_word(0x0040,0x000E);
28566 83F2           55                         push	bp
28567 83F3           89E5                       mov	bp,sp
28568 83F5           4C                         dec	sp
28569 83F6           4C                         dec	sp
28570                                           ! Debug: list int = const $E (used reg = )
28571 83F7           B8                   000E  mov	ax,*$E
28572 83FA           50                         push	ax
28573                                           ! Debug: list int = const $40 (used reg = )
28574 83FB           B8                   0040  mov	ax,*$40
28575 83FE           50                         push	ax
28576                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28577 83FF           E8         8205            call	_read_word
28578 8402           83C4                   04  add	sp,*4
28579                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
28580 8405           8946         FE            mov	-2[bp],ax
28581                                           !BCC_EOS
28582                                           ! 4209   Bit8u device, status;
28583                                           !BCC_EOS
28584                                           ! 4210   Bit16u vheads, vspt, vcylinders;
28585                                           !BCC_EOS
28586                                           ! 4211   Bit16u head, sector, cylinder, nbsectors;
28587                                           !BCC_EOS
28588                                           ! 4212   Bit32u vlba, ilba, slba, elba;
28589                                           !BCC_EOS
28590                                           ! 4213   Bit16u before, segment, offset;
28591                                           !BCC_EOS
28592                                           ! 4214   Bit8u atacmd[12];
28593                                           !BCC_EOS
28594                                           ! 4215   ;
28595 8408           83C4                   CE  add	sp,*-$32
28596                                           !BCC_EOS
28597                                           ! 4216   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
28598                                           ! Debug: list * unsigned char = const $25D (used reg = )
28599 840B           B8                   025D  mov	ax,#$25D
28600 840E           50                         push	ax
28601                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28602 840F           FF76         FE            push	-2[bp]
28603                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28604 8412           E8         81DF            call	_read_byte
28605 8415           83C4                   04  add	sp,*4
28606                                           ! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
28607 8418           30E4                       xor	ah,ah
28608 841A           D1E0                       shl	ax,*1
28609                                           ! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
28610 841C           8846         FD            mov	-3[bp],al
28611                                           !BCC_EOS
28612                                           ! 4217 
28613                                           ! 4217   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
28614                                           ! Debug: list * unsigned short = const $25E (used reg = )
28615 841F           B8                   025E  mov	ax,#$25E
28616 8422           50                         push	ax
28617                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28618 8423           FF76         FE            push	-2[bp]
28619                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28620 8426           E8         81CB            call	_read_byte
28621 8429           83C4                   04  add	sp,*4
28622                                           ! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
28623 842C           30E4                       xor	ah,ah
28624 842E           0246         FD            add	al,-3[bp]
28625 8431           80D4                   00  adc	ah,*0
28626 8434           8846         FD            mov	-3[bp],al
28627                                           !BCC_EOS
28628                                           ! 4218   write_byte(0x0040, 0x0074, 0x00);
28629                                           ! Debug: list int = const 0 (used reg = )
28630 8437           31C0                       xor	ax,ax
28631 8439           50                         push	ax
28632                                           ! Debug: list int = const $74 (used reg = )
28633 843A           B8                   0074  mov	ax,*$74
28634 843D           50                         push	ax
28635                                           ! Debug: list int = const $40 (used reg = )
28636 843E           B8                   0040  mov	ax,*$40
28637 8441           50                         push	ax
28638                                           ! Debug: func () void = write_byte+0 (used reg = )
28639 8442           E8         81D5            call	_write_byte
28640 8445           83C4                   06  add	sp,*6
28641                                           !BCC_EOS
28642                                           ! 4219   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
28643                                           ! 4220    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
28644                                           ! Debug: list * unsigned char = const $25A (used reg = )
28645 8448           B8                   025A  mov	ax,#$25A
28646 844B           50                         push	ax
28647                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28648 844C           FF76         FE            push	-2[bp]
28649                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28650 844F           E8         81A2            call	_read_byte
28651 8452           83C4                   04  add	sp,*4
28652                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
28653 8455           84C0                       test	al,al
28654 8457           74           19            je  	.5F9
28655                       00008459            .5FA:
28656                                           ! Debug: expression subtree swapping
28657                                           ! Debug: list * unsigned char = const $25C (used reg = )
28658 8459           B8                   025C  mov	ax,#$25C
28659 845C           50                         push	ax
28660                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28661 845D           FF76         FE            push	-2[bp]
28662                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28663 8460           E8         8191            call	_read_byte
28664 8463           83C4                   04  add	sp,*4
28665 8466           50                         push	ax
28666                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
28667 8467           8A46         12            mov	al,$12[bp]
28668                                           ! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
28669 846A           3A46         CA            cmp	al,-$36[bp]
28670 846D           8D66         CC            lea	sp,-$34[bp]
28671 8470           74           06            je  	.5F8
28672                       00008472            .5F9:
28673                                           ! 4221     ;
28674                                           !BCC_EOS
28675                                           ! 4222     goto int13_fail;
28676 8472           83C4                   00  add	sp,#..FFE2+$36
28677 8475           E9         0531            br 	.FFE2
28678                                           !BCC_EOS
28679                                           ! 4223     }
28680                                           ! 4224   switch (( AX >> 8 )) {
28681                       00008478            .5F8:
28682                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
28683 8478           8B46         16            mov	ax,$16[bp]
28684 847B           88E0                       mov	al,ah
28685 847D           30E4                       xor	ah,ah
28686 847F           E9         04AC            br 	.5FD
28687                                           ! 4225     case 0x00:
28688                                           ! 4226     case 0x09:
28689                       00008482            .5FE:
28690                                           ! 4227     case 0x0c:
28691                       00008482            .5FF:
28692                                           ! 4228     case 0x0d:
28693                       00008482            .600:
28694                                           ! 4229     case 0x10:
28695                       00008482            .601:
28696                                           ! 4230     case 0x11:
28697                       00008482            .602:
28698                                           ! 4231     case 0x14:
28699                       00008482            .603:
28700                                           ! 4232     case 0x16:
28701                       00008482            .604:
28702                                           ! 4233       goto int13_success;
28703                       00008482            .605:
28704 8482           83C4                   00  add	sp,#..FFE0-..FFE1
28705 8485           E9         054E            br 	.FFE0
28706                                           !BCC_EOS
28707                                           ! 4234       break;
28708 8488           E9         051E            br 	.5FB
28709                                           !BCC_EOS
28710                                           ! 4235     case 0x03:
28711                                           ! 4236     case 0x05:
28712                       0000848B            .606:
28713                                           ! 4237       AX = ((AX & 0x00ff) | ((0x03) << 8));
28714                       0000848B            .607:
28715                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
28716 848B           8A46         16            mov	al,$16[bp]
28717                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
28718 848E           30E4                       xor	ah,ah
28719 8490           0D                   0300  or	ax,#$300
28720                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
28721 8493           8946         16            mov	$16[bp],ax
28722                                           !BCC_EOS
28723                                           ! 4238       goto int13_fail_noah;
28724 8496           83C4                   00  add	sp,#..FFDF-..FFE1
28725 8499           E9         0518            br 	.FFDF
28726                                           !BCC_EOS
28727                                           ! 4239       break;
28728 849C           E9         050A            br 	.5FB
28729                                           !BCC_EOS
28730                                           ! 4240     case 0x01:
28731                                           ! 4241       status=read_byte(0x0040, 0x0074);
28732                       0000849F            .608:
28733                                           ! Debug: list int = const $74 (used reg = )
28734 849F           B8                   0074  mov	ax,*$74
28735 84A2           50                         push	ax
28736                                           ! Debug: list int = const $40 (used reg = )
28737 84A3           B8                   0040  mov	ax,*$40
28738 84A6           50                         push	ax
28739                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
28740 84A7           E8         814A            call	_read_byte
28741 84AA           83C4                   04  add	sp,*4
28742                                           ! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
28743 84AD           8846         FC            mov	-4[bp],al
28744                                           !BCC_EOS
28745                                           ! 4242       AX = ((AX & 0x00ff) | ((status) << 8));
28746                                           ! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
28747 84B0           8A46         FC            mov	al,-4[bp]
28748 84B3           30E4                       xor	ah,ah
28749 84B5           88C4                       mov	ah,al
28750 84B7           30C0                       xor	al,al
28751 84B9           50                         push	ax
28752                                           ! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
28753 84BA           8A46         16            mov	al,$16[bp]
28754                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
28755 84BD           30E4                       xor	ah,ah
28756 84BF           0B46         CA            or	ax,0+..FFE1[bp]
28757 84C2           44                         inc	sp
28758 84C3           44                         inc	sp
28759                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
28760 84C4           8946         16            mov	$16[bp],ax
28761                                           !BCC_EOS
28762                                           ! 4243       write_byte(0x0040, 0x0074, 0);
28763                                           ! Debug: list int = const 0 (used reg = )
28764 84C7           31C0                       xor	ax,ax
28765 84C9           50                         push	ax
28766                                           ! Debug: list int = const $74 (used reg = )
28767 84CA           B8                   0074  mov	ax,*$74
28768 84CD           50                         push	ax
28769                                           ! Debug: list int = const $40 (used reg = )
28770 84CE           B8                   0040  mov	ax,*$40
28771 84D1           50                         push	ax
28772                                           ! Debug: func () void = write_byte+0 (used reg = )
28773 84D2           E8         8145            call	_write_byte
28774 84D5           83C4                   06  add	sp,*6
28775                                           !BCC_EOS
28776                                           ! 4244       if (status) goto int13_fail_nostatus;
28777 84D8           8A46         FC            mov	al,-4[bp]
28778 84DB           84C0                       test	al,al
28779 84DD           74           08            je  	.609
28780                       000084DF            .60A:
28781 84DF           83C4                   00  add	sp,#..FFDE-..FFE1
28782 84E2           E9         04E5            br 	.FFDE
28783                                           !BCC_EOS
28784                                           ! 4245       else goto int13_success_noah;
28785 84E5           EB           06            jmp .60B
28786                       000084E7            .609:
28787 84E7           83C4                   00  add	sp,#..FFDD-..FFE1
28788 84EA           E9         04F3            br 	.FFDD
28789                                           !BCC_EOS
28790                                           ! 4246       break;
28791                       000084ED            .60B:
28792 84ED           E9         04B9            br 	.5FB
28793                                           !BCC_EOS
28794                                           ! 4247     case 0x02:
28795                                           ! 4248     case 0x04:
28796                       000084F0            .60C:
28797                                           ! 4249       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
28798                       000084F0            .60D:
28799                                           ! Debug: list * unsigned short = const $26E (used reg = )
28800 84F0           B8                   026E  mov	ax,#$26E
28801 84F3           50                         push	ax
28802                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28803 84F4           FF76         FE            push	-2[bp]
28804                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28805 84F7           E8         810D            call	_read_word
28806 84FA           83C4                   04  add	sp,*4
28807                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
28808 84FD           8946         F8            mov	-8[bp],ax
28809                                           !BCC_EOS
28810                                           ! 4250       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
28811                                           ! Debug: list * unsigned short = const $26C (used reg = )
28812 8500           B8                   026C  mov	ax,#$26C
28813 8503           50                         push	ax
28814                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28815 8504           FF76         FE            push	-2[bp]
28816                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28817 8507           E8         80FD            call	_read_word
28818 850A           83C4                   04  add	sp,*4
28819                                           ! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
28820 850D           8946         F6            mov	-$A[bp],ax
28821                                           !BCC_EOS
28822                                           ! 4251       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
28823                                           ! Debug: list * unsigned short = const $26A (used reg = )
28824 8510           B8                   026A  mov	ax,#$26A
28825 8513           50                         push	ax
28826                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28827 8514           FF76         FE            push	-2[bp]
28828                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
28829 8517           E8         80ED            call	_read_word
28830 851A           83C4                   04  add	sp,*4
28831                                           ! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
28832 851D           8946         FA            mov	-6[bp],ax
28833                                           !BCC_EOS
28834                                           ! 4252       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
28835                                           ! Debug: list * unsigned long = const $260 (used reg = )
28836 8520           B8                   0260  mov	ax,#$260
28837 8523           50                         push	ax
28838                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
28839 8524           FF76         FE            push	-2[bp]
28840                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
28841 8527           E8         7B59            call	_read_dword
28842 852A           89D3                       mov	bx,dx
28843 852C           83C4                   04  add	sp,*4
28844                                           ! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
28845 852F           8946         E6            mov	-$1A[bp],ax
28846 8532           895E         E8            mov	-$18[bp],bx
28847                                           !BCC_EOS
28848                                           ! 4253       sector = ( CX & 0x00ff ) & 0x003f;
28849                                           ! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
28850 8535           8A46         14            mov	al,$14[bp]
28851                                           ! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
28852 8538           24                     3F  and	al,*$3F
28853                                           ! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
28854 853A           30E4                       xor	ah,ah
28855 853C           8946         F2            mov	-$E[bp],ax
28856                                           !BCC_EOS
28857                                           ! 4254       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
28858                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
28859 853F           8B46         14            mov	ax,$14[bp]
28860 8542           88E0                       mov	al,ah
28861 8544           30E4                       xor	ah,ah
28862 8546           50                         push	ax
28863                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
28864 8547           8A46         14            mov	al,$14[bp]
28865                                           ! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
28866 854A           24                     C0  and	al,#$C0
28867                                           ! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
28868 854C           30E4                       xor	ah,ah
28869 854E           D1E0                       shl	ax,*1
28870 8550           D1E0                       shl	ax,*1
28871                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
28872 8552           0B46         CA            or	ax,0+..FFE1[bp]
28873 8555           44                         inc	sp
28874 8556           44                         inc	sp
28875                                           ! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
28876 8557           8946         F0            mov	-$10[bp],ax
28877                                           !BCC_EOS
28878                                           ! 4255       head = ( DX >> 8 );
28879                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
28880 855A           8B46         12            mov	ax,$12[bp]
28881 855D           88E0                       mov	al,ah
28882 855F           30E4                       xor	ah,ah
28883                                           ! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
28884 8561           8946         F4            mov	-$C[bp],ax
28885                                           !BCC_EOS
28886                                           ! 4256       nbsectors = ( AX & 0x00ff );
28887                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
28888 8564           8A46         16            mov	al,$16[bp]
28889                                           ! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
28890 8567           30E4                       xor	ah,ah
28891 8569           8946         EE            mov	-$12[bp],ax
28892                                           !BCC_EOS
28893                                           ! 4257       segment = ES;
28894                                           ! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
28895 856C           8B46         06            mov	ax,6[bp]
28896 856F           8946         DA            mov	-$26[bp],ax
28897                                           !BCC_EOS
28898                                           ! 4258       offset = BX;
28899                                           ! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
28900 8572           8B46         10            mov	ax,$10[bp]
28901 8575           8946         D8            mov	-$28[bp],ax
28902                                           !BCC_EOS
28903                                           ! 4259       if(nbsectors==0) goto int13_success;
28904                                           ! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
28905 8578           8B46         EE            mov	ax,-$12[bp]
28906 857B           85C0                       test	ax,ax
28907 857D           75           06            jne 	.60E
28908                       0000857F            .60F:
28909 857F           83C4                   00  add	sp,#..FFE0-..FFE1
28910 8582           E9         0451            br 	.FFE0
28911                                           !BCC_EOS
28912                                           ! 4260       if ((sector > vspt)
28913                       00008585            .60E:
28914                                           ! 4261        || (cylinder >= vcylinders)
28915                                           ! 4262        || (head >= vheads)) {
28916                                           ! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
28917 8585           8B46         F2            mov	ax,-$E[bp]
28918 8588           3B46         F8            cmp	ax,-8[bp]
28919 858B           77           10            ja  	.611
28920                       0000858D            .613:
28921                                           ! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
28922 858D           8B46         F0            mov	ax,-$10[bp]
28923 8590           3B46         F6            cmp	ax,-$A[bp]
28924 8593           73           08            jae 	.611
28925                       00008595            .612:
28926                                           ! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
28927 8595           8B46         F4            mov	ax,-$C[bp]
28928 8598           3B46         FA            cmp	ax,-6[bp]
28929 859B           72           06            jb  	.610
28930                       0000859D            .611:
28931                                           ! 4263         goto int13_fail;
28932 859D           83C4                   00  add	sp,#..FFE2-..FFE1
28933 85A0           E9         0406            br 	.FFE2
28934                                           !BCC_EOS
28935                                           ! 4264         }
28936                                           ! 4265       if (( AX >> 8 ) == 0x04) goto int13_success;
28937                       000085A3            .610:
28938                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
28939 85A3           8B46         16            mov	ax,$16[bp]
28940 85A6           88E0                       mov	al,ah
28941 85A8           30E4                       xor	ah,ah
28942                                           ! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
28943 85AA           3D                   0004  cmp	ax,*4
28944 85AD           75           06            jne 	.614
28945                       000085AF            .615:
28946 85AF           83C4                   00  add	sp,#..FFE0-..FFE1
28947 85B2           E9         0421            br 	.FFE0
28948                                           !BCC_EOS
28949                                           ! 4266       segment = ES+(BX / 16);
28950                       000085B5            .614:
28951                                           ! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
28952 85B5           8B46         10            mov	ax,$10[bp]
28953 85B8           B1                     04  mov	cl,*4
28954 85BA           D3E8                       shr	ax,cl
28955                                           ! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
28956                                           ! Debug: expression subtree swapping
28957 85BC           0346         06            add	ax,6[bp]
28958                                           ! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
28959 85BF           8946         DA            mov	-$26[bp],ax
28960                                           !BCC_EOS
28961                                           ! 4267       offset = BX % 16;
28962                                           ! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
28963 85C2           8B46         10            mov	ax,$10[bp]
28964 85C5           24                     0F  and	al,*$F
28965                                           ! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
28966 85C7           30E4                       xor	ah,ah
28967 85C9           8946         D8            mov	-$28[bp],ax
28968                                           !BCC_EOS
28969                                           ! 4268       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
28970                                           ! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
28971 85CC           8B46         F2            mov	ax,-$E[bp]
28972                                           ! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
28973 85CF           48                         dec	ax
28974 85D0           31DB                       xor	bx,bx
28975 85D2           53                         push	bx
28976 85D3           50                         push	ax
28977                                           ! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
28978 85D4           8B46         F8            mov	ax,-8[bp]
28979 85D7           31DB                       xor	bx,bx
28980 85D9           53                         push	bx
28981 85DA           50                         push	ax
28982                                           ! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
28983 85DB           8B46         F4            mov	ax,-$C[bp]
28984 85DE           31DB                       xor	bx,bx
28985 85E0           53                         push	bx
28986 85E1           50                         push	ax
28987                                           ! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
28988 85E2           8B46         FA            mov	ax,-6[bp]
28989 85E5           31DB                       xor	bx,bx
28990 85E7           53                         push	bx
28991 85E8           50                         push	ax
28992                                           ! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
28993 85E9           8B46         F0            mov	ax,-$10[bp]
28994 85EC           31DB                       xor	bx,bx
28995                                           ! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
28996 85EE           8D7E         BC            lea	di,-$E+..FFE1[bp]
28997 85F1           E8         7AF5            call	lmulul
28998 85F4           83C4                   04  add	sp,*4
28999                                           ! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
29000 85F7           8D7E         C0            lea	di,-$A+..FFE1[bp]
29001 85FA           E8         7AC6            call	laddul
29002 85FD           83C4                   04  add	sp,*4
29003                                           ! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
29004 8600           8D7E         C4            lea	di,-6+..FFE1[bp]
29005 8603           E8         7AE3            call	lmulul
29006 8606           83C4                   04  add	sp,*4
29007                                           ! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
29008 8609           8D7E         C8            lea	di,-2+..FFE1[bp]
29009 860C           E8         7AB4            call	laddul
29010 860F           83C4                   04  add	sp,*4
29011                                           ! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29012 8612           8946         EA            mov	-$16[bp],ax
29013 8615           895E         EC            mov	-$14[bp],bx
29014                                           !BCC_EOS
29015                                           ! 4269       AX = ((AX & 0xff00) | (nbsectors));
29016                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29017 8618           8B46         16            mov	ax,$16[bp]
29018 861B           30C0                       xor	al,al
29019                                           ! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
29020 861D           0B46         EE            or	ax,-$12[bp]
29021                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29022 8620           8946         16            mov	$16[bp],ax
29023                                           !BCC_EOS
29024                                           ! 4270       slba = (Bit32u)vlba/4;
29025                                           ! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
29026 8623           B8                   0004  mov	ax,*4
29027 8626           31DB                       xor	bx,bx
29028 8628           53                         push	bx
29029 8629           50                         push	ax
29030 862A           8B46         EA            mov	ax,-$16[bp]
29031 862D           8B5E         EC            mov	bx,-$14[bp]
29032 8630           8D7E         C8            lea	di,-2+..FFE1[bp]
29033 8633           E8         7B38            call	ldivul
29034 8636           83C4                   04  add	sp,*4
29035                                           ! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
29036 8639           8946         E2            mov	-$1E[bp],ax
29037 863C           895E         E4            mov	-$1C[bp],bx
29038                                           !BCC_EOS
29039                                           ! 4271       before= (Bit16u)vlba%4;
29040                                           ! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
29041 863F           8B46         EA            mov	ax,-$16[bp]
29042 8642           24                     03  and	al,*3
29043                                           ! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
29044 8644           30E4                       xor	ah,ah
29045 8646           8946         DC            mov	-$24[bp],ax
29046                                           !BCC_EOS
29047                                           ! 4272       elba = (Bit32u)(vlba+nbsectors-1)/4;
29048                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
29049 8649           8B46         EE            mov	ax,-$12[bp]
29050 864C           31DB                       xor	bx,bx
29051                                           ! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
29052                                           ! Debug: expression subtree swapping
29053 864E           8D7E         EA            lea	di,-$16[bp]
29054 8651           E8         7A6F            call	laddul
29055                                           ! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29056 8654           53                         push	bx
29057 8655           50                         push	ax
29058 8656           B8                   0001  mov	ax,*1
29059 8659           31DB                       xor	bx,bx
29060 865B           53                         push	bx
29061 865C           50                         push	ax
29062 865D           8B46         C8            mov	ax,-2+..FFE1[bp]
29063 8660           8B5E         CA            mov	bx,0+..FFE1[bp]
29064 8663           8D7E         C4            lea	di,-6+..FFE1[bp]
29065 8666           E8         7A78            call	lsubul
29066 8669           83C4                   08  add	sp,*8
29067                                           ! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
29068                                           ! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
29069 866C           53                         push	bx
29070 866D           50                         push	ax
29071 866E           B8                   0004  mov	ax,*4
29072 8671           31DB                       xor	bx,bx
29073 8673           53                         push	bx
29074 8674           50                         push	ax
29075 8675           8B46         C8            mov	ax,-2+..FFE1[bp]
29076 8678           8B5E         CA            mov	bx,0+..FFE1[bp]
29077 867B           8D7E         C4            lea	di,-6+..FFE1[bp]
29078 867E           E8         7AED            call	ldivul
29079 8681           83C4                   08  add	sp,*8
29080                                           ! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
29081 8684           8946         DE            mov	-$22[bp],ax
29082 8687           895E         E0            mov	-$20[bp],bx
29083                                           !BCC_EOS
29084                                           ! 4273       memsetb(get_SS(),atacmd,0,12);
29085                                           ! Debug: list int = const $C (used reg = )
29086 868A           B8                   000C  mov	ax,*$C
29087 868D           50                         push	ax
29088                                           ! Debug: list int = const 0 (used reg = )
29089 868E           31C0                       xor	ax,ax
29090 8690           50                         push	ax
29091                                           ! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
29092 8691           8D5E         CC            lea	bx,-$34[bp]
29093 8694           53                         push	bx
29094                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29095 8695           E8         7FB5            call	_get_SS
29096                                           ! Debug: list unsigned short = ax+0 (used reg = )
29097 8698           50                         push	ax
29098                                           ! Debug: func () void = memsetb+0 (used reg = )
29099 8699           E8         7964            call	_memsetb
29100 869C           83C4                   08  add	sp,*8
29101                                           !BCC_EOS
29102                                           ! 4274       atacmd[0]=0x28;
29103                                           ! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
29104 869F           B0                     28  mov	al,*$28
29105 86A1           8846         CC            mov	-$34[bp],al
29106                                           !BCC_EOS
29107                                           ! 4275       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
29108                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29109 86A4           8B46         DE            mov	ax,-$22[bp]
29110 86A7           8B5E         E0            mov	bx,-$20[bp]
29111 86AA           8D7E         E2            lea	di,-$1E[bp]
29112 86AD           E8         7A31            call	lsubul
29113                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29114 86B0           53                         push	bx
29115 86B1           50                         push	ax
29116 86B2           B8                   0001  mov	ax,*1
29117 86B5           31DB                       xor	bx,bx
29118 86B7           53                         push	bx
29119 86B8           50                         push	ax
29120 86B9           8B46         C8            mov	ax,-2+..FFE1[bp]
29121 86BC           8B5E         CA            mov	bx,0+..FFE1[bp]
29122 86BF           8D7E         C4            lea	di,-6+..FFE1[bp]
29123 86C2           E8         79FE            call	laddul
29124 86C5           83C4                   08  add	sp,*8
29125                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29126                                           ! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
29127 86C8           30C0                       xor	al,al
29128                                           ! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
29129 86CA           88E0                       mov	al,ah
29130 86CC           30E4                       xor	ah,ah
29131                                           ! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
29132 86CE           8846         D3            mov	-$2D[bp],al
29133                                           !BCC_EOS
29134                                           ! 4276       atacmd[8]=((Bit16u)(elba-slba+1) & 0x0
29135                                           ! 4276 0ff);
29136                                           ! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
29137 86D1           8B46         DE            mov	ax,-$22[bp]
29138 86D4           8B5E         E0            mov	bx,-$20[bp]
29139 86D7           8D7E         E2            lea	di,-$1E[bp]
29140 86DA           E8         7A04            call	lsubul
29141                                           ! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
29142 86DD           53                         push	bx
29143 86DE           50                         push	ax
29144 86DF           B8                   0001  mov	ax,*1
29145 86E2           31DB                       xor	bx,bx
29146 86E4           53                         push	bx
29147 86E5           50                         push	ax
29148 86E6           8B46         C8            mov	ax,-2+..FFE1[bp]
29149 86E9           8B5E         CA            mov	bx,0+..FFE1[bp]
29150 86EC           8D7E         C4            lea	di,-6+..FFE1[bp]
29151 86EF           E8         79D1            call	laddul
29152 86F2           83C4                   08  add	sp,*8
29153                                           ! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
29154                                           ! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
29155                                           ! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
29156 86F5           8846         D4            mov	-$2C[bp],al
29157                                           !BCC_EOS
29158                                           ! 4277       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
29159                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29160 86F8           8B46         E6            mov	ax,-$1A[bp]
29161 86FB           8B5E         E8            mov	bx,-$18[bp]
29162 86FE           8D7E         E2            lea	di,-$1E[bp]
29163 8701           E8         79BF            call	laddul
29164                                           ! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
29165 8704           53                         push	bx
29166 8705           50                         push	ax
29167 8706           31C0                       xor	ax,ax
29168 8708           BB                   FF00  mov	bx,#$FF00
29169 870B           53                         push	bx
29170 870C           50                         push	ax
29171 870D           8B46         C8            mov	ax,-2+..FFE1[bp]
29172 8710           8B5E         CA            mov	bx,0+..FFE1[bp]
29173 8713           8D7E         C4            lea	di,-6+..FFE1[bp]
29174 8716           E8         79A2            call	landul
29175 8719           83C4                   08  add	sp,*8
29176                                           ! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
29177 871C           93                         xchg	bx,ax
29178 871D           88E0                       mov	al,ah
29179 871F           30E4                       xor	ah,ah
29180 8721           31DB                       xor	bx,bx
29181                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
29182 8723           8846         CE            mov	-$32[bp],al
29183                                           !BCC_EOS
29184                                           ! 4278       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
29185                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29186 8726           8B46         E6            mov	ax,-$1A[bp]
29187 8729           8B5E         E8            mov	bx,-$18[bp]
29188 872C           8D7E         E2            lea	di,-$1E[bp]
29189 872F           E8         7991            call	laddul
29190                                           ! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
29191 8732           53                         push	bx
29192 8733           50                         push	ax
29193 8734           31C0                       xor	ax,ax
29194 8736           BB                   00FF  mov	bx,#$FF
29195 8739           53                         push	bx
29196 873A           50                         push	ax
29197 873B           8B46         C8            mov	ax,-2+..FFE1[bp]
29198 873E           8B5E         CA            mov	bx,0+..FFE1[bp]
29199 8741           8D7E         C4            lea	di,-6+..FFE1[bp]
29200 8744           E8         7974            call	landul
29201 8747           83C4                   08  add	sp,*8
29202                                           ! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
29203 874A           93                         xchg	bx,ax
29204 874B           31DB                       xor	bx,bx
29205                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
29206 874D           8846         CF            mov	-$31[bp],al
29207                                           !BCC_EOS
29208                                           ! 4279       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
29209                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29210 8750           8B46         E6            mov	ax,-$1A[bp]
29211 8753           8B5E         E8            mov	bx,-$18[bp]
29212 8756           8D7E         E2            lea	di,-$1E[bp]
29213 8759           E8         7967            call	laddul
29214                                           ! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
29215 875C           53                         push	bx
29216 875D           50                         push	ax
29217 875E           B8                   FF00  mov	ax,#$FF00
29218 8761           31DB                       xor	bx,bx
29219 8763           53                         push	bx
29220 8764           50                         push	ax
29221 8765           8B46         C8            mov	ax,-2+..FFE1[bp]
29222 8768           8B5E         CA            mov	bx,0+..FFE1[bp]
29223 876B           8D7E         C4            lea	di,-6+..FFE1[bp]
29224 876E           E8         794A            call	landul
29225 8771           83C4                   08  add	sp,*8
29226                                           ! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
29227 8774           88E0                       mov	al,ah
29228 8776           88DC                       mov	ah,bl
29229 8778           88FB                       mov	bl,bh
29230 877A           28FF                       sub	bh,bh
29231                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
29232 877C           8846         D0            mov	-$30[bp],al
29233                                           !BCC_EOS
29234                                           ! 4280       atacmd[5]=(ilba+slba & 0x000000ff);
29235                                           ! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
29236 877F           8B46         E6            mov	ax,-$1A[bp]
29237 8782           8B5E         E8            mov	bx,-$18[bp]
29238 8785           8D7E         E2            lea	di,-$1E[bp]
29239 8788           E8         7938            call	laddul
29240                                           ! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
29241 878B           53                         push	bx
29242 878C           50                         push	ax
29243 878D           B8                   00FF  mov	ax,#$FF
29244 8790           31DB                       xor	bx,bx
29245 8792           53                         push	bx
29246 8793           50                         push	ax
29247 8794           8B46         C8            mov	ax,-2+..FFE1[bp]
29248 8797           8B5E         CA            mov	bx,0+..FFE1[bp]
29249 879A           8D7E         C4            lea	di,-6+..FFE1[bp]
29250 879D           E8         791B            call	landul
29251 87A0           83C4                   08  add	sp,*8
29252                                           ! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
29253 87A3           8846         D1            mov	-$2F[bp],al
29254                                           !BCC_EOS
29255                                           ! 4281       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
29256                                           ! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
29257 87A6           FF76         D8            push	-$28[bp]
29258                                           ! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
29259 87A9           FF76         DA            push	-$26[bp]
29260                                           ! Debug: list int = const 1 (used reg = )
29261 87AC           B8                   0001  mov	ax,*1
29262 87AF           50                         push	ax
29263                                           ! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
29264 87B0           8B46         EE            mov	ax,-$12[bp]
29265 87B3           31DB                       xor	bx,bx
29266                                           ! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
29267 87B5           53                         push	bx
29268 87B6           50                         push	ax
29269 87B7           B8                   0200  mov	ax,#$200
29270 87BA           31DB                       xor	bx,bx
29271 87BC           53                         push	bx
29272 87BD           50                         push	ax
29273 87BE           8B46         C2            mov	ax,-8+..FFE1[bp]
29274 87C1           8B5E         C4            mov	bx,-6+..FFE1[bp]
29275 87C4           8D7E         BE            lea	di,-$C+..FFE1[bp]
29276 87C7           E8         791F            call	lmulul
29277 87CA           83C4                   08  add	sp,*8
29278                                           ! Debug: list unsigned long = bx+0 (used reg = )
29279 87CD           53                         push	bx
29280 87CE           50                         push	ax
29281                                           ! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
29282 87CF           8B46         DC            mov	ax,-$24[bp]
29283 87D2           B9                   0200  mov	cx,#$200
29284 87D5           F7E9                       imul	cx
29285                                           ! Debug: list unsigned int = ax+0 (used reg = )
29286 87D7           50                         push	ax
29287                                           ! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
29288 87D8           8D5E         CC            lea	bx,-$34[bp]
29289 87DB           53                         push	bx
29290                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
29291 87DC           E8         7E6E            call	_get_SS
29292                                           ! Debug: list unsigned short = ax+0 (used reg = )
29293 87DF           50                         push	ax
29294                                           ! Debug: list int = const $C (used reg = )
29295 87E0           B8                   000C  mov	ax,*$C
29296 87E3           50                         push	ax
29297                                           ! Debug: list unsigned char device = [S+$48-5] (used reg = )
29298 87E4           8A46         FD            mov	al,-3[bp]
29299 87E7           30E4                       xor	ah,ah
29300 87E9           50                         push	ax
29301                                           ! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
29302 87EA           E8         ADDE            call	_ata_cmd_packet
29303 87ED           83C4                   14  add	sp,*$14
29304                                           ! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
29305 87F0           8846         FC            mov	-4[bp],al
29306                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
29307 87F3           84C0                       test	al,al
29308 87F5           74           1B            je  	.616
29309                       000087F7            .617:
29310                                           ! 4282         ;
29311                                           !BCC_EOS
29312                                           ! 4283         AX = ((AX & 0x00ff) | ((0x02) << 8));
29313                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29314 87F7           8A46         16            mov	al,$16[bp]
29315                                           ! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
29316 87FA           30E4                       xor	ah,ah
29317 87FC           0D                   0200  or	ax,#$200
29318                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29319 87FF           8946         16            mov	$16[bp],ax
29320                                           !BCC_EOS
29321                                           ! 4284         AX = ((AX & 0xff00) | (0));
29322                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29323 8802           8B46         16            mov	ax,$16[bp]
29324 8805           30C0                       xor	al,al
29325                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29326 8807           0C                     00  or	al,*0
29327                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29328 8809           8946         16            mov	$16[bp],ax
29329                                           !BCC_EOS
29330                                           ! 4285         goto int13_fail_noah;
29331 880C           83C4                   00  add	sp,#..FFDF-..FFE1
29332 880F           E9         01A2            br 	.FFDF
29333                                           !BCC_EOS
29334                                           ! 4286         }
29335                                           ! 4287       goto int13_success;
29336                       00008812            .616:
29337 8812           83C4                   00  add	sp,#..FFE0-..FFE1
29338 8815           E9         01BE            br 	.FFE0
29339                                           !BCC_EOS
29340                                           ! 4288       break;
29341 8818           E9         018E            br 	.5FB
29342                                           !BCC_EOS
29343                                           ! 4289     case 0x08:
29344                                           ! 4290       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
29345                       0000881B            .618:
29346                                           ! Debug: list * unsigned short = const $26E (used reg = )
29347 881B           B8                   026E  mov	ax,#$26E
29348 881E           50                         push	ax
29349                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29350 881F           FF76         FE            push	-2[bp]
29351                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29352 8822           E8         7DE2            call	_read_word
29353 8825           83C4                   04  add	sp,*4
29354                                           ! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
29355 8828           8946         F8            mov	-8[bp],ax
29356                                           !BCC_EOS
29357                                           ! 4291       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
29358                                           ! Debug: list * unsigned short = const $26C (used reg = )
29359 882B           B8                   026C  mov	ax,#$26C
29360 882E           50                         push	ax
29361                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29362 882F           FF76         FE            push	-2[bp]
29363                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29364 8832           E8         7DD2            call	_read_word
29365 8835           83C4                   04  add	sp,*4
29366                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
29367                                           ! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
29368 8838           48                         dec	ax
29369 8839           8946         F6            mov	-$A[bp],ax
29370                                           !BCC_EOS
29371                                           ! 4292       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
29372                                           ! Debug: list * unsigned short = const $26A (used reg = )
29373 883C           B8                   026A  mov	ax,#$26A
29374 883F           50                         push	ax
29375                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29376 8840           FF76         FE            push	-2[bp]
29377                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
29378 8843           E8         7DC1            call	_read_word
29379 8846           83C4                   04  add	sp,*4
29380                                           ! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
29381                                           ! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
29382 8849           48                         dec	ax
29383 884A           8946         FA            mov	-6[bp],ax
29384                                           !BCC_EOS
29385                                           ! 4293       AX = ((AX & 0xff00) | (0x00));
29386                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
29387 884D           8B46         16            mov	ax,$16[bp]
29388 8850           30C0                       xor	al,al
29389                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29390 8852           0C                     00  or	al,*0
29391                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29392 8854           8946         16            mov	$16[bp],ax
29393                                           !BCC_EOS
29394                                           ! 4294       BX = ((BX & 0xff00) | (0x00));
29395                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29396 8857           8B46         10            mov	ax,$10[bp]
29397 885A           30C0                       xor	al,al
29398                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
29399 885C           0C                     00  or	al,*0
29400                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29401 885E           8946         10            mov	$10[bp],ax
29402                                           !BCC_EOS
29403                                           ! 4295       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
29404                                           ! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
29405 8861           8A46         F6            mov	al,-$A[bp]
29406                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
29407 8864           30E4                       xor	ah,ah
29408 8866           88C4                       mov	ah,al
29409 8868           30C0                       xor	al,al
29410 886A           50                         push	ax
29411                                           ! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
29412 886B           8A46         14            mov	al,$14[bp]
29413                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29414 886E           30E4                       xor	ah,ah
29415 8870           0B46         CA            or	ax,0+..FFE1[bp]
29416 8873           44                         inc	sp
29417 8874           44                         inc	sp
29418                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
29419 8875           8946         14            mov	$14[bp],ax
29420                                           !BCC_EOS
29421                                           ! 4296       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
29422                                           ! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
29423 8878           8A46         F8            mov	al,-8[bp]
29424 887B           24                     3F  and	al,*$3F
29425 887D           50                         push	ax
29426                                           ! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
29427 887E           8B46         F6            mov	ax,-$A[bp]
29428 8881           D1E8                       shr	ax,*1
29429 8883           D1E8                       shr	ax,*1
29430                                           ! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
29431 8885           24                     C0  and	al,#$C0
29432                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29433 8887           0A46         CA            or	al,0+..FFE1[bp]
29434 888A           44                         inc	sp
29435 888B           44                         inc	sp
29436 888C           50                         push	ax
29437                                           ! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
29438 888D           8B46         14            mov	ax,$14[bp]
29439 8890           30C0                       xor	al,al
29440                                           ! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
29441 8892           0A46         CA            or	al,0+..FFE1[bp]
29442 8895           44                         inc	sp
29443 8896           44                         inc	sp
29444                                           ! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
29445 8897           8946         14            mov	$14[bp],ax
29446                                           !BCC_EOS
29447                                           ! 4297       DX = ((DX & 0x00ff) | ((vheads) << 8));
29448                                           ! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
29449 889A           8B46         FA            mov	ax,-6[bp]
29450 889D           88C4                       mov	ah,al
29451 889F           30C0                       xor	al,al
29452 88A1           50                         push	ax
29453                                           ! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
29454 88A2           8A46         12            mov	al,$12[bp]
29455                                           ! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
29456 88A5           30E4                       xor	ah,ah
29457 88A7           0B46         CA            or	ax,0+..FFE1[bp]
29458 88AA           44                         inc	sp
29459 88AB           44                         inc	sp
29460                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
29461 88AC           8946         12            mov	$12[bp],ax
29462                                           !BCC_EOS
29463                                           ! 4298       DX = ((DX & 0xff00) | (0x02));
29464                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
29465 88AF           8B46         12            mov	ax,$12[bp]
29466 88B2           30C0                       xor	al,al
29467                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
29468 88B4           0C                     02  or	al,*2
29469                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
29470 88B6           8946         12            mov	$12[bp],ax
29471                                           !BCC_EOS
29472                                           ! 4299       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
29473                                           ! Debug: list * unsigned char = const $25B (used reg = )
29474 88B9           B8                   025B  mov	ax,#$25B
29475 88BC           50                         push	ax
29476                                           ! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
29477 88BD           FF76         FE            push	-2[bp]
29478                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29479 88C0           E8         7D31            call	_read_byte
29480 88C3           83C4                   04  add	sp,*4
29481 88C6           EB           26            jmp .61B
29482                                           ! 4300         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
29483                       000088C8            .61C:
29484                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29485 88C8           8B46         10            mov	ax,$10[bp]
29486 88CB           30C0                       xor	al,al
29487                                           ! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
29488 88CD           0C                     02  or	al,*2
29489                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29490 88CF           8946         10            mov	$10[bp],ax
29491                                           !BCC_EOS
29492 88D2           EB           26            jmp .619
29493                                           !BCC_EOS
29494                                           ! 4301         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
29495                       000088D4            .61D:
29496                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29497 88D4           8B46         10            mov	ax,$10[bp]
29498 88D7           30C0                       xor	al,al
29499                                           ! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
29500 88D9           0C                     04  or	al,*4
29501                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29502 88DB           8946         10            mov	$10[bp],ax
29503                                           !BCC_EOS
29504 88DE           EB           1A            jmp .619
29505                                           !BCC_EOS
29506                                           ! 4302         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
29507                       000088E0            .61E:
29508                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
29509 88E0           8B46         10            mov	ax,$10[bp]
29510 88E3           30C0                       xor	al,al
29511                                           ! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
29512 88E5           0C                     06  or	al,*6
29513                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
29514 88E7           8946         10            mov	$10[bp],ax
29515                                           !BCC_EOS
29516 88EA           EB           0E            jmp .619
29517                                           !BCC_EOS
29518                                           ! 4303         }
29519                                           ! 4304 #asm
29520 88EC           EB           0C            jmp .619
29521                       000088EE            .61B:
29522 88EE           2C                     01  sub	al,*1
29523 88F0           74           D6            je 	.61C
29524 88F2           2C                     01  sub	al,*1
29525 88F4           74           DE            je 	.61D
29526 88F6           2C                     01  sub	al,*1
29527 88F8           74           E6            je 	.61E
29528                       000088FA            .619:
29529                                           !BCC_EOS
29530                                           !BCC_ASM
29531                       00000040            _int13_cdemu.BP	set	$40
29532                       0000000C            .int13_cdemu.BP	set	$C
29533                       0000004E            _int13_cdemu.CS	set	$4E
29534                       0000001A            .int13_cdemu.CS	set	$1A
29535                       00000022            _int13_cdemu.nbsectors	set	$22
29536                       FFFFFFEE            .int13_cdemu.nbsectors	set	-$12
29537                       00000048            _int13_cdemu.CX	set	$48
29538                       00000014            .int13_cdemu.CX	set	$14
29539                       00000012            _int13_cdemu.elba	set	$12
29540                       FFFFFFDE            .int13_cdemu.elba	set	-$22
29541                       0000000E            _int13_cdemu.segment	set	$E
29542                       FFFFFFDA            .int13_cdemu.segment	set	-$26
29543                       0000003C            _int13_cdemu.DI	set	$3C
29544                       00000008            .int13_cdemu.DI	set	8
29545                       00000050            _int13_cdemu.FLAGS	set	$50
29546                       0000001C            .int13_cdemu.FLAGS	set	$1C
29547                       0000002A            _int13_cdemu.vcylinders	set	$2A
29548                       FFFFFFF6            .int13_cdemu.vcylinders	set	-$A
29549                       00000026            _int13_cdemu.sector	set	$26
29550                       FFFFFFF2            .int13_cdemu.sector	set	-$E
29551                       00000038            _int13_cdemu.DS	set	$38
29552                       00000004            .int13_cdemu.DS	set	4
29553                       00000028            _int13_cdemu.head	set	$28
29554                       FFFFFFF4            .int13_cdemu.head	set	-$C
29555                       00000024            _int13_cdemu.cylinder	set	$24
29556                       FFFFFFF0            .int13_cdemu.cylinder	set	-$10
29557                       00000046            _int13_cdemu.DX	set	$46
29558                       00000012            .int13_cdemu.DX	set	$12
29559                       00000031            _int13_cdemu.device	set	$31
29560                       FFFFFFFD            .int13_cdemu.device	set	-3
29561                       0000003A            _int13_cdemu.ES	set	$3A
29562                       00000006            .int13_cdemu.ES	set	6
29563                       0000002C            _int13_cdemu.vspt	set	$2C
29564                       FFFFFFF8            .int13_cdemu.vspt	set	-8
29565                       0000001E            _int13_cdemu.vlba	set	$1E
29566                       FFFFFFEA            .int13_cdemu.vlba	set	-$16
29567                       00000032            _int13_cdemu.ebda_seg	set	$32
29568                       FFFFFFFE            .int13_cdemu.ebda_seg	set	-2
29569                       0000003E            _int13_cdemu.SI	set	$3E
29570                       0000000A            .int13_cdemu.SI	set	$A
29571                       0000004C            _int13_cdemu.IP	set	$4C
29572                       00000018            .int13_cdemu.IP	set	$18
29573                       00000030            _int13_cdemu.status	set	$30
29574                       FFFFFFFC            .int13_cdemu.status	set	-4
29575                       00000000            _int13_cdemu.atacmd	set	0
29576                       FFFFFFCC            .int13_cdemu.atacmd	set	-$34
29577                       0000004A            _int13_cdemu.AX	set	$4A
29578                       00000016            .int13_cdemu.AX	set	$16
29579                       0000001A            _int13_cdemu.ilba	set	$1A
29580                       FFFFFFE6            .int13_cdemu.ilba	set	-$1A
29581                       00000010            _int13_cdemu.before	set	$10
29582                       FFFFFFDC            .int13_cdemu.before	set	-$24
29583                       0000000C            _int13_cdemu.offset	set	$C
29584                       FFFFFFD8            .int13_cdemu.offset	set	-$28
29585                       00000016            _int13_cdemu.slba	set	$16
29586                       FFFFFFE2            .int13_cdemu.slba	set	-$1E
29587                       00000042            _int13_cdemu.SP	set	$42
29588                       0000000E            .int13_cdemu.SP	set	$E
29589                       0000002E            _int13_cdemu.vheads	set	$2E
29590                       FFFFFFFA            .int13_cdemu.vheads	set	-6
29591                       00000044            _int13_cdemu.BX	set	$44
29592                       00000010            .int13_cdemu.BX	set	$10
29593 88FA           55                               push bp
29594 88FB           89E5                             mov bp, sp
29595 88FD           B8                   EFDE        mov ax, #diskette_param_table2
29596 8900           8946         3E                  mov _int13_cdemu.DI+2[bp], ax
29597 8903           8C4E         3C                  mov _int13_cdemu.ES+2[bp], cs
29598 8906           5D                               pop bp
29599                                           ! 4311 endasm
29600                                           !BCC_ENDASM
29601                                           !BCC_EOS
29602                                           ! 4312       goto int13_success;
29603 8907           83C4                   00  add	sp,#..FFE0-..FFE1
29604 890A           E9         00C9            br 	.FFE0
29605                                           !BCC_EOS
29606                                           ! 4313       break;
29607 890D           E9         0099            br 	.5FB
29608                                           !BCC_EOS
29609                                           ! 4314     case 0x15:
29610                                           ! 4315       AX = ((AX & 0x00ff) | ((0x03) << 8));
29611                       00008910            .61F:
29612                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29613 8910           8A46         16            mov	al,$16[bp]
29614                                           ! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
29615 8913           30E4                       xor	ah,ah
29616 8915           0D                   0300  or	ax,#$300
29617                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29618 8918           8946         16            mov	$16[bp],ax
29619                                           !BCC_EOS
29620                                           ! 4316       goto int13_success_noah;
29621 891B           83C4                   00  add	sp,#..FFDD-..FFE1
29622 891E           E9         00BF            br 	.FFDD
29623                                           !BCC_EOS
29624                                           ! 4317       break;
29625 8921           E9         0085            br 	.5FB
29626                                           !BCC_EOS
29627                                           ! 4318     case 0x0a:
29628                                           ! 4319     case 0x0b:
29629                       00008924            .620:
29630                                           ! 4320     case 0x18:
29631                       00008924            .621:
29632                                           ! 4321     case 0x41:
29633                       00008924            .622:
29634                                           ! 4322     case 0x42:
29635                       00008924            .623:
29636                                           ! 4323     case 0x43:
29637                       00008924            .624:
29638                                           ! 4324     case 0x44:
29639                       00008924            .625:
29640                                           ! 4325     case 0x45:
29641                       00008924            .626:
29642                                           ! 4326     case 0x46:
29643                       00008924            .627:
29644                                           ! 4327     case 0x47:
29645                       00008924            .628:
29646                                           ! 4328     case 0x48:
29647                       00008924            .629:
29648                                           ! 4329     case 0x49:
29649                       00008924            .62A:
29650                                           ! 4330     case 0x4e:
29651                       00008924            .62B:
29652                                           ! 4331     case 0x50:
29653                       00008924            .62C:
29654                                           ! 4332     default:
29655                       00008924            .62D:
29656                                           ! 4333       ;
29657                       00008924            .62E:
29658                                           !BCC_EOS
29659                                           ! 4334       goto int13_fail;
29660 8924           83C4                   00  add	sp,#..FFE2-..FFE1
29661 8927           E9         007F            jmp .FFE2
29662                                           !BCC_EOS
29663                                           ! 4335       break;
29664 892A           EB           7D            jmp .5FB
29665                                           !BCC_EOS
29666                                           ! 4336     }
29667                                           ! 4337 int13_fail:
29668 892C           EB           7B            jmp .5FB
29669                       0000892E            .5FD:
29670 892E           2D                   0000  sub	ax,*0
29671 8931           7C           F1            jl 	.62E
29672 8933           3D                   0018  cmp	ax,*$18
29673 8936           77           3B            ja  	.62F
29674 8938           D1E0                       shl	ax,*1
29675 893A           89C3                       mov	bx,ax
29676 893C           2E                         seg	cs
29677 893D           FFA7       8941            br	.630[bx]
29678                       00008941            .630:
29679 8941                      8482            .word	.5FE
29680 8943                      849F            .word	.608
29681 8945                      84F0            .word	.60C
29682 8947                      848B            .word	.606
29683 8949                      84F0            .word	.60D
29684 894B                      848B            .word	.607
29685 894D                      8924            .word	.62E
29686 894F                      8924            .word	.62E
29687 8951                      881B            .word	.618
29688 8953                      8482            .word	.5FF
29689 8955                      8924            .word	.620
29690 8957                      8924            .word	.621
29691 8959                      8482            .word	.600
29692 895B                      8482            .word	.601
29693 895D                      8924            .word	.62E
29694 895F                      8924            .word	.62E
29695 8961                      8482            .word	.602
29696 8963                      8482            .word	.603
29697 8965                      8924            .word	.62E
29698 8967                      8924            .word	.62E
29699 8969                      8482            .word	.604
29700 896B                      8910            .word	.61F
29701 896D                      8482            .word	.605
29702 896F                      8924            .word	.62E
29703 8971                      8924            .word	.622
29704                       00008973            .62F:
29705 8973           2D                   0041  sub	ax,*$41
29706 8976           72           AC            jb 	.62E
29707 8978           3D                   000F  cmp	ax,*$F
29708 897B           77           29            ja  	.631
29709 897D           D1E0                       shl	ax,*1
29710 897F           89C3                       mov	bx,ax
29711 8981           2E                         seg	cs
29712 8982           FFA7       8986            br	.632[bx]
29713                       00008986            .632:
29714 8986                      8924            .word	.623
29715 8988                      8924            .word	.624
29716 898A                      8924            .word	.625
29717 898C                      8924            .word	.626
29718 898E                      8924            .word	.627
29719 8990                      8924            .word	.628
29720 8992                      8924            .word	.629
29721 8994                      8924            .word	.62A
29722 8996                      8924            .word	.62B
29723 8998                      8924            .word	.62E
29724 899A                      8924            .word	.62E
29725 899C                      8924            .word	.62E
29726 899E                      8924            .word	.62E
29727 89A0                      8924            .word	.62C
29728 89A2                      8924            .word	.62E
29729 89A4                      8924            .word	.62D
29730                       000089A6            .631:
29731 89A6           E9         FF7B            br 	.62E
29732                       000089A9            .5FB:
29733                       FFFFFFCA            ..FFE1	=	-$36
29734                       000089A9            .FFE2:
29735                       FFFFFFCA            ..FFE2	=	-$36
29736                                           ! 4338     AX = ((AX & 0x00ff) | ((0x01) << 8));
29737                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29738 89A9           8A46         16            mov	al,$16[bp]
29739                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
29740 89AC           30E4                       xor	ah,ah
29741 89AE           0D                   0100  or	ax,#$100
29742                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
29743 89B1           8946         16            mov	$16[bp],ax
29744                                           !BCC_EOS
29745                                           ! 4339 int13_fail_noah:
29746                       000089B4            .FFDF:
29747                       FFFFFFCA            ..FFDF	=	-$36
29748                                           ! 4340     write_byte(0x0040, 0x0074, ( AX >> 8 ));
29749                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
29750 89B4           8B46         16            mov	ax,$16[bp]
29751 89B7           88E0                       mov	al,ah
29752 89B9           30E4                       xor	ah,ah
29753                                           ! Debug: list unsigned int = ax+0 (used reg = )
29754 89BB           50                         push	ax
29755                                           ! Debug: list int = const $74 (used reg = )
29756 89BC           B8                   0074  mov	ax,*$74
29757 89BF           50                         push	ax
29758                                           ! Debug: list int = const $40 (used reg = )
29759 89C0           B8                   0040  mov	ax,*$40
29760 89C3           50                         push	ax
29761                                           ! Debug: func () void = write_byte+0 (used reg = )
29762 89C4           E8         7C53            call	_write_byte
29763 89C7           83C4                   06  add	sp,*6
29764                                           !BCC_EOS
29765                                           ! 4341 int13_fail_nostatus:
29766                       000089CA            .FFDE:
29767                       FFFFFFCA            ..FFDE	=	-$36
29768                                           ! 4342     FLAGS |= 0x0001;
29769                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
29770 89CA           8B46         1C            mov	ax,$1C[bp]
29771 89CD           0C                     01  or	al,*1
29772 89CF           8946         1C            mov	$1C[bp],ax
29773                                           !BCC_EOS
29774                                           ! 4343     return;
29775 89D2           89EC                       mov	sp,bp
29776 89D4           5D                         pop	bp
29777 89D5           C3                         ret
29778                                           !BCC_EOS
29779                                           ! 4344 int13_success:
29780                       000089D6            .FFE0:
29781                       FFFFFFCA            ..FFE0	=	-$36
29782                                           ! 4344 
29783                                           ! 4345     AX = ((AX & 0x00ff) | ((0x00) << 8));
29784                                           ! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
29785 89D6           8A46         16            mov	al,$16[bp]
29786                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
29787 89D9           0C                     00  or	al,*0
29788                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
29789 89DB           30E4                       xor	ah,ah
29790 89DD           8946         16            mov	$16[bp],ax
29791                                           !BCC_EOS
29792                                           ! 4346 int13_success_noah:
29793                       000089E0            .FFDD:
29794                       FFFFFFCA            ..FFDD	=	-$36
29795                                           ! 4347     write_byte(0x0040, 0x0074, 0x00);
29796                                           ! Debug: list int = const 0 (used reg = )
29797 89E0           31C0                       xor	ax,ax
29798 89E2           50                         push	ax
29799                                           ! Debug: list int = const $74 (used reg = )
29800 89E3           B8                   0074  mov	ax,*$74
29801 89E6           50                         push	ax
29802                                           ! Debug: list int = const $40 (used reg = )
29803 89E7           B8                   0040  mov	ax,*$40
29804 89EA           50                         push	ax
29805                                           ! Debug: func () void = write_byte+0 (used reg = )
29806 89EB           E8         7C2C            call	_write_byte
29807 89EE           83C4                   06  add	sp,*6
29808                                           !BCC_EOS
29809                                           ! 4348     FLAGS &= 0xfffe;
29810                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
29811 89F1           8B46         1C            mov	ax,$1C[bp]
29812 89F4           24                     FE  and	al,#$FE
29813 89F6           8946         1C            mov	$1C[bp],ax
29814                                           !BCC_EOS
29815                                           ! 4349     return;
29816 89F9           89EC                       mov	sp,bp
29817 89FB           5D                         pop	bp
29818 89FC           C3                         ret
29819                                           !BCC_EOS
29820                                           ! 4350 }
29821                                           ! 4351 void floppy_reset_controller()
29822                                           ! Register BX used in function int13_cdemu
29823                                           ! 4352 {
29824                                           export	_floppy_reset_controller
29825                       000089FD            _floppy_reset_controller:
29826                                           ! 4353   Bit8u val8;
29827                                           !BCC_EOS
29828                                           ! 4354   val8 = inb(0x03f2);
29829 89FD           55                         push	bp
29830 89FE           89E5                       mov	bp,sp
29831 8A00           4C                         dec	sp
29832 8A01           4C                         dec	sp
29833                                           ! Debug: list int = const $3F2 (used reg = )
29834 8A02           B8                   03F2  mov	ax,#$3F2
29835 8A05           50                         push	ax
29836                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29837 8A06           E8         7B35            call	_inb
29838 8A09           44                         inc	sp
29839 8A0A           44                         inc	sp
29840                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
29841 8A0B           8846         FF            mov	-1[bp],al
29842                                           !BCC_EOS
29843                                           ! 4355   outb(0x03f2, val8 & ~0x04);
29844                                           ! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
29845 8A0E           8A46         FF            mov	al,-1[bp]
29846 8A11           24                     FB  and	al,#$FB
29847                                           ! Debug: list unsigned char = al+0 (used reg = )
29848 8A13           30E4                       xor	ah,ah
29849 8A15           50                         push	ax
29850                                           ! Debug: list int = const $3F2 (used reg = )
29851 8A16           B8                   03F2  mov	ax,#$3F2
29852 8A19           50                         push	ax
29853                                           ! Debug: func () void = outb+0 (used reg = )
29854 8A1A           E8         7B37            call	_outb
29855 8A1D           83C4                   04  add	sp,*4
29856                                           !BCC_EOS
29857                                           ! 4356   outb(0x03f2, val8 | 0x04);
29858                                           ! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
29859 8A20           8A46         FF            mov	al,-1[bp]
29860 8A23           0C                     04  or	al,*4
29861                                           ! Debug: list unsigned char = al+0 (used reg = )
29862 8A25           30E4                       xor	ah,ah
29863 8A27           50                         push	ax
29864                                           ! Debug: list int = const $3F2 (used reg = )
29865 8A28           B8                   03F2  mov	ax,#$3F2
29866 8A2B           50                         push	ax
29867                                           ! Debug: func () void = outb+0 (used reg = )
29868 8A2C           E8         7B25            call	_outb
29869 8A2F           83C4                   04  add	sp,*4
29870                                           !BCC_EOS
29871                                           ! 4357   do {
29872                       00008A32            .635:
29873                                           ! 4358     val8 = inb(0x3f4);
29874                                           ! Debug: list int = const $3F4 (used reg = )
29875 8A32           B8                   03F4  mov	ax,#$3F4
29876 8A35           50                         push	ax
29877                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29878 8A36           E8         7B05            call	_inb
29879 8A39           44                         inc	sp
29880 8A3A           44                         inc	sp
29881                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
29882 8A3B           8846         FF            mov	-1[bp],al
29883                                           !BCC_EOS
29884                                           ! 4359   } while ( (val8 & 0xc0) != 0x80 );
29885                       00008A3E            .634:
29886                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
29887 8A3E           8A46         FF            mov	al,-1[bp]
29888 8A41           24                     C0  and	al,#$C0
29889                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
29890 8A43           3C                     80  cmp	al,#$80
29891 8A45           75           EB            jne	.635
29892                       00008A47            .636:
29893                                           !BCC_EOS
29894                                           ! 4360 }
29895                       00008A47            .633:
29896 8A47           89EC                       mov	sp,bp
29897 8A49           5D                         pop	bp
29898 8A4A           C3                         ret
29899                                           ! 4361 void floppy_prepare_controller(drive)
29900                                           ! 4362   Bit16u drive;
29901                                           export	_floppy_prepare_controller
29902                       00008A4B            _floppy_prepare_controller:
29903                                           !BCC_EOS
29904                                           ! 4363 {
29905                                           ! 4364   Bit8u val8, dor, prev_reset;
29906                                           !BCC_EOS
29907                                           ! 4365   val8 = read_byte(0x0040, 0x003e);
29908 8A4B           55                         push	bp
29909 8A4C           89E5                       mov	bp,sp
29910 8A4E           83C4                   FC  add	sp,*-4
29911                                           ! Debug: list int = const $3E (used reg = )
29912 8A51           B8                   003E  mov	ax,*$3E
29913 8A54           50                         push	ax
29914                                           ! Debug: list int = const $40 (used reg = )
29915 8A55           B8                   0040  mov	ax,*$40
29916 8A58           50                         push	ax
29917                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
29918 8A59           E8         7B98            call	_read_byte
29919 8A5C           83C4                   04  add	sp,*4
29920                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
29921 8A5F           8846         FF            mov	-1[bp],al
29922                                           !BCC_EOS
29923                                           ! 4366   val8 &= 0x7f;
29924                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
29925 8A62           8A46         FF            mov	al,-1[bp]
29926 8A65           24                     7F  and	al,*$7F
29927 8A67           8846         FF            mov	-1[bp],al
29928                                           !BCC_EOS
29929                                           ! 4367   write_byte(0x0040, 0x003e, val8);
29930                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
29931 8A6A           8A46         FF            mov	al,-1[bp]
29932 8A6D           30E4                       xor	ah,ah
29933 8A6F           50                         push	ax
29934                                           ! Debug: list int = const $3E (used reg = )
29935 8A70           B8                   003E  mov	ax,*$3E
29936 8A73           50                         push	ax
29937                                           ! Debug: list int = const $40 (used reg = )
29938 8A74           B8                   0040  mov	ax,*$40
29939 8A77           50                         push	ax
29940                                           ! Debug: func () void = write_byte+0 (used reg = )
29941 8A78           E8         7B9F            call	_write_byte
29942 8A7B           83C4                   06  add	sp,*6
29943                                           !BCC_EOS
29944                                           ! 4368   prev_reset = inb(0x03f2) & 0x04;
29945                                           ! Debug: list int = const $3F2 (used reg = )
29946 8A7E           B8                   03F2  mov	ax,#$3F2
29947 8A81           50                         push	ax
29948                                           ! Debug: func () unsigned char = inb+0 (used reg = )
29949 8A82           E8         7AB9            call	_inb
29950 8A85           44                         inc	sp
29951 8A86           44                         inc	sp
29952                                           ! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
29953 8A87           24                     04  and	al,*4
29954                                           ! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
29955 8A89           8846         FD            mov	-3[bp],al
29956                                           !BCC_EOS
29957                                           ! 4369   if (drive)
29958 8A8C           8B46         04            mov	ax,4[bp]
29959 8A8F           85C0                       test	ax,ax
29960 8A91           74           07            je  	.637
29961                       00008A93            .638:
29962                                           ! 4370     dor = 0x20;
29963                                           ! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
29964 8A93           B0                     20  mov	al,*$20
29965 8A95           8846         FE            mov	-2[bp],al
29966                                           !BCC_EOS
29967                                           ! 4371   else
29968                                           ! 4372     dor = 0x10;
29969 8A98           EB           05            jmp .639
29970                       00008A9A            .637:
29971                                           ! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
29972 8A9A           B0                     10  mov	al,*$10
29973 8A9C           8846         FE            mov	-2[bp],al
29974                                           !BCC_EOS
29975                                           ! 4373   dor |= 0x0c;
29976                       00008A9F            .639:
29977                                           ! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
29978 8A9F           8A46         FE            mov	al,-2[bp]
29979 8AA2           0C                     0C  or	al,*$C
29980 8AA4           8846         FE            mov	-2[bp],al
29981                                           !BCC_EOS
29982                                           ! 4374   dor |= drive;
29983                                           ! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
29984 8AA7           8B46         04            mov	ax,4[bp]
29985 8AAA           0A46         FE            or	al,-2[bp]
29986 8AAD           8846         FE            mov	-2[bp],al
29987                                           !BCC_EOS
29988                                           ! 4375   outb(0x03f2, dor);
29989                                           ! Debug: list unsigned char dor = [S+6-4] (used reg = )
29990 8AB0           8A46         FE            mov	al,-2[bp]
29991 8AB3           30E4                       xor	ah,ah
29992 8AB5           50                         push	ax
29993                                           ! Debug: list int = const $3F2 (used reg = )
29994 8AB6           B8                   03F2  mov	ax,#$3F2
29995 8AB9           50                         push	ax
29996                                           ! Debug: func () void = outb+0 (used reg = )
29997 8ABA           E8         7A97            call	_outb
29998 8ABD           83C4                   04  add	sp,*4
29999                                           !BCC_EOS
30000                                           ! 4376   write_byte(0x40,0x40, 37);
30001                                           ! Debug: list int = const $25 (used reg = )
30002 8AC0           B8                   0025  mov	ax,*$25
30003 8AC3           50                         push	ax
30004                                           ! Debug: list int = const $40 (used reg = )
30005 8AC4           B8                   0040  mov	ax,*$40
30006 8AC7           50                         push	ax
30007                                           ! Debug: list int = const $40 (used reg = )
30008 8AC8           B8                   0040  mov	ax,*$40
30009 8ACB           50                         push	ax
30010                                           ! Debug: func () void = write_byte+0 (used reg = )
30011 8ACC           E8         7B4B            call	_write_byte
30012 8ACF           83C4                   06  add	sp,*6
30013                                           !BCC_EOS
30014                                           ! 4377   do {
30015                       00008AD2            .63C:
30016                                           ! 4378     val8 = inb(0x3f4);
30017                                           ! Debug: list int = const $3F4 (used reg = )
30018 8AD2           B8                   03F4  mov	ax,#$3F4
30019 8AD5           50                         push	ax
30020                                           ! Debug: func () unsigned char = inb+0 (used reg = )
30021 8AD6           E8         7A65            call	_inb
30022 8AD9           44                         inc	sp
30023 8ADA           44                         inc	sp
30024                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30025 8ADB           8846         FF            mov	-1[bp],al
30026                                           !BCC_EOS
30027                                           ! 4379   } while ( (val8 & 0xc0) != 0x80 );
30028                       00008ADE            .63B:
30029                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
30030 8ADE           8A46         FF            mov	al,-1[bp]
30031 8AE1           24                     C0  and	al,#$C0
30032                                           ! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
30033 8AE3           3C                     80  cmp	al,#$80
30034 8AE5           75           EB            jne	.63C
30035                       00008AE7            .63D:
30036                                           !BCC_EOS
30037                                           ! 4380   if (prev_reset == 0) {
30038                       00008AE7            .63A:
30039                                           ! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
30040 8AE7           8A46         FD            mov	al,-3[bp]
30041 8AEA           84C0                       test	al,al
30042 8AEC           75           38            jne 	.63E
30043                       00008AEE            .63F:
30044                                           ! 4381 #asm
30045                                           !BCC_EOS
30046                                           !BCC_ASM
30047                       00000002            _floppy_prepare_controller.dor	set	2
30048                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30049                       00000001            _floppy_prepare_controller.prev_reset	set	1
30050                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30051                       00000003            _floppy_prepare_controller.val8	set	3
30052                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30053                       00000008            _floppy_prepare_controller.drive	set	8
30054                       00000004            .floppy_prepare_controller.drive	set	4
30055 8AEE           FB                             sti
30056                                           ! 4383 endasm
30057                                           !BCC_ENDASM
30058                                           !BCC_EOS
30059                                           ! 4384     do {
30060                       00008AEF            .642:
30061                                           ! 4385       val8 = read_byte(0x0040, 0x003e);
30062                                           ! Debug: list int = const $3E (used reg = )
30063 8AEF           B8                   003E  mov	ax,*$3E
30064 8AF2           50                         push	ax
30065                                           ! Debug: list int = const $40 (used reg = )
30066 8AF3           B8                   0040  mov	ax,*$40
30067 8AF6           50                         push	ax
30068                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30069 8AF7           E8         7AFA            call	_read_byte
30070 8AFA           83C4                   04  add	sp,*4
30071                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30072 8AFD           8846         FF            mov	-1[bp],al
30073                                           !BCC_EOS
30074                                           ! 4386     } while ( (val8 & 0x80) == 0 );
30075                       00008B00            .641:
30076                                           ! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
30077 8B00           8A46         FF            mov	al,-1[bp]
30078 8B03           24                     80  and	al,#$80
30079                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
30080 8B05           84C0                       test	al,al
30081 8B07           74           E6            je 	.642
30082                       00008B09            .643:
30083                                           !BCC_EOS
30084                                           ! 4387     val8 &= 0x7f;
30085                       00008B09            .640:
30086                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30087 8B09           8A46         FF            mov	al,-1[bp]
30088 8B0C           24                     7F  and	al,*$7F
30089 8B0E           8846         FF            mov	-1[bp],al
30090                                           !BCC_EOS
30091                                           ! 4388 #asm
30092                                           !BCC_EOS
30093                                           !BCC_ASM
30094                       00000002            _floppy_prepare_controller.dor	set	2
30095                       FFFFFFFE            .floppy_prepare_controller.dor	set	-2
30096                       00000001            _floppy_prepare_controller.prev_reset	set	1
30097                       FFFFFFFD            .floppy_prepare_controller.prev_reset	set	-3
30098                       00000003            _floppy_prepare_controller.val8	set	3
30099                       FFFFFFFF            .floppy_prepare_controller.val8	set	-1
30100                       00000008            _floppy_prepare_controller.drive	set	8
30101                       00000004            .floppy_prepare_controller.drive	set	4
30102 8B11           FA                             cli
30103                                           ! 4390 endasm
30104                                           !BCC_ENDASM
30105                                           !BCC_EOS
30106                                           ! 4391     write_byte(0x0040, 0x003e, val8);
30107                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30108 8B12           8A46         FF            mov	al,-1[bp]
30109 8B15           30E4                       xor	ah,ah
30110 8B17           50                         push	ax
30111                                           ! Debug: list int = const $3E (used reg = )
30112 8B18           B8                   003E  mov	ax,*$3E
30113 8B1B           50                         push	ax
30114                                           ! Debug: list int = const $40 (used reg = )
30115 8B1C           B8                   0040  mov	ax,*$40
30116 8B1F           50                         push	ax
30117                                           ! Debug: func () void = write_byte+0 (used reg = )
30118 8B20           E8         7AF7            call	_write_byte
30119 8B23           83C4                   06  add	sp,*6
30120                                           !BCC_EOS
30121                                           ! 4392   }
30122                                           ! 4393 }
30123                       00008B26            .63E:
30124 8B26           89EC                       mov	sp,bp
30125 8B28           5D                         pop	bp
30126 8B29           C3                         ret
30127                                           ! 4394   bx_bool
30128                                           ! 4395 floppy_media_known(drive)
30129                                           ! 4396   Bit16u drive;
30130                                           export	_floppy_media_known
30131                       00008B2A            _floppy_media_known:
30132                                           !BCC_EOS
30133                                           ! 4397 {
30134                                           ! 4398   Bit8u val8;
30135                                           !BCC_EOS
30136                                           ! 4399   Bit16u media_state_offset;
30137                                           !BCC_EOS
30138                                           ! 4400   val8 = read_byte(0x0040, 0x003e);
30139 8B2A           55                         push	bp
30140 8B2B           89E5                       mov	bp,sp
30141 8B2D           83C4                   FC  add	sp,*-4
30142                                           ! Debug: list int = const $3E (used reg = )
30143 8B30           B8                   003E  mov	ax,*$3E
30144 8B33           50                         push	ax
30145                                           ! Debug: list int = const $40 (used reg = )
30146 8B34           B8                   0040  mov	ax,*$40
30147 8B37           50                         push	ax
30148                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30149 8B38           E8         7AB9            call	_read_byte
30150 8B3B           83C4                   04  add	sp,*4
30151                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30152 8B3E           8846         FF            mov	-1[bp],al
30153                                           !BCC_EOS
30154                                           ! 4401   if (drive)
30155 8B41           8B46         04            mov	ax,4[bp]
30156 8B44           85C0                       test	ax,ax
30157 8B46           74           0A            je  	.644
30158                       00008B48            .645:
30159                                           ! 4402     val8 >>= 1;
30160                                           ! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30161 8B48           8A46         FF            mov	al,-1[bp]
30162 8B4B           30E4                       xor	ah,ah
30163 8B4D           D1E8                       shr	ax,*1
30164 8B4F           8846         FF            mov	-1[bp],al
30165                                           !BCC_EOS
30166                                           ! 4403   val8 &= 0x01;
30167                       00008B52            .644:
30168                                           ! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30169 8B52           8A46         FF            mov	al,-1[bp]
30170 8B55           24                     01  and	al,*1
30171 8B57           8846         FF            mov	-1[bp],al
30172                                           !BCC_EOS
30173                                           ! 4404   if (val8 == 0)
30174                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30175 8B5A           8A46         FF            mov	al,-1[bp]
30176 8B5D           84C0                       test	al,al
30177 8B5F           75           06            jne 	.646
30178                       00008B61            .647:
30179                                           ! 4405     return(0);
30180 8B61           31C0                       xor	ax,ax
30181 8B63           89EC                       mov	sp,bp
30182 8B65           5D                         pop	bp
30183 8B66           C3                         ret
30184                                           !BCC_EOS
30185                                           ! 4406   media_state_offset = 0x0090;
30186                       00008B67            .646:
30187                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
30188 8B67           B8                   0090  mov	ax,#$90
30189 8B6A           8946         FC            mov	-4[bp],ax
30190                                           !BCC_EOS
30191                                           ! 4407   if (drive)
30192 8B6D           8B46         04            mov	ax,4[bp]
30193 8B70           85C0                       test	ax,ax
30194 8B72           74           07            je  	.648
30195                       00008B74            .649:
30196                                           ! 4408     media_state_offset += 1;
30197                                           ! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
30198 8B74           8B46         FC            mov	ax,-4[bp]
30199 8B77           40                         inc	ax
30200 8B78           8946         FC            mov	-4[bp],ax
30201                                           !BCC_EOS
30202                                           ! 4409   val8 = read_byte(0x0040, media_state_offset);
30203                       00008B7B            .648:
30204                                           ! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
30205 8B7B           FF76         FC            push	-4[bp]
30206                                           ! Debug: list int = const $40 (used reg = )
30207 8B7E           B8                   0040  mov	ax,*$40
30208 8B81           50                         push	ax
30209                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30210 8B82           E8         7A6F            call	_read_byte
30211 8B85           83C4                   04  add	sp,*4
30212                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30213 8B88           8846         FF            mov	-1[bp],al
30214                                           !BCC_EOS
30215                                           ! 4410   val8 = (val8 >> 4) & 0x01;
30216                                           ! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
30217 8B8B           8A46         FF            mov	al,-1[bp]
30218 8B8E           30E4                       xor	ah,ah
30219 8B90           B1                     04  mov	cl,*4
30220 8B92           D3E8                       shr	ax,cl
30221                                           ! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
30222 8B94           24                     01  and	al,*1
30223                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30224 8B96           8846         FF            mov	-1[bp],al
30225                                           !BCC_EOS
30226                                           ! 4411   if (val8 == 0)
30227                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30228 8B99           8A46         FF            mov	al,-1[bp]
30229 8B9C           84C0                       test	al,al
30230 8B9E           75           06            jne 	.64A
30231                       00008BA0            .64B:
30232                                           ! 4412     return(0);
30233 8BA0           31C0                       xor	ax,ax
30234 8BA2           89EC                       mov	sp,bp
30235 8BA4           5D                         pop	bp
30236 8BA5           C3                         ret
30237                                           !BCC_EOS
30238                                           ! 4413   return(1);
30239                       00008BA6            .64A:
30240 8BA6           B8                   0001  mov	ax,*1
30241 8BA9           89EC                       mov	sp,bp
30242 8BAB           5D                         pop	bp
30243 8BAC           C3                         ret
30244                                           !BCC_EOS
30245                                           ! 4414 }
30246                                           ! 4415   bx_bool
30247                                           ! 4416 floppy_media_sense(drive)
30248                                           ! 4417   Bit16u drive;
30249                                           export	_floppy_media_sense
30250                       00008BAD            _floppy_media_sense:
30251                                           !BCC_EOS
30252                                           ! 4418 {
30253                                           ! 4419   bx_bool retval;
30254                                           !BCC_EOS
30255                                           ! 4420   Bit16u media_state_offset;
30256                                           !BCC_EOS
30257                                           ! 4421   Bit8u drive_type, config_data, media_state;
30258                                           !BCC_EOS
30259                                           ! 4422   if (floppy_drive_recal(drive) == 0) {
30260 8BAD           55                         push	bp
30261 8BAE           89E5                       mov	bp,sp
30262 8BB0           83C4                   F8  add	sp,*-8
30263                                           ! Debug: list unsigned short drive = [S+$A+2] (used reg = )
30264 8BB3           FF76         04            push	4[bp]
30265                                           ! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
30266 8BB6           E8         0154            call	_floppy_drive_recal
30267 8BB9           44                         inc	sp
30268 8BBA           44                         inc	sp
30269                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
30270 8BBB           85C0                       test	ax,ax
30271 8BBD           75           06            jne 	.64C
30272                       00008BBF            .64D:
30273                                           ! 4423     return(0);
30274 8BBF           31C0                       xor	ax,ax
30275 8BC1           89EC                       mov	sp,bp
30276 8BC3           5D                         pop	bp
30277 8BC4           C3                         ret
30278                                           !BCC_EOS
30279                                           ! 4424     }
30280                                           ! 4425   drive_type = inb_cmos(0x10);
30281                       00008BC5            .64C:
30282                                           ! Debug: list int = const $10 (used reg = )
30283 8BC5           B8                   0010  mov	ax,*$10
30284 8BC8           50                         push	ax
30285                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30286 8BC9           E8         79B7            call	_inb_cmos
30287 8BCC           44                         inc	sp
30288 8BCD           44                         inc	sp
30289                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
30290 8BCE           8846         FB            mov	-5[bp],al
30291                                           !BCC_EOS
30292                                           ! 4426   if (drive == 0)
30293                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
30294 8BD1           8B46         04            mov	ax,4[bp]
30295 8BD4           85C0                       test	ax,ax
30296 8BD6           75           0E            jne 	.64E
30297                       00008BD8            .64F:
30298                                           ! 4427     drive_type >>= 4;
30299                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
30300 8BD8           8A46         FB            mov	al,-5[bp]
30301 8BDB           30E4                       xor	ah,ah
30302 8BDD           B1                     04  mov	cl,*4
30303 8BDF           D3E8                       shr	ax,cl
30304 8BE1           8846         FB            mov	-5[bp],al
30305                                           !BCC_EOS
30306                                           ! 4428   else
30307                                           ! 4429     drive_type &= 0x0f;
30308 8BE4           EB           08            jmp .650
30309                       00008BE6            .64E:
30310                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
30311 8BE6           8A46         FB            mov	al,-5[bp]
30312 8BE9           24                     0F  and	al,*$F
30313 8BEB           8846         FB            mov	-5[bp],al
30314                                           !BCC_EOS
30315                                           ! 4430   if ( drive_type == 1 ) {
30316                       00008BEE            .650:
30317                                           ! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
30318 8BEE           8A46         FB            mov	al,-5[bp]
30319 8BF1           3C                     01  cmp	al,*1
30320 8BF3           75           13            jne 	.651
30321                       00008BF5            .652:
30322                                           ! 4431     config_data = 0x00;
30323                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30324 8BF5           30C0                       xor	al,al
30325 8BF7           8846         FA            mov	-6[bp],al
30326                                           !BCC_EOS
30327                                           ! 4432     media_state = 0x25;
30328                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
30329 8BFA           B0                     25  mov	al,*$25
30330 8BFC           8846         F9            mov	-7[bp],al
30331                                           !BCC_EOS
30332                                           ! 4433     retval = 1;
30333                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30334 8BFF           B8                   0001  mov	ax,*1
30335 8C02           8946         FE            mov	-2[bp],ax
30336                                           !BCC_EOS
30337                                           ! 4434     }
30338                                           ! 4435   else if ( drive_type == 2 ) {
30339 8C05           E9         00C2            br 	.653
30340                       00008C08            .651:
30341                                           ! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
30342 8C08           8A46         FB            mov	al,-5[bp]
30343 8C0B           3C                     02  cmp	al,*2
30344 8C0D           75           13            jne 	.654
30345                       00008C0F            .655:
30346                                           ! 4436     config_data = 0x00;
30347                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30348 8C0F           30C0                       xor	al,al
30349 8C11           8846         FA            mov	-6[bp],al
30350                                           !BCC_EOS
30351                                           ! 4437     media_state = 0x25;
30352                                           ! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
30353 8C14           B0                     25  mov	al,*$25
30354 8C16           8846         F9            mov	-7[bp],al
30355                                           !BCC_EOS
30356                                           ! 4438     retval = 1;
30357                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30358 8C19           B8                   0001  mov	ax,*1
30359 8C1C           8946         FE            mov	-2[bp],ax
30360                                           !BCC_EOS
30361                                           ! 4439     }
30362                                           ! 4440   else if ( drive_type == 3 ) {
30363 8C1F           E9         00A8            br 	.656
30364                       00008C22            .654:
30365                                           ! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
30366 8C22           8A46         FB            mov	al,-5[bp]
30367 8C25           3C                     03  cmp	al,*3
30368 8C27           75           13            jne 	.657
30369                       00008C29            .658:
30370                                           ! 4441     config_data = 0x00;
30371                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30372 8C29           30C0                       xor	al,al
30373 8C2B           8846         FA            mov	-6[bp],al
30374                                           !BCC_EOS
30375                                           ! 4442     media_state = 0x17;
30376                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
30377 8C2E           B0                     17  mov	al,*$17
30378 8C30           8846         F9            mov	-7[bp],al
30379                                           !BCC_EOS
30380                                           ! 4443     retval = 1;
30381                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30382 8C33           B8                   0001  mov	ax,*1
30383 8C36           8946         FE            mov	-2[bp],ax
30384                                           !BCC_EOS
30385                                           ! 4444     }
30386                                           ! 4445   else if ( drive_type == 4 ) {
30387 8C39           E9         008E            br 	.659
30388                       00008C3C            .657:
30389                                           ! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
30390 8C3C           8A46         FB            mov	al,-5[bp]
30391 8C3F           3C                     04  cmp	al,*4
30392 8C41           75           12            jne 	.65A
30393                       00008C43            .65B:
30394                                           ! 4446     config_data = 0x00;
30395                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30396 8C43           30C0                       xor	al,al
30397 8C45           8846         FA            mov	-6[bp],al
30398                                           !BCC_EOS
30399                                           ! 4447     media_state =
30400                                           ! 4447  0x17;
30401                                           ! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
30402 8C48           B0                     17  mov	al,*$17
30403 8C4A           8846         F9            mov	-7[bp],al
30404                                           !BCC_EOS
30405                                           ! 4448     retval = 1;
30406                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30407 8C4D           B8                   0001  mov	ax,*1
30408 8C50           8946         FE            mov	-2[bp],ax
30409                                           !BCC_EOS
30410                                           ! 4449     }
30411                                           ! 4450   else if ( drive_type == 5 ) {
30412 8C53           EB           75            jmp .65C
30413                       00008C55            .65A:
30414                                           ! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
30415 8C55           8A46         FB            mov	al,-5[bp]
30416 8C58           3C                     05  cmp	al,*5
30417 8C5A           75           12            jne 	.65D
30418                       00008C5C            .65E:
30419                                           ! 4451     config_data = 0xCC;
30420                                           ! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
30421 8C5C           B0                     CC  mov	al,#$CC
30422 8C5E           8846         FA            mov	-6[bp],al
30423                                           !BCC_EOS
30424                                           ! 4452     media_state = 0xD7;
30425                                           ! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
30426 8C61           B0                     D7  mov	al,#$D7
30427 8C63           8846         F9            mov	-7[bp],al
30428                                           !BCC_EOS
30429                                           ! 4453     retval = 1;
30430                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30431 8C66           B8                   0001  mov	ax,*1
30432 8C69           8946         FE            mov	-2[bp],ax
30433                                           !BCC_EOS
30434                                           ! 4454     }
30435                                           ! 4455   else if ( drive_type == 6 ) {
30436 8C6C           EB           5C            jmp .65F
30437                       00008C6E            .65D:
30438                                           ! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
30439 8C6E           8A46         FB            mov	al,-5[bp]
30440 8C71           3C                     06  cmp	al,*6
30441 8C73           75           12            jne 	.660
30442                       00008C75            .661:
30443                                           ! 4456     config_data = 0x00;
30444                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30445 8C75           30C0                       xor	al,al
30446 8C77           8846         FA            mov	-6[bp],al
30447                                           !BCC_EOS
30448                                           ! 4457     media_state = 0x27;
30449                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30450 8C7A           B0                     27  mov	al,*$27
30451 8C7C           8846         F9            mov	-7[bp],al
30452                                           !BCC_EOS
30453                                           ! 4458     retval = 1;
30454                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30455 8C7F           B8                   0001  mov	ax,*1
30456 8C82           8946         FE            mov	-2[bp],ax
30457                                           !BCC_EOS
30458                                           ! 4459     }
30459                                           ! 4460   else if ( drive_type == 7 ) {
30460 8C85           EB           43            jmp .662
30461                       00008C87            .660:
30462                                           ! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
30463 8C87           8A46         FB            mov	al,-5[bp]
30464 8C8A           3C                     07  cmp	al,*7
30465 8C8C           75           12            jne 	.663
30466                       00008C8E            .664:
30467                                           ! 4461     config_data = 0x00;
30468                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30469 8C8E           30C0                       xor	al,al
30470 8C90           8846         FA            mov	-6[bp],al
30471                                           !BCC_EOS
30472                                           ! 4462     media_state = 0x27;
30473                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30474 8C93           B0                     27  mov	al,*$27
30475 8C95           8846         F9            mov	-7[bp],al
30476                                           !BCC_EOS
30477                                           ! 4463     retval = 1;
30478                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30479 8C98           B8                   0001  mov	ax,*1
30480 8C9B           8946         FE            mov	-2[bp],ax
30481                                           !BCC_EOS
30482                                           ! 4464     }
30483                                           ! 4465   else if ( drive_type == 8 ) {
30484 8C9E           EB           2A            jmp .665
30485                       00008CA0            .663:
30486                                           ! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
30487 8CA0           8A46         FB            mov	al,-5[bp]
30488 8CA3           3C                     08  cmp	al,*8
30489 8CA5         0F85         0012            bne 	.666
30490                       00008CA9            .667:
30491                                           ! 4466     config_data = 0x00;
30492                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30493 8CA9           30C0                       xor	al,al
30494 8CAB           8846         FA            mov	-6[bp],al
30495                                           !BCC_EOS
30496                                           ! 4467     media_state = 0x27;
30497                                           ! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
30498 8CAE           B0                     27  mov	al,*$27
30499 8CB0           8846         F9            mov	-7[bp],al
30500                                           !BCC_EOS
30501                                           ! 4468     retval = 1;
30502                                           ! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
30503 8CB3           B8                   0001  mov	ax,*1
30504 8CB6           8946         FE            mov	-2[bp],ax
30505                                           !BCC_EOS
30506                                           ! 4469     }
30507                                           ! 4470   else {
30508 8CB9           EB           0F            jmp .668
30509                       00008CBB            .666:
30510                                           ! 4471     config_data = 0x00;
30511                                           ! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
30512 8CBB           30C0                       xor	al,al
30513 8CBD           8846         FA            mov	-6[bp],al
30514                                           !BCC_EOS
30515                                           ! 4472     media_state = 0x00;
30516                                           ! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
30517 8CC0           30C0                       xor	al,al
30518 8CC2           8846         F9            mov	-7[bp],al
30519                                           !BCC_EOS
30520                                           ! 4473     retval = 0;
30521                                           ! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
30522 8CC5           31C0                       xor	ax,ax
30523 8CC7           8946         FE            mov	-2[bp],ax
30524                                           !BCC_EOS
30525                                           ! 4474     }
30526                                           ! 4475   if (drive == 0)
30527                       00008CCA            .668:
30528                       00008CCA            .665:
30529                       00008CCA            .662:
30530                       00008CCA            .65F:
30531                       00008CCA            .65C:
30532                       00008CCA            .659:
30533                       00008CCA            .656:
30534                       00008CCA            .653:
30535                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
30536 8CCA           8B46         04            mov	ax,4[bp]
30537 8CCD           85C0                       test	ax,ax
30538 8CCF           75           08            jne 	.669
30539                       00008CD1            .66A:
30540                                           ! 4476     media_state_offset = 0x90;
30541                                           ! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
30542 8CD1           B8                   0090  mov	ax,#$90
30543 8CD4           8946         FC            mov	-4[bp],ax
30544                                           !BCC_EOS
30545                                           ! 4477   else
30546                                           ! 4478     media_state_offset = 0x91;
30547 8CD7           EB           06            jmp .66B
30548                       00008CD9            .669:
30549                                           ! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
30550 8CD9           B8                   0091  mov	ax,#$91
30551 8CDC           8946         FC            mov	-4[bp],ax
30552                                           !BCC_EOS
30553                                           ! 4479   write_byte(0x0040, 0x008B, config_data);
30554                       00008CDF            .66B:
30555                                           ! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
30556 8CDF           8A46         FA            mov	al,-6[bp]
30557 8CE2           30E4                       xor	ah,ah
30558 8CE4           50                         push	ax
30559                                           ! Debug: list int = const $8B (used reg = )
30560 8CE5           B8                   008B  mov	ax,#$8B
30561 8CE8           50                         push	ax
30562                                           ! Debug: list int = const $40 (used reg = )
30563 8CE9           B8                   0040  mov	ax,*$40
30564 8CEC           50                         push	ax
30565                                           ! Debug: func () void = write_byte+0 (used reg = )
30566 8CED           E8         792A            call	_write_byte
30567 8CF0           83C4                   06  add	sp,*6
30568                                           !BCC_EOS
30569                                           ! 4480   write_byte(0x0040, media_state_offset, media_state);
30570                                           ! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
30571 8CF3           8A46         F9            mov	al,-7[bp]
30572 8CF6           30E4                       xor	ah,ah
30573 8CF8           50                         push	ax
30574                                           ! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
30575 8CF9           FF76         FC            push	-4[bp]
30576                                           ! Debug: list int = const $40 (used reg = )
30577 8CFC           B8                   0040  mov	ax,*$40
30578 8CFF           50                         push	ax
30579                                           ! Debug: func () void = write_byte+0 (used reg = )
30580 8D00           E8         7917            call	_write_byte
30581 8D03           83C4                   06  add	sp,*6
30582                                           !BCC_EOS
30583                                           ! 4481   return(retval);
30584 8D06           8B46         FE            mov	ax,-2[bp]
30585 8D09           89EC                       mov	sp,bp
30586 8D0B           5D                         pop	bp
30587 8D0C           C3                         ret
30588                                           !BCC_EOS
30589                                           ! 4482 }
30590                                           ! 4483   bx_bool
30591                                           ! 4484 floppy_drive_recal(drive)
30592                                           ! 4485   Bit16u drive;
30593                                           export	_floppy_drive_recal
30594                       00008D0D            _floppy_drive_recal:
30595                                           !BCC_EOS
30596                                           ! 4486 {
30597                                           ! 4487   Bit8u val8;
30598                                           !BCC_EOS
30599                                           ! 4488   Bit16u curr_cyl_offset;
30600                                           !BCC_EOS
30601                                           ! 4489   floppy_prepare_controller(drive);
30602 8D0D           55                         push	bp
30603 8D0E           89E5                       mov	bp,sp
30604 8D10           83C4                   FC  add	sp,*-4
30605                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
30606 8D13           FF76         04            push	4[bp]
30607                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
30608 8D16           E8         FD32            call	_floppy_prepare_controller
30609 8D19           44                         inc	sp
30610 8D1A           44                         inc	sp
30611                                           !BCC_EOS
30612                                           ! 4490   outb(0x03f5, 0x07);
30613                                           ! Debug: list int = const 7 (used reg = )
30614 8D1B           B8                   0007  mov	ax,*7
30615 8D1E           50                         push	ax
30616                                           ! Debug: list int = const $3F5 (used reg = )
30617 8D1F           B8                   03F5  mov	ax,#$3F5
30618 8D22           50                         push	ax
30619                                           ! Debug: func () void = outb+0 (used reg = )
30620 8D23           E8         782E            call	_outb
30621 8D26           83C4                   04  add	sp,*4
30622                                           !BCC_EOS
30623                                           ! 4491   outb(0x03f5, drive);
30624                                           ! Debug: list unsigned short drive = [S+6+2] (used reg = )
30625 8D29           FF76         04            push	4[bp]
30626                                           ! Debug: list int = const $3F5 (used reg = )
30627 8D2C           B8                   03F5  mov	ax,#$3F5
30628 8D2F           50                         push	ax
30629                                           ! Debug: func () void = outb+0 (used reg = )
30630 8D30           E8         7821            call	_outb
30631 8D33           83C4                   04  add	sp,*4
30632                                           !BCC_EOS
30633                                           ! 4492 #asm
30634                                           !BCC_EOS
30635                                           !BCC_ASM
30636                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
30637                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
30638                       00000003            _floppy_drive_recal.val8	set	3
30639                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
30640                       00000008            _floppy_drive_recal.drive	set	8
30641                       00000004            .floppy_drive_recal.drive	set	4
30642 8D36           FB                           sti
30643                                           ! 4494 endasm
30644                                           !BCC_ENDASM
30645                                           !BCC_EOS
30646                                           ! 4495   do {
30647                       00008D37            .66E:
30648                                           ! 4496     val8 = (read_byte(0x0040, 0x003e) & 0x80);
30649                                           ! Debug: list int = const $3E (used reg = )
30650 8D37           B8                   003E  mov	ax,*$3E
30651 8D3A           50                         push	ax
30652                                           ! Debug: list int = const $40 (used reg = )
30653 8D3B           B8                   0040  mov	ax,*$40
30654 8D3E           50                         push	ax
30655                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30656 8D3F           E8         78B2            call	_read_byte
30657 8D42           83C4                   04  add	sp,*4
30658                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
30659 8D45           24                     80  and	al,#$80
30660                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30661 8D47           8846         FF            mov	-1[bp],al
30662                                           !BCC_EOS
30663                                           ! 4497   } while ( val8 == 0 );
30664                       00008D4A            .66D:
30665                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30666 8D4A           8A46         FF            mov	al,-1[bp]
30667 8D4D           84C0                       test	al,al
30668 8D4F           74           E6            je 	.66E
30669                       00008D51            .66F:
30670                                           !BCC_EOS
30671                                           ! 4498   val8 = 0;
30672                       00008D51            .66C:
30673                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
30674 8D51           30C0                       xor	al,al
30675 8D53           8846         FF            mov	-1[bp],al
30676                                           !BCC_EOS
30677                                           ! 4499 #asm
30678                                           !BCC_EOS
30679                                           !BCC_ASM
30680                       00000000            _floppy_drive_recal.curr_cyl_offset	set	0
30681                       FFFFFFFC            .floppy_drive_recal.curr_cyl_offset	set	-4
30682                       00000003            _floppy_drive_recal.val8	set	3
30683                       FFFFFFFF            .floppy_drive_recal.val8	set	-1
30684                       00000008            _floppy_drive_recal.drive	set	8
30685                       00000004            .floppy_drive_recal.drive	set	4
30686 8D56           FA                           cli
30687                                           ! 4501 endasm
30688                                           !BCC_ENDASM
30689                                           !BCC_EOS
30690                                           ! 4502   val8 = read_byte(0x0040, 0x003e);
30691                                           ! Debug: list int = const $3E (used reg = )
30692 8D57           B8                   003E  mov	ax,*$3E
30693 8D5A           50                         push	ax
30694                                           ! Debug: list int = const $40 (used reg = )
30695 8D5B           B8                   0040  mov	ax,*$40
30696 8D5E           50                         push	ax
30697                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
30698 8D5F           E8         7892            call	_read_byte
30699 8D62           83C4                   04  add	sp,*4
30700                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
30701 8D65           8846         FF            mov	-1[bp],al
30702                                           !BCC_EOS
30703                                           ! 4503   val8 &= 0x7f;
30704                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
30705 8D68           8A46         FF            mov	al,-1[bp]
30706 8D6B           24                     7F  and	al,*$7F
30707 8D6D           8846         FF            mov	-1[bp],al
30708                                           !BCC_EOS
30709                                           ! 4504   if (drive) {
30710 8D70           8B46         04            mov	ax,4[bp]
30711 8D73           85C0                       test	ax,ax
30712 8D75           74           10            je  	.670
30713                       00008D77            .671:
30714                                           ! 4505     val8 |= 0x02;
30715                                           ! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
30716 8D77           8A46         FF            mov	al,-1[bp]
30717 8D7A           0C                     02  or	al,*2
30718 8D7C           8846         FF            mov	-1[bp],al
30719                                           !BCC_EOS
30720                                           ! 4506     curr_cyl_offset = 0x0095;
30721                                           ! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
30722 8D7F           B8                   0095  mov	ax,#$95
30723 8D82           8946         FC            mov	-4[bp],ax
30724                                           !BCC_EOS
30725                                           ! 4507   } else {
30726 8D85           EB           0E            jmp .672
30727                       00008D87            .670:
30728                                           ! 4508     val8 |= 0x01;
30729                                           ! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
30730 8D87           8A46         FF            mov	al,-1[bp]
30731 8D8A           0C                     01  or	al,*1
30732 8D8C           8846         FF            mov	-1[bp],al
30733                                           !BCC_EOS
30734                                           ! 4509     curr_cyl_offset = 0x0094;
30735                                           ! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
30736 8D8F           B8                   0094  mov	ax,#$94
30737 8D92           8946         FC            mov	-4[bp],ax
30738                                           !BCC_EOS
30739                                           ! 4510   }
30740                                           ! 4511   write_byte(0x0040, 0x003e, val8);
30741                       00008D95            .672:
30742                                           ! Debug: list unsigned char val8 = [S+6-3] (used reg = )
30743 8D95           8A46         FF            mov	al,-1[bp]
30744 8D98           30E4                       xor	ah,ah
30745 8D9A           50                         push	ax
30746                                           ! Debug: list int = const $3E (used reg = )
30747 8D9B           B8                   003E  mov	ax,*$3E
30748 8D9E           50                         push	ax
30749                                           ! Debug: list int = const $40 (used reg = )
30750 8D9F           B8                   0040  mov	ax,*$40
30751 8DA2           50                         push	ax
30752                                           ! Debug: func () void = write_byte+0 (used reg = )
30753 8DA3           E8         7874            call	_write_byte
30754 8DA6           83C4                   06  add	sp,*6
30755                                           !BCC_EOS
30756                                           ! 4512   write_byte(0x0040, curr_cyl_offset, 0);
30757                                           ! Debug: list int = const 0 (used reg = )
30758 8DA9           31C0                       xor	ax,ax
30759 8DAB           50                         push	ax
30760                                           ! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
30761 8DAC           FF76         FC            push	-4[bp]
30762                                           ! Debug: list int = const $40 (used reg = )
30763 8DAF           B8                   0040  mov	ax,*$40
30764 8DB2           50                         push	ax
30765                                           ! Debug: func () void = write_byte+0 (used reg = )
30766 8DB3           E8         7864            call	_write_byte
30767 8DB6           83C4                   06  add	sp,*6
30768                                           !BCC_EOS
30769                                           ! 4513   return(1);
30770 8DB9           B8                   0001  mov	ax,*1
30771 8DBC           89EC                       mov	sp,bp
30772 8DBE           5D                         pop	bp
30773 8DBF           C3                         ret
30774                                           !BCC_EOS
30775                                           ! 4514 }
30776                                           ! 4515   bx_bool
30777                                           ! 4516 floppy_drive_exists(drive)
30778                                           ! 4517   Bit16u drive;
30779                                           export	_floppy_drive_exists
30780                       00008DC0            _floppy_drive_exists:
30781                                           !BCC_EOS
30782                                           ! 4518 {
30783                                           ! 4519   Bit8u drive_type;
30784                                           !BCC_EOS
30785                                           ! 4520   drive_type = inb_cmos(0x10);
30786 8DC0           55                         push	bp
30787 8DC1           89E5                       mov	bp,sp
30788 8DC3           4C                         dec	sp
30789 8DC4           4C                         dec	sp
30790                                           ! Debug: list int = const $10 (used reg = )
30791 8DC5           B8                   0010  mov	ax,*$10
30792 8DC8           50                         push	ax
30793                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30794 8DC9           E8         77B7            call	_inb_cmos
30795 8DCC           44                         inc	sp
30796 8DCD           44                         inc	sp
30797                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
30798 8DCE           8846         FF            mov	-1[bp],al
30799                                           !BCC_EOS
30800                                           ! 4521   if (drive == 0)
30801                                           ! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
30802 8DD1           8B46         04            mov	ax,4[bp]
30803 8DD4           85C0                       test	ax,ax
30804 8DD6           75           0E            jne 	.673
30805                       00008DD8            .674:
30806                                           ! 4522     drive_type >>= 4;
30807                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
30808 8DD8           8A46         FF            mov	al,-1[bp]
30809 8DDB           30E4                       xor	ah,ah
30810 8DDD           B1                     04  mov	cl,*4
30811 8DDF           D3E8                       shr	ax,cl
30812 8DE1           8846         FF            mov	-1[bp],al
30813                                           !BCC_EOS
30814                                           ! 4523   else
30815                                           ! 4524     drive_type &= 0x0f;
30816 8DE4           EB           08            jmp .675
30817                       00008DE6            .673:
30818                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
30819 8DE6           8A46         FF            mov	al,-1[bp]
30820 8DE9           24                     0F  and	al,*$F
30821 8DEB           8846         FF            mov	-1[bp],al
30822                                           !BCC_EOS
30823                                           ! 4525   if ( drive_type == 0 )
30824                       00008DEE            .675:
30825                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
30826 8DEE           8A46         FF            mov	al,-1[bp]
30827 8DF1           84C0                       test	al,al
30828 8DF3           75           08            jne 	.676
30829                       00008DF5            .677:
30830                                           ! 4526     return(0);
30831 8DF5           31C0                       xor	ax,ax
30832 8DF7           89EC                       mov	sp,bp
30833 8DF9           5D                         pop	bp
30834 8DFA           C3                         ret
30835                                           !BCC_EOS
30836                                           ! 4527   else
30837                                           ! 4528     return(1);
30838 8DFB           EB           07            jmp .678
30839                       00008DFD            .676:
30840 8DFD           B8                   0001  mov	ax,*1
30841 8E00           89EC                       mov	sp,bp
30842 8E02           5D                         pop	bp
30843 8E03           C3                         ret
30844                                           !BCC_EOS
30845                                           ! 4529 }
30846                       00008E04            .678:
30847 8E04           89EC                       mov	sp,bp
30848 8E06           5D                         pop	bp
30849 8E07           C3                         ret
30850                                           ! 4530   void
30851                                           ! 4531 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
30852                                           ! 4532   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
30853                                           export	_int13_diskette_function
30854                       00008E08            _int13_diskette_function:
30855                                           !BCC_EOS
30856                                           ! 4533 {
30857                                           ! 4534   Bit8u drive, num_sectors, track, sector, head, status;
30858                                           !BCC_EOS
30859                                           ! 4535   Bit16u base_address, base_count, base_es;
30860                                           !BCC_EOS
30861                                           ! 4536   Bit8u page, mode_register, val8, dor;
30862                                           !BCC_EOS
30863                                           ! 4537   Bit8u return_status[7];
30864                                           !BCC_EOS
30865                                           ! 4538   Bit8u drive_type, num_floppies, ah;
30866                                           !BCC_EOS
30867                                           ! 4539   Bit16u es, last_addr;
30868                                           !BCC_EOS
30869                                           ! 4540   ;
30870 8E08           55                         push	bp
30871 8E09           89E5                       mov	bp,sp
30872 8E0B           83C4                   E2  add	sp,*-$1E
30873                                           !BCC_EOS
30874                                           ! 4541   ah = ( AX >> 8 );
30875                                           ! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
30876 8E0E           8B46         16            mov	ax,$16[bp]
30877 8E11           88E0                       mov	al,ah
30878 8E13           30E4                       xor	ah,ah
30879                                           ! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
30880 8E15           8846         E6            mov	-$1A[bp],al
30881                                           !BCC_EOS
30882                                           ! 4542   switch ( ah ) {
30883 8E18           8A46         E6            mov	al,-$1A[bp]
30884 8E1B           E9         10A1            br 	.67B
30885                                           ! 4543     case 0x00:
30886                                           ! 4544 ;
30887                       00008E1E            .67C:
30888                                           !BCC_EOS
30889                                           ! 4545       drive = ( ELDX & 0x00ff );
30890                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
30891 8E1E           8A46         0E            mov	al,$E[bp]
30892                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
30893 8E21           8846         FF            mov	-1[bp],al
30894                                           !BCC_EOS
30895                                           ! 4546       if (drive > 1) {
30896                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
30897 8E24           8A46         FF            mov	al,-1[bp]
30898 8E27           3C                     01  cmp	al,*1
30899 8E29           76           20            jbe 	.67D
30900                       00008E2B            .67E:
30901                                           ! 4547         AX 
30902                                           ! 4547 = ((AX & 0x00ff) | ((1) << 8));
30903                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30904 8E2B           8A46         16            mov	al,$16[bp]
30905                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
30906 8E2E           30E4                       xor	ah,ah
30907 8E30           0D                   0100  or	ax,#$100
30908                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30909 8E33           8946         16            mov	$16[bp],ax
30910                                           !BCC_EOS
30911                                           ! 4548         set_diskette_ret_status(1);
30912                                           ! Debug: list int = const 1 (used reg = )
30913 8E36           B8                   0001  mov	ax,*1
30914 8E39           50                         push	ax
30915                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30916 8E3A           E8         10C5            call	_set_diskette_ret_status
30917 8E3D           44                         inc	sp
30918 8E3E           44                         inc	sp
30919                                           !BCC_EOS
30920                                           ! 4549         FLAGS |= 0x0001;
30921                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30922 8E3F           8B46         1C            mov	ax,$1C[bp]
30923 8E42           0C                     01  or	al,*1
30924 8E44           8946         1C            mov	$1C[bp],ax
30925                                           !BCC_EOS
30926                                           ! 4550         return;
30927 8E47           89EC                       mov	sp,bp
30928 8E49           5D                         pop	bp
30929 8E4A           C3                         ret
30930                                           !BCC_EOS
30931                                           ! 4551       }
30932                                           ! 4552       drive_type = inb_cmos(0x10);
30933                       00008E4B            .67D:
30934                                           ! Debug: list int = const $10 (used reg = )
30935 8E4B           B8                   0010  mov	ax,*$10
30936 8E4E           50                         push	ax
30937                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
30938 8E4F           E8         7731            call	_inb_cmos
30939 8E52           44                         inc	sp
30940 8E53           44                         inc	sp
30941                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30942 8E54           8846         E8            mov	-$18[bp],al
30943                                           !BCC_EOS
30944                                           ! 4553       if (drive == 0)
30945                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
30946 8E57           8A46         FF            mov	al,-1[bp]
30947 8E5A           84C0                       test	al,al
30948 8E5C           75           0E            jne 	.67F
30949                       00008E5E            .680:
30950                                           ! 4554         drive_type >>= 4;
30951                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30952 8E5E           8A46         E8            mov	al,-$18[bp]
30953 8E61           30E4                       xor	ah,ah
30954 8E63           B1                     04  mov	cl,*4
30955 8E65           D3E8                       shr	ax,cl
30956 8E67           8846         E8            mov	-$18[bp],al
30957                                           !BCC_EOS
30958                                           ! 4555       else
30959                                           ! 4556         drive_type &= 0x0f;
30960 8E6A           EB           08            jmp .681
30961                       00008E6C            .67F:
30962                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
30963 8E6C           8A46         E8            mov	al,-$18[bp]
30964 8E6F           24                     0F  and	al,*$F
30965 8E71           8846         E8            mov	-$18[bp],al
30966                                           !BCC_EOS
30967                                           ! 4557       if (drive_type == 0) {
30968                       00008E74            .681:
30969                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
30970 8E74           8A46         E8            mov	al,-$18[bp]
30971 8E77           84C0                       test	al,al
30972 8E79           75           20            jne 	.682
30973                       00008E7B            .683:
30974                                           ! 4558         AX = ((AX & 0x00ff) | ((0x80) << 8));
30975                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
30976 8E7B           8A46         16            mov	al,$16[bp]
30977                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
30978 8E7E           30E4                       xor	ah,ah
30979 8E80           0D                   8000  or	ax,#-$8000
30980                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
30981 8E83           8946         16            mov	$16[bp],ax
30982                                           !BCC_EOS
30983                                           ! 4559         set_diskette_ret_status(0x80);
30984                                           ! Debug: list int = const $80 (used reg = )
30985 8E86           B8                   0080  mov	ax,#$80
30986 8E89           50                         push	ax
30987                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
30988 8E8A           E8         1075            call	_set_diskette_ret_status
30989 8E8D           44                         inc	sp
30990 8E8E           44                         inc	sp
30991                                           !BCC_EOS
30992                                           ! 4560         FLAGS |= 0x0001;
30993                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
30994 8E8F           8B46         1C            mov	ax,$1C[bp]
30995 8E92           0C                     01  or	al,*1
30996 8E94           8946         1C            mov	$1C[bp],ax
30997                                           !BCC_EOS
30998                                           ! 4561         return;
30999 8E97           89EC                       mov	sp,bp
31000 8E99           5D                         pop	bp
31001 8E9A           C3                         ret
31002                                           !BCC_EOS
31003                                           ! 4562       }
31004                                           ! 4563       AX = ((AX & 0x00ff) | ((0) << 8));
31005                       00008E9B            .682:
31006                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31007 8E9B           8A46         16            mov	al,$16[bp]
31008                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
31009 8E9E           0C                     00  or	al,*0
31010                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
31011 8EA0           30E4                       xor	ah,ah
31012 8EA2           8946         16            mov	$16[bp],ax
31013                                           !BCC_EOS
31014                                           ! 4564       set_diskette_ret_status(0);
31015                                           ! Debug: list int = const 0 (used reg = )
31016 8EA5           31C0                       xor	ax,ax
31017 8EA7           50                         push	ax
31018                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31019 8EA8           E8         1057            call	_set_diskette_ret_status
31020 8EAB           44                         inc	sp
31021 8EAC           44                         inc	sp
31022                                           !BCC_EOS
31023                                           ! 4565       FLAGS &= 0xfffe;
31024                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31025 8EAD           8B46         1C            mov	ax,$1C[bp]
31026 8EB0           24                     FE  and	al,#$FE
31027 8EB2           8946         1C            mov	$1C[bp],ax
31028                                           !BCC_EOS
31029                                           ! 4566       set_diskette_current_cyl(drive, 0);
31030                                           ! Debug: list int = const 0 (used reg = )
31031 8EB5           31C0                       xor	ax,ax
31032 8EB7           50                         push	ax
31033                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
31034 8EB8           8A46         FF            mov	al,-1[bp]
31035 8EBB           30E4                       xor	ah,ah
31036 8EBD           50                         push	ax
31037                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
31038 8EBE           E8         1059            call	_set_diskette_current_cyl
31039 8EC1           83C4                   04  add	sp,*4
31040                                           !BCC_EOS
31041                                           ! 4567       return;
31042 8EC4           89EC                       mov	sp,bp
31043 8EC6           5D                         pop	bp
31044 8EC7           C3                         ret
31045                                           !BCC_EOS
31046                                           ! 4568     case 0x01:
31047                                           ! 4569       FLAGS &= 0xfffe;
31048                       00008EC8            .684:
31049                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31050 8EC8           8B46         1C            mov	ax,$1C[bp]
31051 8ECB           24                     FE  and	al,#$FE
31052 8ECD           8946         1C            mov	$1C[bp],ax
31053                                           !BCC_EOS
31054                                           ! 4570       val8 = read_byte(0x0000, 0x0441);
31055                                           ! Debug: list int = const $441 (used reg = )
31056 8ED0           B8                   0441  mov	ax,#$441
31057 8ED3           50                         push	ax
31058                                           ! Debug: list int = const 0 (used reg = )
31059 8ED4           31C0                       xor	ax,ax
31060 8ED6           50                         push	ax
31061                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31062 8ED7           E8         771A            call	_read_byte
31063 8EDA           83C4                   04  add	sp,*4
31064                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31065 8EDD           8846         F1            mov	-$F[bp],al
31066                                           !BCC_EOS
31067                                           ! 4571       AX = ((AX & 0x00ff) | ((val8) << 8));
31068                                           ! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
31069 8EE0           8A46         F1            mov	al,-$F[bp]
31070 8EE3           30E4                       xor	ah,ah
31071 8EE5           88C4                       mov	ah,al
31072 8EE7           30C0                       xor	al,al
31073 8EE9           50                         push	ax
31074                                           ! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
31075 8EEA           8A46         16            mov	al,$16[bp]
31076                                           ! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
31077 8EED           30E4                       xor	ah,ah
31078 8EEF           0B46         E0            or	ax,0+..FFDC[bp]
31079 8EF2           44                         inc	sp
31080 8EF3           44                         inc	sp
31081                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31082 8EF4           8946         16            mov	$16[bp],ax
31083                                           !BCC_EOS
31084                                           ! 4572       if (val8) {
31085 8EF7           8A46         F1            mov	al,-$F[bp]
31086 8EFA           84C0                       test	al,al
31087 8EFC           74           08            je  	.685
31088                       00008EFE            .686:
31089                                           ! 4573         FLAGS |= 0x0001;
31090                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31091 8EFE           8B46         1C            mov	ax,$1C[bp]
31092 8F01           0C                     01  or	al,*1
31093 8F03           8946         1C            mov	$1C[bp],ax
31094                                           !BCC_EOS
31095                                           ! 4574       }
31096                                           ! 4575       return;
31097                       00008F06            .685:
31098 8F06           89EC                       mov	sp,bp
31099 8F08           5D                         pop	bp
31100 8F09           C3                         ret
31101                                           !BCC_EOS
31102                                           ! 4576     case 0x02:
31103                                           ! 4577     case 0x03:
31104                       00008F0A            .687:
31105                                           ! 4578     case 0x04:
31106                       00008F0A            .688:
31107                                           ! 4579       num_sectors = ( AX & 0x00ff );
31108                       00008F0A            .689:
31109                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31110 8F0A           8A46         16            mov	al,$16[bp]
31111                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31112 8F0D           8846         FE            mov	-2[bp],al
31113                                           !BCC_EOS
31114                                           ! 4580       track = ( CX >> 8 );
31115                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
31116 8F10           8B46         14            mov	ax,$14[bp]
31117 8F13           88E0                       mov	al,ah
31118 8F15           30E4                       xor	ah,ah
31119                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
31120 8F17           8846         FD            mov	-3[bp],al
31121                                           !BCC_EOS
31122                                           ! 4581       sector = ( CX & 0x00ff );
31123                                           ! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
31124 8F1A           8A46         14            mov	al,$14[bp]
31125                                           ! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
31126 8F1D           8846         FC            mov	-4[bp],al
31127                                           !BCC_EOS
31128                                           ! 4582       head = ( DX >> 8 );
31129                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
31130 8F20           8B46         12            mov	ax,$12[bp]
31131 8F23           88E0                       mov	al,ah
31132 8F25           30E4                       xor	ah,ah
31133                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
31134 8F27           8846         FB            mov	-5[bp],al
31135                                           !BCC_EOS
31136                                           ! 4583       drive = ( ELDX & 0x00ff );
31137                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
31138 8F2A           8A46         0E            mov	al,$E[bp]
31139                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
31140 8F2D           8846         FF            mov	-1[bp],al
31141                                           !BCC_EOS
31142                                           ! 4584       if ((drive > 1) || (head > 1) || (sector == 0) ||
31143                                           ! 4585           (num_sectors == 0) || (num_sectors > 72)) {
31144                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
31145 8F30           8A46         FF            mov	al,-1[bp]
31146 8F33           3C                     01  cmp	al,*1
31147 8F35           77           1C            ja  	.68B
31148                       00008F37            .68F:
31149                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
31150 8F37           8A46         FB            mov	al,-5[bp]
31151 8F3A           3C                     01  cmp	al,*1
31152 8F3C           77           15            ja  	.68B
31153                       00008F3E            .68E:
31154                                           ! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
31155 8F3E           8A46         FC            mov	al,-4[bp]
31156 8F41           84C0                       test	al,al
31157 8F43           74           0E            je  	.68B
31158                       00008F45            .68D:
31159                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
31160 8F45           8A46         FE            mov	al,-2[bp]
31161 8F48           84C0                       test	al,al
31162 8F4A           74           07            je  	.68B
31163                       00008F4C            .68C:
31164                                           ! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
31165 8F4C           8A46         FE            mov	al,-2[bp]
31166 8F4F           3C                     48  cmp	al,*$48
31167 8F51           76           2A            jbe 	.68A
31168                       00008F53            .68B:
31169                                           ! 4586         ;
31170                                           !BCC_EOS
31171                                           ! 4587         AX = ((AX & 0x00ff) | ((1) << 8));
31172                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31173 8F53           8A46         16            mov	al,$16[bp]
31174                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
31175 8F56           30E4                       xor	ah,ah
31176 8F58           0D                   0100  or	ax,#$100
31177                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31178 8F5B           8946         16            mov	$16[bp],ax
31179                                           !BCC_EOS
31180                                           ! 4588         set_diskette_ret_status(1);
31181                                           ! Debug: list int = const 1 (used reg = )
31182 8F5E           B8                   0001  mov	ax,*1
31183 8F61           50                         push	ax
31184                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31185 8F62           E8         0F9D            call	_set_diskette_ret_status
31186 8F65           44                         inc	sp
31187 8F66           44                         inc	sp
31188                                           !BCC_EOS
31189                                           ! 4589         AX = ((AX & 0xff00) | (0));
31190                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31191 8F67           8B46         16            mov	ax,$16[bp]
31192 8F6A           30C0                       xor	al,al
31193                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31194 8F6C           0C                     00  or	al,*0
31195                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31196 8F6E           8946         16            mov	$16[bp],ax
31197                                           !BCC_EOS
31198                                           ! 4590         FLAGS |= 0x0001;
31199                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31200 8F71           8B46         1C            mov	ax,$1C[bp]
31201 8F74           0C                     01  or	al,*1
31202 8F76           8946         1C            mov	$1C[bp],ax
31203                                           !BCC_EOS
31204                                           ! 4591         return;
31205 8F79           89EC                       mov	sp,bp
31206 8F7B           5D                         pop	bp
31207 8F7C           C3                         ret
31208                                           !BCC_EOS
31209                                           ! 4592       }
31210                                           ! 4593       if (floppy_drive_exists(drive) == 0) {
31211                       00008F7D            .68A:
31212                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31213 8F7D           8A46         FF            mov	al,-1[bp]
31214 8F80           30E4                       xor	ah,ah
31215 8F82           50                         push	ax
31216                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
31217 8F83           E8         FE3A            call	_floppy_drive_exists
31218 8F86           44                         inc	sp
31219 8F87           44                         inc	sp
31220                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31221 8F88           85C0                       test	ax,ax
31222 8F8A           75           2A            jne 	.690
31223                       00008F8C            .691:
31224                                           ! 4594         AX = ((AX & 0x00ff) | ((0x80) << 8));
31225                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31226 8F8C           8A46         16            mov	al,$16[bp]
31227                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31228 8F8F           30E4                       xor	ah,ah
31229 8F91           0D                   8000  or	ax,#-$8000
31230                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31231 8F94           8946         16            mov	$16[bp],ax
31232                                           !BCC_EOS
31233                                           ! 4595         set_diskette_ret_status(0x80);
31234                                           ! Debug: list int = const $80 (used reg = )
31235 8F97           B8                   0080  mov	ax,#$80
31236 8F9A           50                         push	ax
31237                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31238 8F9B           E8         0F64            call	_set_diskette_ret_status
31239 8F9E           44                         inc	sp
31240 8F9F           44                         inc	sp
31241                                           !BCC_EOS
31242                                           ! 4596         AX = ((AX & 0xff00) | (0));
31243                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31244 8FA0           8B46         16            mov	ax,$16[bp]
31245 8FA3           30C0                       xor	al,al
31246                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31247 8FA5           0C                     00  or	al,*0
31248                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31249 8FA7           8946         16            mov	$16[bp],ax
31250                                           !BCC_EOS
31251                                           ! 4597         FLAGS |= 0x0001;
31252                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31253 8FAA           8B46         1C            mov	ax,$1C[bp]
31254 8FAD           0C                     01  or	al,*1
31255 8FAF           8946         1C            mov	$1C[bp],ax
31256                                           !BCC_EOS
31257                                           ! 4598         return;
31258 8FB2           89EC                       mov	sp,bp
31259 8FB4           5D                         pop	bp
31260 8FB5           C3                         ret
31261                                           !BCC_EOS
31262                                           ! 4599       }
31263                                           ! 4600       if (floppy_media_known(drive) == 0) {
31264                       00008FB6            .690:
31265                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31266 8FB6           8A46         FF            mov	al,-1[bp]
31267 8FB9           30E4                       xor	ah,ah
31268 8FBB           50                         push	ax
31269                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
31270 8FBC           E8         FB6B            call	_floppy_media_known
31271 8FBF           44                         inc	sp
31272 8FC0           44                         inc	sp
31273                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31274 8FC1           85C0                       test	ax,ax
31275 8FC3           75           39            jne 	.692
31276                       00008FC5            .693:
31277                                           ! 4601         if (floppy_media_sense(drive) == 0) {
31278                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31279 8FC5           8A46         FF            mov	al,-1[bp]
31280 8FC8           30E4                       xor	ah,ah
31281 8FCA           50                         push	ax
31282                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
31283 8FCB           E8         FBDF            call	_floppy_media_sense
31284 8FCE           44                         inc	sp
31285 8FCF           44                         inc	sp
31286                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
31287 8FD0           85C0                       test	ax,ax
31288 8FD2           75           2A            jne 	.694
31289                       00008FD4            .695:
31290                                           ! 4602           AX = ((AX & 0x00ff) | ((0x0C) << 8));
31291                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31292 8FD4           8A46         16            mov	al,$16[bp]
31293                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
31294 8FD7           30E4                       xor	ah,ah
31295 8FD9           0D                   0C00  or	ax,#$C00
31296                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31297 8FDC           8946         16            mov	$16[bp],ax
31298                                           !BCC_EOS
31299                                           ! 4603           set_diskette_ret_status(0x0C);
31300                                           ! Debug: list int = const $C (used reg = )
31301 8FDF           B8                   000C  mov	ax,*$C
31302 8FE2           50                         push	ax
31303                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31304 8FE3           E8         0F1C            call	_set_diskette_ret_status
31305 8FE6           44                         inc	sp
31306 8FE7           44                         inc	sp
31307                                           !BCC_EOS
31308                                           ! 4604           AX = ((AX & 0xff00) | (0));
31309                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31310 8FE8           8B46         16            mov	ax,$16[bp]
31311 8FEB           30C0                       xor	al,al
31312                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31313 8FED           0C                     00  or	al,*0
31314                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31315 8FEF           8946         16            mov	$16[bp],ax
31316                                           !BCC_EOS
31317                                           ! 4605           FLAGS |= 0x0001;
31318                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31319 8FF2           8B46         1C            mov	ax,$1C[bp]
31320 8FF5           0C                     01  or	al,*1
31321 8FF7           8946         1C            mov	$1C[bp],ax
31322                                           !BCC_EOS
31323                                           ! 4606           return;
31324 8FFA           89EC                       mov	sp,bp
31325 8FFC           5D                         pop	bp
31326 8FFD           C3                         ret
31327                                           !BCC_EOS
31328                                           ! 4607         }
31329                                           ! 4608       }
31330                       00008FFE            .694:
31331                                           ! 4609       if (ah == 0x02) {
31332                       00008FFE            .692:
31333                                           ! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
31334 8FFE           8A46         E6            mov	al,-$1A[bp]
31335 9001           3C                     02  cmp	al,*2
31336 9003         0F85         03B4            bne 	.696
31337                       00009007            .697:
31338                                           ! 4610         page = (ES >> 12);
31339                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
31340 9007           8B46         06            mov	ax,6[bp]
31341 900A           88E0                       mov	al,ah
31342 900C           30E4                       xor	ah,ah
31343 900E           B1                     04  mov	cl,*4
31344 9010           D3E8                       shr	ax,cl
31345                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
31346 9012           8846         F3            mov	-$D[bp],al
31347                                           !BCC_EOS
31348                                           ! 4611         base_es = (ES << 4);
31349                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
31350 9015           8B46         06            mov	ax,6[bp]
31351 9018           B1                     04  mov	cl,*4
31352 901A           D3E0                       shl	ax,cl
31353                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
31354 901C           8946         F4            mov	-$C[bp],ax
31355                                           !BCC_EOS
31356                                           ! 4612         base_address = base_es + BX;
31357                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
31358 901F           8B46         F4            mov	ax,-$C[bp]
31359 9022           0346         10            add	ax,$10[bp]
31360                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
31361 9025           8946         F8            mov	-8[bp],ax
31362                                           !BCC_EOS
31363                                           ! 4613         if ( base_address < base_es ) {
31364                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
31365 9028           8B46         F8            mov	ax,-8[bp]
31366 902B           3B46         F4            cmp	ax,-$C[bp]
31367 902E           73           07            jae 	.698
31368                       00009030            .699:
31369                                           ! 4614           page++;
31370                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
31371 9030           8A46         F3            mov	al,-$D[bp]
31372 9033           40                         inc	ax
31373 9034           8846         F3            mov	-$D[bp],al
31374                                           !BCC_EOS
31375                                           ! 4615         }
31376                                           ! 4616         base_count = (num_sectors * 512) - 1;
31377                       00009037            .698:
31378                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
31379 9037           8A46         FE            mov	al,-2[bp]
31380 903A           30E4                       xor	ah,ah
31381 903C           B9                   0200  mov	cx,#$200
31382 903F           F7E9                       imul	cx
31383                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
31384                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
31385 9041           48                         dec	ax
31386 9042           8946         F6            mov	-$A[bp],ax
31387                                           !BCC_EOS
31388                                           ! 4617         last_addr = base_address + base_count;
31389                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
31390 9045           8B46         F8            mov	ax,-8[bp]
31391 9048           0346         F6            add	ax,-$A[bp]
31392                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
31393 904B           8946         E2            mov	-$1E[bp],ax
31394                                           !BCC_EOS
31395                                           ! 4618         if (last_addr < base_address) {
31396                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
31397 904E           8B46         E2            mov	ax,-$1E[bp]
31398 9051           3B46         F8            cmp	ax,-8[bp]
31399 9054           73           2A            jae 	.69A
31400                       00009056            .69B:
31401                                           ! 4619         
31402                                           ! 4619   AX = ((AX & 0x00ff) | ((0x09) << 8));
31403                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31404 9056           8A46         16            mov	al,$16[bp]
31405                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
31406 9059           30E4                       xor	ah,ah
31407 905B           0D                   0900  or	ax,#$900
31408                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31409 905E           8946         16            mov	$16[bp],ax
31410                                           !BCC_EOS
31411                                           ! 4620           set_diskette_ret_status(0x09);
31412                                           ! Debug: list int = const 9 (used reg = )
31413 9061           B8                   0009  mov	ax,*9
31414 9064           50                         push	ax
31415                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31416 9065           E8         0E9A            call	_set_diskette_ret_status
31417 9068           44                         inc	sp
31418 9069           44                         inc	sp
31419                                           !BCC_EOS
31420                                           ! 4621           AX = ((AX & 0xff00) | (0));
31421                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31422 906A           8B46         16            mov	ax,$16[bp]
31423 906D           30C0                       xor	al,al
31424                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31425 906F           0C                     00  or	al,*0
31426                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31427 9071           8946         16            mov	$16[bp],ax
31428                                           !BCC_EOS
31429                                           ! 4622           FLAGS |= 0x0001;
31430                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31431 9074           8B46         1C            mov	ax,$1C[bp]
31432 9077           0C                     01  or	al,*1
31433 9079           8946         1C            mov	$1C[bp],ax
31434                                           !BCC_EOS
31435                                           ! 4623           return;
31436 907C           89EC                       mov	sp,bp
31437 907E           5D                         pop	bp
31438 907F           C3                         ret
31439                                           !BCC_EOS
31440                                           ! 4624         }
31441                                           ! 4625         ;
31442                       00009080            .69A:
31443                                           !BCC_EOS
31444                                           ! 4626         outb(0x000a, 0x06);
31445                                           ! Debug: list int = const 6 (used reg = )
31446 9080           B8                   0006  mov	ax,*6
31447 9083           50                         push	ax
31448                                           ! Debug: list int = const $A (used reg = )
31449 9084           B8                   000A  mov	ax,*$A
31450 9087           50                         push	ax
31451                                           ! Debug: func () void = outb+0 (used reg = )
31452 9088           E8         74C9            call	_outb
31453 908B           83C4                   04  add	sp,*4
31454                                           !BCC_EOS
31455                                           ! 4627   ;
31456                                           !BCC_EOS
31457                                           ! 4628         outb(0x000c, 0x00);
31458                                           ! Debug: list int = const 0 (used reg = )
31459 908E           31C0                       xor	ax,ax
31460 9090           50                         push	ax
31461                                           ! Debug: list int = const $C (used reg = )
31462 9091           B8                   000C  mov	ax,*$C
31463 9094           50                         push	ax
31464                                           ! Debug: func () void = outb+0 (used reg = )
31465 9095           E8         74BC            call	_outb
31466 9098           83C4                   04  add	sp,*4
31467                                           !BCC_EOS
31468                                           ! 4629         outb(0x0004, base_address);
31469                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
31470 909B           FF76         F8            push	-8[bp]
31471                                           ! Debug: list int = const 4 (used reg = )
31472 909E           B8                   0004  mov	ax,*4
31473 90A1           50                         push	ax
31474                                           ! Debug: func () void = outb+0 (used reg = )
31475 90A2           E8         74AF            call	_outb
31476 90A5           83C4                   04  add	sp,*4
31477                                           !BCC_EOS
31478                                           ! 4630         outb(0x0004, base_address>>8);
31479                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
31480 90A8           8B46         F8            mov	ax,-8[bp]
31481 90AB           88E0                       mov	al,ah
31482 90AD           30E4                       xor	ah,ah
31483                                           ! Debug: list unsigned int = ax+0 (used reg = )
31484 90AF           50                         push	ax
31485                                           ! Debug: list int = const 4 (used reg = )
31486 90B0           B8                   0004  mov	ax,*4
31487 90B3           50                         push	ax
31488                                           ! Debug: func () void = outb+0 (used reg = )
31489 90B4           E8         749D            call	_outb
31490 90B7           83C4                   04  add	sp,*4
31491                                           !BCC_EOS
31492                                           ! 4631   ;
31493                                           !BCC_EOS
31494                                           ! 4632         outb(0x000c, 0x00);
31495                                           ! Debug: list int = const 0 (used reg = )
31496 90BA           31C0                       xor	ax,ax
31497 90BC           50                         push	ax
31498                                           ! Debug: list int = const $C (used reg = )
31499 90BD           B8                   000C  mov	ax,*$C
31500 90C0           50                         push	ax
31501                                           ! Debug: func () void = outb+0 (used reg = )
31502 90C1           E8         7490            call	_outb
31503 90C4           83C4                   04  add	sp,*4
31504                                           !BCC_EOS
31505                                           ! 4633         outb(0x0005, base_count);
31506                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
31507 90C7           FF76         F6            push	-$A[bp]
31508                                           ! Debug: list int = const 5 (used reg = )
31509 90CA           B8                   0005  mov	ax,*5
31510 90CD           50                         push	ax
31511                                           ! Debug: func () void = outb+0 (used reg = )
31512 90CE           E8         7483            call	_outb
31513 90D1           83C4                   04  add	sp,*4
31514                                           !BCC_EOS
31515                                           ! 4634         outb(0x0005, base_count>>8);
31516                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
31517 90D4           8B46         F6            mov	ax,-$A[bp]
31518 90D7           88E0                       mov	al,ah
31519 90D9           30E4                       xor	ah,ah
31520                                           ! Debug: list unsigned int = ax+0 (used reg = )
31521 90DB           50                         push	ax
31522                                           ! Debug: list int = const 5 (used reg = )
31523 90DC           B8                   0005  mov	ax,*5
31524 90DF           50                         push	ax
31525                                           ! Debug: func () void = outb+0 (used reg = )
31526 90E0           E8         7471            call	_outb
31527 90E3           83C4                   04  add	sp,*4
31528                                           !BCC_EOS
31529                                           ! 4635         mode_register = 0x46;
31530                                           ! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
31531 90E6           B0                     46  mov	al,*$46
31532 90E8           8846         F2            mov	-$E[bp],al
31533                                           !BCC_EOS
31534                                           ! 4636   ;
31535                                           !BCC_EOS
31536                                           ! 4637         outb(0x000b, mode_register);
31537                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
31538 90EB           8A46         F2            mov	al,-$E[bp]
31539 90EE           30E4                       xor	ah,ah
31540 90F0           50                         push	ax
31541                                           ! Debug: list int = const $B (used reg = )
31542 90F1           B8                   000B  mov	ax,*$B
31543 90F4           50                         push	ax
31544                                           ! Debug: func () void = outb+0 (used reg = )
31545 90F5           E8         745C            call	_outb
31546 90F8           83C4                   04  add	sp,*4
31547                                           !BCC_EOS
31548                                           ! 4638   ;
31549                                           !BCC_EOS
31550                                           ! 4639         outb(0x0081, page);
31551                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
31552 90FB           8A46         F3            mov	al,-$D[bp]
31553 90FE           30E4                       xor	ah,ah
31554 9100           50                         push	ax
31555                                           ! Debug: list int = const $81 (used reg = )
31556 9101           B8                   0081  mov	ax,#$81
31557 9104           50                         push	ax
31558                                           ! Debug: func () void = outb+0 (used reg = )
31559 9105           E8         744C            call	_outb
31560 9108           83C4                   04  add	sp,*4
31561                                           !BCC_EOS
31562                                           ! 4640   ;
31563                                           !BCC_EOS
31564                                           ! 4641         outb(0x000a, 0x02);
31565                                           ! Debug: list int = const 2 (used reg = )
31566 910B           B8                   0002  mov	ax,*2
31567 910E           50                         push	ax
31568                                           ! Debug: list int = const $A (used reg = )
31569 910F           B8                   000A  mov	ax,*$A
31570 9112           50                         push	ax
31571                                           ! Debug: func () void = outb+0 (used reg = )
31572 9113           E8         743E            call	_outb
31573 9116           83C4                   04  add	sp,*4
31574                                           !BCC_EOS
31575                                           ! 4642         ;
31576                                           !BCC_EOS
31577                                           ! 4643         outb(0x000a, 0x02);
31578                                           ! Debug: list int = const 2 (used reg = )
31579 9119           B8                   0002  mov	ax,*2
31580 911C           50                         push	ax
31581                                           ! Debug: list int = const $A (used reg = )
31582 911D           B8                   000A  mov	ax,*$A
31583 9120           50                         push	ax
31584                                           ! Debug: func () void = outb+0 (used reg = )
31585 9121           E8         7430            call	_outb
31586 9124           83C4                   04  add	sp,*4
31587                                           !BCC_EOS
31588                                           ! 4644         floppy_prepare_controller(drive);
31589                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
31590 9127           8A46         FF            mov	al,-1[bp]
31591 912A           30E4                       xor	ah,ah
31592 912C           50                         push	ax
31593                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
31594 912D           E8         F91B            call	_floppy_prepare_controller
31595 9130           44                         inc	sp
31596 9131           44                         inc	sp
31597                                           !BCC_EOS
31598                                           ! 4645         outb(0x03f5, 0xe6);
31599                                           ! Debug: list int = const $E6 (used reg = )
31600 9132           B8                   00E6  mov	ax,#$E6
31601 9135           50                         push	ax
31602                                           ! Debug: list int = const $3F5 (used reg = )
31603 9136           B8                   03F5  mov	ax,#$3F5
31604 9139           50                         push	ax
31605                                           ! Debug: func () void = outb+0 (used reg = )
31606 913A           E8         7417            call	_outb
31607 913D           83C4                   04  add	sp,*4
31608                                           !BCC_EOS
31609                                           ! 4646         outb(0x03f5, (head << 2) | drive);
31610                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
31611 9140           8A46         FB            mov	al,-5[bp]
31612 9143           30E4                       xor	ah,ah
31613 9145           D1E0                       shl	ax,*1
31614 9147           D1E0                       shl	ax,*1
31615                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
31616 9149           0A46         FF            or	al,-1[bp]
31617                                           ! Debug: list unsigned int = ax+0 (used reg = )
31618 914C           50                         push	ax
31619                                           ! Debug: list int = const $3F5 (used reg = )
31620 914D           B8                   03F5  mov	ax,#$3F5
31621 9150           50                         push	ax
31622                                           ! Debug: func () void = outb+0 (used reg = )
31623 9151           E8         7400            call	_outb
31624 9154           83C4                   04  add	sp,*4
31625                                           !BCC_EOS
31626                                           ! 4647         outb(0x03f5, track);
31627                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
31628 9157           8A46         FD            mov	al,-3[bp]
31629 915A           30E4                       xor	ah,ah
31630 915C           50                         push	ax
31631                                           ! Debug: list int = const $3F5 (used reg = )
31632 915D           B8                   03F5  mov	ax,#$3F5
31633 9160           50                         push	ax
31634                                           ! Debug: func () void = outb+0 (used reg = )
31635 9161           E8         73F0            call	_outb
31636 9164           83C4                   04  add	sp,*4
31637                                           !BCC_EOS
31638                                           ! 4648         outb(0x03f5, head);
31639                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
31640 9167           8A46         FB            mov	al,-5[bp]
31641 916A           30E4                       xor	ah,ah
31642 916C           50                         push	ax
31643                                           ! Debug: list int = const $3F5 (used reg = )
31644 916D           B8                   03F5  mov	ax,#$3F5
31645 9170           50                         push	ax
31646                                           ! Debug: func () void = outb+0 (used reg = )
31647 9171           E8         73E0            call	_outb
31648 9174           83C4                   04  add	sp,*4
31649                                           !BCC_EOS
31650                                           ! 4649         outb(0x03f5, sector);
31651                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
31652 9177           8A46         FC            mov	al,-4[bp]
31653 917A           30E4                       xor	ah,ah
31654 917C           50                         push	ax
31655                                           ! Debug: list int = const $3F5 (used reg = )
31656 917D           B8                   03F5  mov	ax,#$3F5
31657 9180           50                         push	ax
31658                                           ! Debug: func () void = outb+0 (used reg = )
31659 9181           E8         73D0            call	_outb
31660 9184           83C4                   04  add	sp,*4
31661                                           !BCC_EOS
31662                                           ! 4650         outb(0x03f5, 2);
31663                                           ! Debug: list int = const 2 (used reg = )
31664 9187           B8                   0002  mov	ax,*2
31665 918A           50                         push	ax
31666                                           ! Debug: list int = const $3F5 (used reg = )
31667 918B           B8                   03F5  mov	ax,#$3F5
31668 918E           50                         push	ax
31669                                           ! Debug: func () void = outb+0 (used reg = )
31670 918F           E8         73C2            call	_outb
31671 9192           83C4                   04  add	sp,*4
31672                                           !BCC_EOS
31673                                           ! 4651         outb(0x03f5, sector + num_sectors - 1);
31674                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
31675 9195           8A46         FC            mov	al,-4[bp]
31676 9198           30E4                       xor	ah,ah
31677 919A           0246         FE            add	al,-2[bp]
31678 919D           80D4                   00  adc	ah,*0
31679                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
31680                                           ! Debug: list unsigned int = ax-1 (used reg = )
31681 91A0           48                         dec	ax
31682 91A1           50                         push	ax
31683                                           ! Debug: list int = const $3F5 (used reg = )
31684 91A2           B8                   03F5  mov	ax,#$3F5
31685 91A5           50                         push	ax
31686                                           ! Debug: func () void = outb+0 (used reg = )
31687 91A6           E8         73AB            call	_outb
31688 91A9           83C4                   04  add	sp,*4
31689                                           !BCC_EOS
31690                                           ! 4652         outb(0x03f5, 0);
31691                                           ! Debug: list int = const 0 (used reg = )
31692 91AC           31C0                       xor	ax,ax
31693 91AE           50                         push	ax
31694                                           ! Debug: list int = const $3F5 (used reg = )
31695 91AF           B8                   03F5  mov	ax,#$3F5
31696 91B2           50                         push	ax
31697                                           ! Debug: func () void = outb+0 (used reg = )
31698 91B3           E8         739E            call	_outb
31699 91B6           83C4                   04  add	sp,*4
31700                                           !BCC_EOS
31701                                           ! 4653         outb(0x03f5, 0xff);
31702                                           ! Debug: list int = const $FF (used reg = )
31703 91B9           B8                   00FF  mov	ax,#$FF
31704 91BC           50                         push	ax
31705                                           ! Debug: list int = const $3F5 (used reg = )
31706 91BD           B8                   03F5  mov	ax,#$3F5
31707 91C0           50                         push	ax
31708                                           ! Debug: func () void = outb+0 (used reg = )
31709 91C1           E8         7390            call	_outb
31710 91C4           83C4                   04  add	sp,*4
31711                                           !BCC_EOS
31712                                           ! 4654 #asm
31713                                           !BCC_EOS
31714                                           !BCC_ASM
31715                       0000002A            _int13_diskette_function.BP	set	$2A
31716                       0000000C            .int13_diskette_function.BP	set	$C
31717                       00000038            _int13_diskette_function.CS	set	$38
31718                       0000001A            .int13_diskette_function.CS	set	$1A
31719                       00000032            _int13_diskette_function.CX	set	$32
31720                       00000014            .int13_diskette_function.CX	set	$14
31721                       00000016            _int13_diskette_function.base_address	set	$16
31722                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
31723                       00000026            _int13_diskette_function.DI	set	$26
31724                       00000008            .int13_diskette_function.DI	set	8
31725                       0000003A            _int13_diskette_function.FLAGS	set	$3A
31726                       0000001C            .int13_diskette_function.FLAGS	set	$1C
31727                       00000014            _int13_diskette_function.base_count	set	$14
31728                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
31729                       0000001A            _int13_diskette_function.sector	set	$1A
31730                       FFFFFFFC            .int13_diskette_function.sector	set	-4
31731                       00000022            _int13_diskette_function.DS	set	$22
31732                       00000004            .int13_diskette_function.DS	set	4
31733                       00000019            _int13_diskette_function.head	set	$19
31734                       FFFFFFFB            .int13_diskette_function.head	set	-5
31735                       0000002C            _int13_diskette_function.ELDX	set	$2C
31736                       0000000E            .int13_diskette_function.ELDX	set	$E
31737                       0000000E            _int13_diskette_function.dor	set	$E
31738                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
31739                       00000030            _int13_diskette_function.DX	set	$30
31740                       00000012            .int13_diskette_function.DX	set	$12
31741                       00000007            _int13_diskette_function.return_status	set	7
31742                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
31743                       00000002            _int13_diskette_function.es	set	2
31744                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
31745                       00000010            _int13_diskette_function.mode_register	set	$10
31746                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
31747                       00000024            _int13_diskette_function.ES	set	$24
31748                       00000006            .int13_diskette_function.ES	set	6
31749                       00000012            _int13_diskette_function.base_es	set	$12
31750                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
31751                       0000001B            _int13_diskette_function.track	set	$1B
31752                       FFFFFFFD            .int13_diskette_function.track	set	-3
31753                       00000028            _int13_diskette_function.SI	set	$28
31754                       0000000A            .int13_diskette_function.SI	set	$A
31755                       00000006            _int13_diskette_function.drive_type	set	6
31756                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
31757                       0000001C            _int13_diskette_function.num_sectors	set	$1C
31758                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
31759                       00000036            _int13_diskette_function.IP	set	$36
31760                       00000018            .int13_diskette_function.IP	set	$18
31761                       00000018            _int13_diskette_function.status	set	$18
31762                       FFFFFFFA            .int13_diskette_function.status	set	-6
31763                       00000034            _int13_diskette_function.AX	set	$34
31764                       00000016            .int13_diskette_function.AX	set	$16
31765                       0000000F            _int13_diskette_function.val8	set	$F
31766                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
31767                       00000000            _int13_diskette_function.last_addr	set	0
31768                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
31769                       00000011            _int13_diskette_function.page	set	$11
31770                       FFFFFFF3            .int13_diskette_function.page	set	-$D
31771                       00000004            _int13_diskette_function.ah	set	4
31772                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
31773                       0000001D            _int13_diskette_function.drive	set	$1D
31774                       FFFFFFFF            .int13_diskette_function.drive	set	-1
31775                       00000005            _int13_diskette_function.num_floppies	set	5
31776                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
31777                       0000002E            _int13_diskette_function.BX	set	$2E
31778                       00000010            .int13_diskette_function.BX	set	$10
31779 91C7           FB                                 sti
31780                                           ! 4656 endasm
31781                                           !BCC_ENDASM
31782                                           !BCC_EOS
31783                                           ! 4657         do {
31784                       000091C8            .69E:
31785                                           ! 4658           val8 = read_byte(0x0040, 0x0040);
31786                                           ! Debug: list int = const $40 (used reg = )
31787 91C8           B8                   0040  mov	ax,*$40
31788 91CB           50                         push	ax
31789                                           ! Debug: list int = const $40 (used reg = )
31790 91CC           B8                   0040  mov	ax,*$40
31791 91CF           50                         push	ax
31792                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31793 91D0           E8         7421            call	_read_byte
31794 91D3           83C4                   04  add	sp,*4
31795                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31796 91D6           8846         F1            mov	-$F[bp],al
31797                                           !BCC_EOS
31798                                           ! 4659           if (val8 == 0) {
31799                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31800 91D9           8A46         F1            mov	al,-$F[bp]
31801 91DC           84C0                       test	al,al
31802 91DE           75           2D            jne 	.69F
31803                       000091E0            .6A0:
31804                                           ! 4660             floppy_reset_controller();
31805                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
31806 91E0           E8         F81A            call	_floppy_reset_controller
31807                                           !BCC_EOS
31808                                           ! 4661             AX = ((AX & 0x00ff) | ((0x80) << 8));
31809                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
31810 91E3           8A46         16            mov	al,$16[bp]
31811                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
31812 91E6           30E4                       xor	ah,ah
31813 91E8           0D                   8000  or	ax,#-$8000
31814                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31815 91EB           8946         16            mov	$16[bp],ax
31816                                           !BCC_EOS
31817                                           ! 4662             set_diskette_ret_status(0x80);
31818                                           ! Debug: list int = const $80 (used reg = )
31819 91EE           B8                   0080  mov	ax,#$80
31820 91F1           50                         push	ax
31821                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
31822 91F2           E8         0D0D            call	_set_diskette_ret_status
31823 91F5           44                         inc	sp
31824 91F6           44                         inc	sp
31825                                           !BCC_EOS
31826                                           ! 4663             AX = ((AX & 0xff00) | (0));
31827                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
31828 91F7           8B46         16            mov	ax,$16[bp]
31829 91FA           30C0                       xor	al,al
31830                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
31831 91FC           0C                     00  or	al,*0
31832                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
31833 91FE           8946         16            mov	$16[bp],ax
31834                                           !BCC_EOS
31835                                           ! 4664             FLAGS |= 0x0001;
31836                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
31837 9201           8B46         1C            mov	ax,$1C[bp]
31838 9204           0C                     01  or	al,*1
31839 9206           8946         1C            mov	$1C[bp],ax
31840                                           !BCC_EOS
31841                                           ! 4665             return;
31842 9209           89EC                       mov	sp,bp
31843 920B           5D                         pop	bp
31844 920C           C3                         ret
31845                                           !BCC_EOS
31846                                           ! 4666           }
31847                                           ! 4667           val8 = (read_byte(0x0040, 0x003e) & 0x80);
31848                       0000920D            .69F:
31849                                           ! Debug: list int = const $3E (used reg = )
31850 920D           B8                   003E  mov	ax,*$3E
31851 9210           50                         push	ax
31852                                           ! Debug: list int = const $40 (used reg = )
31853 9211           B8                   0040  mov	ax,*$40
31854 9214           50                         push	ax
31855                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31856 9215           E8         73DC            call	_read_byte
31857 9218           83C4                   04  add	sp,*4
31858                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
31859 921B           24                     80  and	al,#$80
31860                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31861 921D           8846         F1            mov	-$F[bp],al
31862                                           !BCC_EOS
31863                                           ! 4668         } while ( val8 == 0 );
31864                       00009220            .69D:
31865                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31866 9220           8A46         F1            mov	al,-$F[bp]
31867 9223           84C0                       test	al,al
31868 9225           74           A1            je 	.69E
31869                       00009227            .6A1:
31870                                           !BCC_EOS
31871                                           ! 4669         val8 = 0;
31872                       00009227            .69C:
31873                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
31874 9227           30C0                       xor	al,al
31875 9229           8846         F1            mov	-$F[bp],al
31876                                           !BCC_EOS
31877                                           ! 4670 #asm
31878                                           !BCC_EOS
31879                                           !BCC_ASM
31880                       0000002A            _int13_diskette_function.BP	set	$2A
31881                       0000000C            .int13_diskette_function.BP	set	$C
31882                       00000038            _int13_diskette_function.CS	set	$38
31883                       0000001A            .int13_diskette_function.CS	set	$1A
31884                       00000032            _int13_diskette_function.CX	set	$32
31885                       00000014            .int13_diskette_function.CX	set	$14
31886                       00000016            _int13_diskette_function.base_address	set	$16
31887                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
31888                       00000026            _int13_diskette_function.DI	set	$26
31889                       00000008            .int13_diskette_function.DI	set	8
31890                       0000003A            _int13_diskette_function.FLAGS	set	$3A
31891                       0000001C            .int13_diskette_function.FLAGS	set	$1C
31892                       00000014            _int13_diskette_function.base_count	set	$14
31893                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
31894                       0000001A            _int13_diskette_function.sector	set	$1A
31895                       FFFFFFFC            .int13_diskette_function.sector	set	-4
31896                       00000022            _int13_diskette_function.DS	set	$22
31897                       00000004            .int13_diskette_function.DS	set	4
31898                       00000019            _int13_diskette_function.head	set	$19
31899                       FFFFFFFB            .int13_diskette_function.head	set	-5
31900                       0000002C            _int13_diskette_function.ELDX	set	$2C
31901                       0000000E            .int13_diskette_function.ELDX	set	$E
31902                       0000000E            _int13_diskette_function.dor	set	$E
31903                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
31904                       00000030            _int13_diskette_function.DX	set	$30
31905                       00000012            .int13_diskette_function.DX	set	$12
31906                       00000007            _int13_diskette_function.return_status	set	7
31907                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
31908                       00000002            _int13_diskette_function.es	set	2
31909                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
31910                       00000010            _int13_diskette_function.mode_register	set	$10
31911                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
31912                       00000024            _int13_diskette_function.ES	set	$24
31913                       00000006            .int13_diskette_function.ES	set	6
31914                       00000012            _int13_diskette_function.base_es	set	$12
31915                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
31916                       0000001B            _int13_diskette_function.track	set	$1B
31917                       FFFFFFFD            .int13_diskette_function.track	set	-3
31918                       00000028            _int13_diskette_function.SI	set	$28
31919                       0000000A            .int13_diskette_function.SI	set	$A
31920                       00000006            _int13_diskette_function.drive_type	set	6
31921                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
31922                       0000001C            _int13_diskette_function.num_sectors	set	$1C
31923                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
31924                       00000036            _int13_diskette_function.IP	set	$36
31925                       00000018            .int13_diskette_function.IP	set	$18
31926                       00000018            _int13_diskette_function.status	set	$18
31927                       FFFFFFFA            .int13_diskette_function.status	set	-6
31928                       00000034            _int13_diskette_function.AX	set	$34
31929                       00000016            .int13_diskette_function.AX	set	$16
31930                       0000000F            _int13_diskette_function.val8	set	$F
31931                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
31932                       00000000            _int13_diskette_function.last_addr	set	0
31933                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
31934                       00000011            _int13_diskette_function.page	set	$11
31935                       FFFFFFF3            .int13_diskette_function.page	set	-$D
31936                       00000004            _int13_diskette_function.ah	set	4
31937                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
31938                       0000001D            _int13_diskette_function.drive	set	$1D
31939                       FFFFFFFF            .int13_diskette_function.drive	set	-1
31940                       00000005            _int13_diskette_function.num_floppies	set	5
31941                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
31942                       0000002E            _int13_diskette_function.BX	set	$2E
31943                       00000010            .int13_diskette_function.BX	set	$10
31944 922C           FA                                 cli
31945                                           ! 4672 endasm
31946                                           !BCC_ENDASM
31947                                           !BCC_EOS
31948                                           ! 4673         val8 = read_byte(0x0040, 0x003e);
31949                                           ! Debug: list int = const $3E (used reg = )
31950 922D           B8                   003E  mov	ax,*$3E
31951 9230           50                         push	ax
31952                                           ! Debug: list int = const $40 (used reg = )
31953 9231           B8                   0040  mov	ax,*$40
31954 9234           50                         push	ax
31955                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
31956 9235           E8         73BC            call	_read_byte
31957 9238           83C4                   04  add	sp,*4
31958                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31959 923B           8846         F1            mov	-$F[bp],al
31960                                           !BCC_EOS
31961                                           ! 4674         val8 &= 0x7f;
31962                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
31963 923E           8A46         F1            mov	al,-$F[bp]
31964 9241           24                     7F  and	al,*$7F
31965 9243           8846         F1            mov	-$F[bp],al
31966                                           !BCC_EOS
31967                                           ! 4675         write_byte(0x0040, 0x003e, val8);
31968                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
31969 9246           8A46         F1            mov	al,-$F[bp]
31970 9249           30E4                       xor	ah,ah
31971 924B           50                         push	ax
31972                                           ! Debug: list int = const $3E (used reg = )
31973 924C           B8                   003E  mov	ax,*$3E
31974 924F           50                         push	ax
31975                                           ! Debug: list int = const $40 (used reg = )
31976 9250           B8                   0040  mov	ax,*$40
31977 9253           50                         push	ax
31978                                           ! Debug: func () void = write_byte+0 (used reg = )
31979 9254           E8         73C3            call	_write_byte
31980 9257           83C4                   06  add	sp,*6
31981                                           !BCC_EOS
31982                                           ! 4676         val8 = inb(0x3f4);
31983                                           ! Debug: list int = const $3F4 (used reg = )
31984 925A           B8                   03F4  mov	ax,#$3F4
31985 925D           50                         push	ax
31986                                           ! Debug: func () unsigned char = inb+0 (used reg = )
31987 925E           E8         72DD            call	_inb
31988 9261           44                         inc	sp
31989 9262           44                         inc	sp
31990                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
31991 9263           8846         F1            mov	-$F[bp],al
31992                                           !BCC_EOS
31993                                           ! 4677         if ( (val8 & 0xc0) != 0xc0 )
31994                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
31995 9266           8A46         F1            mov	al,-$F[bp]
31996 9269           24                     C0  and	al,#$C0
31997                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
31998 926B           3C                     C0  cmp	al,#$C0
31999 926D           74           0E            je  	.6A2
32000                       0000926F            .6A3:
32001                                           ! 4678           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32002                                           ! Debug: list * char = .6A4+0 (used reg = )
32003 926F           BB                   D0F6  mov	bx,#.6A4
32004 9272           53                         push	bx
32005                                           ! Debug: list int = const 7 (used reg = )
32006 9273           B8                   0007  mov	ax,*7
32007 9276           50                         push	ax
32008                                           ! Debug: func () void = bios_printf+0 (used reg = )
32009 9277           E8         77A1            call	_bios_printf
32010 927A           83C4                   04  add	sp,*4
32011                                           !BCC_EOS
32012                                           ! 4679         return_status[0] = inb(0x3f5);
32013                       0000927D            .6A2:
32014                                           ! Debug: list int = const $3F5 (used reg = )
32015 927D           B8                   03F5  mov	ax,#$3F5
32016 9280           50                         push	ax
32017                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32018 9281           E8         72BA            call	_inb
32019 9284           44                         inc	sp
32020 9285           44                         inc	sp
32021                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32022 9286           8846         E9            mov	-$17[bp],al
32023                                           !BCC_EOS
32024                                           ! 4680         return_status[1] = inb(0x3f5);
32025                                           ! Debug: list int = const $3F5 (used reg = )
32026 9289           B8                   03F5  mov	ax,#$3F5
32027 928C           50                         push	ax
32028                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32029 928D           E8         72AE            call	_inb
32030 9290           44                         inc	sp
32031 9291           44                         inc	sp
32032                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32033 9292           8846         EA            mov	-$16[bp],al
32034                                           !BCC_EOS
32035                                           ! 4681         return_status[2] = inb(0x3f5);
32036                                           ! Debug: list int = const $3F5 (used reg = )
32037 9295           B8                   03F5  mov	ax,#$3F5
32038 9298           50                         push	ax
32039                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32040 9299           E8         72A2            call	_inb
32041 929C           44                         inc	sp
32042 929D           44                         inc	sp
32043                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32044 929E           8846         EB            mov	-$15[bp],al
32045                                           !BCC_EOS
32046                                           ! 4682         return_status[3] = inb(0x3f5);
32047                                           ! Debug: list int = const $3F5 (used reg = )
32048 92A1           B8                   03F5  mov	ax,#$3F5
32049 92A4           50                         push	ax
32050                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32051 92A5           E8         7296            call	_inb
32052 92A8           44                         inc	sp
32053 92A9           44                         inc	sp
32054                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32055 92AA           8846         EC            mov	-$14[bp],al
32056                                           !BCC_EOS
32057                                           ! 4683         return_status[4] = inb(0x3f5);
32058                                           ! Debug: list int = const $3F5 (used reg = )
32059 92AD           B8                   03F5  mov	ax,#$3F5
32060 92B0           50                         push	ax
32061                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32062 92B1           E8         728A            call	_inb
32063 92B4           44                         inc	sp
32064 92B5           44                         inc	sp
32065                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32066 92B6           8846         ED            mov	-$13[bp],al
32067                                           !BCC_EOS
32068                                           ! 4684         return_status[5] = inb(0x3f5);
32069                                           ! Debug: list int = const $3F5 (used reg = )
32070 92B9           B8                   03F5  mov	ax,#$3F5
32071 92BC           50                         push	ax
32072                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32073 92BD           E8         727E            call	_inb
32074 92C0           44                         inc	sp
32075 92C1           44                         inc	sp
32076                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
32077 92C2           8846         EE            mov	-$12[bp],al
32078                                           !BCC_EOS
32079                                           ! 4685         return_status[6] = inb(0x3f5);
32080                                           ! Debug: list int = const $3F5 (used reg = )
32081 92C5           B8                   03F5  mov	ax,#$3F5
32082 92C8           50                         push	ax
32083                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32084 92C9           E8         7272            call	_inb
32085 92CC           44                         inc	sp
32086 92CD           44                         inc	sp
32087                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
32088 92CE           8846         EF            mov	-$11[bp],al
32089                                           !BCC_EOS
32090                                           ! 4686         write_byte(0x0040, 0x0042, return_status[0]);
32091                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
32092 92D1           8A46         E9            mov	al,-$17[bp]
32093 92D4           30E4                       xor	ah,ah
32094 92D6           50                         push	ax
32095                                           ! Debug: list int = const $42 (used reg = )
32096 92D7           B8                   0042  mov	ax,*$42
32097 92DA           50                         push	ax
32098                                           ! Debug: list int = const $40 (used reg = )
32099 92DB           B8                   0040  mov	ax,*$40
32100 92DE           50                         push	ax
32101                                           ! Debug: func () void = write_byte+0 (used reg = )
32102 92DF           E8         7338            call	_write_byte
32103 92E2           83C4                   06  add	sp,*6
32104                                           !BCC_EOS
32105                                           ! 4687         write_byte(0x0040, 0x0043, return_status[1]);
32106                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
32107 92E5           8A46         EA            mov	al,-$16[bp]
32108 92E8           30E4                       xor	ah,ah
32109 92EA           50                         push	ax
32110                                           ! Debug: list int = const $43 (used reg = )
32111 92EB           B8                   0043  mov	ax,*$43
32112 92EE           50                         push	ax
32113                                           ! Debug: list int = const $40 (used reg = )
32114 92EF           B8                   0040  mov	ax,*$40
32115 92F2           50                         push	ax
32116                                           ! Debug: func () void = write_byte+0 (used reg = )
32117 92F3           E8         7324            call	_write_byte
32118 92F6           83C4                   06  add	sp,*6
32119                                           !BCC_EOS
32120                                           ! 4688         write_byte(0x0040, 0x0044, 
32121                                           ! 4688 return_status[2]);
32122                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
32123 92F9           8A46         EB            mov	al,-$15[bp]
32124 92FC           30E4                       xor	ah,ah
32125 92FE           50                         push	ax
32126                                           ! Debug: list int = const $44 (used reg = )
32127 92FF           B8                   0044  mov	ax,*$44
32128 9302           50                         push	ax
32129                                           ! Debug: list int = const $40 (used reg = )
32130 9303           B8                   0040  mov	ax,*$40
32131 9306           50                         push	ax
32132                                           ! Debug: func () void = write_byte+0 (used reg = )
32133 9307           E8         7310            call	_write_byte
32134 930A           83C4                   06  add	sp,*6
32135                                           !BCC_EOS
32136                                           ! 4689         write_byte(0x0040, 0x0045, return_status[3]);
32137                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
32138 930D           8A46         EC            mov	al,-$14[bp]
32139 9310           30E4                       xor	ah,ah
32140 9312           50                         push	ax
32141                                           ! Debug: list int = const $45 (used reg = )
32142 9313           B8                   0045  mov	ax,*$45
32143 9316           50                         push	ax
32144                                           ! Debug: list int = const $40 (used reg = )
32145 9317           B8                   0040  mov	ax,*$40
32146 931A           50                         push	ax
32147                                           ! Debug: func () void = write_byte+0 (used reg = )
32148 931B           E8         72FC            call	_write_byte
32149 931E           83C4                   06  add	sp,*6
32150                                           !BCC_EOS
32151                                           ! 4690         write_byte(0x0040, 0x0046, return_status[4]);
32152                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
32153 9321           8A46         ED            mov	al,-$13[bp]
32154 9324           30E4                       xor	ah,ah
32155 9326           50                         push	ax
32156                                           ! Debug: list int = const $46 (used reg = )
32157 9327           B8                   0046  mov	ax,*$46
32158 932A           50                         push	ax
32159                                           ! Debug: list int = const $40 (used reg = )
32160 932B           B8                   0040  mov	ax,*$40
32161 932E           50                         push	ax
32162                                           ! Debug: func () void = write_byte+0 (used reg = )
32163 932F           E8         72E8            call	_write_byte
32164 9332           83C4                   06  add	sp,*6
32165                                           !BCC_EOS
32166                                           ! 4691         write_byte(0x0040, 0x0047, return_status[5]);
32167                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
32168 9335           8A46         EE            mov	al,-$12[bp]
32169 9338           30E4                       xor	ah,ah
32170 933A           50                         push	ax
32171                                           ! Debug: list int = const $47 (used reg = )
32172 933B           B8                   0047  mov	ax,*$47
32173 933E           50                         push	ax
32174                                           ! Debug: list int = const $40 (used reg = )
32175 933F           B8                   0040  mov	ax,*$40
32176 9342           50                         push	ax
32177                                           ! Debug: func () void = write_byte+0 (used reg = )
32178 9343           E8         72D4            call	_write_byte
32179 9346           83C4                   06  add	sp,*6
32180                                           !BCC_EOS
32181                                           ! 4692         write_byte(0x0040, 0x0048, return_status[6]);
32182                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
32183 9349           8A46         EF            mov	al,-$11[bp]
32184 934C           30E4                       xor	ah,ah
32185 934E           50                         push	ax
32186                                           ! Debug: list int = const $48 (used reg = )
32187 934F           B8                   0048  mov	ax,*$48
32188 9352           50                         push	ax
32189                                           ! Debug: list int = const $40 (used reg = )
32190 9353           B8                   0040  mov	ax,*$40
32191 9356           50                         push	ax
32192                                           ! Debug: func () void = write_byte+0 (used reg = )
32193 9357           E8         72C0            call	_write_byte
32194 935A           83C4                   06  add	sp,*6
32195                                           !BCC_EOS
32196                                           ! 4693         if ( (return_status[0] & 0xc0) != 0 ) {
32197                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
32198 935D           8A46         E9            mov	al,-$17[bp]
32199 9360           24                     C0  and	al,#$C0
32200                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
32201 9362           84C0                       test	al,al
32202 9364           74           2A            je  	.6A5
32203                       00009366            .6A6:
32204                                           ! 4694           AX = ((AX & 0x00ff) | ((0x20) << 8));
32205                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32206 9366           8A46         16            mov	al,$16[bp]
32207                                           ! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
32208 9369           30E4                       xor	ah,ah
32209 936B           0D                   2000  or	ax,#$2000
32210                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32211 936E           8946         16            mov	$16[bp],ax
32212                                           !BCC_EOS
32213                                           ! 4695           set_diskette_ret_status(0x20);
32214                                           ! Debug: list int = const $20 (used reg = )
32215 9371           B8                   0020  mov	ax,*$20
32216 9374           50                         push	ax
32217                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32218 9375           E8         0B8A            call	_set_diskette_ret_status
32219 9378           44                         inc	sp
32220 9379           44                         inc	sp
32221                                           !BCC_EOS
32222                                           ! 4696           AX = ((AX & 0xff00) | (0));
32223                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32224 937A           8B46         16            mov	ax,$16[bp]
32225 937D           30C0                       xor	al,al
32226                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32227 937F           0C                     00  or	al,*0
32228                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32229 9381           8946         16            mov	$16[bp],ax
32230                                           !BCC_EOS
32231                                           ! 4697           FLAGS |= 0x0001;
32232                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32233 9384           8B46         1C            mov	ax,$1C[bp]
32234 9387           0C                     01  or	al,*1
32235 9389           8946         1C            mov	$1C[bp],ax
32236                                           !BCC_EOS
32237                                           ! 4698           return;
32238 938C           89EC                       mov	sp,bp
32239 938E           5D                         pop	bp
32240 938F           C3                         ret
32241                                           !BCC_EOS
32242                                           ! 4699         }
32243                                           ! 4700         set_diskette_current_cyl(drive, track);
32244                       00009390            .6A5:
32245                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32246 9390           8A46         FD            mov	al,-3[bp]
32247 9393           30E4                       xor	ah,ah
32248 9395           50                         push	ax
32249                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
32250 9396           8A46         FF            mov	al,-1[bp]
32251 9399           30E4                       xor	ah,ah
32252 939B           50                         push	ax
32253                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
32254 939C           E8         0B7B            call	_set_diskette_current_cyl
32255 939F           83C4                   04  add	sp,*4
32256                                           !BCC_EOS
32257                                           ! 4701         AX = ((AX & 0x00ff) | ((0x00) << 8));
32258                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32259 93A2           8A46         16            mov	al,$16[bp]
32260                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
32261 93A5           0C                     00  or	al,*0
32262                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
32263 93A7           30E4                       xor	ah,ah
32264 93A9           8946         16            mov	$16[bp],ax
32265                                           !BCC_EOS
32266                                           ! 4702         FLAGS &= 0xfffe;
32267                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32268 93AC           8B46         1C            mov	ax,$1C[bp]
32269 93AF           24                     FE  and	al,#$FE
32270 93B1           8946         1C            mov	$1C[bp],ax
32271                                           !BCC_EOS
32272                                           ! 4703         return;
32273 93B4           89EC                       mov	sp,bp
32274 93B6           5D                         pop	bp
32275 93B7           C3                         ret
32276                                           !BCC_EOS
32277                                           ! 4704       } else if (ah == 0x03) {
32278 93B8           E9         03D7            br 	.6A7
32279                       000093BB            .696:
32280                                           ! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
32281 93BB           8A46         E6            mov	al,-$1A[bp]
32282 93BE           3C                     03  cmp	al,*3
32283 93C0         0F85         03A6            bne 	.6A8
32284                       000093C4            .6A9:
32285                                           ! 4705         page = (ES >> 12);
32286                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
32287 93C4           8B46         06            mov	ax,6[bp]
32288 93C7           88E0                       mov	al,ah
32289 93C9           30E4                       xor	ah,ah
32290 93CB           B1                     04  mov	cl,*4
32291 93CD           D3E8                       shr	ax,cl
32292                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
32293 93CF           8846         F3            mov	-$D[bp],al
32294                                           !BCC_EOS
32295                                           ! 4706         base_es = (ES << 4);
32296                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
32297 93D2           8B46         06            mov	ax,6[bp]
32298 93D5           B1                     04  mov	cl,*4
32299 93D7           D3E0                       shl	ax,cl
32300                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
32301 93D9           8946         F4            mov	-$C[bp],ax
32302                                           !BCC_EOS
32303                                           ! 4707         base_address = base_es + BX;
32304                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
32305 93DC           8B46         F4            mov	ax,-$C[bp]
32306 93DF           0346         10            add	ax,$10[bp]
32307                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
32308 93E2           8946         F8            mov	-8[bp],ax
32309                                           !BCC_EOS
32310                                           ! 4708         if ( base_address < base_es ) {
32311                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
32312 93E5           8B46         F8            mov	ax,-8[bp]
32313 93E8           3B46         F4            cmp	ax,-$C[bp]
32314 93EB           73           07            jae 	.6AA
32315                       000093ED            .6AB:
32316                                           ! 4709           page++;
32317                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
32318 93ED           8A46         F3            mov	al,-$D[bp]
32319 93F0           40                         inc	ax
32320 93F1           8846         F3            mov	-$D[bp],al
32321                                           !BCC_EOS
32322                                           ! 4710         }
32323                                           ! 4711         base_count = (num_sectors * 512) - 1;
32324                       000093F4            .6AA:
32325                                           ! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
32326 93F4           8A46         FE            mov	al,-2[bp]
32327 93F7           30E4                       xor	ah,ah
32328 93F9           B9                   0200  mov	cx,#$200
32329 93FC           F7E9                       imul	cx
32330                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32331                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
32332 93FE           48                         dec	ax
32333 93FF           8946         F6            mov	-$A[bp],ax
32334                                           !BCC_EOS
32335                                           ! 4712         last_addr = base_address + base_count;
32336                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
32337 9402           8B46         F8            mov	ax,-8[bp]
32338 9405           0346         F6            add	ax,-$A[bp]
32339                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
32340 9408           8946         E2            mov	-$1E[bp],ax
32341                                           !BCC_EOS
32342                                           ! 4713         if (last_addr < base_address) {
32343                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
32344 940B           8B46         E2            mov	ax,-$1E[bp]
32345 940E           3B46         F8            cmp	ax,-8[bp]
32346 9411           73           2A            jae 	.6AC
32347                       00009413            .6AD:
32348                                           ! 4714           AX = ((AX & 0x00ff) | ((0x09) << 8));
32349                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32350 9413           8A46         16            mov	al,$16[bp]
32351                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
32352 9416           30E4                       xor	ah,ah
32353 9418           0D                   0900  or	ax,#$900
32354                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32355 941B           8946         16            mov	$16[bp],ax
32356                                           !BCC_EOS
32357                                           ! 4715           set_diskette_ret_status(0x09);
32358                                           ! Debug: list int = const 9 (used reg = )
32359 941E           B8                   0009  mov	ax,*9
32360 9421           50                         push	ax
32361                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32362 9422           E8         0ADD            call	_set_diskette_ret_status
32363 9425           44                         inc	sp
32364 9426           44                         inc	sp
32365                                           !BCC_EOS
32366                                           ! 4716           AX = ((AX & 0xff00) | (0));
32367                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32368 9427           8B46         16            mov	ax,$16[bp]
32369 942A           30C0                       xor	al,al
32370                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32371 942C           0C                     00  or	al,*0
32372                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32373 942E           8946         16            mov	$16[bp],ax
32374                                           !BCC_EOS
32375                                           ! 4717           FLAGS |= 0x0001;
32376                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32377 9431           8B46         1C            mov	ax,$1C[bp]
32378 9434           0C                     01  or	al,*1
32379 9436           8946         1C            mov	$1C[bp],ax
32380                                           !BCC_EOS
32381                                           ! 4718           return;
32382 9439           89EC                       mov	sp,bp
32383 943B           5D                         pop	bp
32384 943C           C3                         ret
32385                                           !BCC_EOS
32386                                           ! 4719         }
32387                                           ! 4720         ;
32388                       0000943D            .6AC:
32389                                           !BCC_EOS
32390                                           ! 4721         outb(0x000a, 0x06);
32391                                           ! Debug: list int = const 6 (used reg = )
32392 943D           B8                   0006  mov	ax,*6
32393 9440           50                         push	ax
32394                                           ! Debug: list int = const $A (used reg = )
32395 9441           B8                   000A  mov	ax,*$A
32396 9444           50                         push	ax
32397                                           ! Debug: func () void = outb+0 (used reg = )
32398 9445           E8         710C            call	_outb
32399 9448           83C4                   04  add	sp,*4
32400                                           !BCC_EOS
32401                                           ! 4722         outb(0x000c, 0x00);
32402                                           ! Debug: list int = const 0 (used reg = )
32403 944B           31C0                       xor	ax,ax
32404 944D           50                         push	ax
32405                                           ! Debug: list int = const $C (used reg = )
32406 944E           B8                   000C  mov	ax,*$C
32407 9451           50                         push	ax
32408                                           ! Debug: func () void = outb+0 (used reg = )
32409 9452           E8         70FF            call	_outb
32410 9455           83C4                   04  add	sp,*4
32411                                           !BCC_EOS
32412                                           ! 4723         outb(0x0004, base_address);
32413                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
32414 9458           FF76         F8            push	-8[bp]
32415                                           ! Debug: list int = const 4 (used reg = )
32416 945B           B8                   0004  mov	ax,*4
32417 945E           50                         push	ax
32418                                           ! Debug: func () void = outb+0 (used reg = )
32419 945F           E8         70F2            call	_outb
32420 9462           83C4                   04  add	sp,*4
32421                                           !BCC_EOS
32422                                           ! 4724         outb(0x0004, base_address>>8);
32423                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
32424 9465           8B46         F8            mov	ax,-8[bp]
32425 9468           88E0                       mov	al,ah
32426 946A           30E4                       xor	ah,ah
32427                                           ! Debug: list unsigned int = ax+0 (used reg = )
32428 946C           50                         push	ax
32429                                           ! Debug: list int = const 4 (used reg = )
32430 946D           B8                   0004  mov	ax,*4
32431 9470           50                         push	ax
32432                                           ! Debug: func () void = outb+0 (used reg = )
32433 9471           E8         70E0            call	_outb
32434 9474           83C4                   04  add	sp,*4
32435                                           !BCC_EOS
32436                                           ! 4725         outb(0x000c, 0x00);
32437                                           ! Debug: list int = const 0 (used reg = )
32438 9477           31C0                       xor	ax,ax
32439 9479           50                         push	ax
32440                                           ! Debug: list int = const $C (used reg = )
32441 947A           B8                   000C  mov	ax,*$C
32442 947D           50                         push	ax
32443                                           ! Debug: func () void = outb+0 (used reg = )
32444 947E           E8         70D3            call	_outb
32445 9481           83C4                   04  add	sp,*4
32446                                           !BCC_EOS
32447                                           ! 4726         outb(0x0005, base_count);
32448                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
32449 9484           FF76         F6            push	-$A[bp]
32450                                           ! Debug: list int = const 5 (used reg = )
32451 9487           B8                   0005  mov	ax,*5
32452 948A           50                         push	ax
32453                                           ! Debug: func () void = outb+0 (used reg = )
32454 948B           E8         70C6            call	_outb
32455 948E           83C4                   04  add	sp,*4
32456                                           !BCC_EOS
32457                                           ! 4727         outb(0x0005, base_count>>8);
32458                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
32459 9491           8B46         F6            mov	ax,-$A[bp]
32460 9494           88E0                       mov	al,ah
32461 9496           30E4                       xor	ah,ah
32462                                           ! Debug: list unsigned int = ax+0 (used reg = )
32463 9498           50                         push	ax
32464                                           ! Debug: list int = const 5 (used reg = )
32465 9499           B8                   0005  mov	ax,*5
32466 949C           50                         push	ax
32467                                           ! Debug: func () void = outb+0 (used reg = )
32468 949D           E8         70B4            call	_outb
32469 94A0           83C4                   04  add	sp,*4
32470                                           !BCC_EOS
32471                                           ! 4728         mode_register = 0x4a;
32472                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
32473 94A3           B0                     4A  mov	al,*$4A
32474 94A5           8846         F2            mov	-$E[bp],al
32475                                           !BCC_EOS
32476                                           ! 4729         outb(0x000b, mode_register);
32477                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
32478 94A8           8A46         F2            mov	al,-$E[bp]
32479 94AB           30E4                       xor	ah,ah
32480 94AD           50                         push	ax
32481                                           ! Debug: list int = const $B (used reg = )
32482 94AE           B8                   000B  mov	ax,*$B
32483 94B1           50                         push	ax
32484                                           ! Debug: func () void = outb+0 (used reg = )
32485 94B2           E8         709F            call	_outb
32486 94B5           83C4                   04  add	sp,*4
32487                                           !BCC_EOS
32488                                           ! 4730         outb(0x0081, page);
32489                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
32490 94B8           8A46         F3            mov	al,-$D[bp]
32491 94BB           30E4                       xor	ah,ah
32492 94BD           50                         push	ax
32493                                           ! Debug: list int = const $81 (used reg = )
32494 94BE           B8                   0081  mov	ax,#$81
32495 94C1           50                         push	ax
32496                                           ! Debug: func () void = outb+0 (used reg = )
32497 94C2           E8         708F            call	_outb
32498 94C5           83C4                   04  add	sp,*4
32499                                           !BCC_EOS
32500                                           ! 4731         ;
32501                                           !BCC_EOS
32502                                           ! 4732         outb(0x000a, 0x02);
32503                                           ! Debug: list int = const 2 (used reg = )
32504 94C8           B8                   0002  mov	ax,*2
32505 94CB           50                         push	ax
32506                                           ! Debug: list int = const $A (used reg = )
32507 94CC           B8                   000A  mov	ax,*$A
32508 94CF           50                         push	ax
32509                                           ! Debug: func () void = outb+0 (used reg = )
32510 94D0           E8         7081            call	_outb
32511 94D3           83C4                   04  add	sp,*4
32512                                           !BCC_EOS
32513                                           ! 4733         floppy_prepare_controller(drive);
32514                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
32515 94D6           8A46         FF            mov	al,-1[bp]
32516 94D9           30E4                       xor	ah,ah
32517 94DB           50                         push	ax
32518                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
32519 94DC           E8         F56C            call	_floppy_prepare_controller
32520 94DF           44                         inc	sp
32521 94E0           44                         inc	sp
32522                                           !BCC_EOS
32523                                           ! 4734         outb(0x03f5, 0xc5);
32524                                           ! Debug: list int = const $C5 (used reg = )
32525 94E1           B8                   00C5  mov	ax,#$C5
32526 94E4           50                         push	ax
32527                                           ! Debug: list int = const $3F5 (used reg = )
32528 94E5           B8                   03F5  mov	ax,#$3F5
32529 94E8           50                         push	ax
32530                                           ! Debug: func () void = outb+0 (used reg = )
32531 94E9           E8         7068            call	_outb
32532 94EC           83C4                   04  add	sp,*4
32533                                           !BCC_EOS
32534                                           ! 4735         outb(0x03f5, (head << 2) | drive);
32535                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
32536 94EF           8A46         FB            mov	al,-5[bp]
32537 94F2           30E4                       xor	ah,ah
32538 94F4           D1E0                       shl	ax,*1
32539 94F6           D1E0                       shl	ax,*1
32540                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
32541 94F8           0A46         FF            or	al,-1[bp]
32542                                           ! Debug: list unsigned int = ax+0 (used reg = )
32543 94FB           50                         push	ax
32544                                           ! Debug: list int = const $3F5 (used reg = )
32545 94FC           B8                   03F5  mov	ax,#$3F5
32546 94FF           50                         push	ax
32547                                           ! Debug: func () void = outb+0 (used reg = )
32548 9500           E8         7051            call	_outb
32549 9503           83C4                   04  add	sp,*4
32550                                           !BCC_EOS
32551                                           ! 4736         outb(0x03f5, track);
32552                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
32553 9506           8A46         FD            mov	al,-3[bp]
32554 9509           30E4                       xor	ah,ah
32555 950B           50                         push	ax
32556                                           ! Debug: list int = const $3F5 (used reg = )
32557 950C           B8                   03F5  mov	ax,#$3F5
32558 950F           50                         push	ax
32559                                           ! Debug: func () void = outb+0 (used reg = )
32560 9510           E8         7041            call	_outb
32561 9513           83C4                   04  add	sp,*4
32562                                           !BCC_EOS
32563                                           ! 4737         outb(0x03f5, head);
32564                                           ! Debug: list unsigned char head = [S+$20-7] (used reg = )
32565 9516           8A46         FB            mov	al,-5[bp]
32566 9519           30E4                       xor	ah,ah
32567 951B           50                         push	ax
32568                                           ! Debug: list int = const $3F5 (used reg = )
32569 951C           B8                   03F5  mov	ax,#$3F5
32570 951F           50                         push	ax
32571                                           ! Debug: func () void = outb+0 (used reg = )
32572 9520           E8         7031            call	_outb
32573 9523           83C4                   04  add	sp,*4
32574                                           !BCC_EOS
32575                                           ! 4738         outb(0x03f5, sector);
32576                                           ! Debug: list unsigned char sector = [S+$20-6] (used reg = )
32577 9526           8A46         FC            mov	al,-4[bp]
32578 9529           30E4                       xor	ah,ah
32579 952B           50                         push	ax
32580                                           ! Debug: list int = const $3F5 (used reg = )
32581 952C           B8                   03F5  mov	ax,#$3F5
32582 952F           50                         push	ax
32583                                           ! Debug: func () void = outb+0 (used reg = )
32584 9530           E8         7021            call	_outb
32585 9533           83C4                   04  add	sp,*4
32586                                           !BCC_EOS
32587                                           ! 4739         outb(0x03f5, 2);
32588                                           ! Debug: list int = const 2 (used reg = )
32589 9536           B8                   0002  mov	ax,*2
32590 9539           50                         push	ax
32591                                           ! Debug: list int = const $3F5 (used reg = )
32592 953A           B8                   03F5  mov	ax,#$3F5
32593 953D           50                         push	ax
32594                                           ! Debug: func () void = outb+0 (used reg = )
32595 953E           E8         7013            call	_outb
32596 9541           83C4                   04  add	sp,*4
32597                                           !BCC_EOS
32598                                           ! 4740         outb(0x03f5, sector + num_sectors - 1);
32599                                           ! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
32600 9544           8A46         FC            mov	al,-4[bp]
32601 9547           30E4                       xor	ah,ah
32602 9549           0246         FE            add	al,-2[bp]
32603 954C           80D4                   00  adc	ah,*0
32604                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
32605                                           ! Debug: list unsigned int = ax-1 (used reg = )
32606 954F           48                         dec	ax
32607 9550           50                         push	ax
32608                                           ! Debug: list int = const $3F5 (used reg = )
32609 9551           B8                   03F5  mov	ax,#$3F5
32610 9554           50                         push	ax
32611                                           ! Debug: func () void = outb+0 (used reg = )
32612 9555           E8         6FFC            call	_outb
32613 9558           83C4                   04  add	sp,*4
32614                                           !BCC_EOS
32615                                           ! 4741         outb(0x03f5, 0);
32616                                           ! Debug: list int = const 0 (used reg = )
32617 955B           31C0                       xor	ax,ax
32618 955D           50                         push	ax
32619                                           ! Debug: list int = const $3F5 (used reg = )
32620 955E           B8                   03F5  mov	ax,#$3F5
32621 9561           50                         push	ax
32622                                           ! Debug: func () void = outb+0 (used reg = )
32623 9562           E8         6FEF            call	_outb
32624 9565           83C4                   04  add	sp,*4
32625                                           !BCC_EOS
32626                                           ! 4742         outb(0x03f5, 0xff);
32627                                           ! Debug: list int = const $FF (used reg = )
32628 9568           B8                   00FF  mov	ax,#$FF
32629 956B           50                         push	ax
32630                                           ! Debug: list int = const $3F5 (used reg = )
32631 956C           B8                   03F5  mov	ax,#$3F5
32632 956F           50                         push	ax
32633                                           ! Debug: func () void = outb+0 (used reg = )
32634 9570           E8         6FE1            call	_outb
32635 9573           83C4                   04  add	sp,*4
32636                                           !BCC_EOS
32637                                           ! 4743 #asm
32638                                           !BCC_EOS
32639                                           !BCC_ASM
32640                       0000002A            _int13_diskette_function.BP	set	$2A
32641                       0000000C            .int13_diskette_function.BP	set	$C
32642                       00000038            _int13_diskette_function.CS	set	$38
32643                       0000001A            .int13_diskette_function.CS	set	$1A
32644                       00000032            _int13_diskette_function.CX	set	$32
32645                       00000014            .int13_diskette_function.CX	set	$14
32646                       00000016            _int13_diskette_function.base_address	set	$16
32647                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32648                       00000026            _int13_diskette_function.DI	set	$26
32649                       00000008            .int13_diskette_function.DI	set	8
32650                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32651                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32652                       00000014            _int13_diskette_function.base_count	set	$14
32653                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32654                       0000001A            _int13_diskette_function.sector	set	$1A
32655                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32656                       00000022            _int13_diskette_function.DS	set	$22
32657                       00000004            .int13_diskette_function.DS	set	4
32658                       00000019            _int13_diskette_function.head	set	$19
32659                       FFFFFFFB            .int13_diskette_function.head	set	-5
32660                       0000002C            _int13_diskette_function.ELDX	set	$2C
32661                       0000000E            .int13_diskette_function.ELDX	set	$E
32662                       0000000E            _int13_diskette_function.dor	set	$E
32663                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32664                       00000030            _int13_diskette_function.DX	set	$30
32665                       00000012            .int13_diskette_function.DX	set	$12
32666                       00000007            _int13_diskette_function.return_status	set	7
32667                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32668                       00000002            _int13_diskette_function.es	set	2
32669                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32670                       00000010            _int13_diskette_function.mode_register	set	$10
32671                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32672                       00000024            _int13_diskette_function.ES	set	$24
32673                       00000006            .int13_diskette_function.ES	set	6
32674                       00000012            _int13_diskette_function.base_es	set	$12
32675                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32676                       0000001B            _int13_diskette_function.track	set	$1B
32677                       FFFFFFFD            .int13_diskette_function.track	set	-3
32678                       00000028            _int13_diskette_function.SI	set	$28
32679                       0000000A            .int13_diskette_function.SI	set	$A
32680                       00000006            _int13_diskette_function.drive_type	set	6
32681                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32682                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32683                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32684                       00000036            _int13_diskette_function.IP	set	$36
32685                       00000018            .int13_diskette_function.IP	set	$18
32686                       00000018            _int13_diskette_function.status	set	$18
32687                       FFFFFFFA            .int13_diskette_function.status	set	-6
32688                       00000034            _int13_diskette_function.AX	set	$34
32689                       00000016            .int13_diskette_function.AX	set	$16
32690                       0000000F            _int13_diskette_function.val8	set	$F
32691                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32692                       00000000            _int13_diskette_function.last_addr	set	0
32693                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32694                       00000011            _int13_diskette_function.page	set	$11
32695                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32696                       00000004            _int13_diskette_function.ah	set	4
32697                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32698                       0000001D            _int13_diskette_function.drive	set	$1D
32699                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32700                       00000005            _int13_diskette_function.num_floppies	set	5
32701                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32702                       0000002E            _int13_diskette_function.BX	set	$2E
32703                       00000010            .int13_diskette_function.BX	set	$10
32704 9576           FB                                 sti
32705                                           ! 4745 endasm
32706                                           !BCC_ENDASM
32707                                           !BCC_EOS
32708                                           ! 4746         do {
32709                       00009577            .6B0:
32710                                           ! 4747           val8 = read_byte(0x0040, 0x0040);
32711                                           ! Debug: list int = const $40 (used reg = )
32712 9577           B8                   0040  mov	ax,*$40
32713 957A           50                         push	ax
32714                                           ! Debug: list int = const $40 (used reg = )
32715 957B           B8                   0040  mov	ax,*$40
32716 957E           50                         push	ax
32717                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32718 957F           E8         7072            call	_read_byte
32719 9582           83C4                   04  add	sp,*4
32720                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32721 9585           8846         F1            mov	-$F[bp],al
32722                                           !BCC_EOS
32723                                           ! 4748           if (val8 == 0) {
32724                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32725 9588           8A46         F1            mov	al,-$F[bp]
32726 958B           84C0                       test	al,al
32727 958D           75           2D            jne 	.6B1
32728                       0000958F            .6B2:
32729                                           ! 4749             floppy_reset_controller();
32730                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
32731 958F           E8         F46B            call	_floppy_reset_controller
32732                                           !BCC_EOS
32733                                           ! 4750             AX = ((AX & 0x00ff) | ((0x80) << 8));
32734                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
32735 9592           8A46         16            mov	al,$16[bp]
32736                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
32737 9595           30E4                       xor	ah,ah
32738 9597           0D                   8000  or	ax,#-$8000
32739                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32740 959A           8946         16            mov	$16[bp],ax
32741                                           !BCC_EOS
32742                                           ! 4751             set_diskette_ret_status(0x80);
32743                                           ! Debug: list int = const $80 (used reg = )
32744 959D           B8                   0080  mov	ax,#$80
32745 95A0           50                         push	ax
32746                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
32747 95A1           E8         095E            call	_set_diskette_ret_status
32748 95A4           44                         inc	sp
32749 95A5           44                         inc	sp
32750                                           !BCC_EOS
32751                                           ! 4752  
32752                                           ! 4752            AX = ((AX & 0xff00) | (0));
32753                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
32754 95A6           8B46         16            mov	ax,$16[bp]
32755 95A9           30C0                       xor	al,al
32756                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
32757 95AB           0C                     00  or	al,*0
32758                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
32759 95AD           8946         16            mov	$16[bp],ax
32760                                           !BCC_EOS
32761                                           ! 4753             FLAGS |= 0x0001;
32762                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
32763 95B0           8B46         1C            mov	ax,$1C[bp]
32764 95B3           0C                     01  or	al,*1
32765 95B5           8946         1C            mov	$1C[bp],ax
32766                                           !BCC_EOS
32767                                           ! 4754             return;
32768 95B8           89EC                       mov	sp,bp
32769 95BA           5D                         pop	bp
32770 95BB           C3                         ret
32771                                           !BCC_EOS
32772                                           ! 4755           }
32773                                           ! 4756           val8 = (read_byte(0x0040, 0x003e) & 0x80);
32774                       000095BC            .6B1:
32775                                           ! Debug: list int = const $3E (used reg = )
32776 95BC           B8                   003E  mov	ax,*$3E
32777 95BF           50                         push	ax
32778                                           ! Debug: list int = const $40 (used reg = )
32779 95C0           B8                   0040  mov	ax,*$40
32780 95C3           50                         push	ax
32781                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32782 95C4           E8         702D            call	_read_byte
32783 95C7           83C4                   04  add	sp,*4
32784                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
32785 95CA           24                     80  and	al,#$80
32786                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32787 95CC           8846         F1            mov	-$F[bp],al
32788                                           !BCC_EOS
32789                                           ! 4757         } while ( val8 == 0 );
32790                       000095CF            .6AF:
32791                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32792 95CF           8A46         F1            mov	al,-$F[bp]
32793 95D2           84C0                       test	al,al
32794 95D4           74           A1            je 	.6B0
32795                       000095D6            .6B3:
32796                                           !BCC_EOS
32797                                           ! 4758         val8 = 0;
32798                       000095D6            .6AE:
32799                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
32800 95D6           30C0                       xor	al,al
32801 95D8           8846         F1            mov	-$F[bp],al
32802                                           !BCC_EOS
32803                                           ! 4759 #asm
32804                                           !BCC_EOS
32805                                           !BCC_ASM
32806                       0000002A            _int13_diskette_function.BP	set	$2A
32807                       0000000C            .int13_diskette_function.BP	set	$C
32808                       00000038            _int13_diskette_function.CS	set	$38
32809                       0000001A            .int13_diskette_function.CS	set	$1A
32810                       00000032            _int13_diskette_function.CX	set	$32
32811                       00000014            .int13_diskette_function.CX	set	$14
32812                       00000016            _int13_diskette_function.base_address	set	$16
32813                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
32814                       00000026            _int13_diskette_function.DI	set	$26
32815                       00000008            .int13_diskette_function.DI	set	8
32816                       0000003A            _int13_diskette_function.FLAGS	set	$3A
32817                       0000001C            .int13_diskette_function.FLAGS	set	$1C
32818                       00000014            _int13_diskette_function.base_count	set	$14
32819                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
32820                       0000001A            _int13_diskette_function.sector	set	$1A
32821                       FFFFFFFC            .int13_diskette_function.sector	set	-4
32822                       00000022            _int13_diskette_function.DS	set	$22
32823                       00000004            .int13_diskette_function.DS	set	4
32824                       00000019            _int13_diskette_function.head	set	$19
32825                       FFFFFFFB            .int13_diskette_function.head	set	-5
32826                       0000002C            _int13_diskette_function.ELDX	set	$2C
32827                       0000000E            .int13_diskette_function.ELDX	set	$E
32828                       0000000E            _int13_diskette_function.dor	set	$E
32829                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
32830                       00000030            _int13_diskette_function.DX	set	$30
32831                       00000012            .int13_diskette_function.DX	set	$12
32832                       00000007            _int13_diskette_function.return_status	set	7
32833                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
32834                       00000002            _int13_diskette_function.es	set	2
32835                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
32836                       00000010            _int13_diskette_function.mode_register	set	$10
32837                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
32838                       00000024            _int13_diskette_function.ES	set	$24
32839                       00000006            .int13_diskette_function.ES	set	6
32840                       00000012            _int13_diskette_function.base_es	set	$12
32841                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
32842                       0000001B            _int13_diskette_function.track	set	$1B
32843                       FFFFFFFD            .int13_diskette_function.track	set	-3
32844                       00000028            _int13_diskette_function.SI	set	$28
32845                       0000000A            .int13_diskette_function.SI	set	$A
32846                       00000006            _int13_diskette_function.drive_type	set	6
32847                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
32848                       0000001C            _int13_diskette_function.num_sectors	set	$1C
32849                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
32850                       00000036            _int13_diskette_function.IP	set	$36
32851                       00000018            .int13_diskette_function.IP	set	$18
32852                       00000018            _int13_diskette_function.status	set	$18
32853                       FFFFFFFA            .int13_diskette_function.status	set	-6
32854                       00000034            _int13_diskette_function.AX	set	$34
32855                       00000016            .int13_diskette_function.AX	set	$16
32856                       0000000F            _int13_diskette_function.val8	set	$F
32857                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
32858                       00000000            _int13_diskette_function.last_addr	set	0
32859                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
32860                       00000011            _int13_diskette_function.page	set	$11
32861                       FFFFFFF3            .int13_diskette_function.page	set	-$D
32862                       00000004            _int13_diskette_function.ah	set	4
32863                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
32864                       0000001D            _int13_diskette_function.drive	set	$1D
32865                       FFFFFFFF            .int13_diskette_function.drive	set	-1
32866                       00000005            _int13_diskette_function.num_floppies	set	5
32867                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
32868                       0000002E            _int13_diskette_function.BX	set	$2E
32869                       00000010            .int13_diskette_function.BX	set	$10
32870 95DB           FA                                 cli
32871                                           ! 4761 endasm
32872                                           !BCC_ENDASM
32873                                           !BCC_EOS
32874                                           ! 4762         val8 = read_byte(0x0040, 0x003e);
32875                                           ! Debug: list int = const $3E (used reg = )
32876 95DC           B8                   003E  mov	ax,*$3E
32877 95DF           50                         push	ax
32878                                           ! Debug: list int = const $40 (used reg = )
32879 95E0           B8                   0040  mov	ax,*$40
32880 95E3           50                         push	ax
32881                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
32882 95E4           E8         700D            call	_read_byte
32883 95E7           83C4                   04  add	sp,*4
32884                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32885 95EA           8846         F1            mov	-$F[bp],al
32886                                           !BCC_EOS
32887                                           ! 4763         val8 &= 0x7f;
32888                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
32889 95ED           8A46         F1            mov	al,-$F[bp]
32890 95F0           24                     7F  and	al,*$7F
32891 95F2           8846         F1            mov	-$F[bp],al
32892                                           !BCC_EOS
32893                                           ! 4764         write_byte(0x0040, 0x003e, val8);
32894                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
32895 95F5           8A46         F1            mov	al,-$F[bp]
32896 95F8           30E4                       xor	ah,ah
32897 95FA           50                         push	ax
32898                                           ! Debug: list int = const $3E (used reg = )
32899 95FB           B8                   003E  mov	ax,*$3E
32900 95FE           50                         push	ax
32901                                           ! Debug: list int = const $40 (used reg = )
32902 95FF           B8                   0040  mov	ax,*$40
32903 9602           50                         push	ax
32904                                           ! Debug: func () void = write_byte+0 (used reg = )
32905 9603           E8         7014            call	_write_byte
32906 9606           83C4                   06  add	sp,*6
32907                                           !BCC_EOS
32908                                           ! 4765         val8 = inb(0x3f4);
32909                                           ! Debug: list int = const $3F4 (used reg = )
32910 9609           B8                   03F4  mov	ax,#$3F4
32911 960C           50                         push	ax
32912                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32913 960D           E8         6F2E            call	_inb
32914 9610           44                         inc	sp
32915 9611           44                         inc	sp
32916                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
32917 9612           8846         F1            mov	-$F[bp],al
32918                                           !BCC_EOS
32919                                           ! 4766         if ( (val8 & 0xc0) != 0xc0 )
32920                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
32921 9615           8A46         F1            mov	al,-$F[bp]
32922 9618           24                     C0  and	al,#$C0
32923                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
32924 961A           3C                     C0  cmp	al,#$C0
32925 961C           74           0E            je  	.6B4
32926                       0000961E            .6B5:
32927                                           ! 4767           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
32928                                           ! Debug: list * char = .6B6+0 (used reg = )
32929 961E           BB                   D0D6  mov	bx,#.6B6
32930 9621           53                         push	bx
32931                                           ! Debug: list int = const 7 (used reg = )
32932 9622           B8                   0007  mov	ax,*7
32933 9625           50                         push	ax
32934                                           ! Debug: func () void = bios_printf+0 (used reg = )
32935 9626           E8         73F2            call	_bios_printf
32936 9629           83C4                   04  add	sp,*4
32937                                           !BCC_EOS
32938                                           ! 4768         return_status[0] = inb(0x3f5);
32939                       0000962C            .6B4:
32940                                           ! Debug: list int = const $3F5 (used reg = )
32941 962C           B8                   03F5  mov	ax,#$3F5
32942 962F           50                         push	ax
32943                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32944 9630           E8         6F0B            call	_inb
32945 9633           44                         inc	sp
32946 9634           44                         inc	sp
32947                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
32948 9635           8846         E9            mov	-$17[bp],al
32949                                           !BCC_EOS
32950                                           ! 4769         return_status[1] = inb(0x3f5);
32951                                           ! Debug: list int = const $3F5 (used reg = )
32952 9638           B8                   03F5  mov	ax,#$3F5
32953 963B           50                         push	ax
32954                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32955 963C           E8         6EFF            call	_inb
32956 963F           44                         inc	sp
32957 9640           44                         inc	sp
32958                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
32959 9641           8846         EA            mov	-$16[bp],al
32960                                           !BCC_EOS
32961                                           ! 4770         return_status[2] = inb(0x3f5);
32962                                           ! Debug: list int = const $3F5 (used reg = )
32963 9644           B8                   03F5  mov	ax,#$3F5
32964 9647           50                         push	ax
32965                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32966 9648           E8         6EF3            call	_inb
32967 964B           44                         inc	sp
32968 964C           44                         inc	sp
32969                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
32970 964D           8846         EB            mov	-$15[bp],al
32971                                           !BCC_EOS
32972                                           ! 4771         return_status[3] = inb(0x3f5);
32973                                           ! Debug: list int = const $3F5 (used reg = )
32974 9650           B8                   03F5  mov	ax,#$3F5
32975 9653           50                         push	ax
32976                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32977 9654           E8         6EE7            call	_inb
32978 9657           44                         inc	sp
32979 9658           44                         inc	sp
32980                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
32981 9659           8846         EC            mov	-$14[bp],al
32982                                           !BCC_EOS
32983                                           ! 4772         return_status[4] = inb(0x3f5);
32984                                           ! Debug: list int = const $3F5 (used reg = )
32985 965C           B8                   03F5  mov	ax,#$3F5
32986 965F           50                         push	ax
32987                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32988 9660           E8         6EDB            call	_inb
32989 9663           44                         inc	sp
32990 9664           44                         inc	sp
32991                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
32992 9665           8846         ED            mov	-$13[bp],al
32993                                           !BCC_EOS
32994                                           ! 4773         return_status[5] = inb(0x3f5);
32995                                           ! Debug: list int = const $3F5 (used reg = )
32996 9668           B8                   03F5  mov	ax,#$3F5
32997 966B           50                         push	ax
32998                                           ! Debug: func () unsigned char = inb+0 (used reg = )
32999 966C           E8         6ECF            call	_inb
33000 966F           44                         inc	sp
33001 9670           44                         inc	sp
33002                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
33003 9671           8846         EE            mov	-$12[bp],al
33004                                           !BCC_EOS
33005                                           ! 4774         return_status[6] = inb(0x3f5);
33006                                           ! Debug: list int = const $3F5 (used reg = )
33007 9674           B8                   03F5  mov	ax,#$3F5
33008 9677           50                         push	ax
33009                                           ! Debug: func () unsigned char = inb+0 (used reg = )
33010 9678           E8         6EC3            call	_inb
33011 967B           44                         inc	sp
33012 967C           44                         inc	sp
33013                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
33014 967D           8846         EF            mov	-$11[bp],al
33015                                           !BCC_EOS
33016                                           ! 4775         write_byte(0x0040, 0x0042, return_status[0]);
33017                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
33018 9680           8A46         E9            mov	al,-$17[bp]
33019 9683           30E4                       xor	ah,ah
33020 9685           50                         push	ax
33021                                           ! Debug: list int = const $42 (used reg = )
33022 9686           B8                   0042  mov	ax,*$42
33023 9689           50                         push	ax
33024                                           ! Debug: list int = const $40 (used reg = )
33025 968A           B8                   0040  mov	ax,*$40
33026 968D           50                         push	ax
33027                                           ! Debug: func () void = write_byte+0 (used reg = )
33028 968E           E8         6F89            call	_write_byte
33029 9691           83C4                   06  add	sp,*6
33030                                           !BCC_EOS
33031                                           ! 4776         write_byte(0x0040, 0x0043, return_status[1]);
33032                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
33033 9694           8A46         EA            mov	al,-$16[bp]
33034 9697           30E4                       xor	ah,ah
33035 9699           50                         push	ax
33036                                           ! Debug: list int = const $43 (used reg = )
33037 969A           B8                   0043  mov	ax,*$43
33038 969D           50                         push	ax
33039                                           ! Debug: list int = const $40 (used reg = )
33040 969E           B8                   0040  mov	ax,*$40
33041 96A1           50                         push	ax
33042                                           ! Debug: func () void = write_byte+0 (used reg = )
33043 96A2           E8         6F75            call	_write_byte
33044 96A5           83C4                   06  add	sp,*6
33045                                           !BCC_EOS
33046                                           ! 4777         write_byte(0x0040, 0x0044, return_status[2]);
33047                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
33048 96A8           8A46         EB            mov	al,-$15[bp]
33049 96AB           30E4                       xor	ah,ah
33050 96AD           50                         push	ax
33051                                           ! Debug: list int = const $44 (used reg = )
33052 96AE           B8                   0044  mov	ax,*$44
33053 96B1           50                         push	ax
33054                                           ! Debug: list int = const $40 (used reg = )
33055 96B2           B8                   0040  mov	ax,*$40
33056 96B5           50                         push	ax
33057                                           ! Debug: func () void = write_byte+0 (used reg = )
33058 96B6           E8         6F61            call	_write_byte
33059 96B9           83C4                   06  add	sp,*6
33060                                           !BCC_EOS
33061                                           ! 4778         write_byte(0x0040, 0x0045, return_status[3]);
33062                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
33063 96BC           8A46         EC            mov	al,-$14[bp]
33064 96BF           30E4                       xor	ah,ah
33065 96C1           50                         push	ax
33066                                           ! Debug: list int = const $45 (used reg = )
33067 96C2           B8                   0045  mov	ax,*$45
33068 96C5           50                         push	ax
33069                                           ! Debug: list int = const $40 (used reg = )
33070 96C6           B8                   0040  mov	ax,*$40
33071 96C9           50                         push	ax
33072                                           ! Debug: func () void = write_byte+0 (used reg = )
33073 96CA           E8         6F4D            call	_write_byte
33074 96CD           83C4                   06  add	sp,*6
33075                                           !BCC_EOS
33076                                           ! 4779         write_byte(0x0040, 0x0046, return_status[4]);
33077                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
33078 96D0           8A46         ED            mov	al,-$13[bp]
33079 96D3           30E4                       xor	ah,ah
33080 96D5           50                         push	ax
33081                                           ! Debug: list int = const $46 (used reg = )
33082 96D6           B8                   0046  mov	ax,*$46
33083 96D9           50                         push	ax
33084                                           ! Debug: list int = const $40 (used reg = )
33085 96DA           B8                   0040  mov	ax,*$40
33086 96DD           50                         push	ax
33087                                           ! Debug: func () void = write_byte+0 (used reg = )
33088 96DE           E8         6F39            call	_write_byte
33089 96E1           83C4                   06  add	sp,*6
33090                                           !BCC_EOS
33091                                           ! 4780         write_byte(0x0040, 0x0047, return_status[5]);
33092                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
33093 96E4           8A46         EE            mov	al,-$12[bp]
33094 96E7           30E4                       xor	ah,ah
33095 96E9           50                         push	ax
33096                                           ! Debug: list int = const $47 (used reg = )
33097 96EA           B8                   0047  mov	ax,*$47
33098 96ED           50                         push	ax
33099                                           ! Debug: list int = const $40 (used reg = )
33100 96EE           B8                   0040  mov	ax,*$40
33101 96F1           50                         push	ax
33102                                           ! Debug: func () void = write_byte+0 (used reg = )
33103 96F2           E8         6F25            call	_write_byte
33104 96F5           83C4                   06  add	sp,*6
33105                                           !BCC_EOS
33106                                           ! 4781         write_byte(0x0040, 0x0048, return_status[6]);
33107                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
33108 96F8           8A46         EF            mov	al,-$11[bp]
33109 96FB           30E4                       xor	ah,ah
33110 96FD           50                         push	ax
33111                                           ! Debug: list int = const $48 (used reg = )
33112 96FE           B8                   0048  mov	ax,*$48
33113 9701           50                         push	ax
33114                                           ! Debug: list int = const $40 (used reg = )
33115 9702           B8                   0040  mov	ax,*$40
33116 9705           50                         push	ax
33117                                           ! Debug: func () void = write_byte+0 (used reg = )
33118 9706           E8         6F11            call	_write_byte
33119 9709           83C4                   06  add	sp,*6
33120                                           !BCC_EOS
33121                                           ! 4782         if ( (return_status[0] & 0xc0) != 0 ) {
33122                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
33123 970C           8A46         E9            mov	al,-$17[bp]
33124 970F           24                     C0  and	al,#$C0
33125                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33126 9711           84C0                       test	al,al
33127 9713           74           2B            je  	.6B7
33128                       00009715            .6B8:
33129                                           ! 4783           if ( (return_status[1] & 0x02) != 0 ) {
33130                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
33131 9715           8A46         EA            mov	al,-$16[bp]
33132 9718           24                     02  and	al,*2
33133                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
33134 971A           84C0                       test	al,al
33135 971C           74           14            je  	.6B9
33136                       0000971E            .6BA:
33137                                           ! 4784             AX = 0x0300;
33138                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
33139 971E           B8                   0300  mov	ax,#$300
33140 9721           8946         16            mov	$16[bp],ax
33141                                           !BCC_EOS
33142                                           ! 4785             FLAGS |= 0x0001;
33143                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33144 9724           8B46         1C            mov	ax,$1C[bp]
33145 9727           0C                     01  or	al,*1
33146 9729           8946         1C            mov	$1C[bp],ax
33147                                           !BCC_EOS
33148                                           ! 4786             return;
33149 972C           89EC                       mov	sp,bp
33150 972E           5D                         pop	bp
33151 972F           C3                         ret
33152                                           !BCC_EOS
33153                                           ! 4787           } else {
33154 9730           EB           0E            jmp .6BB
33155                       00009732            .6B9:
33156                                           ! 4788             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
33157                                           ! Debug: list * char = .6BC+0 (used reg = )
33158 9732           BB                   D0B1  mov	bx,#.6BC
33159 9735           53                         push	bx
33160                                           ! Debug: list int = const 7 (used reg = )
33161 9736           B8                   0007  mov	ax,*7
33162 9739           50                         push	ax
33163                                           ! Debug: func () void = bios_printf+0 (used reg = )
33164 973A           E8         72DE            call	_bios_printf
33165 973D           83C4                   04  add	sp,*4
33166                                           !BCC_EOS
33167                                           ! 4789           }
33168                                           ! 4790         }
33169                       00009740            .6BB:
33170                                           ! 4791         set_diskette_current_cyl(drive, track);
33171                       00009740            .6B7:
33172                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33173 9740           8A46         FD            mov	al,-3[bp]
33174 9743           30E4                       xor	ah,ah
33175 9745           50                         push	ax
33176                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33177 9746           8A46         FF            mov	al,-1[bp]
33178 9749           30E4                       xor	ah,ah
33179 974B           50                         push	ax
33180                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33181 974C           E8         07CB            call	_set_diskette_current_cyl
33182 974F           83C4                   04  add	sp,*4
33183                                           !BCC_EOS
33184                                           ! 4792         AX = ((AX & 0x00ff) | ((0x00) << 8));
33185                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33186 9752           8A46         16            mov	al,$16[bp]
33187                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33188 9755           0C                     00  or	al,*0
33189                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33190 9757           30E4                       xor	ah,ah
33191 9759           8946         16            mov	$16[bp],ax
33192                                           !BCC_EOS
33193                                           ! 4793         FLAGS &= 0xfffe;
33194                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33195 975C           8B46         1C            mov	ax,$1C[bp]
33196 975F           24                     FE  and	al,#$FE
33197 9761           8946         1C            mov	$1C[bp],ax
33198                                           !BCC_EOS
33199                                           ! 4794         return;
33200 9764           89EC                       mov	sp,bp
33201 9766           5D                         pop	bp
33202 9767           C3                         ret
33203                                           !BCC_EOS
33204                                           ! 4795       } else {
33205 9768           EB           28            jmp .6BD
33206                       0000976A            .6A8:
33207                                           ! 4796         set_diskette_current_cyl(drive, track);
33208                                           ! Debug: list unsigned char track = [S+$20-5] (used reg = )
33209 976A           8A46         FD            mov	al,-3[bp]
33210 976D           30E4                       xor	ah,ah
33211 976F           50                         push	ax
33212                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
33213 9770           8A46         FF            mov	al,-1[bp]
33214 9773           30E4                       xor	ah,ah
33215 9775           50                         push	ax
33216                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
33217 9776           E8         07A1            call	_set_diskette_current_cyl
33218 9779           83C4                   04  add	sp,*4
33219                                           !BCC_EOS
33220                                           ! 4797         FLAGS &= 0xfffe;
33221                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33222 977C           8B46         1C            mov	ax,$1C[bp]
33223 977F           24                     FE  and	al,#$FE
33224 9781           8946         1C            mov	$1C[bp],ax
33225                                           !BCC_EOS
33226                                           ! 4798         AX = ((AX & 0x00ff) | ((0x00) << 8));
33227                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33228 9784           8A46         16            mov	al,$16[bp]
33229                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
33230 9787           0C                     00  or	al,*0
33231                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
33232 9789           30E4                       xor	ah,ah
33233 978B           8946         16            mov	$16[bp],ax
33234                                           !BCC_EOS
33235                                           ! 4799         return;
33236 978E           89EC                       mov	sp,bp
33237 9790           5D                         pop	bp
33238 9791           C3                         ret
33239                                           !BCC_EOS
33240                                           ! 4800       }
33241                                           ! 4801       break;
33242                       00009792            .6BD:
33243                       00009792            .6A7:
33244 9792           E9         0769            br 	.679
33245                                           !BCC_EOS
33246                                           ! 4802     case 0x05:
33247                                           ! 4803 ;
33248                       00009795            .6BE:
33249                                           !BCC_EOS
33250                                           ! 4804       num_sectors = ( AX & 0x00ff );
33251                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33252 9795           8A46         16            mov	al,$16[bp]
33253                                           ! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33254 9798           8846         FE            mov	-2[bp],al
33255                                           !BCC_EOS
33256                                           ! 4805       track = ( CX >> 8 );
33257                                           ! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
33258 979B           8B46         14            mov	ax,$14[bp]
33259 979E           88E0                       mov	al,ah
33260 97A0           30E4                       xor	ah,ah
33261                                           ! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
33262 97A2           8846         FD            mov	-3[bp],al
33263                                           !BCC_EOS
33264                                           ! 4806       head = ( DX >> 8 );
33265                                           ! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
33266 97A5           8B46         12            mov	ax,$12[bp]
33267 97A8           88E0                       mov	al,ah
33268 97AA           30E4                       xor	ah,ah
33269                                           ! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
33270 97AC           8846         FB            mov	-5[bp],al
33271                                           !BCC_EOS
33272                                           ! 4807       drive = ( ELDX & 0x00ff );
33273                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
33274 97AF           8A46         0E            mov	al,$E[bp]
33275                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
33276 97B2           8846         FF            mov	-1[bp],al
33277                                           !BCC_EOS
33278                                           ! 4808       if ((drive > 1) || (head > 1) || (track > 79) ||
33279                                           ! 4809           (num_sectors == 0) || (num_sectors > 18)) {
33280                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
33281 97B5           8A46         FF            mov	al,-1[bp]
33282 97B8           3C                     01  cmp	al,*1
33283 97BA           77           1C            ja  	.6C0
33284                       000097BC            .6C4:
33285                                           ! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
33286 97BC           8A46         FB            mov	al,-5[bp]
33287 97BF           3C                     01  cmp	al,*1
33288 97C1           77           15            ja  	.6C0
33289                       000097C3            .6C3:
33290                                           ! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
33291 97C3           8A46         FD            mov	al,-3[bp]
33292 97C6           3C                     4F  cmp	al,*$4F
33293 97C8           77           0E            ja  	.6C0
33294                       000097CA            .6C2:
33295                                           ! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
33296 97CA           8A46         FE            mov	al,-2[bp]
33297 97CD           84C0                       test	al,al
33298 97CF           74           07            je  	.6C0
33299                       000097D1            .6C1:
33300                                           ! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
33301 97D1           8A46         FE            mov	al,-2[bp]
33302 97D4           3C                     12  cmp	al,*$12
33303 97D6           76           1C            jbe 	.6BF
33304                       000097D8            .6C0:
33305                                           ! 4810         AX = ((AX & 0x00ff) | ((1) << 8));
33306                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33307 97D8           8A46         16            mov	al,$16[bp]
33308                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
33309 97DB           30E4                       xor	ah,ah
33310 97DD           0D                   0100  or	ax,#$100
33311                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33312 97E0           8946         16            mov	$16[bp],ax
33313                                           !BCC_EOS
33314                                           ! 4811         set_diskette_ret_status(1);
33315                                           ! Debug: list int = const 1 (used reg = )
33316 97E3           B8                   0001  mov	ax,*1
33317 97E6           50                         push	ax
33318                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33319 97E7           E8         0718            call	_set_diskette_ret_status
33320 97EA           44                         inc	sp
33321 97EB           44                         inc	sp
33322                                           !BCC_EOS
33323                                           ! 4812   
33324                                           ! 4812       FLAGS |= 0x0001;
33325                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33326 97EC           8B46         1C            mov	ax,$1C[bp]
33327 97EF           0C                     01  or	al,*1
33328 97F1           8946         1C            mov	$1C[bp],ax
33329                                           !BCC_EOS
33330                                           ! 4813       }
33331                                           ! 4814       if (floppy_drive_exists(drive) == 0) {
33332                       000097F4            .6BF:
33333                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33334 97F4           8A46         FF            mov	al,-1[bp]
33335 97F7           30E4                       xor	ah,ah
33336 97F9           50                         push	ax
33337                                           ! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
33338 97FA           E8         F5C3            call	_floppy_drive_exists
33339 97FD           44                         inc	sp
33340 97FE           44                         inc	sp
33341                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33342 97FF           85C0                       test	ax,ax
33343 9801           75           20            jne 	.6C5
33344                       00009803            .6C6:
33345                                           ! 4815         AX = ((AX & 0x00ff) | ((0x80) << 8));
33346                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33347 9803           8A46         16            mov	al,$16[bp]
33348                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33349 9806           30E4                       xor	ah,ah
33350 9808           0D                   8000  or	ax,#-$8000
33351                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33352 980B           8946         16            mov	$16[bp],ax
33353                                           !BCC_EOS
33354                                           ! 4816         set_diskette_ret_status(0x80);
33355                                           ! Debug: list int = const $80 (used reg = )
33356 980E           B8                   0080  mov	ax,#$80
33357 9811           50                         push	ax
33358                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33359 9812           E8         06ED            call	_set_diskette_ret_status
33360 9815           44                         inc	sp
33361 9816           44                         inc	sp
33362                                           !BCC_EOS
33363                                           ! 4817         FLAGS |= 0x0001;
33364                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33365 9817           8B46         1C            mov	ax,$1C[bp]
33366 981A           0C                     01  or	al,*1
33367 981C           8946         1C            mov	$1C[bp],ax
33368                                           !BCC_EOS
33369                                           ! 4818         return;
33370 981F           89EC                       mov	sp,bp
33371 9821           5D                         pop	bp
33372 9822           C3                         ret
33373                                           !BCC_EOS
33374                                           ! 4819       }
33375                                           ! 4820       if (floppy_media_known(drive) == 0) {
33376                       00009823            .6C5:
33377                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33378 9823           8A46         FF            mov	al,-1[bp]
33379 9826           30E4                       xor	ah,ah
33380 9828           50                         push	ax
33381                                           ! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
33382 9829           E8         F2FE            call	_floppy_media_known
33383 982C           44                         inc	sp
33384 982D           44                         inc	sp
33385                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33386 982E           85C0                       test	ax,ax
33387 9830           75           39            jne 	.6C7
33388                       00009832            .6C8:
33389                                           ! 4821         if (floppy_media_sense(drive) == 0) {
33390                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33391 9832           8A46         FF            mov	al,-1[bp]
33392 9835           30E4                       xor	ah,ah
33393 9837           50                         push	ax
33394                                           ! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
33395 9838           E8         F372            call	_floppy_media_sense
33396 983B           44                         inc	sp
33397 983C           44                         inc	sp
33398                                           ! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
33399 983D           85C0                       test	ax,ax
33400 983F           75           2A            jne 	.6C9
33401                       00009841            .6CA:
33402                                           ! 4822           AX = ((AX & 0x00ff) | ((0x0C) << 8));
33403                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33404 9841           8A46         16            mov	al,$16[bp]
33405                                           ! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
33406 9844           30E4                       xor	ah,ah
33407 9846           0D                   0C00  or	ax,#$C00
33408                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33409 9849           8946         16            mov	$16[bp],ax
33410                                           !BCC_EOS
33411                                           ! 4823           set_diskette_ret_status(0x0C);
33412                                           ! Debug: list int = const $C (used reg = )
33413 984C           B8                   000C  mov	ax,*$C
33414 984F           50                         push	ax
33415                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33416 9850           E8         06AF            call	_set_diskette_ret_status
33417 9853           44                         inc	sp
33418 9854           44                         inc	sp
33419                                           !BCC_EOS
33420                                           ! 4824           AX = ((AX & 0xff00) | (0));
33421                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33422 9855           8B46         16            mov	ax,$16[bp]
33423 9858           30C0                       xor	al,al
33424                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33425 985A           0C                     00  or	al,*0
33426                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33427 985C           8946         16            mov	$16[bp],ax
33428                                           !BCC_EOS
33429                                           ! 4825           FLAGS |= 0x0001;
33430                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33431 985F           8B46         1C            mov	ax,$1C[bp]
33432 9862           0C                     01  or	al,*1
33433 9864           8946         1C            mov	$1C[bp],ax
33434                                           !BCC_EOS
33435                                           ! 4826           return;
33436 9867           89EC                       mov	sp,bp
33437 9869           5D                         pop	bp
33438 986A           C3                         ret
33439                                           !BCC_EOS
33440                                           ! 4827         }
33441                                           ! 4828       }
33442                       0000986B            .6C9:
33443                                           ! 4829       page = (ES >> 12);
33444                       0000986B            .6C7:
33445                                           ! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
33446 986B           8B46         06            mov	ax,6[bp]
33447 986E           88E0                       mov	al,ah
33448 9870           30E4                       xor	ah,ah
33449 9872           B1                     04  mov	cl,*4
33450 9874           D3E8                       shr	ax,cl
33451                                           ! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
33452 9876           8846         F3            mov	-$D[bp],al
33453                                           !BCC_EOS
33454                                           ! 4830       base_es = (ES << 4);
33455                                           ! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
33456 9879           8B46         06            mov	ax,6[bp]
33457 987C           B1                     04  mov	cl,*4
33458 987E           D3E0                       shl	ax,cl
33459                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
33460 9880           8946         F4            mov	-$C[bp],ax
33461                                           !BCC_EOS
33462                                           ! 4831       base_address = base_es + BX;
33463                                           ! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
33464 9883           8B46         F4            mov	ax,-$C[bp]
33465 9886           0346         10            add	ax,$10[bp]
33466                                           ! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
33467 9889           8946         F8            mov	-8[bp],ax
33468                                           !BCC_EOS
33469                                           ! 4832       if ( base_address < base_es ) {
33470                                           ! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
33471 988C           8B46         F8            mov	ax,-8[bp]
33472 988F           3B46         F4            cmp	ax,-$C[bp]
33473 9892           73           07            jae 	.6CB
33474                       00009894            .6CC:
33475                                           ! 4833         page++;
33476                                           ! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
33477 9894           8A46         F3            mov	al,-$D[bp]
33478 9897           40                         inc	ax
33479 9898           8846         F3            mov	-$D[bp],al
33480                                           !BCC_EOS
33481                                           ! 4834       }
33482                                           ! 4835       base_count = (num_sectors * 4) - 1;
33483                       0000989B            .6CB:
33484                                           ! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
33485 989B           8A46         FE            mov	al,-2[bp]
33486 989E           30E4                       xor	ah,ah
33487 98A0           D1E0                       shl	ax,*1
33488 98A2           D1E0                       shl	ax,*1
33489                                           ! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
33490                                           ! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
33491 98A4           48                         dec	ax
33492 98A5           8946         F6            mov	-$A[bp],ax
33493                                           !BCC_EOS
33494                                           ! 4836       last_addr = base_address + base_count;
33495                                           ! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
33496 98A8           8B46         F8            mov	ax,-8[bp]
33497 98AB           0346         F6            add	ax,-$A[bp]
33498                                           ! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
33499 98AE           8946         E2            mov	-$1E[bp],ax
33500                                           !BCC_EOS
33501                                           ! 4837       if (last_addr < base_address) {
33502                                           ! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
33503 98B1           8B46         E2            mov	ax,-$1E[bp]
33504 98B4           3B46         F8            cmp	ax,-8[bp]
33505 98B7           73           2A            jae 	.6CD
33506                       000098B9            .6CE:
33507                                           ! 4838         AX = ((AX & 0x00ff) | ((0x09) << 8));
33508                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33509 98B9           8A46         16            mov	al,$16[bp]
33510                                           ! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
33511 98BC           30E4                       xor	ah,ah
33512 98BE           0D                   0900  or	ax,#$900
33513                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33514 98C1           8946         16            mov	$16[bp],ax
33515                                           !BCC_EOS
33516                                           ! 4839         set_diskette_ret_status(0x09);
33517                                           ! Debug: list int = const 9 (used reg = )
33518 98C4           B8                   0009  mov	ax,*9
33519 98C7           50                         push	ax
33520                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33521 98C8           E8         0637            call	_set_diskette_ret_status
33522 98CB           44                         inc	sp
33523 98CC           44                         inc	sp
33524                                           !BCC_EOS
33525                                           ! 4840         AX = ((AX & 0xff00) | (0));
33526                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
33527 98CD           8B46         16            mov	ax,$16[bp]
33528 98D0           30C0                       xor	al,al
33529                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
33530 98D2           0C                     00  or	al,*0
33531                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33532 98D4           8946         16            mov	$16[bp],ax
33533                                           !BCC_EOS
33534                                           ! 4841         FLAGS |= 0x0001;
33535                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33536 98D7           8B46         1C            mov	ax,$1C[bp]
33537 98DA           0C                     01  or	al,*1
33538 98DC           8946         1C            mov	$1C[bp],ax
33539                                           !BCC_EOS
33540                                           ! 4842         return;
33541 98DF           89EC                       mov	sp,bp
33542 98E1           5D                         pop	bp
33543 98E2           C3                         ret
33544                                           !BCC_EOS
33545                                           ! 4843       }
33546                                           ! 4844       outb(0x000a, 0x06);
33547                       000098E3            .6CD:
33548                                           ! Debug: list int = const 6 (used reg = )
33549 98E3           B8                   0006  mov	ax,*6
33550 98E6           50                         push	ax
33551                                           ! Debug: list int = const $A (used reg = )
33552 98E7           B8                   000A  mov	ax,*$A
33553 98EA           50                         push	ax
33554                                           ! Debug: func () void = outb+0 (used reg = )
33555 98EB           E8         6C66            call	_outb
33556 98EE           83C4                   04  add	sp,*4
33557                                           !BCC_EOS
33558                                           ! 4845       outb(0x000c, 0x00);
33559                                           ! Debug: list int = const 0 (used reg = )
33560 98F1           31C0                       xor	ax,ax
33561 98F3           50                         push	ax
33562                                           ! Debug: list int = const $C (used reg = )
33563 98F4           B8                   000C  mov	ax,*$C
33564 98F7           50                         push	ax
33565                                           ! Debug: func () void = outb+0 (used reg = )
33566 98F8           E8         6C59            call	_outb
33567 98FB           83C4                   04  add	sp,*4
33568                                           !BCC_EOS
33569                                           ! 4846       outb(0x0004, base_address);
33570                                           ! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
33571 98FE           FF76         F8            push	-8[bp]
33572                                           ! Debug: list int = const 4 (used reg = )
33573 9901           B8                   0004  mov	ax,*4
33574 9904           50                         push	ax
33575                                           ! Debug: func () void = outb+0 (used reg = )
33576 9905           E8         6C4C            call	_outb
33577 9908           83C4                   04  add	sp,*4
33578                                           !BCC_EOS
33579                                           ! 4847       outb(0x0004, base_address>>8);
33580                                           ! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
33581 990B           8B46         F8            mov	ax,-8[bp]
33582 990E           88E0                       mov	al,ah
33583 9910           30E4                       xor	ah,ah
33584                                           ! Debug: list unsigned int = ax+0 (used reg = )
33585 9912           50                         push	ax
33586                                           ! Debug: list int = const 4 (used reg = )
33587 9913           B8                   0004  mov	ax,*4
33588 9916           50                         push	ax
33589                                           ! Debug: func () void = outb+0 (used reg = )
33590 9917           E8         6C3A            call	_outb
33591 991A           83C4                   04  add	sp,*4
33592                                           !BCC_EOS
33593                                           ! 4848       outb(0x000c, 0x00);
33594                                           ! Debug: list int = const 0 (used reg = )
33595 991D           31C0                       xor	ax,ax
33596 991F           50                         push	ax
33597                                           ! Debug: list int = const $C (used reg = )
33598 9920           B8                   000C  mov	ax,*$C
33599 9923           50                         push	ax
33600                                           ! Debug: func () void = outb+0 (used reg = )
33601 9924           E8         6C2D            call	_outb
33602 9927           83C4                   04  add	sp,*4
33603                                           !BCC_EOS
33604                                           ! 4849       outb(0x0005, base_count);
33605                                           ! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
33606 992A           FF76         F6            push	-$A[bp]
33607                                           ! Debug: list int = const 5 (used reg = )
33608 992D           B8                   0005  mov	ax,*5
33609 9930           50                         push	ax
33610                                           ! Debug: func () void = outb+0 (used reg = )
33611 9931           E8         6C20            call	_outb
33612 9934           83C4                   04  add	sp,*4
33613                                           !BCC_EOS
33614                                           ! 4850       outb(0x0005, base_count>>8);
33615                                           ! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
33616 9937           8B46         F6            mov	ax,-$A[bp]
33617 993A           88E0                       mov	al,ah
33618 993C           30E4                       xor	ah,ah
33619                                           ! Debug: list unsigned int = ax+0 (used reg = )
33620 993E           50                         push	ax
33621                                           ! Debug: list int = const 5 (used reg = )
33622 993F           B8                   0005  mov	ax,*5
33623 9942           50                         push	ax
33624                                           ! Debug: func () void = outb+0 (used reg = )
33625 9943           E8         6C0E            call	_outb
33626 9946           83C4                   04  add	sp,*4
33627                                           !BCC_EOS
33628                                           ! 4851       mode_register = 0x4a;
33629                                           ! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
33630 9949           B0                     4A  mov	al,*$4A
33631 994B           8846         F2            mov	-$E[bp],al
33632                                           !BCC_EOS
33633                                           ! 4852       outb(0x000b, mode_register);
33634                                           ! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
33635 994E           8A46         F2            mov	al,-$E[bp]
33636 9951           30E4                       xor	ah,ah
33637 9953           50                         push	ax
33638                                           ! Debug: list int = const $B (used reg = )
33639 9954           B8                   000B  mov	ax,*$B
33640 9957           50                         push	ax
33641                                           ! Debug: func () void = outb+0 (used reg = )
33642 9958           E8         6BF9            call	_outb
33643 995B           83C4                   04  add	sp,*4
33644                                           !BCC_EOS
33645                                           ! 4853       outb(0x0081, page);
33646                                           ! Debug: list unsigned char page = [S+$20-$F] (used reg = )
33647 995E           8A46         F3            mov	al,-$D[bp]
33648 9961           30E4                       xor	ah,ah
33649 9963           50                         push	ax
33650                                           ! Debug: list int = const $81 (used reg = )
33651 9964           B8                   0081  mov	ax,#$81
33652 9967           50                         push	ax
33653                                           ! Debug: func () void = outb+0 (used reg = )
33654 9968           E8         6BE9            call	_outb
33655 996B           83C4                   04  add	sp,*4
33656                                           !BCC_EOS
33657                                           ! 4854       outb(0x000a, 0x02);
33658                                           ! Debug: list int = const 2 (used reg = )
33659 996E           B8                   0002  mov	ax,*2
33660 9971           50                         push	ax
33661                                           ! Debug: list int = const $A (used reg = )
33662 9972           B8                   000A  mov	ax,*$A
33663 9975           50                         push	ax
33664                                           ! Debug: func () void = outb+0 (used reg = )
33665 9976           E8         6BDB            call	_outb
33666 9979           83C4                   04  add	sp,*4
33667                                           !BCC_EOS
33668                                           ! 4855       floppy_prepare_controller(drive);
33669                                           ! Debug: list unsigned char drive = [S+$20-3] (used reg = )
33670 997C           8A46         FF            mov	al,-1[bp]
33671 997F           30E4                       xor	ah,ah
33672 9981           50                         push	ax
33673                                           ! Debug: func () void = floppy_prepare_controller+0 (used reg = )
33674 9982           E8         F0C6            call	_floppy_prepare_controller
33675 9985           44                         inc	sp
33676 9986           44                         inc	sp
33677                                           !BCC_EOS
33678                                           ! 4856       outb(0x03f5, 0x4d);
33679                                           ! Debug: list int = const $4D (used reg = )
33680 9987           B8                   004D  mov	ax,*$4D
33681 998A           50                         push	ax
33682                                           ! Debug: list int = const $3F5 (used reg = )
33683 998B           B8                   03F5  mov	ax,#$3F5
33684 998E           50                         push	ax
33685                                           ! Debug: func () void = outb+0 (used reg = )
33686 998F           E8         6BC2            call	_outb
33687 9992           83C4                   04  add	sp,*4
33688                                           !BCC_EOS
33689                                           ! 4857       outb(0x03f5, (head << 2) | drive);
33690                                           ! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
33691 9995           8A46         FB            mov	al,-5[bp]
33692 9998           30E4                       xor	ah,ah
33693 999A           D1E0                       shl	ax,*1
33694 999C           D1E0                       shl	ax,*1
33695                                           ! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
33696 999E           0A46         FF            or	al,-1[bp]
33697                                           ! Debug: list unsigned int = ax+0 (used reg = )
33698 99A1           50                         push	ax
33699                                           ! Debug: list int = const $3F5 (used reg = )
33700 99A2           B8                   03F5  mov	ax,#$3F5
33701 99A5           50                         push	ax
33702                                           ! Debug: func () void = outb+0 (used reg = )
33703 99A6           E8         6BAB            call	_outb
33704 99A9           83C4                   04  add	sp,*4
33705                                           !BCC_EOS
33706                                           ! 4858       outb(0x03f5, 2);
33707                                           ! Debug: list int = const 2 (used reg = )
33708 99AC           B8                   0002  mov	ax,*2
33709 99AF           50                         push	ax
33710                                           ! Debug: list int = const $3F5 (used reg = )
33711 99B0           B8                   03F5  mov	ax,#$3F5
33712 99B3           50                         push	ax
33713                                           ! Debug: func () void = outb+0 (used reg = )
33714 99B4           E8         6B9D            call	_outb
33715 99B7           83C4                   04  add	sp,*4
33716                                           !BCC_EOS
33717                                           ! 4859       outb(0x03f5, num_sectors);
33718                                           ! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
33719 99BA           8A46         FE            mov	al,-2[bp]
33720 99BD           30E4                       xor	ah,ah
33721 99BF           50                         push	ax
33722                                           ! Debug: list int = const $3F5 (used reg = )
33723 99C0           B8                   03F5  mov	ax,#$3F5
33724 99C3           50                         push	ax
33725                                           ! Debug: func () void = outb+0 (used reg = )
33726 99C4           E8         6B8D            call	_outb
33727 99C7           83C4                   04  add	sp,*4
33728                                           !BCC_EOS
33729                                           ! 4860       outb(0x03f5, 0);
33730                                           ! Debug: list int = const 0 (used reg = )
33731 99CA           31C0                       xor	ax,ax
33732 99CC           50                         push	ax
33733                                           ! Debug: list int = const $3F5 (used reg = )
33734 99CD           B8                   03F5  mov	ax,#$3F5
33735 99D0           50                         push	ax
33736                                           ! Debug: func () void = outb+0 (used reg = )
33737 99D1           E8         6B80            call	_outb
33738 99D4           83C4                   04  add	sp,*4
33739                                           !BCC_EOS
33740                                           ! 4861       outb(0x03f5, 0xf6);
33741                                           ! Debug: list int = const $F6 (used reg = )
33742 99D7           B8                   00F6  mov	ax,#$F6
33743 99DA           50                         push	ax
33744                                           ! Debug: list int = const $3F5 (used reg = )
33745 99DB           B8                   03F5  mov	ax,#$3F5
33746 99DE           50                         push	ax
33747                                           ! Debug: func () void = outb+0 (used reg = )
33748 99DF           E8         6B72            call	_outb
33749 99E2           83C4                   04  add	sp,*4
33750                                           !BCC_EOS
33751                                           ! 4862 #asm
33752                                           !BCC_EOS
33753                                           !BCC_ASM
33754                       0000002A            _int13_diskette_function.BP	set	$2A
33755                       0000000C            .int13_diskette_function.BP	set	$C
33756                       00000038            _int13_diskette_function.CS	set	$38
33757                       0000001A            .int13_diskette_function.CS	set	$1A
33758                       00000032            _int13_diskette_function.CX	set	$32
33759                       00000014            .int13_diskette_function.CX	set	$14
33760                       00000016            _int13_diskette_function.base_address	set	$16
33761                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33762                       00000026            _int13_diskette_function.DI	set	$26
33763                       00000008            .int13_diskette_function.DI	set	8
33764                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33765                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33766                       00000014            _int13_diskette_function.base_count	set	$14
33767                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33768                       0000001A            _int13_diskette_function.sector	set	$1A
33769                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33770                       00000022            _int13_diskette_function.DS	set	$22
33771                       00000004            .int13_diskette_function.DS	set	4
33772                       00000019            _int13_diskette_function.head	set	$19
33773                       FFFFFFFB            .int13_diskette_function.head	set	-5
33774                       0000002C            _int13_diskette_function.ELDX	set	$2C
33775                       0000000E            .int13_diskette_function.ELDX	set	$E
33776                       0000000E            _int13_diskette_function.dor	set	$E
33777                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33778                       00000030            _int13_diskette_function.DX	set	$30
33779                       00000012            .int13_diskette_function.DX	set	$12
33780                       00000007            _int13_diskette_function.return_status	set	7
33781                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33782                       00000002            _int13_diskette_function.es	set	2
33783                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33784                       00000010            _int13_diskette_function.mode_register	set	$10
33785                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33786                       00000024            _int13_diskette_function.ES	set	$24
33787                       00000006            .int13_diskette_function.ES	set	6
33788                       00000012            _int13_diskette_function.base_es	set	$12
33789                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33790                       0000001B            _int13_diskette_function.track	set	$1B
33791                       FFFFFFFD            .int13_diskette_function.track	set	-3
33792                       00000028            _int13_diskette_function.SI	set	$28
33793                       0000000A            .int13_diskette_function.SI	set	$A
33794                       00000006            _int13_diskette_function.drive_type	set	6
33795                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33796                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33797                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33798                       00000036            _int13_diskette_function.IP	set	$36
33799                       00000018            .int13_diskette_function.IP	set	$18
33800                       00000018            _int13_diskette_function.status	set	$18
33801                       FFFFFFFA            .int13_diskette_function.status	set	-6
33802                       00000034            _int13_diskette_function.AX	set	$34
33803                       00000016            .int13_diskette_function.AX	set	$16
33804                       0000000F            _int13_diskette_function.val8	set	$F
33805                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33806                       00000000            _int13_diskette_function.last_addr	set	0
33807                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33808                       00000011            _int13_diskette_function.page	set	$11
33809                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33810                       00000004            _int13_diskette_function.ah	set	4
33811                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33812                       0000001D            _int13_diskette_function.drive	set	$1D
33813                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33814                       00000005            _int13_diskette_function.num_floppies	set	5
33815                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33816                       0000002E            _int13_diskette_function.BX	set	$2E
33817                       00000010            .int13_diskette_function.BX	set	$10
33818 99E5           FB                               sti
33819                                           ! 4864 endasm
33820                                           !BCC_ENDASM
33821                                           !BCC_EOS
33822                                           ! 4865       do {
33823                       000099E6            .6D1:
33824                                           ! 4866         val8 = read_byte(0x0040, 0x0040);
33825                                           ! Debug: list int = const $40 (used reg = )
33826 99E6           B8                   0040  mov	ax,*$40
33827 99E9           50                         push	ax
33828                                           ! Debug: list int = const $40 (used reg = )
33829 99EA           B8                   0040  mov	ax,*$40
33830 99ED           50                         push	ax
33831                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33832 99EE           E8         6C03            call	_read_byte
33833 99F1           83C4                   04  add	sp,*4
33834                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33835 99F4           8846         F1            mov	-$F[bp],al
33836                                           !BCC_EOS
33837                                           ! 4867         if (val8 == 0) {
33838                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33839 99F7           8A46         F1            mov	al,-$F[bp]
33840 99FA           84C0                       test	al,al
33841 99FC           75           23            jne 	.6D2
33842                       000099FE            .6D3:
33843                                           ! 4868           floppy_reset_controller();
33844                                           ! Debug: func () void = floppy_reset_controller+0 (used reg = )
33845 99FE           E8         EFFC            call	_floppy_reset_controller
33846                                           !BCC_EOS
33847                                           ! 4869           AX = ((AX & 0x00ff) | ((0x80) << 8));
33848                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
33849 9A01           8A46         16            mov	al,$16[bp]
33850                                           ! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
33851 9A04           30E4                       xor	ah,ah
33852 9A06           0D                   8000  or	ax,#-$8000
33853                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
33854 9A09           8946         16            mov	$16[bp],ax
33855                                           !BCC_EOS
33856                                           ! 4870           set_diskette_ret_status(0x80);
33857                                           ! Debug: list int = const $80 (used reg = )
33858 9A0C           B8                   0080  mov	ax,#$80
33859 9A0F           50                         push	ax
33860                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
33861 9A10           E8         04EF            call	_set_diskette_ret_status
33862 9A13           44                         inc	sp
33863 9A14           44                         inc	sp
33864                                           !BCC_EOS
33865                                           ! 4871           FLAGS |= 0x0001;
33866                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
33867 9A15           8B46         1C            mov	ax,$1C[bp]
33868 9A18           0C                     01  or	al,*1
33869 9A1A           8946         1C            mov	$1C[bp],ax
33870                                           !BCC_EOS
33871                                           ! 4872           return;
33872 9A1D           89EC                       mov	sp,bp
33873 9A1F           5D                         pop	bp
33874 9A20           C3                         ret
33875                                           !BCC_EOS
33876                                           ! 4873         }
33877                                           ! 4874         val8 = (read_byte(0x0040, 0x003e) & 0x80);
33878                       00009A21            .6D2:
33879                                           ! Debug: list int = const $3E (used reg = )
33880 9A21           B8                   003E  mov	ax,*$3E
33881 9A24           50                         push	ax
33882                                           ! Debug: list int = const $40 (used reg = )
33883 9A25           B8                   0040  mov	ax,*$40
33884 9A28           50                         push	ax
33885                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33886 9A29           E8         6BC8            call	_read_byte
33887 9A2C           83C4                   04  add	sp,*4
33888                                           ! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
33889 9A2F           24                     80  and	al,#$80
33890                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33891 9A31           8846         F1            mov	-$F[bp],al
33892                                           !BCC_EOS
33893                                           ! 4875       } while ( val8 == 0 );
33894                       00009A34            .6D0:
33895                                           ! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33896 9A34           8A46         F1            mov	al,-$F[bp]
33897 9A37           84C0                       test	al,al
33898 9A39           74           AB            je 	.6D1
33899                       00009A3B            .6D4:
33900                                           !BCC_EOS
33901                                           ! 4876       val8 = 0;
33902                       00009A3B            .6CF:
33903                                           ! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
33904 9A3B           30C0                       xor	al,al
33905 9A3D           8846         F1            mov	-$F[bp],al
33906                                           !BCC_EOS
33907                                           ! 4877 #asm
33908                                           !BCC_EOS
33909                                           !BCC_ASM
33910                       0000002A            _int13_diskette_function.BP	set	$2A
33911                       0000000C            .int13_diskette_function.BP	set	$C
33912                       00000038            _int13_diskette_function.CS	set	$38
33913                       0000001A            .int13_diskette_function.CS	set	$1A
33914                       00000032            _int13_diskette_function.CX	set	$32
33915                       00000014            .int13_diskette_function.CX	set	$14
33916                       00000016            _int13_diskette_function.base_address	set	$16
33917                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
33918                       00000026            _int13_diskette_function.DI	set	$26
33919                       00000008            .int13_diskette_function.DI	set	8
33920                       0000003A            _int13_diskette_function.FLAGS	set	$3A
33921                       0000001C            .int13_diskette_function.FLAGS	set	$1C
33922                       00000014            _int13_diskette_function.base_count	set	$14
33923                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
33924                       0000001A            _int13_diskette_function.sector	set	$1A
33925                       FFFFFFFC            .int13_diskette_function.sector	set	-4
33926                       00000022            _int13_diskette_function.DS	set	$22
33927                       00000004            .int13_diskette_function.DS	set	4
33928                       00000019            _int13_diskette_function.head	set	$19
33929                       FFFFFFFB            .int13_diskette_function.head	set	-5
33930                       0000002C            _int13_diskette_function.ELDX	set	$2C
33931                       0000000E            .int13_diskette_function.ELDX	set	$E
33932                       0000000E            _int13_diskette_function.dor	set	$E
33933                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
33934                       00000030            _int13_diskette_function.DX	set	$30
33935                       00000012            .int13_diskette_function.DX	set	$12
33936                       00000007            _int13_diskette_function.return_status	set	7
33937                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
33938                       00000002            _int13_diskette_function.es	set	2
33939                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
33940                       00000010            _int13_diskette_function.mode_register	set	$10
33941                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
33942                       00000024            _int13_diskette_function.ES	set	$24
33943                       00000006            .int13_diskette_function.ES	set	6
33944                       00000012            _int13_diskette_function.base_es	set	$12
33945                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
33946                       0000001B            _int13_diskette_function.track	set	$1B
33947                       FFFFFFFD            .int13_diskette_function.track	set	-3
33948                       00000028            _int13_diskette_function.SI	set	$28
33949                       0000000A            .int13_diskette_function.SI	set	$A
33950                       00000006            _int13_diskette_function.drive_type	set	6
33951                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
33952                       0000001C            _int13_diskette_function.num_sectors	set	$1C
33953                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
33954                       00000036            _int13_diskette_function.IP	set	$36
33955                       00000018            .int13_diskette_function.IP	set	$18
33956                       00000018            _int13_diskette_function.status	set	$18
33957                       FFFFFFFA            .int13_diskette_function.status	set	-6
33958                       00000034            _int13_diskette_function.AX	set	$34
33959                       00000016            .int13_diskette_function.AX	set	$16
33960                       0000000F            _int13_diskette_function.val8	set	$F
33961                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
33962                       00000000            _int13_diskette_function.last_addr	set	0
33963                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
33964                       00000011            _int13_diskette_function.page	set	$11
33965                       FFFFFFF3            .int13_diskette_function.page	set	-$D
33966                       00000004            _int13_diskette_function.ah	set	4
33967                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
33968                       0000001D            _int13_diskette_function.drive	set	$1D
33969                       FFFFFFFF            .int13_diskette_function.drive	set	-1
33970                       00000005            _int13_diskette_function.num_floppies	set	5
33971                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
33972                       0000002E            _int13_diskette_function.BX	set	$2E
33973                       00000010            .int13_diskette_function.BX	set	$10
33974 9A40           FA                               cli
33975                                           ! 4879 endasm
33976                                           !BCC_ENDASM
33977                                           !BCC_EOS
33978                                           ! 4880       val8 = read_byte(0x0040, 0x003e);
33979                                           ! Debug: list int = const $3E (used reg = )
33980 9A41           B8                   003E  mov	ax,*$3E
33981 9A44           50                         push	ax
33982                                           ! Debug: list int = const $40 (used reg = )
33983 9A45           B8                   0040  mov	ax,*$40
33984 9A48           50                         push	ax
33985                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
33986 9A49           E8         6BA8            call	_read_byte
33987 9A4C           83C4                   04  add	sp,*4
33988                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
33989 9A4F           8846         F1            mov	-$F[bp],al
33990                                           !BCC_EOS
33991                                           ! 4881       val8 &= 0x7f;
33992                                           ! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
33993 9A52           8A46         F1            mov	al,-$F[bp]
33994 9A55           24                     7F  and	al,*$7F
33995 9A57           8846         F1            mov	-$F[bp],al
33996                                           !BCC_EOS
33997                                           ! 4882       write_byte(0x0040, 0x003e, val8);
33998                                           ! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
33999 9A5A           8A46         F1            mov	al,-$F[bp]
34000 9A5D           30E4                       xor	ah,ah
34001 9A5F           50                         push	ax
34002                                           ! Debug: list int = const $3E (used reg = )
34003 9A60           B8                   003E  mov	ax,*$3E
34004 9A63           50                         push	ax
34005                                           ! Debug: list int = const $40 (used reg = )
34006 9A64           B8                   0040  mov	ax,*$40
34007 9A67           50                         push	ax
34008                                           ! Debug: func () void = write_byte+0 (used reg = )
34009 9A68           E8         6BAF            call	_write_byte
34010 9A6B           83C4                   06  add	sp,*6
34011                                           !BCC_EOS
34012                                           ! 4883       val8 = inb(0x3f4);
34013                                           ! Debug: list int = const $3F4 (used reg = )
34014 9A6E           B8                   03F4  mov	ax,#$3F4
34015 9A71           50                         push	ax
34016                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34017 9A72           E8         6AC9            call	_inb
34018 9A75           44                         inc	sp
34019 9A76           44                         inc	sp
34020                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
34021 9A77           8846         F1            mov	-$F[bp],al
34022                                           !BCC_EOS
34023                                           ! 4884       if ( (val8 & 0xc0) != 0xc0 )
34024                                           ! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
34025 9A7A           8A46         F1            mov	al,-$F[bp]
34026 9A7D           24                     C0  and	al,#$C0
34027                                           ! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
34028 9A7F           3C                     C0  cmp	al,#$C0
34029 9A81           74           0E            je  	.6D5
34030                       00009A83            .6D6:
34031                                           ! 4885         bi
34032                                           ! 4885 os_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
34033                                           ! Debug: list * char = .6D7+0 (used reg = )
34034 9A83           BB                   D091  mov	bx,#.6D7
34035 9A86           53                         push	bx
34036                                           ! Debug: list int = const 7 (used reg = )
34037 9A87           B8                   0007  mov	ax,*7
34038 9A8A           50                         push	ax
34039                                           ! Debug: func () void = bios_printf+0 (used reg = )
34040 9A8B           E8         6F8D            call	_bios_printf
34041 9A8E           83C4                   04  add	sp,*4
34042                                           !BCC_EOS
34043                                           ! 4886       return_status[0] = inb(0x3f5);
34044                       00009A91            .6D5:
34045                                           ! Debug: list int = const $3F5 (used reg = )
34046 9A91           B8                   03F5  mov	ax,#$3F5
34047 9A94           50                         push	ax
34048                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34049 9A95           E8         6AA6            call	_inb
34050 9A98           44                         inc	sp
34051 9A99           44                         inc	sp
34052                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
34053 9A9A           8846         E9            mov	-$17[bp],al
34054                                           !BCC_EOS
34055                                           ! 4887       return_status[1] = inb(0x3f5);
34056                                           ! Debug: list int = const $3F5 (used reg = )
34057 9A9D           B8                   03F5  mov	ax,#$3F5
34058 9AA0           50                         push	ax
34059                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34060 9AA1           E8         6A9A            call	_inb
34061 9AA4           44                         inc	sp
34062 9AA5           44                         inc	sp
34063                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
34064 9AA6           8846         EA            mov	-$16[bp],al
34065                                           !BCC_EOS
34066                                           ! 4888       return_status[2] = inb(0x3f5);
34067                                           ! Debug: list int = const $3F5 (used reg = )
34068 9AA9           B8                   03F5  mov	ax,#$3F5
34069 9AAC           50                         push	ax
34070                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34071 9AAD           E8         6A8E            call	_inb
34072 9AB0           44                         inc	sp
34073 9AB1           44                         inc	sp
34074                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
34075 9AB2           8846         EB            mov	-$15[bp],al
34076                                           !BCC_EOS
34077                                           ! 4889       return_status[3] = inb(0x3f5);
34078                                           ! Debug: list int = const $3F5 (used reg = )
34079 9AB5           B8                   03F5  mov	ax,#$3F5
34080 9AB8           50                         push	ax
34081                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34082 9AB9           E8         6A82            call	_inb
34083 9ABC           44                         inc	sp
34084 9ABD           44                         inc	sp
34085                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
34086 9ABE           8846         EC            mov	-$14[bp],al
34087                                           !BCC_EOS
34088                                           ! 4890       return_status[4] = inb(0x3f5);
34089                                           ! Debug: list int = const $3F5 (used reg = )
34090 9AC1           B8                   03F5  mov	ax,#$3F5
34091 9AC4           50                         push	ax
34092                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34093 9AC5           E8         6A76            call	_inb
34094 9AC8           44                         inc	sp
34095 9AC9           44                         inc	sp
34096                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
34097 9ACA           8846         ED            mov	-$13[bp],al
34098                                           !BCC_EOS
34099                                           ! 4891       return_status[5] = inb(0x3f5);
34100                                           ! Debug: list int = const $3F5 (used reg = )
34101 9ACD           B8                   03F5  mov	ax,#$3F5
34102 9AD0           50                         push	ax
34103                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34104 9AD1           E8         6A6A            call	_inb
34105 9AD4           44                         inc	sp
34106 9AD5           44                         inc	sp
34107                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
34108 9AD6           8846         EE            mov	-$12[bp],al
34109                                           !BCC_EOS
34110                                           ! 4892       return_status[6] = inb(0x3f5);
34111                                           ! Debug: list int = const $3F5 (used reg = )
34112 9AD9           B8                   03F5  mov	ax,#$3F5
34113 9ADC           50                         push	ax
34114                                           ! Debug: func () unsigned char = inb+0 (used reg = )
34115 9ADD           E8         6A5E            call	_inb
34116 9AE0           44                         inc	sp
34117 9AE1           44                         inc	sp
34118                                           ! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
34119 9AE2           8846         EF            mov	-$11[bp],al
34120                                           !BCC_EOS
34121                                           ! 4893       write_byte(0x0040, 0x0042, return_status[0]);
34122                                           ! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
34123 9AE5           8A46         E9            mov	al,-$17[bp]
34124 9AE8           30E4                       xor	ah,ah
34125 9AEA           50                         push	ax
34126                                           ! Debug: list int = const $42 (used reg = )
34127 9AEB           B8                   0042  mov	ax,*$42
34128 9AEE           50                         push	ax
34129                                           ! Debug: list int = const $40 (used reg = )
34130 9AEF           B8                   0040  mov	ax,*$40
34131 9AF2           50                         push	ax
34132                                           ! Debug: func () void = write_byte+0 (used reg = )
34133 9AF3           E8         6B24            call	_write_byte
34134 9AF6           83C4                   06  add	sp,*6
34135                                           !BCC_EOS
34136                                           ! 4894       write_byte(0x0040, 0x0043, return_status[1]);
34137                                           ! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
34138 9AF9           8A46         EA            mov	al,-$16[bp]
34139 9AFC           30E4                       xor	ah,ah
34140 9AFE           50                         push	ax
34141                                           ! Debug: list int = const $43 (used reg = )
34142 9AFF           B8                   0043  mov	ax,*$43
34143 9B02           50                         push	ax
34144                                           ! Debug: list int = const $40 (used reg = )
34145 9B03           B8                   0040  mov	ax,*$40
34146 9B06           50                         push	ax
34147                                           ! Debug: func () void = write_byte+0 (used reg = )
34148 9B07           E8         6B10            call	_write_byte
34149 9B0A           83C4                   06  add	sp,*6
34150                                           !BCC_EOS
34151                                           ! 4895       write_byte(0x0040, 0x0044, return_status[2]);
34152                                           ! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
34153 9B0D           8A46         EB            mov	al,-$15[bp]
34154 9B10           30E4                       xor	ah,ah
34155 9B12           50                         push	ax
34156                                           ! Debug: list int = const $44 (used reg = )
34157 9B13           B8                   0044  mov	ax,*$44
34158 9B16           50                         push	ax
34159                                           ! Debug: list int = const $40 (used reg = )
34160 9B17           B8                   0040  mov	ax,*$40
34161 9B1A           50                         push	ax
34162                                           ! Debug: func () void = write_byte+0 (used reg = )
34163 9B1B           E8         6AFC            call	_write_byte
34164 9B1E           83C4                   06  add	sp,*6
34165                                           !BCC_EOS
34166                                           ! 4896       write_byte(0x0040, 0x0045, return_status[3]);
34167                                           ! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
34168 9B21           8A46         EC            mov	al,-$14[bp]
34169 9B24           30E4                       xor	ah,ah
34170 9B26           50                         push	ax
34171                                           ! Debug: list int = const $45 (used reg = )
34172 9B27           B8                   0045  mov	ax,*$45
34173 9B2A           50                         push	ax
34174                                           ! Debug: list int = const $40 (used reg = )
34175 9B2B           B8                   0040  mov	ax,*$40
34176 9B2E           50                         push	ax
34177                                           ! Debug: func () void = write_byte+0 (used reg = )
34178 9B2F           E8         6AE8            call	_write_byte
34179 9B32           83C4                   06  add	sp,*6
34180                                           !BCC_EOS
34181                                           ! 4897       write_byte(0x0040, 0x0046, return_status[4]);
34182                                           ! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
34183 9B35           8A46         ED            mov	al,-$13[bp]
34184 9B38           30E4                       xor	ah,ah
34185 9B3A           50                         push	ax
34186                                           ! Debug: list int = const $46 (used reg = )
34187 9B3B           B8                   0046  mov	ax,*$46
34188 9B3E           50                         push	ax
34189                                           ! Debug: list int = const $40 (used reg = )
34190 9B3F           B8                   0040  mov	ax,*$40
34191 9B42           50                         push	ax
34192                                           ! Debug: func () void = write_byte+0 (used reg = )
34193 9B43           E8         6AD4            call	_write_byte
34194 9B46           83C4                   06  add	sp,*6
34195                                           !BCC_EOS
34196                                           ! 4898       write_byte(0x0040, 0x0047, return_status[5]);
34197                                           ! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
34198 9B49           8A46         EE            mov	al,-$12[bp]
34199 9B4C           30E4                       xor	ah,ah
34200 9B4E           50                         push	ax
34201                                           ! Debug: list int = const $47 (used reg = )
34202 9B4F           B8                   0047  mov	ax,*$47
34203 9B52           50                         push	ax
34204                                           ! Debug: list int = const $40 (used reg = )
34205 9B53           B8                   0040  mov	ax,*$40
34206 9B56           50                         push	ax
34207                                           ! Debug: func () void = write_byte+0 (used reg = )
34208 9B57           E8         6AC0            call	_write_byte
34209 9B5A           83C4                   06  add	sp,*6
34210                                           !BCC_EOS
34211                                           ! 4899       write_byte(0x0040, 0x0048, return_status[6]);
34212                                           ! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
34213 9B5D           8A46         EF            mov	al,-$11[bp]
34214 9B60           30E4                       xor	ah,ah
34215 9B62           50                         push	ax
34216                                           ! Debug: list int = const $48 (used reg = )
34217 9B63           B8                   0048  mov	ax,*$48
34218 9B66           50                         push	ax
34219                                           ! Debug: list int = const $40 (used reg = )
34220 9B67           B8                   0040  mov	ax,*$40
34221 9B6A           50                         push	ax
34222                                           ! Debug: func () void = write_byte+0 (used reg = )
34223 9B6B           E8         6AAC            call	_write_byte
34224 9B6E           83C4                   06  add	sp,*6
34225                                           !BCC_EOS
34226                                           ! 4900       if ( (return_status[0] & 0xc0) != 0 ) {
34227                                           ! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
34228 9B71           8A46         E9            mov	al,-$17[bp]
34229 9B74           24                     C0  and	al,#$C0
34230                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34231 9B76           84C0                       test	al,al
34232 9B78           74           2B            je  	.6D8
34233                       00009B7A            .6D9:
34234                                           ! 4901         if ( (return_status[1] & 0x02) != 0 ) {
34235                                           ! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
34236 9B7A           8A46         EA            mov	al,-$16[bp]
34237 9B7D           24                     02  and	al,*2
34238                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
34239 9B7F           84C0                       test	al,al
34240 9B81           74           14            je  	.6DA
34241                       00009B83            .6DB:
34242                                           ! 4902           AX = 0x0300;
34243                                           ! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
34244 9B83           B8                   0300  mov	ax,#$300
34245 9B86           8946         16            mov	$16[bp],ax
34246                                           !BCC_EOS
34247                                           ! 4903           FLAGS |= 0x0001;
34248                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34249 9B89           8B46         1C            mov	ax,$1C[bp]
34250 9B8C           0C                     01  or	al,*1
34251 9B8E           8946         1C            mov	$1C[bp],ax
34252                                           !BCC_EOS
34253                                           ! 4904           return;
34254 9B91           89EC                       mov	sp,bp
34255 9B93           5D                         pop	bp
34256 9B94           C3                         ret
34257                                           !BCC_EOS
34258                                           ! 4905         } else {
34259 9B95           EB           0E            jmp .6DC
34260                       00009B97            .6DA:
34261                                           ! 4906           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
34262                                           ! Debug: list * char = .6DD+0 (used reg = )
34263 9B97           BB                   D06B  mov	bx,#.6DD
34264 9B9A           53                         push	bx
34265                                           ! Debug: list int = const 7 (used reg = )
34266 9B9B           B8                   0007  mov	ax,*7
34267 9B9E           50                         push	ax
34268                                           ! Debug: func () void = bios_printf+0 (used reg = )
34269 9B9F           E8         6E79            call	_bios_printf
34270 9BA2           83C4                   04  add	sp,*4
34271                                           !BCC_EOS
34272                                           ! 4907         }
34273                                           ! 4908       }
34274                       00009BA5            .6DC:
34275                                           ! 4909       AX = ((AX & 0x00ff) | ((0) << 8));
34276                       00009BA5            .6D8:
34277                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34278 9BA5           8A46         16            mov	al,$16[bp]
34279                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34280 9BA8           0C                     00  or	al,*0
34281                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34282 9BAA           30E4                       xor	ah,ah
34283 9BAC           8946         16            mov	$16[bp],ax
34284                                           !BCC_EOS
34285                                           ! 4910       set_diskette_ret_status(0);
34286                                           ! Debug: list int = const 0 (used reg = )
34287 9BAF           31C0                       xor	ax,ax
34288 9BB1           50                         push	ax
34289                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34290 9BB2           E8         034D            call	_set_diskette_ret_status
34291 9BB5           44                         inc	sp
34292 9BB6           44                         inc	sp
34293                                           !BCC_EOS
34294                                           ! 4911       set_diskette_current_cyl(drive, 0);
34295                                           ! Debug: list int = const 0 (used reg = )
34296 9BB7           31C0                       xor	ax,ax
34297 9BB9           50                         push	ax
34298                                           ! Debug: list unsigned char drive = [S+$22-3] (used reg = )
34299 9BBA           8A46         FF            mov	al,-1[bp]
34300 9BBD           30E4                       xor	ah,ah
34301 9BBF           50                         push	ax
34302                                           ! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
34303 9BC0           E8         0357            call	_set_diskette_current_cyl
34304 9BC3           83C4                   04  add	sp,*4
34305                                           !BCC_EOS
34306                                           ! 4912       FLAGS &= 0xfffe;
34307                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34308 9BC6           8B46         1C            mov	ax,$1C[bp]
34309 9BC9           24                     FE  and	al,#$FE
34310 9BCB           8946         1C            mov	$1C[bp],ax
34311                                           !BCC_EOS
34312                                           ! 4913       return;
34313 9BCE           89EC                       mov	sp,bp
34314 9BD0           5D                         pop	bp
34315 9BD1           C3                         ret
34316                                           !BCC_EOS
34317                                           ! 4914     case 0x08:
34318                                           ! 4915 ;
34319                       00009BD2            .6DE:
34320                                           !BCC_EOS
34321                                           ! 4916       drive = ( ELDX & 0x00ff );
34322                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34323 9BD2           8A46         0E            mov	al,$E[bp]
34324                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34325 9BD5           8846         FF            mov	-1[bp],al
34326                                           !BCC_EOS
34327                                           ! 4917       if (drive > 1) {
34328                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34329 9BD8           8A46         FF            mov	al,-1[bp]
34330 9BDB           3C                     01  cmp	al,*1
34331 9BDD           76           35            jbe 	.6DF
34332                       00009BDF            .6E0:
34333                                           ! 4918         AX = 0;
34334                                           ! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
34335 9BDF           31C0                       xor	ax,ax
34336 9BE1           8946         16            mov	$16[bp],ax
34337                                           !BCC_EOS
34338                                           ! 4919         BX = 0;
34339                                           ! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
34340 9BE4           31C0                       xor	ax,ax
34341 9BE6           8946         10            mov	$10[bp],ax
34342                                           !BCC_EOS
34343                                           ! 4920         CX = 0;
34344                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
34345 9BE9           31C0                       xor	ax,ax
34346 9BEB           8946         14            mov	$14[bp],ax
34347                                           !BCC_EOS
34348                                           ! 4921         DX = 0;
34349                                           ! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
34350 9BEE           31C0                       xor	ax,ax
34351 9BF0           8946         12            mov	$12[bp],ax
34352                                           !BCC_EOS
34353                                           ! 4922         ES = 0;
34354                                           ! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
34355 9BF3           31C0                       xor	ax,ax
34356 9BF5           8946         06            mov	6[bp],ax
34357                                           !BCC_EOS
34358                                           ! 4923         DI = 0;
34359                                           ! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
34360 9BF8           31C0                       xor	ax,ax
34361 9BFA           8946         08            mov	8[bp],ax
34362                                           !BCC_EOS
34363                                           ! 4924         DX = ((DX & 0xff00) | (num_floppies));
34364                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
34365 9BFD           8B46         12            mov	ax,$12[bp]
34366 9C00           30C0                       xor	al,al
34367                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
34368 9C02           0A46         E7            or	al,-$19[bp]
34369                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34370 9C05           8946         12            mov	$12[bp],ax
34371                                           !BCC_EOS
34372                                           ! 4925         FLAGS |= 0x0001;
34373                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34374 9C08           8B46         1C            mov	ax,$1C[bp]
34375 9C0B           0C                     01  or	al,*1
34376 9C0D           8946         1C            mov	$1C[bp],ax
34377                                           !BCC_EOS
34378                                           ! 4926         return;
34379 9C10           89EC                       mov	sp,bp
34380 9C12           5D                         pop	bp
34381 9C13           C3                         ret
34382                                           !BCC_EOS
34383                                           ! 4927         }
34384                                           ! 4928       drive_type = inb_cmos(0x10);
34385                       00009C14            .6DF:
34386                                           ! Debug: list int = const $10 (used reg = )
34387 9C14           B8                   0010  mov	ax,*$10
34388 9C17           50                         push	ax
34389                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34390 9C18           E8         6968            call	_inb_cmos
34391 9C1B           44                         inc	sp
34392 9C1C           44                         inc	sp
34393                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34394 9C1D           8846         E8            mov	-$18[bp],al
34395                                           !BCC_EOS
34396                                           ! 4929       num_floppies = 0;
34397                                           ! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
34398 9C20           30C0                       xor	al,al
34399 9C22           8846         E7            mov	-$19[bp],al
34400                                           !BCC_EOS
34401                                           ! 4930       if (drive_type & 0xf0)
34402                                           ! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34403 9C25           8A46         E8            mov	al,-$18[bp]
34404 9C28           24                     F0  and	al,#$F0
34405 9C2A           84C0                       test	al,al
34406 9C2C           74           07            je  	.6E1
34407                       00009C2E            .6E2:
34408                                           ! 4931         num_floppies++;
34409                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
34410 9C2E           8A46         E7            mov	al,-$19[bp]
34411 9C31           40                         inc	ax
34412 9C32           8846         E7            mov	-$19[bp],al
34413                                           !BCC_EOS
34414                                           ! 4932       if (drive_type & 0x0f)
34415                       00009C35            .6E1:
34416                                           ! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34417 9C35           8A46         E8            mov	al,-$18[bp]
34418 9C38           24                     0F  and	al,*$F
34419 9C3A           84C0                       test	al,al
34420 9C3C           74           07            je  	.6E3
34421                       00009C3E            .6E4:
34422                                           ! 4933         num_floppies++;
34423                                           ! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
34424 9C3E           8A46         E7            mov	al,-$19[bp]
34425 9C41           40                         inc	ax
34426 9C42           8846         E7            mov	-$19[bp],al
34427                                           !BCC_EOS
34428                                           ! 4934       if (drive == 0)
34429                       00009C45            .6E3:
34430                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
34431 9C45           8A46         FF            mov	al,-1[bp]
34432 9C48           84C0                       test	al,al
34433 9C4A         0F85         000E            bne 	.6E5
34434                       00009C4E            .6E6:
34435                                           ! 4935         drive_type >>= 4;
34436                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34437 9C4E           8A46         E8            mov	al,-$18[bp]
34438 9C51           30E4                       xor	ah,ah
34439 9C53           B1                     04  mov	cl,*4
34440 9C55           D3E8                       shr	ax,cl
34441 9C57           8846         E8            mov	-$18[bp],al
34442                                           !BCC_EOS
34443                                           ! 4936       else
34444                                           ! 4937         drive_type &= 0x0f;
34445 9C5A           EB           08            jmp .6E7
34446                       00009C5C            .6E5:
34447                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34448 9C5C           8A46         E8            mov	al,-$18[bp]
34449 9C5F           24                     0F  and	al,*$F
34450 9C61           8846         E8            mov	-$18[bp],al
34451                                           !BCC_EOS
34452                                           ! 4938       BX = ((BX & 0x00ff) | ((0) << 8));
34453                       00009C64            .6E7:
34454                                           ! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
34455 9C64           8A46         10            mov	al,$10[bp]
34456                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34457 9C67           0C                     00  or	al,*0
34458                                           ! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
34459 9C69           30E4                       xor	ah,ah
34460 9C6B           8946         10            mov	$10[bp],ax
34461                                           !BCC_EOS
34462                                           ! 4939       BX = ((BX & 0xff00) | (drive_type));
34463                                           ! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
34464 9C6E           8B46         10            mov	ax,$10[bp]
34465 9C71           30C0                       xor	al,al
34466                                           ! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
34467 9C73           0A46         E8            or	al,-$18[bp]
34468                                           ! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
34469 9C76           8946         10            mov	$10[bp],ax
34470                                           !BCC_EOS
34471                                           ! 4940       AX = ((AX & 0x00ff) | ((0) << 8));
34472                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34473 9C79           8A46         16            mov	al,$16[bp]
34474                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34475 9C7C           0C                     00  or	al,*0
34476                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34477 9C7E           30E4                       xor	ah,ah
34478 9C80           8946         16            mov	$16[bp],ax
34479                                           !BCC_EOS
34480                                           ! 4941       AX = ((AX & 0xff00) | (0));
34481                                           ! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
34482 9C83           8B46         16            mov	ax,$16[bp]
34483 9C86           30C0                       xor	al,al
34484                                           ! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
34485 9C88           0C                     00  or	al,*0
34486                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34487 9C8A           8946         16            mov	$16[bp],ax
34488                                           !BCC_EOS
34489                                           ! 4942       DX = ((DX & 0xff00) | (num_floppies));
34490                                           ! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
34491 9C8D           8B46         12            mov	ax,$12[bp]
34492 9C90           30C0                       xor	al,al
34493                                           ! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
34494 9C92           0A46         E7            or	al,-$19[bp]
34495                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34496 9C95           8946         12            mov	$12[bp],ax
34497                                           !BCC_EOS
34498                                           ! 4943       switch (drive_type) {
34499 9C98           8A46         E8            mov	al,-$18[bp]
34500 9C9B           E9         00BC            br 	.6EA
34501                                           ! 4944         case 0:
34502                                           ! 4945           CX = 0;
34503                       00009C9E            .6EB:
34504                                           ! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
34505 9C9E           31C0                       xor	ax,ax
34506 9CA0           8946         14            mov	$14[bp],ax
34507                                           !BCC_EOS
34508                                           ! 4946           DX = ((DX & 0x00ff) | ((0) << 8));
34509                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34510 9CA3           8A46         12            mov	al,$12[bp]
34511                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34512 9CA6           0C                     00  or	al,*0
34513                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34514 9CA8           30E4                       xor	ah,ah
34515 9CAA           8946         12            mov	$12[bp],ax
34516                                           !BCC_EOS
34517                                           ! 4947           break;
34518 9CAD           E9         00D1            br 	.6E8
34519                                           !BCC_EOS
34520                                           ! 4948         case 1:
34521                                           ! 4949           CX = 0x2709;
34522                       00009CB0            .6EC:
34523                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
34524 9CB0           B8                   2709  mov	ax,#$2709
34525 9CB3           8946         14            mov	$14[bp],ax
34526                                           !BCC_EOS
34527                                           ! 4950           DX = ((DX & 0x00ff) | ((1) << 8));
34528                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34529 9CB6           8A46         12            mov	al,$12[bp]
34530                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34531 9CB9           30E4                       xor	ah,ah
34532 9CBB           0D                   0100  or	ax,#$100
34533                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34534 9CBE           8946         12            mov	$12[bp],ax
34535                                           !BCC_EOS
34536                                           ! 4951      
34537                                           ! 4951      break;
34538 9CC1           E9         00BD            br 	.6E8
34539                                           !BCC_EOS
34540                                           ! 4952         case 2:
34541                                           ! 4953           CX = 0x4f0f;
34542                       00009CC4            .6ED:
34543                                           ! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
34544 9CC4           B8                   4F0F  mov	ax,#$4F0F
34545 9CC7           8946         14            mov	$14[bp],ax
34546                                           !BCC_EOS
34547                                           ! 4954           DX = ((DX & 0x00ff) | ((1) << 8));
34548                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34549 9CCA           8A46         12            mov	al,$12[bp]
34550                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34551 9CCD           30E4                       xor	ah,ah
34552 9CCF           0D                   0100  or	ax,#$100
34553                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34554 9CD2           8946         12            mov	$12[bp],ax
34555                                           !BCC_EOS
34556                                           ! 4955           break;
34557 9CD5           E9         00A9            br 	.6E8
34558                                           !BCC_EOS
34559                                           ! 4956         case 3:
34560                                           ! 4957           CX = 0x4f09;
34561                       00009CD8            .6EE:
34562                                           ! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
34563 9CD8           B8                   4F09  mov	ax,#$4F09
34564 9CDB           8946         14            mov	$14[bp],ax
34565                                           !BCC_EOS
34566                                           ! 4958           DX = ((DX & 0x00ff) | ((1) << 8));
34567                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34568 9CDE           8A46         12            mov	al,$12[bp]
34569                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34570 9CE1           30E4                       xor	ah,ah
34571 9CE3           0D                   0100  or	ax,#$100
34572                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34573 9CE6           8946         12            mov	$12[bp],ax
34574                                           !BCC_EOS
34575                                           ! 4959           break;
34576 9CE9           E9         0095            br 	.6E8
34577                                           !BCC_EOS
34578                                           ! 4960         case 4:
34579                                           ! 4961           CX = 0x4f12;
34580                       00009CEC            .6EF:
34581                                           ! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
34582 9CEC           B8                   4F12  mov	ax,#$4F12
34583 9CEF           8946         14            mov	$14[bp],ax
34584                                           !BCC_EOS
34585                                           ! 4962           DX = ((DX & 0x00ff) | ((1) << 8));
34586                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34587 9CF2           8A46         12            mov	al,$12[bp]
34588                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34589 9CF5           30E4                       xor	ah,ah
34590 9CF7           0D                   0100  or	ax,#$100
34591                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34592 9CFA           8946         12            mov	$12[bp],ax
34593                                           !BCC_EOS
34594                                           ! 4963           break;
34595 9CFD           E9         0081            br 	.6E8
34596                                           !BCC_EOS
34597                                           ! 4964         case 5:
34598                                           ! 4965           CX = 0x4f24;
34599                       00009D00            .6F0:
34600                                           ! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
34601 9D00           B8                   4F24  mov	ax,#$4F24
34602 9D03           8946         14            mov	$14[bp],ax
34603                                           !BCC_EOS
34604                                           ! 4966           DX = ((DX & 0x00ff) | ((1) << 8));
34605                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34606 9D06           8A46         12            mov	al,$12[bp]
34607                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34608 9D09           30E4                       xor	ah,ah
34609 9D0B           0D                   0100  or	ax,#$100
34610                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34611 9D0E           8946         12            mov	$12[bp],ax
34612                                           !BCC_EOS
34613                                           ! 4967           break;
34614 9D11           EB           6E            jmp .6E8
34615                                           !BCC_EOS
34616                                           ! 4968         case 6:
34617                                           ! 4969           CX = 0x2708;
34618                       00009D13            .6F1:
34619                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
34620 9D13           B8                   2708  mov	ax,#$2708
34621 9D16           8946         14            mov	$14[bp],ax
34622                                           !BCC_EOS
34623                                           ! 4970           DX = ((DX & 0x00ff) | ((0) << 8));
34624                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34625 9D19           8A46         12            mov	al,$12[bp]
34626                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34627 9D1C           0C                     00  or	al,*0
34628                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34629 9D1E           30E4                       xor	ah,ah
34630 9D20           8946         12            mov	$12[bp],ax
34631                                           !BCC_EOS
34632                                           ! 4971           break;
34633 9D23           EB           5C            jmp .6E8
34634                                           !BCC_EOS
34635                                           ! 4972         case 7:
34636                                           ! 4973           CX = 0x2709;
34637                       00009D25            .6F2:
34638                                           ! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
34639 9D25           B8                   2709  mov	ax,#$2709
34640 9D28           8946         14            mov	$14[bp],ax
34641                                           !BCC_EOS
34642                                           ! 4974           DX = ((DX & 0x00ff) | ((0) << 8));
34643                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34644 9D2B           8A46         12            mov	al,$12[bp]
34645                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34646 9D2E           0C                     00  or	al,*0
34647                                           ! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
34648 9D30           30E4                       xor	ah,ah
34649 9D32           8946         12            mov	$12[bp],ax
34650                                           !BCC_EOS
34651                                           ! 4975           break;
34652 9D35           EB           4A            jmp .6E8
34653                                           !BCC_EOS
34654                                           ! 4976         case 8:
34655                                           ! 4977           CX = 0x2708;
34656                       00009D37            .6F3:
34657                                           ! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
34658 9D37           B8                   2708  mov	ax,#$2708
34659 9D3A           8946         14            mov	$14[bp],ax
34660                                           !BCC_EOS
34661                                           ! 4978           DX = ((DX & 0x00ff) | ((1) << 8));
34662                                           ! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
34663 9D3D           8A46         12            mov	al,$12[bp]
34664                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34665 9D40           30E4                       xor	ah,ah
34666 9D42           0D                   0100  or	ax,#$100
34667                                           ! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
34668 9D45           8946         12            mov	$12[bp],ax
34669                                           !BCC_EOS
34670                                           ! 4979           break;
34671 9D48           EB           37            jmp .6E8
34672                                           !BCC_EOS
34673                                           ! 4980         default:
34674                                           ! 4981           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
34675                       00009D4A            .6F4:
34676                                           ! Debug: list * char = .6F5+0 (used reg = )
34677 9D4A           BB                   D04B  mov	bx,#.6F5
34678 9D4D           53                         push	bx
34679                                           ! Debug: list int = const 7 (used reg = )
34680 9D4E           B8                   0007  mov	ax,*7
34681 9D51           50                         push	ax
34682                                           ! Debug: func () void = bios_printf+0 (used reg = )
34683 9D52           E8         6CC6            call	_bios_printf
34684 9D55           83C4                   04  add	sp,*4
34685                                           !BCC_EOS
34686                                           ! 4982         }
34687                                           ! 4983 #asm
34688 9D58           EB           27            jmp .6E8
34689                       00009D5A            .6EA:
34690 9D5A           2C                     00  sub	al,*0
34691 9D5C           72           EC            jb 	.6F4
34692 9D5E           3C                     08  cmp	al,*8
34693 9D60           77           1D            ja  	.6F6
34694 9D62           30E4                       xor	ah,ah
34695 9D64           D1E0                       shl	ax,*1
34696 9D66           89C3                       mov	bx,ax
34697 9D68           2E                         seg	cs
34698 9D69           FFA7       9D6D            br	.6F7[bx]
34699                       00009D6D            .6F7:
34700 9D6D                      9C9E            .word	.6EB
34701 9D6F                      9CB0            .word	.6EC
34702 9D71                      9CC4            .word	.6ED
34703 9D73                      9CD8            .word	.6EE
34704 9D75                      9CEC            .word	.6EF
34705 9D77                      9D00            .word	.6F0
34706 9D79                      9D13            .word	.6F1
34707 9D7B                      9D25            .word	.6F2
34708 9D7D                      9D37            .word	.6F3
34709                       00009D7F            .6F6:
34710 9D7F           EB           C9            jmp	.6F4
34711                       00009D81            .6E8:
34712                                           !BCC_EOS
34713                                           !BCC_ASM
34714                       0000002A            _int13_diskette_function.BP	set	$2A
34715                       0000000C            .int13_diskette_function.BP	set	$C
34716                       00000038            _int13_diskette_function.CS	set	$38
34717                       0000001A            .int13_diskette_function.CS	set	$1A
34718                       00000032            _int13_diskette_function.CX	set	$32
34719                       00000014            .int13_diskette_function.CX	set	$14
34720                       00000016            _int13_diskette_function.base_address	set	$16
34721                       FFFFFFF8            .int13_diskette_function.base_address	set	-8
34722                       00000026            _int13_diskette_function.DI	set	$26
34723                       00000008            .int13_diskette_function.DI	set	8
34724                       0000003A            _int13_diskette_function.FLAGS	set	$3A
34725                       0000001C            .int13_diskette_function.FLAGS	set	$1C
34726                       00000014            _int13_diskette_function.base_count	set	$14
34727                       FFFFFFF6            .int13_diskette_function.base_count	set	-$A
34728                       0000001A            _int13_diskette_function.sector	set	$1A
34729                       FFFFFFFC            .int13_diskette_function.sector	set	-4
34730                       00000022            _int13_diskette_function.DS	set	$22
34731                       00000004            .int13_diskette_function.DS	set	4
34732                       00000019            _int13_diskette_function.head	set	$19
34733                       FFFFFFFB            .int13_diskette_function.head	set	-5
34734                       0000002C            _int13_diskette_function.ELDX	set	$2C
34735                       0000000E            .int13_diskette_function.ELDX	set	$E
34736                       0000000E            _int13_diskette_function.dor	set	$E
34737                       FFFFFFF0            .int13_diskette_function.dor	set	-$10
34738                       00000030            _int13_diskette_function.DX	set	$30
34739                       00000012            .int13_diskette_function.DX	set	$12
34740                       00000007            _int13_diskette_function.return_status	set	7
34741                       FFFFFFE9            .int13_diskette_function.return_status	set	-$17
34742                       00000002            _int13_diskette_function.es	set	2
34743                       FFFFFFE4            .int13_diskette_function.es	set	-$1C
34744                       00000010            _int13_diskette_function.mode_register	set	$10
34745                       FFFFFFF2            .int13_diskette_function.mode_register	set	-$E
34746                       00000024            _int13_diskette_function.ES	set	$24
34747                       00000006            .int13_diskette_function.ES	set	6
34748                       00000012            _int13_diskette_function.base_es	set	$12
34749                       FFFFFFF4            .int13_diskette_function.base_es	set	-$C
34750                       0000001B            _int13_diskette_function.track	set	$1B
34751                       FFFFFFFD            .int13_diskette_function.track	set	-3
34752                       00000028            _int13_diskette_function.SI	set	$28
34753                       0000000A            .int13_diskette_function.SI	set	$A
34754                       00000006            _int13_diskette_function.drive_type	set	6
34755                       FFFFFFE8            .int13_diskette_function.drive_type	set	-$18
34756                       0000001C            _int13_diskette_function.num_sectors	set	$1C
34757                       FFFFFFFE            .int13_diskette_function.num_sectors	set	-2
34758                       00000036            _int13_diskette_function.IP	set	$36
34759                       00000018            .int13_diskette_function.IP	set	$18
34760                       00000018            _int13_diskette_function.status	set	$18
34761                       FFFFFFFA            .int13_diskette_function.status	set	-6
34762                       00000034            _int13_diskette_function.AX	set	$34
34763                       00000016            .int13_diskette_function.AX	set	$16
34764                       0000000F            _int13_diskette_function.val8	set	$F
34765                       FFFFFFF1            .int13_diskette_function.val8	set	-$F
34766                       00000000            _int13_diskette_function.last_addr	set	0
34767                       FFFFFFE2            .int13_diskette_function.last_addr	set	-$1E
34768                       00000011            _int13_diskette_function.page	set	$11
34769                       FFFFFFF3            .int13_diskette_function.page	set	-$D
34770                       00000004            _int13_diskette_function.ah	set	4
34771                       FFFFFFE6            .int13_diskette_function.ah	set	-$1A
34772                       0000001D            _int13_diskette_function.drive	set	$1D
34773                       FFFFFFFF            .int13_diskette_function.drive	set	-1
34774                       00000005            _int13_diskette_function.num_floppies	set	5
34775                       FFFFFFE7            .int13_diskette_function.num_floppies	set	-$19
34776                       0000002E            _int13_diskette_function.BX	set	$2E
34777                       00000010            .int13_diskette_function.BX	set	$10
34778 9D81           55                               push bp
34779 9D82           89E5                             mov bp, sp
34780 9D84           B8                   EFDE        mov ax, #diskette_param_table2
34781 9D87           8946         28                  mov _int13_diskette_function.DI+2[bp], ax
34782 9D8A           8C4E         26                  mov _int13_diskette_function.ES+2[bp], cs
34783 9D8D           5D                               pop bp
34784                                           ! 4990 endasm
34785                                           !BCC_ENDASM
34786                                           !BCC_EOS
34787                                           ! 4991       FLAGS &= 0xfffe;
34788                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34789 9D8E           8B46         1C            mov	ax,$1C[bp]
34790 9D91           24                     FE  and	al,#$FE
34791 9D93           8946         1C            mov	$1C[bp],ax
34792                                           !BCC_EOS
34793                                           ! 4992       return;
34794 9D96           89EC                       mov	sp,bp
34795 9D98           5D                         pop	bp
34796 9D99           C3                         ret
34797                                           !BCC_EOS
34798                                           ! 4993     case 0x15:
34799                                           ! 4994 ;
34800                       00009D9A            .6F8:
34801                                           !BCC_EOS
34802                                           ! 4995       drive = ( ELDX & 0x00ff );
34803                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34804 9D9A           8A46         0E            mov	al,$E[bp]
34805                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34806 9D9D           8846         FF            mov	-1[bp],al
34807                                           !BCC_EOS
34808                                           ! 4996       if (drive > 1) {
34809                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34810 9DA0           8A46         FF            mov	al,-1[bp]
34811 9DA3           3C                     01  cmp	al,*1
34812 9DA5           76           16            jbe 	.6F9
34813                       00009DA7            .6FA:
34814                                           ! 4997         AX = ((AX & 0x00ff) | ((0) << 8));
34815                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34816 9DA7           8A46         16            mov	al,$16[bp]
34817                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34818 9DAA           0C                     00  or	al,*0
34819                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34820 9DAC           30E4                       xor	ah,ah
34821 9DAE           8946         16            mov	$16[bp],ax
34822                                           !BCC_EOS
34823                                           ! 4998         FLAGS |= 0x0001;
34824                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34825 9DB1           8B46         1C            mov	ax,$1C[bp]
34826 9DB4           0C                     01  or	al,*1
34827 9DB6           8946         1C            mov	$1C[bp],ax
34828                                           !BCC_EOS
34829                                           ! 4999         return;
34830 9DB9           89EC                       mov	sp,bp
34831 9DBB           5D                         pop	bp
34832 9DBC           C3                         ret
34833                                           !BCC_EOS
34834                                           ! 5000         }
34835                                           ! 5001       drive_type = inb_cmos(0x10);
34836                       00009DBD            .6F9:
34837                                           ! Debug: list int = const $10 (used reg = )
34838 9DBD           B8                   0010  mov	ax,*$10
34839 9DC0           50                         push	ax
34840                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
34841 9DC1           E8         67BF            call	_inb_cmos
34842 9DC4           44                         inc	sp
34843 9DC5           44                         inc	sp
34844                                           ! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34845 9DC6           8846         E8            mov	-$18[bp],al
34846                                           !BCC_EOS
34847                                           ! 5002       if (drive == 0)
34848                                           ! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
34849 9DC9           8A46         FF            mov	al,-1[bp]
34850 9DCC           84C0                       test	al,al
34851 9DCE           75           0E            jne 	.6FB
34852                       00009DD0            .6FC:
34853                                           ! 5003         drive_type >>= 4;
34854                                           ! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34855 9DD0           8A46         E8            mov	al,-$18[bp]
34856 9DD3           30E4                       xor	ah,ah
34857 9DD5           B1                     04  mov	cl,*4
34858 9DD7           D3E8                       shr	ax,cl
34859 9DD9           8846         E8            mov	-$18[bp],al
34860                                           !BCC_EOS
34861                                           ! 5004       else
34862                                           ! 5005         drive_type &= 0x0f;
34863 9DDC           EB           08            jmp .6FD
34864                       00009DDE            .6FB:
34865                                           ! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
34866 9DDE           8A46         E8            mov	al,-$18[bp]
34867 9DE1           24                     0F  and	al,*$F
34868 9DE3           8846         E8            mov	-$18[bp],al
34869                                           !BCC_EOS
34870                                           ! 5006       FLAGS &= 0xfffe;
34871                       00009DE6            .6FD:
34872                                           ! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34873 9DE6           8B46         1C            mov	ax,$1C[bp]
34874 9DE9           24                     FE  and	al,#$FE
34875 9DEB           8946         1C            mov	$1C[bp],ax
34876                                           !BCC_EOS
34877                                           ! 5007       if (drive_type==0) {
34878                                           ! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
34879 9DEE           8A46         E8            mov	al,-$18[bp]
34880 9DF1           84C0                       test	al,al
34881 9DF3           75           0C            jne 	.6FE
34882                       00009DF5            .6FF:
34883                                           ! 5008         AX = ((AX & 0x00ff) | ((0) << 8));
34884                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34885 9DF5           8A46         16            mov	al,$16[bp]
34886                                           ! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
34887 9DF8           0C                     00  or	al,*0
34888                                           ! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
34889 9DFA           30E4                       xor	ah,ah
34890 9DFC           8946         16            mov	$16[bp],ax
34891                                           !BCC_EOS
34892                                           ! 5009         }
34893                                           ! 5010       else {
34894 9DFF           EB           0B            jmp .700
34895                       00009E01            .6FE:
34896                                           ! 5011         AX = ((AX & 0x00ff) | ((1) << 8));
34897                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34898 9E01           8A46         16            mov	al,$16[bp]
34899                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34900 9E04           30E4                       xor	ah,ah
34901 9E06           0D                   0100  or	ax,#$100
34902                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34903 9E09           8946         16            mov	$16[bp],ax
34904                                           !BCC_EOS
34905                                           ! 5012         }
34906                                           ! 5013       return;
34907                       00009E0C            .700:
34908 9E0C           89EC                       mov	sp,bp
34909 9E0E           5D                         pop	bp
34910 9E0F           C3                         ret
34911                                           !BCC_EOS
34912                                           ! 5014     case 0x16:
34913                                           ! 5015 ;
34914                       00009E10            .701:
34915                                           !BCC_EOS
34916                                           ! 5016       drive = ( ELDX & 0x00ff );
34917                                           ! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
34918 9E10           8A46         0E            mov	al,$E[bp]
34919                                           ! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
34920 9E13           8846         FF            mov	-1[bp],al
34921                                           !BCC_EOS
34922                                           ! 5017       if (drive > 1) {
34923                                           ! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
34924 9E16           8A46         FF            mov	al,-1[bp]
34925 9E19           3C                     01  cmp	al,*1
34926 9E1B           76           20            jbe 	.702
34927                       00009E1D            .703:
34928                                           ! 5018         AX = ((AX & 0x00ff) | ((0x01) << 8));
34929                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34930 9E1D           8A46         16            mov	al,$16[bp]
34931                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34932 9E20           30E4                       xor	ah,ah
34933 9E22           0D                   0100  or	ax,#$100
34934                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34935 9E25           8946         16            mov	$16[bp],ax
34936                                           !BCC_EOS
34937                                           ! 5019         set_diskette_ret_status(0x01);
34938                                           ! Debug: list int = const 1 (used reg = )
34939 9E28           B8                   0001  mov	ax,*1
34940 9E2B           50                         push	ax
34941                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34942 9E2C           E8         00D3            call	_set_diskette_ret_status
34943 9E2F           44                         inc	sp
34944 9E30           44                         inc	sp
34945                                           !BCC_EOS
34946                                           ! 5020         FLAGS |= 0x0001;
34947                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34948 9E31           8B46         1C            mov	ax,$1C[bp]
34949 9E34           0C                     01  or	al,*1
34950 9E36           8946         1C            mov	$1C[bp],ax
34951                                           !BCC_EOS
34952                                           ! 5021         return;
34953 9E39           89EC                       mov	sp,bp
34954 9E3B           5D                         pop	bp
34955 9E3C           C3                         ret
34956                                           !BCC_EOS
34957                                           ! 5022         }
34958                                           ! 5023       AX = ((AX & 0x00ff) | ((0x06) << 8));
34959                       00009E3D            .702:
34960                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34961 9E3D           8A46         16            mov	al,$16[bp]
34962                                           ! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
34963 9E40           30E4                       xor	ah,ah
34964 9E42           0D                   0600  or	ax,#$600
34965                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34966 9E45           8946         16            mov	$16[bp],ax
34967                                           !BCC_EOS
34968                                           ! 5024       set_diskette_ret_status(0x06);
34969                                           ! Debug: list int = const 6 (used reg = )
34970 9E48           B8                   0006  mov	ax,*6
34971 9E4B           50                         push	ax
34972                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
34973 9E4C           E8         00B3            call	_set_diskette_ret_status
34974 9E4F           44                         inc	sp
34975 9E50           44                         inc	sp
34976                                           !BCC_EOS
34977                                           ! 5025       FLAGS |= 0x0001;
34978                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
34979 9E51           8B46         1C            mov	ax,$1C[bp]
34980 9E54           0C                     01  or	al,*1
34981 9E56           8946         1C            mov	$1C[bp],ax
34982                                           !BCC_EOS
34983                                           ! 5026       return;
34984 9E59           89EC                       mov	sp,bp
34985 9E5B           5D                         pop	bp
34986 9E5C           C3                         ret
34987                                           !BCC_EOS
34988                                           ! 5027     case 0x17:
34989                                           ! 5028 ;
34990                       00009E5D            .704:
34991                                           !BCC_EOS
34992                                           ! 5029       AX = ((AX & 0x00ff) | ((0x01) << 8));
34993                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
34994 9E5D           8A46         16            mov	al,$16[bp]
34995                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
34996 9E60           30E4                       xor	ah,ah
34997 9E62           0D                   0100  or	ax,#$100
34998                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
34999 9E65           8946         16            mov	$16[bp],ax
35000                                           !BCC_EOS
35001                                           ! 5030       set_diskette_ret_status(1);
35002                                           ! Debug: list int = const 1 (used reg = )
35003 9E68           B8                   0001  mov	ax,*1
35004 9E6B           50                         push	ax
35005                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35006 9E6C           E8         0093            call	_set_diskette_ret_status
35007 9E6F           44                         inc	sp
35008 9E70           44                         inc	sp
35009                                           !BCC_EOS
35010                                           ! 5031       FLAGS |= 0x0001;
35011                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35012 9E71           8B46         1C            mov	ax,$1C[bp]
35013 9E74           0C                     01  or	al,*1
35014 9E76           8946         1C            mov	$1C[bp],ax
35015                                           !BCC_EOS
35016                                           ! 5032       return;
35017 9E79           89EC                       mov	sp,bp
35018 9E7B           5D                         pop	bp
35019 9E7C           C3                         ret
35020                                           !BCC_EOS
35021                                           ! 5033     case 0x18:
35022                                           ! 5034 ;
35023                       00009E7D            .705:
35024                                           !BCC_EOS
35025                                           ! 5035       AX = ((AX & 0x00ff) | ((0x01) << 8));
35026                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35027 9E7D           8A46         16            mov	al,$16[bp]
35028                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35029 9E80           30E4                       xor	ah,ah
35030 9E82           0D                   0100  or	ax,#$100
35031                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35032 9E85           8946         16            mov	$16[bp],ax
35033                                           !BCC_EOS
35034                                           ! 5036       set_d
35035                                           ! 5036 iskette_ret_status(1);
35036                                           ! Debug: list int = const 1 (used reg = )
35037 9E88           B8                   0001  mov	ax,*1
35038 9E8B           50                         push	ax
35039                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35040 9E8C           E8         0073            call	_set_diskette_ret_status
35041 9E8F           44                         inc	sp
35042 9E90           44                         inc	sp
35043                                           !BCC_EOS
35044                                           ! 5037       FLAGS |= 0x0001;
35045                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35046 9E91           8B46         1C            mov	ax,$1C[bp]
35047 9E94           0C                     01  or	al,*1
35048 9E96           8946         1C            mov	$1C[bp],ax
35049                                           !BCC_EOS
35050                                           ! 5038       return;
35051 9E99           89EC                       mov	sp,bp
35052 9E9B           5D                         pop	bp
35053 9E9C           C3                         ret
35054                                           !BCC_EOS
35055                                           ! 5039     default:
35056                                           ! 5040         ;
35057                       00009E9D            .706:
35058                                           !BCC_EOS
35059                                           ! 5041         AX = ((AX & 0x00ff) | ((0x01) << 8));
35060                                           ! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
35061 9E9D           8A46         16            mov	al,$16[bp]
35062                                           ! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
35063 9EA0           30E4                       xor	ah,ah
35064 9EA2           0D                   0100  or	ax,#$100
35065                                           ! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
35066 9EA5           8946         16            mov	$16[bp],ax
35067                                           !BCC_EOS
35068                                           ! 5042         set_diskette_ret_status(1);
35069                                           ! Debug: list int = const 1 (used reg = )
35070 9EA8           B8                   0001  mov	ax,*1
35071 9EAB           50                         push	ax
35072                                           ! Debug: func () void = set_diskette_ret_status+0 (used reg = )
35073 9EAC           E8         0053            call	_set_diskette_ret_status
35074 9EAF           44                         inc	sp
35075 9EB0           44                         inc	sp
35076                                           !BCC_EOS
35077                                           ! 5043         FLAGS |= 0x0001;
35078                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
35079 9EB1           8B46         1C            mov	ax,$1C[bp]
35080 9EB4           0C                     01  or	al,*1
35081 9EB6           8946         1C            mov	$1C[bp],ax
35082                                           !BCC_EOS
35083                                           ! 5044         return;
35084 9EB9           89EC                       mov	sp,bp
35085 9EBB           5D                         pop	bp
35086 9EBC           C3                         ret
35087                                           !BCC_EOS
35088                                           ! 5045     }
35089                                           ! 5046 }
35090 9EBD           EB           3F            jmp .679
35091                       00009EBF            .67B:
35092 9EBF           2C                     00  sub	al,*0
35093 9EC1           72           DA            jb 	.706
35094 9EC3           3C                     08  cmp	al,*8
35095 9EC5           77           1D            ja  	.707
35096 9EC7           30E4                       xor	ah,ah
35097 9EC9           D1E0                       shl	ax,*1
35098 9ECB           89C3                       mov	bx,ax
35099 9ECD           2E                         seg	cs
35100 9ECE           FFA7       9ED2            br	.708[bx]
35101                       00009ED2            .708:
35102 9ED2                      8E1E            .word	.67C
35103 9ED4                      8EC8            .word	.684
35104 9ED6                      8F0A            .word	.687
35105 9ED8                      8F0A            .word	.688
35106 9EDA                      8F0A            .word	.689
35107 9EDC                      9795            .word	.6BE
35108 9EDE                      9E9D            .word	.706
35109 9EE0                      9E9D            .word	.706
35110 9EE2                      9BD2            .word	.6DE
35111                       00009EE4            .707:
35112 9EE4           2C                     15  sub	al,*$15
35113 9EE6         0F84         FEB0            beq 	.6F8
35114 9EEA           2C                     01  sub	al,*1
35115 9EEC         0F84         FF20            beq 	.701
35116 9EF0           2C                     01  sub	al,*1
35117 9EF2         0F84         FF67            beq 	.704
35118 9EF6           2C                     01  sub	al,*1
35119 9EF8         0F84         FF81            beq 	.705
35120 9EFC           EB           9F            jmp	.706
35121                       00009EFE            .679:
35122                       FFFFFFE0            ..FFDC	=	-$20
35123 9EFE           89EC                       mov	sp,bp
35124 9F00           5D                         pop	bp
35125 9F01           C3                         ret
35126                                           ! 5047  void
35127                                           ! Register BX used in function int13_diskette_function
35128                                           ! 5048 set_diskette_ret_status(value)
35129                                           ! 5049   Bit8u value;
35130                                           export	_set_diskette_ret_status
35131                       00009F02            _set_diskette_ret_status:
35132                                           !BCC_EOS
35133                                           ! 5050 {
35134                                           ! 5051   write_byte(0x0040, 0x0041, value);
35135 9F02           55                         push	bp
35136 9F03           89E5                       mov	bp,sp
35137                                           ! Debug: list unsigned char value = [S+2+2] (used reg = )
35138 9F05           8A46         04            mov	al,4[bp]
35139 9F08           30E4                       xor	ah,ah
35140 9F0A           50                         push	ax
35141                                           ! Debug: list int = const $41 (used reg = )
35142 9F0B           B8                   0041  mov	ax,*$41
35143 9F0E           50                         push	ax
35144                                           ! Debug: list int = const $40 (used reg = )
35145 9F0F           B8                   0040  mov	ax,*$40
35146 9F12           50                         push	ax
35147                                           ! Debug: func () void = write_byte+0 (used reg = )
35148 9F13           E8         6704            call	_write_byte
35149 9F16           89EC                       mov	sp,bp
35150                                           !BCC_EOS
35151                                           ! 5052 }
35152 9F18           5D                         pop	bp
35153 9F19           C3                         ret
35154                                           ! 5053   void
35155                                           ! 5054 set_diskette_current_cyl(drive, cyl)
35156                                           ! 5055   Bit8u drive;
35157                                           export	_set_diskette_current_cyl
35158                       00009F1A            _set_diskette_current_cyl:
35159                                           !BCC_EOS
35160                                           ! 5056   Bit8u cyl;
35161                                           !BCC_EOS
35162                                           ! 5057 {
35163                                           ! 5058   if (drive > 1)
35164 9F1A           55                         push	bp
35165 9F1B           89E5                       mov	bp,sp
35166                                           ! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
35167 9F1D           8A46         04            mov	al,4[bp]
35168 9F20           3C                     01  cmp	al,*1
35169 9F22           76           0D            jbe 	.709
35170                       00009F24            .70A:
35171                                           ! 5059     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
35172                                           ! Debug: list * char = .70B+0 (used reg = )
35173 9F24           BB                   D024  mov	bx,#.70B
35174 9F27           53                         push	bx
35175                                           ! Debug: list int = const 7 (used reg = )
35176 9F28           B8                   0007  mov	ax,*7
35177 9F2B           50                         push	ax
35178                                           ! Debug: func () void = bios_printf+0 (used reg = )
35179 9F2C           E8         6AEC            call	_bios_printf
35180 9F2F           89EC                       mov	sp,bp
35181                                           !BCC_EOS
35182                                           ! 5060   write_byte(0x0040, 0x0094+drive, cyl);
35183                       00009F31            .709:
35184                                           ! Debug: list unsigned char cyl = [S+2+4] (used reg = )
35185 9F31           8A46         06            mov	al,6[bp]
35186 9F34           30E4                       xor	ah,ah
35187 9F36           50                         push	ax
35188                                           ! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
35189                                           ! Debug: expression subtree swapping
35190 9F37           8A46         04            mov	al,4[bp]
35191 9F3A           30E4                       xor	ah,ah
35192                                           ! Debug: list unsigned int = ax+$94 (used reg = )
35193 9F3C           05                   0094  add	ax,#$94
35194 9F3F           50                         push	ax
35195                                           ! Debug: list int = const $40 (used reg = )
35196 9F40           B8                   0040  mov	ax,*$40
35197 9F43           50                         push	ax
35198                                           ! Debug: func () void = write_byte+0 (used reg = )
35199 9F44           E8         66D3            call	_write_byte
35200 9F47           89EC                       mov	sp,bp
35201                                           !BCC_EOS
35202                                           ! 5061 }
35203 9F49           5D                         pop	bp
35204 9F4A           C3                         ret
35205                                           ! 5062   void
35206                                           ! Register BX used in function set_diskette_current_cyl
35207                                           ! 5063 determine_floppy_media(drive)
35208                                           ! 5064   Bit16u drive;
35209                                           export	_determine_floppy_media
35210                       00009F4B            _determine_floppy_media:
35211                                           !BCC_EOS
35212                                           ! 5065 {
35213                                           ! 5066 }
35214 9F4B           C3                         ret
35215                                           ! 5067   void
35216                                           ! 5068 int17_function(regs, ds, iret_addr)
35217                                           ! 5069   pusha_regs_t regs;
35218                                           export	_int17_function
35219                       00009F4C            _int17_function:
35220                                           !BCC_EOS
35221                                           ! 5070   Bit16u ds;
35222                                           !BCC_EOS
35223                                           ! 5071   iret_addr_t iret_addr;
35224                                           !BCC_EOS
35225                                           ! 5072 {
35226                                           ! 5073   Bit16u addr,timeout;
35227                                           !BCC_EOS
35228                                           ! 5074   Bit8u val8;
35229                                           !BCC_EOS
35230                                           ! 5075 #asm
35231 9F4C           55                         push	bp
35232 9F4D           89E5                       mov	bp,sp
35233 9F4F           83C4                   FA  add	sp,*-6
35234                                           !BCC_EOS
35235                                           !BCC_ASM
35236                       0000001A            _int17_function.ds	set	$1A
35237                       00000014            .int17_function.ds	set	$14
35238                       00000002            _int17_function.timeout	set	2
35239                       FFFFFFFC            .int17_function.timeout	set	-4
35240                       00000001            _int17_function.val8	set	1
35241                       FFFFFFFB            .int17_function.val8	set	-5
35242                       0000001C            _int17_function.iret_addr	set	$1C
35243                       00000016            .int17_function.iret_addr	set	$16
35244                       00000004            _int17_function.addr	set	4
35245                       FFFFFFFE            .int17_function.addr	set	-2
35246                       0000000A            _int17_function.regs	set	$A
35247                       00000004            .int17_function.regs	set	4
35248 9F52           FB                           sti
35249                                           ! 5077 endasm
35250                                           !BCC_ENDASM
35251                                           !BCC_EOS
35252                                           ! 5078   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
35253                                           ! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
35254 9F53           8B46         0E            mov	ax,$E[bp]
35255 9F56           D1E0                       shl	ax,*1
35256                                           ! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
35257                                           ! Debug: list unsigned int = ax+8 (used reg = )
35258 9F58           05                   0008  add	ax,*8
35259 9F5B           50                         push	ax
35260                                           ! Debug: list int = const $40 (used reg = )
35261 9F5C           B8                   0040  mov	ax,*$40
35262 9F5F           50                         push	ax
35263                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35264 9F60           E8         66A4            call	_read_word
35265 9F63           83C4                   04  add	sp,*4
35266                                           ! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
35267 9F66           8946         FE            mov	-2[bp],ax
35268                                           !BCC_EOS
35269                                           ! 5079   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
35270                                           ! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
35271 9F69           8A46         13            mov	al,$13[bp]
35272 9F6C           3C                     03  cmp	al,*3
35273 9F6E         0F83         0106            bhis	.70C
35274                       00009F72            .70F:
35275                                           ! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
35276 9F72           8B46         0E            mov	ax,$E[bp]
35277 9F75           3D                   0003  cmp	ax,*3
35278 9F78         0F83         00FC            bhis	.70C
35279                       00009F7C            .70E:
35280                                           ! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
35281 9F7C           8B46         FE            mov	ax,-2[bp]
35282 9F7F           85C0                       test	ax,ax
35283 9F81         0F84         00F3            beq 	.70C
35284                       00009F85            .70D:
35285                                           ! 5080     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
35286                                           ! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
35287                                           ! Debug: expression subtree swapping
35288 9F85           8B46         0E            mov	ax,$E[bp]
35289                                           ! Debug: list unsigned int = ax+$78 (used reg = )
35290 9F88           05                   0078  add	ax,*$78
35291 9F8B           50                         push	ax
35292                                           ! Debug: list int = const $40 (used reg = )
35293 9F8C           B8                   0040  mov	ax,*$40
35294 9F8F           50                         push	ax
35295                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
35296 9F90           E8         6661            call	_read_byte
35297 9F93           83C4                   04  add	sp,*4
35298                                           ! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
35299 9F96           30E4                       xor	ah,ah
35300 9F98           88C4                       mov	ah,al
35301 9F9A           30C0                       xor	al,al
35302                                           ! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
35303 9F9C           8946         FC            mov	-4[bp],ax
35304                                           !BCC_EOS
35305                                           ! 5081     if (regs.u.r8.ah == 0) {
35306                                           ! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
35307 9F9F           8A46         13            mov	al,$13[bp]
35308 9FA2           84C0                       test	al,al
35309 9FA4           75           66            jne 	.710
35310                       00009FA6            .711:
35311                                           ! 5082       outb(addr, regs.u.r8.al);
35312                                           ! Debug: list unsigned char regs = [S+8+$10] (used reg = )
35313 9FA6           8A46         12            mov	al,$12[bp]
35314 9FA9           30E4                       xor	ah,ah
35315 9FAB           50                         push	ax
35316                                           ! Debug: list unsigned short addr = [S+$A-4] (used reg = )
35317 9FAC           FF76         FE            push	-2[bp]
35318                                           ! Debug: func () void = outb+0 (used reg = )
35319 9FAF           E8         65A2            call	_outb
35320 9FB2           83C4                   04  add	sp,*4
35321                                           !BCC_EOS
35322                                           ! 5083       val8 = inb(addr+2);
35323                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
35324 9FB5           8B46         FE            mov	ax,-2[bp]
35325                                           ! Debug: list unsigned int = ax+2 (used reg = )
35326 9FB8           40                         inc	ax
35327 9FB9           40                         inc	ax
35328 9FBA           50                         push	ax
35329                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35330 9FBB           E8         6580            call	_inb
35331 9FBE           44                         inc	sp
35332 9FBF           44                         inc	sp
35333                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35334 9FC0           8846         FB            mov	-5[bp],al
35335                                           !BCC_EOS
35336                                           ! 5084       outb(addr+2, val8 | 0x01);
35337                                           ! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
35338 9FC3           8A46         FB            mov	al,-5[bp]
35339 9FC6           0C                     01  or	al,*1
35340                                           ! Debug: list unsigned char = al+0 (used reg = )
35341 9FC8           30E4                       xor	ah,ah
35342 9FCA           50                         push	ax
35343                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35344 9FCB           8B46         FE            mov	ax,-2[bp]
35345                                           ! Debug: list unsigned int = ax+2 (used reg = )
35346 9FCE           40                         inc	ax
35347 9FCF           40                         inc	ax
35348 9FD0           50                         push	ax
35349                                           ! Debug: func () void = outb+0 (used reg = )
35350 9FD1           E8         6580            call	_outb
35351 9FD4           83C4                   04  add	sp,*4
35352                                           !BCC_EOS
35353                                           ! 5085 #asm
35354                                           !BCC_EOS
35355                                           !BCC_ASM
35356                       0000001A            _int17_function.ds	set	$1A
35357                       00000014            .int17_function.ds	set	$14
35358                       00000002            _int17_function.timeout	set	2
35359                       FFFFFFFC            .int17_function.timeout	set	-4
35360                       00000001            _int17_function.val8	set	1
35361                       FFFFFFFB            .int17_function.val8	set	-5
35362                       0000001C            _int17_function.iret_addr	set	$1C
35363                       00000016            .int17_function.iret_addr	set	$16
35364                       00000004            _int17_function.addr	set	4
35365                       FFFFFFFE            .int17_function.addr	set	-2
35366                       0000000A            _int17_function.regs	set	$A
35367                       00000004            .int17_function.regs	set	4
35368 9FD7           90                               nop
35369                                           ! 5087 endasm
35370                                           !BCC_ENDASM
35371                                           !BCC_EOS
35372                                           ! 5088       outb(addr+2, val8 & ~0x01);
35373                                           ! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
35374 9FD8           8A46         FB            mov	al,-5[bp]
35375 9FDB           24                     FE  and	al,#$FE
35376                                           ! Debug: list unsigned char = al+0 (used reg = )
35377 9FDD           30E4                       xor	ah,ah
35378 9FDF           50                         push	ax
35379                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35380 9FE0           8B46         FE            mov	ax,-2[bp]
35381                                           ! Debug: list unsigned int = ax+2 (used reg = )
35382 9FE3           40                         inc	ax
35383 9FE4           40                         inc	ax
35384 9FE5           50                         push	ax
35385                                           ! Debug: func () void = outb+0 (used reg = )
35386 9FE6           E8         656B            call	_outb
35387 9FE9           83C4                   04  add	sp,*4
35388                                           !BCC_EOS
35389                                           ! 5089       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
35390 9FEC           EB           07            jmp .713
35391                       00009FEE            .714:
35392                                           ! 5090         timeout--;
35393                                           ! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
35394 9FEE           8B46         FC            mov	ax,-4[bp]
35395 9FF1           48                         dec	ax
35396 9FF2           8946         FC            mov	-4[bp],ax
35397                                           !BCC_EOS
35398                                           ! 5091       }
35399                                           ! 5092     }
35400                       00009FF5            .713:
35401                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
35402 9FF5           8B46         FE            mov	ax,-2[bp]
35403                                           ! Debug: list unsigned int = ax+1 (used reg = )
35404 9FF8           40                         inc	ax
35405 9FF9           50                         push	ax
35406                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35407 9FFA           E8         6541            call	_inb
35408 9FFD           44                         inc	sp
35409 9FFE           44                         inc	sp
35410                                           ! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
35411 9FFF           24                     40  and	al,*$40
35412                                           ! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
35413 A001           3C                     40  cmp	al,*$40
35414 A003           75           07            jne 	.715
35415                       0000A005            .716:
35416 A005           8B46         FC            mov	ax,-4[bp]
35417 A008           85C0                       test	ax,ax
35418 A00A           75           E2            jne	.714
35419                       0000A00C            .715:
35420                       0000A00C            .712:
35421                                           ! 5093     if (regs.u.r8.ah == 1) {
35422                       0000A00C            .710:
35423                                           ! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
35424 A00C           8A46         13            mov	al,$13[bp]
35425 A00F           3C                     01  cmp	al,*1
35426 A011           75           37            jne 	.717
35427                       0000A013            .718:
35428                                           ! 5094       val8 = inb(addr+2);
35429                                           ! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
35430 A013           8B46         FE            mov	ax,-2[bp]
35431                                           ! Debug: list unsigned int = ax+2 (used reg = )
35432 A016           40                         inc	ax
35433 A017           40                         inc	ax
35434 A018           50                         push	ax
35435                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35436 A019           E8         6522            call	_inb
35437 A01C           44                         inc	sp
35438 A01D           44                         inc	sp
35439                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35440 A01E           8846         FB            mov	-5[bp],al
35441                                           !BCC_EOS
35442                                           ! 5095       outb(addr+2, val8 & ~0x04);
35443                                           ! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
35444 A021           8A46         FB            mov	al,-5[bp]
35445 A024           24                     FB  and	al,#$FB
35446                                           ! Debug: list unsigned char = al+0 (used reg = )
35447 A026           30E4                       xor	ah,ah
35448 A028           50                         push	ax
35449                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35450 A029           8B46         FE            mov	ax,-2[bp]
35451                                           ! Debug: list unsigned int = ax+2 (used reg = )
35452 A02C           40                         inc	ax
35453 A02D           40                         inc	ax
35454 A02E           50                         push	ax
35455                                           ! Debug: func () void = outb+0 (used reg = )
35456 A02F           E8         6522            call	_outb
35457 A032           83C4                   04  add	sp,*4
35458                                           !BCC_EOS
35459                                           ! 5096 #asm
35460                                           !BCC_EOS
35461                                           !BCC_ASM
35462                       0000001A            _int17_function.ds	set	$1A
35463                       00000014            .int17_function.ds	set	$14
35464                       00000002            _int17_function.timeout	set	2
35465                       FFFFFFFC            .int17_function.timeout	set	-4
35466                       00000001            _int17_function.val8	set	1
35467                       FFFFFFFB            .int17_function.val8	set	-5
35468                       0000001C            _int17_function.iret_addr	set	$1C
35469                       00000016            .int17_function.iret_addr	set	$16
35470                       00000004            _int17_function.addr	set	4
35471                       FFFFFFFE            .int17_function.addr	set	-2
35472                       0000000A            _int17_function.regs	set	$A
35473                       00000004            .int17_function.regs	set	4
35474 A035           90                               nop
35475                                           ! 5098 endasm
35476                                           !BCC_ENDASM
35477                                           !BCC_EOS
35478                                           ! 5099       outb(addr+2, val8 | 0x04);
35479                                           ! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
35480 A036           8A46         FB            mov	al,-5[bp]
35481 A039           0C                     04  or	al,*4
35482                                           ! Debug: list unsigned char = al+0 (used reg = )
35483 A03B           30E4                       xor	ah,ah
35484 A03D           50                         push	ax
35485                                           ! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
35486 A03E           8B46         FE            mov	ax,-2[bp]
35487                                           ! Debug: list unsigned int = ax+2 (used reg = )
35488 A041           40                         inc	ax
35489 A042           40                         inc	ax
35490 A043           50                         push	ax
35491                                           ! Debug: func () void = outb+0 (used reg = )
35492 A044           E8         650D            call	_outb
35493 A047           83C4                   04  add	sp,*4
35494                                           !BCC_EOS
35495                                           ! 5100     }
35496                                           ! 5101     val8 = inb(addr+1);
35497                       0000A04A            .717:
35498                                           ! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
35499 A04A           8B46         FE            mov	ax,-2[bp]
35500                                           ! Debug: list unsigned int = ax+1 (used reg = )
35501 A04D           40                         inc	ax
35502 A04E           50                         push	ax
35503                                           ! Debug: func () unsigned char = inb+0 (used reg = )
35504 A04F           E8         64EC            call	_inb
35505 A052           44                         inc	sp
35506 A053           44                         inc	sp
35507                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
35508 A054           8846         FB            mov	-5[bp],al
35509                                           !BCC_EOS
35510                                           ! 5102     regs.u.r8.ah = (val8 ^ 0x48);
35511                                           ! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
35512 A057           8A46         FB            mov	al,-5[bp]
35513 A05A           34                     48  xor	al,*$48
35514                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
35515 A05C           8846         13            mov	$13[bp],al
35516                                           !BCC_EOS
35517                                           ! 5103     if (!timeout) regs.u.r8.ah |= 0x01;
35518 A05F           8B46         FC            mov	ax,-4[bp]
35519 A062           85C0                       test	ax,ax
35520 A064           75           08            jne 	.719
35521                       0000A066            .71A:
35522                                           ! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
35523 A066           8A46         13            mov	al,$13[bp]
35524 A069           0C                     01  or	al,*1
35525 A06B           8846         13            mov	$13[bp],al
35526                                           !BCC_EOS
35527                                           ! 5104     iret_addr.flags.u.r8.flagsl &= 0xfe;
35528                       0000A06E            .719:
35529                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
35530 A06E           8A46         1A            mov	al,$1A[bp]
35531 A071           24                     FE  and	al,#$FE
35532 A073           8846         1A            mov	$1A[bp],al
35533                                           !BCC_EOS
35534                                           ! 5105   } else {
35535 A076           EB           08            jmp .71B
35536                       0000A078            .70C:
35537                                           ! 5106     iret_addr.flags.u.r8.flagsl |= 0x01;
35538                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
35539 A078           8A46         1A            mov	al,$1A[bp]
35540 A07B           0C                     01  or	al,*1
35541 A07D           8846         1A            mov	$1A[bp],al
35542                                           !BCC_EOS
35543                                           ! 5107   }
35544                                           ! 5108 }
35545                       0000A080            .71B:
35546 A080           89EC                       mov	sp,bp
35547 A082           5D                         pop	bp
35548 A083           C3                         ret
35549                                           ! 5109 void
35550                                           ! 5110 int18_function(seq_nr)
35551                                           ! 5111 Bit16u seq_nr;
35552                                           export	_int18_function
35553                       0000A084            _int18_function:
35554                                           !BCC_EOS
35555                                           ! 5112 {
35556                                           ! 5113   Bit16u ebda_seg=read_word(0x0040,0x000E);
35557 A084           55                         push	bp
35558 A085           89E5                       mov	bp,sp
35559 A087           4C                         dec	sp
35560 A088           4C                         dec	sp
35561                                           ! Debug: list int = const $E (used reg = )
35562 A089           B8                   000E  mov	ax,*$E
35563 A08C           50                         push	ax
35564                                           ! Debug: list int = const $40 (used reg = )
35565 A08D           B8                   0040  mov	ax,*$40
35566 A090           50                         push	ax
35567                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35568 A091           E8         6573            call	_read_word
35569 A094           83C4                   04  add	sp,*4
35570                                           ! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
35571 A097           8946         FE            mov	-2[bp],ax
35572                                           !BCC_EOS
35573                                           ! 5114   Bit16u bootdev;
35574                                           !BCC_EOS
35575                                           ! 5115   Bit8u bootdrv;
35576                                           !BCC_EOS
35577                                           ! 5116   Bit8u bootchk;
35578                                           !BCC_EOS
35579                                           ! 5117   Bit16u bootseg;
35580                                           !BCC_EOS
35581                                           ! 5118   Bit16u bootip;
35582                                           !BCC_EOS
35583                                           ! 5119   Bit16u status;
35584                                           !BCC_EOS
35585                                           ! 5120   Bit16u bootfirst;
35586                                           !BCC_EOS
35587                                           ! 5121   ipl_entry_t e;
35588                                           !BCC_EOS
35589                                           ! 5122   bootdev = inb_cmos(0x3d);
35590 A09A           83C4                   E4  add	sp,*-$1C
35591                                           ! Debug: list int = const $3D (used reg = )
35592 A09D           B8                   003D  mov	ax,*$3D
35593 A0A0           50                         push	ax
35594                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35595 A0A1           E8         64DF            call	_inb_cmos
35596 A0A4           44                         inc	sp
35597 A0A5           44                         inc	sp
35598                                           ! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35599 A0A6           30E4                       xor	ah,ah
35600 A0A8           8946         FC            mov	-4[bp],ax
35601                                           !BCC_EOS
35602                                           ! 5123   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
35603                                           ! Debug: list int = const $38 (used reg = )
35604 A0AB           B8                   0038  mov	ax,*$38
35605 A0AE           50                         push	ax
35606                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35607 A0AF           E8         64D1            call	_inb_cmos
35608 A0B2           44                         inc	sp
35609 A0B3           44                         inc	sp
35610                                           ! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
35611 A0B4           24                     F0  and	al,#$F0
35612                                           ! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
35613 A0B6           30E4                       xor	ah,ah
35614 A0B8           B1                     04  mov	cl,*4
35615 A0BA           D3E0                       shl	ax,cl
35616                                           ! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35617 A0BC           0B46         FC            or	ax,-4[bp]
35618 A0BF           8946         FC            mov	-4[bp],ax
35619                                           !BCC_EOS
35620                                           ! 5124   bootdev >>= 4 * seq_nr;
35621                                           ! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
35622                                           ! Debug: expression subtree swapping
35623 A0C2           8B46         04            mov	ax,4[bp]
35624 A0C5           D1E0                       shl	ax,*1
35625 A0C7           D1E0                       shl	ax,*1
35626                                           ! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
35627 A0C9           89C3                       mov	bx,ax
35628 A0CB           8B46         FC            mov	ax,-4[bp]
35629 A0CE           89D9                       mov	cx,bx
35630 A0D0           D3E8                       shr	ax,cl
35631 A0D2           8946         FC            mov	-4[bp],ax
35632                                           !BCC_EOS
35633                                           ! 5125   bootdev &= 0xf;
35634                                           ! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
35635 A0D5           8A46         FC            mov	al,-4[bp]
35636 A0D8           24                     0F  and	al,*$F
35637 A0DA           30E4                       xor	ah,ah
35638 A0DC           8946         FC            mov	-4[bp],ax
35639                                           !BCC_EOS
35640                                           ! 5126   bootfirst = read_word(ebda_seg, 0x0384);
35641                                           ! Debug: list int = const $384 (used reg = )
35642 A0DF           B8                   0384  mov	ax,#$384
35643 A0E2           50                         push	ax
35644                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
35645 A0E3           FF76         FE            push	-2[bp]
35646                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35647 A0E6           E8         651E            call	_read_word
35648 A0E9           83C4                   04  add	sp,*4
35649                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
35650 A0EC           8946         F2            mov	-$E[bp],ax
35651                                           !BCC_EOS
35652                                           ! 5127   if (bootfirst != 0xFFFF) {
35653                                           ! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
35654 A0EF           8B46         F2            mov	ax,-$E[bp]
35655 A0F2           3D                   FFFF  cmp	ax,#$FFFF
35656 A0F5           74           2A            je  	.71C
35657                       0000A0F7            .71D:
35658                                           ! 5128     bootdev = bootfirst;
35659                                           ! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
35660 A0F7           8B46         F2            mov	ax,-$E[bp]
35661 A0FA           8946         FC            mov	-4[bp],ax
35662                                           !BCC_EOS
35663                                           ! 5129     write_word(ebda_seg, 0x0384, 0xFFFF);
35664                                           ! Debug: list unsigned int = const $FFFF (used reg = )
35665 A0FD           B8                   FFFF  mov	ax,#$FFFF
35666 A100           50                         push	ax
35667                                           ! Debug: list int = const $384 (used reg = )
35668 A101           B8                   0384  mov	ax,#$384
35669 A104           50                         push	ax
35670                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
35671 A105           FF76         FE            push	-2[bp]
35672                                           ! Debug: func () void = write_word+0 (used reg = )
35673 A108           E8         6527            call	_write_word
35674 A10B           83C4                   06  add	sp,*6
35675                                           !BCC_EOS
35676                                           ! 5130     write_word(ebda_seg, 0x0382,
35677                                           ! 5130  0xFFFF);
35678                                           ! Debug: list unsigned int = const $FFFF (used reg = )
35679 A10E           B8                   FFFF  mov	ax,#$FFFF
35680 A111           50                         push	ax
35681                                           ! Debug: list int = const $382 (used reg = )
35682 A112           B8                   0382  mov	ax,#$382
35683 A115           50                         push	ax
35684                                           ! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
35685 A116           FF76         FE            push	-2[bp]
35686                                           ! Debug: func () void = write_word+0 (used reg = )
35687 A119           E8         6516            call	_write_word
35688 A11C           83C4                   06  add	sp,*6
35689                                           !BCC_EOS
35690                                           ! 5131   } else if (bootdev == 0) {
35691 A11F           EB           3C            jmp .71E
35692                       0000A121            .71C:
35693                                           ! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
35694 A121           8B46         FC            mov	ax,-4[bp]
35695 A124           85C0                       test	ax,ax
35696 A126           75           35            jne 	.71F
35697                       0000A128            .720:
35698                                           ! 5132     bios_printf(2, "\nNo bootable device.\n");
35699                                           ! Debug: list * char = .721+0 (used reg = )
35700 A128           BB                   D00E  mov	bx,#.721
35701 A12B           53                         push	bx
35702                                           ! Debug: list int = const 2 (used reg = )
35703 A12C           B8                   0002  mov	ax,*2
35704 A12F           50                         push	ax
35705                                           ! Debug: func () void = bios_printf+0 (used reg = )
35706 A130           E8         68E8            call	_bios_printf
35707 A133           83C4                   04  add	sp,*4
35708                                           !BCC_EOS
35709                                           ! 5133     bios_printf(2, "Powering off in 30 seconds.\n");
35710                                           ! Debug: list * char = .722+0 (used reg = )
35711 A136           BB                   CFF1  mov	bx,#.722
35712 A139           53                         push	bx
35713                                           ! Debug: list int = const 2 (used reg = )
35714 A13A           B8                   0002  mov	ax,*2
35715 A13D           50                         push	ax
35716                                           ! Debug: func () void = bios_printf+0 (used reg = )
35717 A13E           E8         68DA            call	_bios_printf
35718 A141           83C4                   04  add	sp,*4
35719                                           !BCC_EOS
35720                                           ! 5134 #asm
35721                                           !BCC_EOS
35722                                           !BCC_ASM
35723                       00000014            _int18_function.bootip	set	$14
35724                       FFFFFFF6            .int18_function.bootip	set	-$A
35725                       00000022            _int18_function.seq_nr	set	$22
35726                       00000004            .int18_function.seq_nr	set	4
35727                       00000018            _int18_function.bootchk	set	$18
35728                       FFFFFFFA            .int18_function.bootchk	set	-6
35729                       00000016            _int18_function.bootseg	set	$16
35730                       FFFFFFF8            .int18_function.bootseg	set	-8
35731                       0000001C            _int18_function.ebda_seg	set	$1C
35732                       FFFFFFFE            .int18_function.ebda_seg	set	-2
35733                       00000012            _int18_function.status	set	$12
35734                       FFFFFFF4            .int18_function.status	set	-$C
35735                       00000010            _int18_function.bootfirst	set	$10
35736                       FFFFFFF2            .int18_function.bootfirst	set	-$E
35737                       00000019            _int18_function.bootdrv	set	$19
35738                       FFFFFFFB            .int18_function.bootdrv	set	-5
35739                       0000001A            _int18_function.bootdev	set	$1A
35740                       FFFFFFFC            .int18_function.bootdev	set	-4
35741                       00000000            _int18_function.e	set	0
35742                       FFFFFFE2            .int18_function.e	set	-$1E
35743 A144           FB                             sti
35744 A145           B9                   01C9      mov cx, #0x01c9
35745 A148           BA                   C380      mov dx, #0xc380
35746 A14B           B4                     86      mov ah, #0x86 ;; INT 15/86: wait CX:DX usec.
35747 A14D           CD                     15      int #0x15
35748                                           ! 5140 endasm
35749                                           !BCC_ENDASM
35750                                           !BCC_EOS
35751                                           ! 5141     bios_printf(1, "");
35752                                           ! Debug: list * char = .723+0 (used reg = )
35753 A14F           BB                   CFF0  mov	bx,#.723
35754 A152           53                         push	bx
35755                                           ! Debug: list int = const 1 (used reg = )
35756 A153           B8                   0001  mov	ax,*1
35757 A156           50                         push	ax
35758                                           ! Debug: func () void = bios_printf+0 (used reg = )
35759 A157           E8         68C1            call	_bios_printf
35760 A15A           83C4                   04  add	sp,*4
35761                                           !BCC_EOS
35762                                           ! 5142   }
35763                                           ! 5143   bootdev -= 1;
35764                       0000A15D            .71F:
35765                       0000A15D            .71E:
35766                                           ! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
35767 A15D           8B46         FC            mov	ax,-4[bp]
35768 A160           48                         dec	ax
35769 A161           8946         FC            mov	-4[bp],ax
35770                                           !BCC_EOS
35771                                           ! 5144   if (get_boot_vector(bootdev, &e) == 0) {
35772                                           ! Debug: list * struct  e = S+$20-$20 (used reg = )
35773 A164           8D5E         E2            lea	bx,-$1E[bp]
35774 A167           53                         push	bx
35775                                           ! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
35776 A168           FF76         FC            push	-4[bp]
35777                                           ! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
35778 A16B           E8         7395            call	_get_boot_vector
35779 A16E           83C4                   04  add	sp,*4
35780                                           ! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
35781 A171           84C0                       test	al,al
35782 A173           75           04            jne 	.724
35783                       0000A175            .725:
35784                                           ! 5145     ;
35785                                           !BCC_EOS
35786                                           ! 5146     return;
35787 A175           89EC                       mov	sp,bp
35788 A177           5D                         pop	bp
35789 A178           C3                         ret
35790                                           !BCC_EOS
35791                                           ! 5147   }
35792                                           ! 5148   print_boot_device(e.type, e.description);
35793                       0000A179            .724:
35794                                           ! Debug: list unsigned long e = [S+$20-$18] (used reg = )
35795 A179           FF76         EC            push	-$14[bp]
35796 A17C           FF76         EA            push	-$16[bp]
35797                                           ! Debug: list unsigned short e = [S+$24-$20] (used reg = )
35798 A17F           FF76         E2            push	-$1E[bp]
35799                                           ! Debug: func () void = print_boot_device+0 (used reg = )
35800 A182           E8         75D7            call	_print_boot_device
35801 A185           83C4                   06  add	sp,*6
35802                                           !BCC_EOS
35803                                           ! 5149   switch(e.type) {
35804 A188           8B46         E2            mov	ax,-$1E[bp]
35805 A18B           E9         012A            br 	.728
35806                                           ! 5150   case 0x01:
35807                                           ! 5151   case 0x02:
35808                       0000A18E            .729:
35809                                           ! 5152     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
35810                       0000A18E            .72A:
35811                                           ! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
35812 A18E           8B46         E2            mov	ax,-$1E[bp]
35813 A191           3D                   0002  cmp	ax,*2
35814 A194           75           04            jne 	.72B
35815                       0000A196            .72C:
35816 A196           B0                     80  mov	al,#$80
35817 A198           EB           02            jmp .72D
35818                       0000A19A            .72B:
35819 A19A           30C0                       xor	al,al
35820                       0000A19C            .72D:
35821                                           ! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
35822 A19C           8846         FB            mov	-5[bp],al
35823                                           !BCC_EOS
35824                                           ! 5153     bootseg = 0x07c0;
35825                                           ! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
35826 A19F           B8                   07C0  mov	ax,#$7C0
35827 A1A2           8946         F8            mov	-8[bp],ax
35828                                           !BCC_EOS
35829                                           ! 5154     status = 0;
35830                                           ! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
35831 A1A5           31C0                       xor	ax,ax
35832 A1A7           8946         F4            mov	-$C[bp],ax
35833                                           !BCC_EOS
35834                                           ! 5155 #asm
35835                                           !BCC_EOS
35836                                           !BCC_ASM
35837                       00000014            _int18_function.bootip	set	$14
35838                       FFFFFFF6            .int18_function.bootip	set	-$A
35839                       00000022            _int18_function.seq_nr	set	$22
35840                       00000004            .int18_function.seq_nr	set	4
35841                       00000018            _int18_function.bootchk	set	$18
35842                       FFFFFFFA            .int18_function.bootchk	set	-6
35843                       00000016            _int18_function.bootseg	set	$16
35844                       FFFFFFF8            .int18_function.bootseg	set	-8
35845                       0000001C            _int18_function.ebda_seg	set	$1C
35846                       FFFFFFFE            .int18_function.ebda_seg	set	-2
35847                       00000012            _int18_function.status	set	$12
35848                       FFFFFFF4            .int18_function.status	set	-$C
35849                       00000010            _int18_function.bootfirst	set	$10
35850                       FFFFFFF2            .int18_function.bootfirst	set	-$E
35851                       00000019            _int18_function.bootdrv	set	$19
35852                       FFFFFFFB            .int18_function.bootdrv	set	-5
35853                       0000001A            _int18_function.bootdev	set	$1A
35854                       FFFFFFFC            .int18_function.bootdev	set	-4
35855                       00000000            _int18_function.e	set	0
35856                       FFFFFFE2            .int18_function.e	set	-$1E
35857 A1AA           55                             push bp
35858 A1AB           89E5                           mov bp, sp
35859 A1AD           50                             push ax
35860 A1AE           53                             push bx
35861 A1AF           51                             push cx
35862 A1B0           52                             push dx
35863 A1B1           8A56         1B                mov dl, _int18_function.bootdrv + 2[bp]
35864 A1B4           8B46         18                mov ax, _int18_function.bootseg + 2[bp]
35865 A1B7           8EC0                           mov es, ax ;; segment
35866 A1B9           31DB                           xor bx, bx ;; offset
35867 A1BB           B4                     02      mov ah, #0x02 ;; function 2, read diskette sector
35868 A1BD           B0                     01      mov al, #0x01 ;; read 1 sector
35869 A1BF           B5                     00      mov ch, #0x00 ;; track 0
35870 A1C1           B1                     01      mov cl, #0x01 ;; sector 1
35871 A1C3           B6                     00      mov dh, #0x00 ;; head 0
35872 A1C5           CD                     13      int #0x13 ;; read sector
35873 A1C7           73           06                jnc int19_load_done
35874 A1C9           B8                   0001      mov ax, #0x0001
35875 A1CC           8946         14                mov _int18_function.status + 2[bp], ax
35876                       0000A1CF            int19_load_done:
35877 A1CF           5A                             pop dx
35878 A1D0           59                             pop cx
35879 A1D1           5B                             pop bx
35880 A1D2           58                             pop ax
35881 A1D3           5D                             pop bp
35882                                           ! 5181 endasm
35883                                           !BCC_ENDASM
35884                                           !BCC_EOS
35885                                           ! 5182     if (status != 0) {
35886                                           ! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
35887 A1D4           8B46         F4            mov	ax,-$C[bp]
35888 A1D7           85C0                       test	ax,ax
35889 A1D9           74           11            je  	.72E
35890                       0000A1DB            .72F:
35891                                           ! 5183       print_boot_failure(e.type, 1);
35892                                           ! Debug: list int = const 1 (used reg = )
35893 A1DB           B8                   0001  mov	ax,*1
35894 A1DE           50                         push	ax
35895                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
35896 A1DF           FF76         E2            push	-$1E[bp]
35897                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
35898 A1E2           E8         7640            call	_print_boot_failure
35899 A1E5           83C4                   04  add	sp,*4
35900                                           !BCC_EOS
35901                                           ! 5184       return;
35902 A1E8           89EC                       mov	sp,bp
35903 A1EA           5D                         pop	bp
35904 A1EB           C3                         ret
35905                                           !BCC_EOS
35906                                           ! 5185     }
35907                                           ! 5186     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
35908                       0000A1EC            .72E:
35909                                           ! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
35910 A1EC           8B46         E2            mov	ax,-$1E[bp]
35911 A1EF           3D                   0001  cmp	ax,*1
35912 A1F2           75           0F            jne 	.731
35913                       0000A1F4            .732:
35914                                           ! Debug: list int = const $38 (used reg = )
35915 A1F4           B8                   0038  mov	ax,*$38
35916 A1F7           50                         push	ax
35917                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
35918 A1F8           E8         6388            call	_inb_cmos
35919 A1FB           44                         inc	sp
35920 A1FC           44                         inc	sp
35921                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
35922 A1FD           24                     01  and	al,*1
35923 A1FF           84C0                       test	al,al
35924 A201           75           22            jne 	.730
35925                       0000A203            .731:
35926                                           ! 5187       if (read_word(bootseg,0x1fe) != 0xaa55) {
35927                                           ! Debug: list int = const $1FE (used reg = )
35928 A203           B8                   01FE  mov	ax,#$1FE
35929 A206           50                         push	ax
35930                                           ! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
35931 A207           FF76         F8            push	-8[bp]
35932                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
35933 A20A           E8         63FA            call	_read_word
35934 A20D           83C4                   04  add	sp,*4
35935                                           ! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
35936 A210           3D                   AA55  cmp	ax,#$AA55
35937 A213           74           10            je  	.733
35938                       0000A215            .734:
35939                                           ! 5188         print_boot_failure(e.type, 0);
35940                                           ! Debug: list int = const 0 (used reg = )
35941 A215           31C0                       xor	ax,ax
35942 A217           50                         push	ax
35943                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
35944 A218           FF76         E2            push	-$1E[bp]
35945                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
35946 A21B           E8         7607            call	_print_boot_failure
35947 A21E           83C4                   04  add	sp,*4
35948                                           !BCC_EOS
35949                                           ! 5189         return;
35950 A221           89EC                       mov	sp,bp
35951 A223           5D                         pop	bp
35952 A224           C3                         ret
35953                                           !BCC_EOS
35954                                           ! 5190       }
35955                                           ! 5191     }
35956                       0000A225            .733:
35957                                           ! 5192     bootip = (bootseg & 0x0fff) << 4;
35958                       0000A225            .730:
35959                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
35960 A225           8B46         F8            mov	ax,-8[bp]
35961 A228           25                   0FFF  and	ax,#$FFF
35962                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
35963 A22B           B1                     04  mov	cl,*4
35964 A22D           D3E0                       shl	ax,cl
35965                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
35966 A22F           8946         F6            mov	-$A[bp],ax
35967                                           !BCC_EOS
35968                                           ! 5193     bootseg &= 0xf000;
35969                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
35970 A232           8B46         F8            mov	ax,-8[bp]
35971 A235           25                   F000  and	ax,#$F000
35972 A238           8946         F8            mov	-8[bp],ax
35973                                           !BCC_EOS
35974                                           ! 5194   break;
35975 A23B           E9         0096            br 	.726
35976                                           !BCC_EOS
35977                                           ! 5195   case 0x03:
35978                                           ! 5196     status = cdrom_boot();
35979                       0000A23E            .735:
35980                                           ! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
35981 A23E           E8         9CAF            call	_cdrom_boot
35982                                           ! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
35983 A241           8946         F4            mov	-$C[bp],ax
35984                                           !BCC_EOS
35985                                           ! 5197     if ( (status & 0x00ff) !=0 ) {
35986                                           ! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
35987 A244           8A46         F4            mov	al,-$C[bp]
35988                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
35989 A247           84C0                       test	al,al
35990 A249           74           19            je  	.736
35991                       0000A24B            .737:
35992                                           ! 5198       print_cdromboot_failure(status);
35993                                           ! Debug: list unsigned short status = [S+$20-$E] (used reg = )
35994 A24B           FF76         F4            push	-$C[bp]
35995                                           ! Debug: func () void = print_cdromboot_failure+0 (used reg = )
35996 A24E           E8         764C            call	_print_cdromboot_failure
35997 A251           44                         inc	sp
35998 A252           44                         inc	sp
35999                                           !BCC_EOS
36000                                           ! 5199       print_boot_failure(e.type, 1);
36001                                           ! Debug: list int = const 1 (used reg = )
36002 A253           B8                   0001  mov	ax,*1
36003 A256           50                         push	ax
36004                                           ! Debug: list unsigned short e = [S+$22-$20] (used reg = )
36005 A257           FF76         E2            push	-$1E[bp]
36006                                           ! Debug: func () void = print_boot_failure+0 (used reg = )
36007 A25A           E8         75C8            call	_print_boot_failure
36008 A25D           83C4                   04  add	sp,*4
36009                                           !BCC_EOS
36010                                           ! 5200       return;
36011 A260           89EC                       mov	sp,bp
36012 A262           5D                         pop	bp
36013 A263           C3                         ret
36014                                           !BCC_EOS
36015                                           ! 5201     }
36016                                           ! 5202     bootdrv = (Bit8u)(status>>8);
36017                       0000A264            .736:
36018                                           ! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
36019 A264           8B46         F4            mov	ax,-$C[bp]
36020 A267           88E0                       mov	al,ah
36021 A269           30E4                       xor	ah,ah
36022                                           ! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
36023                                           ! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
36024 A26B           8846         FB            mov	-5[bp],al
36025                                           !BCC_EOS
36026                                           ! 5203     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
36027                                           ! Debug: list * unsigned short = const $266 (used reg = )
36028 A26E           B8                   0266  mov	ax,#$266
36029 A271           50                         push	ax
36030                                           ! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
36031 A272           FF76         FE            push	-2[bp]
36032                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
36033 A275           E8         638F            call	_read_word
36034 A278           83C4                   04  add	sp,*4
36035                                           ! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36036 A27B           8946         F8            mov	-8[bp],ax
36037                                           !BCC_EOS
36038                                           ! 5204     bootip = (bootseg & 0x0fff) << 4;
36039                                           ! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
36040 A27E           8B46         F8            mov	ax,-8[bp]
36041 A281           25                   0FFF  and	ax,#$FFF
36042                                           ! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
36043 A284           B1                     04  mov	cl,*4
36044 A286           D3E0                       shl	ax,cl
36045                                           ! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36046 A288           8946         F6            mov	-$A[bp],ax
36047                                           !BCC_EOS
36048                                           ! 5205     bootseg &= 0xf000;
36049                                           ! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
36050 A28B           8B46         F8            mov	ax,-8[bp]
36051 A28E           25                   F000  and	ax,#$F000
36052 A291           8946         F8            mov	-8[bp],ax
36053                                           !BCC_EOS
36054                                           ! 5206     break;
36055 A294           EB           3E            jmp .726
36056                                           !BCC_EOS
36057                                           ! 5207   case 0x80:
36058                                           ! 5208     bootseg = e.vector >> 16;
36059                       0000A296            .738:
36060                                           ! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
36061 A296           8B46         E6            mov	ax,-$1A[bp]
36062 A299           8B5E         E8            mov	bx,-$18[bp]
36063 A29C           93                         xchg	bx,ax
36064 A29D           31DB                       xor	bx,bx
36065                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
36066 A29F           8946         F8            mov	-8[bp],ax
36067                                           !BCC_EOS
36068                                           ! 5209     bootip = e.vector & 0xffff;
36069                                           ! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
36070                                           ! Debug: expression subtree swapping
36071 A2A2           B8                   FFFF  mov	ax,#$FFFF
36072 A2A5           31DB                       xor	bx,bx
36073 A2A7           8D7E         E6            lea	di,-$1A[bp]
36074 A2AA           E8         5E0E            call	landul
36075                                           ! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
36076 A2AD           8946         F6            mov	-$A[bp],ax
36077                                           !BCC_EOS
36078                                           ! 5210     break;
36079 A2B0           EB           22            jmp .726
36080                                           !BCC_EOS
36081                                           ! 5211   default: return;
36082                       0000A2B2            .739:
36083 A2B2           89EC                       mov	sp,bp
36084 A2B4           5D                         pop	bp
36085 A2B5           C3                         ret
36086                                           !BCC_EOS
36087                                           ! 5212   }
36088                                           ! 5213   ;
36089 A2B6           EB           1C            jmp .726
36090                       0000A2B8            .728:
36091 A2B8           2D                   0001  sub	ax,*1
36092 A2BB         0F84         FECF            beq 	.729
36093 A2BF           2D                   0001  sub	ax,*1
36094 A2C2         0F84         FEC8            beq 	.72A
36095 A2C6           2D                   0001  sub	ax,*1
36096 A2C9         0F84         FF71            beq 	.735
36097 A2CD           2D                   007D  sub	ax,*$7D
36098 A2D0           74           C4            je 	.738
36099 A2D2           EB           DE            jmp	.739
36100                       0000A2D4            .726:
36101                       FFFFFFE0            ..FFDB	=	-$20
36102                                           !BCC_EOS
36103                                           ! 5214 #asm
36104                                           !BCC_EOS
36105                                           !BCC_ASM
36106                       00000014            _int18_function.bootip	set	$14
36107                       FFFFFFF6            .int18_function.bootip	set	-$A
36108                       00000022            _int18_function.seq_nr	set	$22
36109                       00000004            .int18_function.seq_nr	set	4
36110                       00000018            _int18_function.bootchk	set	$18
36111                       FFFFFFFA            .int18_function.bootchk	set	-6
36112                       00000016            _int18_function.bootseg	set	$16
36113                       FFFFFFF8            .int18_function.bootseg	set	-8
36114                       0000001C            _int18_function.ebda_seg	set	$1C
36115                       FFFFFFFE            .int18_function.ebda_seg	set	-2
36116                       00000012            _int18_function.status	set	$12
36117                       FFFFFFF4            .int18_function.status	set	-$C
36118                       00000010            _int18_function.bootfirst	set	$10
36119                       FFFFFFF2            .int18_function.bootfirst	set	-$E
36120                       00000019            _int18_function.bootdrv	set	$19
36121                       FFFFFFFB            .int18_function.bootdrv	set	-5
36122                       0000001A            _int18_function.bootdev	set	$1A
36123                       FFFFFFFC            .int18_function.bootdev	set	-4
36124                       00000000            _int18_function.e	set	0
36125                       FFFFFFE2            .int18_function.e	set	-$1E
36126 A2D4           89E5                           mov bp, sp
36127 A2D6           0E                             push cs
36128 A2D7           68                   A828      push #int18_handler
36129                                               ;; Build an iret stack frame that will take us to the boot vector.
36130                                               ;; iret pops ip, then cs, then flags, so push them in the opposite order.
36131 A2DA           9C                             pushf
36132 A2DB           8B46         16                mov ax, _int18_function.bootseg + 0[bp]
36133 A2DE           50                             push ax
36134 A2DF           8B46         14                mov ax, _int18_function.bootip + 0[bp]
36135 A2E2           50                             push ax
36136                                               ;; Set the magic number in ax and the boot drive in dl.
36137 A2E3           B8                   AA55      mov ax, #0xaa55
36138 A2E6           8A56         19                mov dl, _int18_function.bootdrv + 0[bp]
36139                                               ;; Zero some of the other registers.
36140 A2E9           31DB                           xor bx, bx
36141 A2EB           8EDB                           mov ds, bx
36142 A2ED           8EC3                           mov es, bx
36143 A2EF           89DD                           mov bp, bx
36144                                               ;; Go!
36145 A2F1           CF                             iret
36146                                           ! 5235 endasm
36147                                           !BCC_ENDASM
36148                                           !BCC_EOS
36149                                           ! 5236 }
36150 A2F2           89EC                       mov	sp,bp
36151 A2F4           5D                         pop	bp
36152 A2F5           C3                         ret
36153                                           ! 5237   void
36154                                           ! Register BX used in function int18_function
36155                                           ! 5238 int1a_function(regs, ds, iret_addr)
36156                                           ! 5239   pusha_regs_t regs;
36157                                           export	_int1a_function
36158                       0000A2F6            _int1a_function:
36159                                           !BCC_EOS
36160                                           ! 5240   Bit16u ds;
36161                                           !BCC_EOS
36162                                           ! 5241   iret_addr_t iret_addr;
36163                                           !BCC_EOS
36164                                           ! 5242 {
36165                                           ! 5243   Bit8u val8;
36166                                           !BCC_EOS
36167                                           ! 5244   ;
36168 A2F6           55                         push	bp
36169 A2F7           89E5                       mov	bp,sp
36170 A2F9           4C                         dec	sp
36171 A2FA           4C                         dec	sp
36172                                           !BCC_EOS
36173                                           ! 5245 #asm
36174                                           !BCC_EOS
36175                                           !BCC_ASM
36176                       00000016            _int1a_function.ds	set	$16
36177                       00000014            .int1a_function.ds	set	$14
36178                       00000001            _int1a_function.val8	set	1
36179                       FFFFFFFF            .int1a_function.val8	set	-1
36180                       00000018            _int1a_function.iret_addr	set	$18
36181                       00000016            .int1a_function.iret_addr	set	$16
36182                       00000006            _int1a_function.regs	set	6
36183                       00000004            .int1a_function.regs	set	4
36184 A2FB           FB                           sti
36185                                           ! 5247 endasm
36186                                           !BCC_ENDASM
36187                                           !BCC_EOS
36188                                           ! 5248   switch (regs.u.r8.ah) {
36189 A2FC           8A46         13            mov	al,$13[bp]
36190 A2FF           E9         0309            br 	.73C
36191                                           ! 5249     case 0:
36192                                           ! 5250 #asm
36193                       0000A302            .73D:
36194                                           !BCC_EOS
36195                                           !BCC_ASM
36196                       00000016            _int1a_function.ds	set	$16
36197                       00000014            .int1a_function.ds	set	$14
36198                       00000001            _int1a_function.val8	set	1
36199                       FFFFFFFF            .int1a_function.val8	set	-1
36200                       00000018            _int1a_function.iret_addr	set	$18
36201                       00000016            .int1a_function.iret_addr	set	$16
36202                       00000006            _int1a_function.regs	set	6
36203                       00000004            .int1a_function.regs	set	4
36204 A302           FA                               cli
36205                                           ! 5252 endasm
36206                                           !BCC_ENDASM
36207                                           !BCC_EOS
36208                                           ! 5253       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
36209                                           ! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
36210 A303           A1         046E            mov	ax,[$46E]
36211 A306           8946         10            mov	$10[bp],ax
36212                                           !BCC_EOS
36213                                           ! 5254       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
36214                                           ! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
36215 A309           A1         046C            mov	ax,[$46C]
36216 A30C           8946         0E            mov	$E[bp],ax
36217                                           !BCC_EOS
36218                                           ! 5255       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
36219                                           ! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
36220 A30F           A0         0470            mov	al,[$470]
36221 A312           8846         12            mov	$12[bp],al
36222                                           !BCC_EOS
36223                                           ! 5256       ((bios_data_t *) 0)->midnight_flag = 0;
36224                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
36225 A315           30C0                       xor	al,al
36226 A317           A2         0470            mov	[$470],al
36227                                           !BCC_EOS
36228                                           ! 5257 #asm
36229                                           !BCC_EOS
36230                                           !BCC_ASM
36231                       00000016            _int1a_function.ds	set	$16
36232                       00000014            .int1a_function.ds	set	$14
36233                       00000001            _int1a_function.val8	set	1
36234                       FFFFFFFF            .int1a_function.val8	set	-1
36235                       00000018            _int1a_function.iret_addr	set	$18
36236                       00000016            .int1a_function.iret_addr	set	$16
36237                       00000006            _int1a_function.regs	set	6
36238                       00000004            .int1a_function.regs	set	4
36239 A31A           FB                               sti
36240                                           ! 5259 endasm
36241                                           !BCC_ENDASM
36242                                           !BCC_EOS
36243                                           ! 5260       iret_addr.flags.u.r8.flagsl &= 0xfe;
36244                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36245 A31B           8A46         1A            mov	al,$1A[bp]
36246 A31E           24                     FE  and	al,#$FE
36247 A320           8846         1A            mov	$1A[bp],al
36248                                           !BCC_EOS
36249                                           ! 5261       break;
36250 A323           E9         030E            br 	.73A
36251                                           !BCC_EOS
36252                                           ! 5262     case 1:
36253                                           ! 5263 #asm
36254                       0000A326            .73E:
36255                                           !BCC_EOS
36256                                           !BCC_ASM
36257                       00000016            _int1a_function.ds	set	$16
36258                       00000014            .int1a_function.ds	set	$14
36259                       00000001            _int1a_function.val8	set	1
36260                       FFFFFFFF            .int1a_function.val8	set	-1
36261                       00000018            _int1a_function.iret_addr	set	$18
36262                       00000016            .int1a_function.iret_addr	set	$16
36263                       00000006            _int1a_function.regs	set	6
36264                       00000004            .int1a_function.regs	set	4
36265 A326           FA                               cli
36266                                           ! 5265 endasm
36267                                           !BCC_ENDASM
36268                                           !BCC_EOS
36269                                           ! 5266       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
36270                                           ! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
36271 A327           8B46         10            mov	ax,$10[bp]
36272 A32A           A3         046E            mov	[$46E],ax
36273                                           !BCC_EOS
36274                                           ! 5267       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
36275                                           ! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
36276 A32D           8B46         0E            mov	ax,$E[bp]
36277 A330           A3         046C            mov	[$46C],ax
36278                                           !BCC_EOS
36279                                           ! 5268       ((bios_data_t *) 0)->midnight_flag = 0;
36280                                           ! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
36281 A333           30C0                       xor	al,al
36282 A335           A2         0470            mov	[$470],al
36283                                           !BCC_EOS
36284                                           ! 5269 #asm
36285                                           !BCC_EOS
36286                                           !BCC_ASM
36287                       00000016            _int1a_function.ds	set	$16
36288                       00000014            .int1a_function.ds	set	$14
36289                       00000001            _int1a_function.val8	set	1
36290                       FFFFFFFF            .int1a_function.val8	set	-1
36291                       00000018            _int1a_function.iret_addr	set	$18
36292                       00000016            .int1a_function.iret_addr	set	$16
36293                       00000006            _int1a_function.regs	set	6
36294                       00000004            .int1a_function.regs	set	4
36295 A338           FB                               sti
36296                                           ! 5271 endasm
36297                                           !BCC_ENDASM
36298                                           !BCC_EOS
36299                                           ! 5272       regs.u.r8.ah = 0;
36300                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36301 A339           30C0                       xor	al,al
36302 A33B           8846         13            mov	$13[bp],al
36303                                           !BCC_EOS
36304                                           ! 5273       iret_addr.flags.u.r8.flagsl &= 0xfe;
36305                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36306 A33E           8A46         1A            mov	al,$1A[bp]
36307 A341           24                     FE  and	al,#$FE
36308 A343           8846         1A            mov	$1A[bp],al
36309                                           !BCC_EOS
36310                                           ! 5274       break;
36311 A346           E9         02EB            br 	.73A
36312                                           !BCC_EOS
36313                                           ! 5275     case 2:
36314                                           ! 5276       if (rtc_updating()) {
36315                       0000A349            .73F:
36316                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36317 A349           E8         6274            call	_rtc_updating
36318 A34C           85C0                       test	ax,ax
36319 A34E           74           0B            je  	.740
36320                       0000A350            .741:
36321                                           ! 5277         iret_addr.flags.u.r8.flagsl |= 0x01;
36322                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36323 A350           8A46         1A            mov	al,$1A[bp]
36324 A353           0C                     01  or	al,*1
36325 A355           8846         1A            mov	$1A[bp],al
36326                                           !BCC_EOS
36327                                           ! 5278         break;
36328 A358           E9         02D9            br 	.73A
36329                                           !BCC_EOS
36330                                           ! 5279         }
36331                                           ! 5280       regs.u.r8.dh = inb_cmos(0x00);
36332                       0000A35B            .740:
36333                                           ! Debug: list int = const 0 (used reg = )
36334 A35B           31C0                       xor	ax,ax
36335 A35D           50                         push	ax
36336                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36337 A35E           E8         6222            call	_inb_cmos
36338 A361           44                         inc	sp
36339 A362           44                         inc	sp
36340                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
36341 A363           8846         0F            mov	$F[bp],al
36342                                           !BCC_EOS
36343                                           ! 5281       regs.u.r8.cl = inb_cmos(0x02);
36344                                           ! Debug: list int = const 2 (used reg = )
36345 A366           B8                   0002  mov	ax,*2
36346 A369           50                         push	ax
36347                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36348 A36A           E8         6216            call	_inb_cmos
36349 A36D           44                         inc	sp
36350 A36E           44                         inc	sp
36351                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
36352 A36F           8846         10            mov	$10[bp],al
36353                                           !BCC_EOS
36354                                           ! 5282       regs.u.r8.ch = inb_cmos(0x04);
36355                                           ! Debug: list int = const 4 (used reg = )
36356 A372           B8                   0004  mov	ax,*4
36357 A375           50                         push	ax
36358                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36359 A376           E8         620A            call	_inb_cmos
36360 A379           44                         inc	sp
36361 A37A           44                         inc	sp
36362                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
36363 A37B           8846         11            mov	$11[bp],al
36364                                           !BCC_EOS
36365                                           ! 5283       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
36366                                           ! Debug: list int = const $B (used reg = )
36367 A37E           B8                   000B  mov	ax,*$B
36368 A381           50                         push	ax
36369                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36370 A382           E8         61FE            call	_inb_cmos
36371 A385           44                         inc	sp
36372 A386           44                         inc	sp
36373                                           ! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
36374 A387           24                     01  and	al,*1
36375                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
36376 A389           8846         0E            mov	$E[bp],al
36377                                           !BCC_EOS
36378                                           ! 5284       regs.u.r8.ah = 0;
36379                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36380 A38C           30C0                       xor	al,al
36381 A38E           8846         13            mov	$13[bp],al
36382                                           !BCC_EOS
36383                                           ! 5285       regs.u.r8.al = regs.u.r8.ch;
36384                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
36385 A391           8A46         11            mov	al,$11[bp]
36386 A394           8846         12            mov	$12[bp],al
36387                                           !BCC_EOS
36388                                           ! 5286       iret_addr.flags.u.r8.flagsl &= 0xfe;
36389                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36390 A397           8A46         1A            mov	al,$1A[bp]
36391 A39A           24                     FE  and	al,#$FE
36392 A39C           8846         1A            mov	$1A[bp],al
36393                                           !BCC_EOS
36394                                           ! 5287       break;
36395 A39F           E9         0292            br 	.73A
36396                                           !BCC_EOS
36397                                           ! 5288     case 3:
36398                                           ! 5289       if (rtc_updating()) {
36399                       0000A3A2            .742:
36400                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36401 A3A2           E8         621B            call	_rtc_updating
36402 A3A5           85C0                       test	ax,ax
36403 A3A7           74           03            je  	.743
36404                       0000A3A9            .744:
36405                                           ! 5290         init_rtc();
36406                                           ! Debug: func () void = init_rtc+0 (used reg = )
36407 A3A9           E8         61E3            call	_init_rtc
36408                                           !BCC_EOS
36409                                           ! 5291         }
36410                                           ! 5292       outb_cmos(0x00, regs.u.r8.dh);
36411                       0000A3AC            .743:
36412                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36413 A3AC           8A46         0F            mov	al,$F[bp]
36414 A3AF           30E4                       xor	ah,ah
36415 A3B1           50                         push	ax
36416                                           ! Debug: list int = const 0 (used reg = )
36417 A3B2           31C0                       xor	ax,ax
36418 A3B4           50                         push	ax
36419                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36420 A3B5           E8         61BC            call	_outb_cmos
36421 A3B8           83C4                   04  add	sp,*4
36422                                           !BCC_EOS
36423                                           ! 5293       outb_cmos(0x02, regs.u.r8.cl);
36424                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36425 A3BB           8A46         10            mov	al,$10[bp]
36426 A3BE           30E4                       xor	ah,ah
36427 A3C0           50                         push	ax
36428                                           ! Debug: list int = const 2 (used reg = )
36429 A3C1           B8                   0002  mov	ax,*2
36430 A3C4           50                         push	ax
36431                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36432 A3C5           E8         61AC            call	_outb_cmos
36433 A3C8           83C4                   04  add	sp,*4
36434                                           !BCC_EOS
36435                                           ! 5294       outb_cmos(0x04, regs.u.r8.ch);
36436                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36437 A3CB           8A46         11            mov	al,$11[bp]
36438 A3CE           30E4                       xor	ah,ah
36439 A3D0           50                         push	ax
36440                                           ! Debug: list int = const 4 (used reg = )
36441 A3D1           B8                   0004  mov	ax,*4
36442 A3D4           50                         push	ax
36443                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36444 A3D5           E8         619C            call	_outb_cmos
36445 A3D8           83C4                   04  add	sp,*4
36446                                           !BCC_EOS
36447                                           ! 5295       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
36448                                           ! Debug: expression subtree swapping
36449                                           ! Debug: list int = const $B (used reg = )
36450 A3DB           B8                   000B  mov	ax,*$B
36451 A3DE           50                         push	ax
36452                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36453 A3DF           E8         61A1            call	_inb_cmos
36454 A3E2           44                         inc	sp
36455 A3E3           44                         inc	sp
36456                                           ! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
36457 A3E4           24                     60  and	al,*$60
36458                                           ! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
36459 A3E6           0C                     02  or	al,*2
36460 A3E8           50                         push	ax
36461                                           ! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
36462 A3E9           8A46         0E            mov	al,$E[bp]
36463 A3EC           24                     01  and	al,*1
36464                                           ! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
36465 A3EE           0A46         FC            or	al,0+..FFDA[bp]
36466 A3F1           44                         inc	sp
36467 A3F2           44                         inc	sp
36468                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36469 A3F3           8846         FF            mov	-1[bp],al
36470                                           !BCC_EOS
36471                                           ! 5296       outb_cmos(0x0b, val8);
36472                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
36473 A3F6           8A46         FF            mov	al,-1[bp]
36474 A3F9           30E4                       xor	ah,ah
36475 A3FB           50                         push	ax
36476                                           ! Debug: list int = const $B (used reg = )
36477 A3FC           B8                   000B  mov	ax,*$B
36478 A3FF           50                         push	ax
36479                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36480 A400           E8         6171            call	_outb_cmos
36481 A403           83C4                   04  add	sp,*4
36482                                           !BCC_EOS
36483                                           ! 5297       regs.u.r8.ah = 0;
36484                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36485 A406           30C0                       xor	al,al
36486 A408           8846         13            mov	$13[bp],al
36487                                           !BCC_EOS
36488                                           ! 5298       regs.u.r8.al = val8;
36489                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36490 A40B           8A46         FF            mov	al,-1[bp]
36491 A40E           8846         12            mov	$12[bp],al
36492                                           !BCC_EOS
36493                                           ! 5299       iret_addr.flags.u.r8.flagsl &= 0xfe;
36494                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36495 A411           8A46         1A            mov	al,$1A[bp]
36496 A414           24                     FE  and	al,#$FE
36497 A416           8846         1A            mov	$1A[bp],al
36498                                           !BCC_EOS
36499                                           ! 5300       break;
36500 A419           E9         0218            br 	.73A
36501                                           !BCC_EOS
36502                                           ! 5301     case 4:
36503                                           ! 5302       regs.u.r8.ah = 0;
36504                       0000A41C            .745:
36505                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36506 A41C           30C0                       xor	al,al
36507 A41E           8846         13            mov	$13[bp],al
36508                                           !BCC_EOS
36509                                           ! 5303 
36510                                           ! 5303       if (rtc_updating()) {
36511                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36512 A421           E8         619C            call	_rtc_updating
36513 A424           85C0                       test	ax,ax
36514 A426           74           0B            je  	.746
36515                       0000A428            .747:
36516                                           ! 5304         iret_addr.flags.u.r8.flagsl |= 0x01;
36517                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36518 A428           8A46         1A            mov	al,$1A[bp]
36519 A42B           0C                     01  or	al,*1
36520 A42D           8846         1A            mov	$1A[bp],al
36521                                           !BCC_EOS
36522                                           ! 5305         break;
36523 A430           E9         0201            br 	.73A
36524                                           !BCC_EOS
36525                                           ! 5306         }
36526                                           ! 5307       regs.u.r8.cl = inb_cmos(0x09);
36527                       0000A433            .746:
36528                                           ! Debug: list int = const 9 (used reg = )
36529 A433           B8                   0009  mov	ax,*9
36530 A436           50                         push	ax
36531                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36532 A437           E8         6149            call	_inb_cmos
36533 A43A           44                         inc	sp
36534 A43B           44                         inc	sp
36535                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
36536 A43C           8846         10            mov	$10[bp],al
36537                                           !BCC_EOS
36538                                           ! 5308       regs.u.r8.dh = inb_cmos(0x08);
36539                                           ! Debug: list int = const 8 (used reg = )
36540 A43F           B8                   0008  mov	ax,*8
36541 A442           50                         push	ax
36542                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36543 A443           E8         613D            call	_inb_cmos
36544 A446           44                         inc	sp
36545 A447           44                         inc	sp
36546                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
36547 A448           8846         0F            mov	$F[bp],al
36548                                           !BCC_EOS
36549                                           ! 5309       regs.u.r8.dl = inb_cmos(0x07);
36550                                           ! Debug: list int = const 7 (used reg = )
36551 A44B           B8                   0007  mov	ax,*7
36552 A44E           50                         push	ax
36553                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36554 A44F           E8         6131            call	_inb_cmos
36555 A452           44                         inc	sp
36556 A453           44                         inc	sp
36557                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
36558 A454           8846         0E            mov	$E[bp],al
36559                                           !BCC_EOS
36560                                           ! 5310       regs.u.r8.ch = inb_cmos(0x32);
36561                                           ! Debug: list int = const $32 (used reg = )
36562 A457           B8                   0032  mov	ax,*$32
36563 A45A           50                         push	ax
36564                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36565 A45B           E8         6125            call	_inb_cmos
36566 A45E           44                         inc	sp
36567 A45F           44                         inc	sp
36568                                           ! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
36569 A460           8846         11            mov	$11[bp],al
36570                                           !BCC_EOS
36571                                           ! 5311       regs.u.r8.al = regs.u.r8.ch;
36572                                           ! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
36573 A463           8A46         11            mov	al,$11[bp]
36574 A466           8846         12            mov	$12[bp],al
36575                                           !BCC_EOS
36576                                           ! 5312       iret_addr.flags.u.r8.flagsl &= 0xfe;
36577                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36578 A469           8A46         1A            mov	al,$1A[bp]
36579 A46C           24                     FE  and	al,#$FE
36580 A46E           8846         1A            mov	$1A[bp],al
36581                                           !BCC_EOS
36582                                           ! 5313       break;
36583 A471           E9         01C0            br 	.73A
36584                                           !BCC_EOS
36585                                           ! 5314     case 5:
36586                                           ! 5315       if (rtc_updating()) {
36587                       0000A474            .748:
36588                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36589 A474           E8         6149            call	_rtc_updating
36590 A477           85C0                       test	ax,ax
36591 A479           74           0E            je  	.749
36592                       0000A47B            .74A:
36593                                           ! 5316         init_rtc();
36594                                           ! Debug: func () void = init_rtc+0 (used reg = )
36595 A47B           E8         6111            call	_init_rtc
36596                                           !BCC_EOS
36597                                           ! 5317         iret_addr.flags.u.r8.flagsl |= 0x01;
36598                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36599 A47E           8A46         1A            mov	al,$1A[bp]
36600 A481           0C                     01  or	al,*1
36601 A483           8846         1A            mov	$1A[bp],al
36602                                           !BCC_EOS
36603                                           ! 5318         break;
36604 A486           E9         01AB            br 	.73A
36605                                           !BCC_EOS
36606                                           ! 5319         }
36607                                           ! 5320       outb_cmos(0x09, regs.u.r8.cl);
36608                       0000A489            .749:
36609                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36610 A489           8A46         10            mov	al,$10[bp]
36611 A48C           30E4                       xor	ah,ah
36612 A48E           50                         push	ax
36613                                           ! Debug: list int = const 9 (used reg = )
36614 A48F           B8                   0009  mov	ax,*9
36615 A492           50                         push	ax
36616                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36617 A493           E8         60DE            call	_outb_cmos
36618 A496           83C4                   04  add	sp,*4
36619                                           !BCC_EOS
36620                                           ! 5321       outb_cmos(0x08, regs.u.r8.dh);
36621                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36622 A499           8A46         0F            mov	al,$F[bp]
36623 A49C           30E4                       xor	ah,ah
36624 A49E           50                         push	ax
36625                                           ! Debug: list int = const 8 (used reg = )
36626 A49F           B8                   0008  mov	ax,*8
36627 A4A2           50                         push	ax
36628                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36629 A4A3           E8         60CE            call	_outb_cmos
36630 A4A6           83C4                   04  add	sp,*4
36631                                           !BCC_EOS
36632                                           ! 5322       outb_cmos(0x07, regs.u.r8.dl);
36633                                           ! Debug: list unsigned char regs = [S+4+$C] (used reg = )
36634 A4A9           8A46         0E            mov	al,$E[bp]
36635 A4AC           30E4                       xor	ah,ah
36636 A4AE           50                         push	ax
36637                                           ! Debug: list int = const 7 (used reg = )
36638 A4AF           B8                   0007  mov	ax,*7
36639 A4B2           50                         push	ax
36640                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36641 A4B3           E8         60BE            call	_outb_cmos
36642 A4B6           83C4                   04  add	sp,*4
36643                                           !BCC_EOS
36644                                           ! 5323       outb_cmos(0x32, regs.u.r8.ch);
36645                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36646 A4B9           8A46         11            mov	al,$11[bp]
36647 A4BC           30E4                       xor	ah,ah
36648 A4BE           50                         push	ax
36649                                           ! Debug: list int = const $32 (used reg = )
36650 A4BF           B8                   0032  mov	ax,*$32
36651 A4C2           50                         push	ax
36652                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36653 A4C3           E8         60AE            call	_outb_cmos
36654 A4C6           83C4                   04  add	sp,*4
36655                                           !BCC_EOS
36656                                           ! 5324       val8 = inb_cmos(0x0b) & 0x7f;
36657                                           ! Debug: list int = const $B (used reg = )
36658 A4C9           B8                   000B  mov	ax,*$B
36659 A4CC           50                         push	ax
36660                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36661 A4CD           E8         60B3            call	_inb_cmos
36662 A4D0           44                         inc	sp
36663 A4D1           44                         inc	sp
36664                                           ! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
36665 A4D2           24                     7F  and	al,*$7F
36666                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36667 A4D4           8846         FF            mov	-1[bp],al
36668                                           !BCC_EOS
36669                                           ! 5325       outb_cmos(0x0b, val8);
36670                                           ! Debug: list unsigned char val8 = [S+4-3] (used reg = )
36671 A4D7           8A46         FF            mov	al,-1[bp]
36672 A4DA           30E4                       xor	ah,ah
36673 A4DC           50                         push	ax
36674                                           ! Debug: list int = const $B (used reg = )
36675 A4DD           B8                   000B  mov	ax,*$B
36676 A4E0           50                         push	ax
36677                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36678 A4E1           E8         6090            call	_outb_cmos
36679 A4E4           83C4                   04  add	sp,*4
36680                                           !BCC_EOS
36681                                           ! 5326       regs.u.r8.ah = 0;
36682                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36683 A4E7           30C0                       xor	al,al
36684 A4E9           8846         13            mov	$13[bp],al
36685                                           !BCC_EOS
36686                                           ! 5327       regs.u.r8.al = val8;
36687                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36688 A4EC           8A46         FF            mov	al,-1[bp]
36689 A4EF           8846         12            mov	$12[bp],al
36690                                           !BCC_EOS
36691                                           ! 5328       iret_addr.flags.u.r8.flagsl &= 0xfe;
36692                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36693 A4F2           8A46         1A            mov	al,$1A[bp]
36694 A4F5           24                     FE  and	al,#$FE
36695 A4F7           8846         1A            mov	$1A[bp],al
36696                                           !BCC_EOS
36697                                           ! 5329       break;
36698 A4FA           E9         0137            br 	.73A
36699                                           !BCC_EOS
36700                                           ! 5330     case 6:
36701                                           ! 5331       val8 = inb_cmos(0x0b);
36702                       0000A4FD            .74B:
36703                                           ! Debug: list int = const $B (used reg = )
36704 A4FD           B8                   000B  mov	ax,*$B
36705 A500           50                         push	ax
36706                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36707 A501           E8         607F            call	_inb_cmos
36708 A504           44                         inc	sp
36709 A505           44                         inc	sp
36710                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36711 A506           8846         FF            mov	-1[bp],al
36712                                           !BCC_EOS
36713                                           ! 5332       regs.u.r16.ax = 0;
36714                                           ! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
36715 A509           31C0                       xor	ax,ax
36716 A50B           8946         12            mov	$12[bp],ax
36717                                           !BCC_EOS
36718                                           ! 5333       if (val8 & 0x20) {
36719                                           ! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
36720 A50E           8A46         FF            mov	al,-1[bp]
36721 A511           24                     20  and	al,*$20
36722 A513           84C0                       test	al,al
36723 A515           74           0B            je  	.74C
36724                       0000A517            .74D:
36725                                           ! 5334         iret_addr.flags.u.r8.flagsl |= 0x01;
36726                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36727 A517           8A46         1A            mov	al,$1A[bp]
36728 A51A           0C                     01  or	al,*1
36729 A51C           8846         1A            mov	$1A[bp],al
36730                                           !BCC_EOS
36731                                           ! 5335         break;
36732 A51F           E9         0112            br 	.73A
36733                                           !BCC_EOS
36734                                           ! 5336         }
36735                                           ! 5337       if (rtc_updating()) {
36736                       0000A522            .74C:
36737                                           ! Debug: func () unsigned short = rtc_updating+0 (used reg = )
36738 A522           E8         609B            call	_rtc_updating
36739 A525           85C0                       test	ax,ax
36740 A527           74           03            je  	.74E
36741                       0000A529            .74F:
36742                                           ! 5338         init_rtc();
36743                                           ! Debug: func () void = init_rtc+0 (used reg = )
36744 A529           E8         6063            call	_init_rtc
36745                                           !BCC_EOS
36746                                           ! 5339         }
36747                                           ! 5340       outb_cmos(0x01, regs.u.r8.dh);
36748                       0000A52C            .74E:
36749                                           ! Debug: list unsigned char regs = [S+4+$D] (used reg = )
36750 A52C           8A46         0F            mov	al,$F[bp]
36751 A52F           30E4                       xor	ah,ah
36752 A531           50                         push	ax
36753                                           ! Debug: list int = const 1 (used reg = )
36754 A532           B8                   0001  mov	ax,*1
36755 A535           50                         push	ax
36756                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36757 A536           E8         603B            call	_outb_cmos
36758 A539           83C4                   04  add	sp,*4
36759                                           !BCC_EOS
36760                                           ! 5341       outb_cmos(0x03, regs.u.r8.cl);
36761                                           ! Debug: list unsigned char regs = [S+4+$E] (used reg = )
36762 A53C           8A46         10            mov	al,$10[bp]
36763 A53F           30E4                       xor	ah,ah
36764 A541           50                         push	ax
36765                                           ! Debug: list int = const 3 (used reg = )
36766 A542           B8                   0003  mov	ax,*3
36767 A545           50                         push	ax
36768                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36769 A546           E8         602B            call	_outb_cmos
36770 A549           83C4                   04  add	sp,*4
36771                                           !BCC_EOS
36772                                           ! 5342       outb_cmos(0x05, regs.u.r8.ch);
36773                                           ! Debug: list unsigned char regs = [S+4+$F] (used reg = )
36774 A54C           8A46         11            mov	al,$11[bp]
36775 A54F           30E4                       xor	ah,ah
36776 A551           50                         push	ax
36777                                           ! Debug: list int = const 5 (used reg = )
36778 A552           B8                   0005  mov	ax,*5
36779 A555           50                         push	ax
36780                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36781 A556           E8         601B            call	_outb_cmos
36782 A559           83C4                   04  add	sp,*4
36783                                           !BCC_EOS
36784                                           ! 5343       outb(0xa1, inb(0xa1) & 0xfe);
36785                                           ! Debug: list int = const $A1 (used reg = )
36786 A55C           B8                   00A1  mov	ax,#$A1
36787 A55F           50                         push	ax
36788                                           ! Debug: func () unsigned char = inb+0 (used reg = )
36789 A560           E8         5FDB            call	_inb
36790 A563           44                         inc	sp
36791 A564           44                         inc	sp
36792                                           ! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
36793 A565           24                     FE  and	al,#$FE
36794                                           ! Debug: list unsigned char = al+0 (used reg = )
36795 A567           30E4                       xor	ah,ah
36796 A569           50                         push	ax
36797                                           ! Debug: list int = const $A1 (used reg = )
36798 A56A           B8                   00A1  mov	ax,#$A1
36799 A56D           50                         push	ax
36800                                           ! Debug: func () void = outb+0 (used reg = )
36801 A56E           E8         5FE3            call	_outb
36802 A571           83C4                   04  add	sp,*4
36803                                           !BCC_EOS
36804                                           ! 5344       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
36805                                           ! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
36806 A574           8A46         FF            mov	al,-1[bp]
36807 A577           24                     7F  and	al,*$7F
36808                                           ! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
36809 A579           0C                     20  or	al,*$20
36810                                           ! Debug: list unsigned char = al+0 (used reg = )
36811 A57B           30E4                       xor	ah,ah
36812 A57D           50                         push	ax
36813                                           ! Debug: list int = const $B (used reg = )
36814 A57E           B8                   000B  mov	ax,*$B
36815 A581           50                         push	ax
36816                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36817 A582           E8         5FEF            call	_outb_cmos
36818 A585           83C4                   04  add	sp,*4
36819                                           !BCC_EOS
36820                                           ! 5345       iret_addr.flags.u.r8.flagsl &= 0xfe;
36821                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36822 A588           8A46         1A            mov	al,$1A[bp]
36823 A58B           24                     FE  and	al,#$FE
36824 A58D           8846         1A            mov	$1A[bp],al
36825                                           !BCC_EOS
36826                                           ! 5346       break;
36827 A590           E9         00A1            br 	.73A
36828                                           !BCC_EOS
36829                                           ! 5347     case 7:
36830                                           ! 5348       val8 = inb_cmos(0x0b);
36831                       0000A593            .750:
36832                                           ! Debug: list int = const $B (used reg = )
36833 A593           B8                   000B  mov	ax,*$B
36834 A596           50                         push	ax
36835                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
36836 A597           E8         5FE9            call	_inb_cmos
36837 A59A           44                         inc	sp
36838 A59B           44                         inc	sp
36839                                           ! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
36840 A59C           8846         FF            mov	-1[bp],al
36841                                           !BCC_EOS
36842                                           ! 5349       outb_cmos(0x0b, val8 & 0x57);
36843                                           ! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
36844 A59F           8A46         FF            mov	al,-1[bp]
36845 A5A2           24                     57  and	al,*$57
36846                                           ! Debug: list unsigned char = al+0 (used reg = )
36847 A5A4           30E4                       xor	ah,ah
36848 A5A6           50                         push	ax
36849                                           ! Debug: list int = const $B (used reg = )
36850 A5A7           B8                   000B  mov	ax,*$B
36851 A5AA           50                         push	ax
36852                                           ! Debug: func () void = outb_cmos+0 (used reg = )
36853 A5AB           E8         5FC6            call	_outb_cmos
36854 A5AE           83C4                   04  add	sp,*4
36855                                           !BCC_EOS
36856                                           ! 5350       regs.u.r8.ah = 0;
36857                                           ! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
36858 A5B1           30C0                       xor	al,al
36859 A5B3           8846         13            mov	$13[bp],al
36860                                           !BCC_EOS
36861                                           ! 5351       regs.u.r8.al = val8;
36862                                           ! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
36863 A5B6           8A46         FF            mov	al,-1[bp]
36864 A5B9           8846         12            mov	$12[bp],al
36865                                           !BCC_EOS
36866                                           ! 5352       iret_addr.flags.u.r8.flagsl &= 0xfe;
36867                                           ! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
36868 A5BC           8A46         1A            mov	al,$1A[bp]
36869 A5BF           24                     FE  and	al,#$FE
36870 A5C1           8846         1A            mov	$1A[bp],al
36871                                           !BCC_EOS
36872                                           ! 5353       break;
36873 A5C4           EB           6E            jmp .73A
36874                                           !BCC_EOS
36875                                           ! 5354     case 0xb1:
36876                                           ! 5355       if (regs.u.r8.bl == 0xff) {
36877                       0000A5C6            .751:
36878                                           ! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
36879 A5C6           8A46         0C            mov	al,$C[bp]
36880 A5C9           3C                     FF  cmp	al,#$FF
36881 A5CB           75           02            jne 	.752
36882                       0000A5CD            .753:
36883                                           ! 5356         ;
36884                                           !BCC_EOS
36885                                           ! 5357       } else if (regs.u.r8.bl == 0x81) {
36886 A5CD           EB           22            jmp .754
36887                       0000A5CF            .752:
36888                                           ! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
36889 A5CF           8A46         0C            mov	al,$C[bp]
36890 A5D2           3C                     81  cmp	al,#$81
36891 A5D4           75           02            jne 	.755
36892                       0000A5D6            .756:
36893                                           ! 5358         ;
36894                                           !BCC_EOS
36895                                           ! 5359       } else if (regs.u.r8.bl == 0x83) {
36896 A5D6           EB           19            jmp .757
36897                       0000A5D8            .755:
36898                                           ! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
36899 A5D8           8A46         0C            mov	al,$C[bp]
36900 A5DB           3C                     83  cmp	al,#$83
36901 A5DD           75           02            jne 	.758
36902                       0000A5DF            .759:
36903                                           ! 5360         ;
36904                                           !BCC_EOS
36905                                           ! 5361       } else if (regs.u.r8.bl == 0x86) {
36906 A5DF           EB           10            jmp .75A
36907                       0000A5E1            .758:
36908                                           ! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
36909 A5E1           8A46         0C            mov	al,$C[bp]
36910 A5E4           3C                     86  cmp	al,#$86
36911 A5E6           75           09            jne 	.75B
36912                       0000A5E8            .75C:
36913                                           ! 5362         if (regs.u.r8.al == 0x02) {
36914                                           ! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
36915 A5E8           8A46         12            mov	al,$12[bp]
36916 A5EB           3C                     02  cmp	al,*2
36917 A5ED           75           02            jne 	.75D
36918                       0000A5EF            .75E:
36919                                           ! 5363           ;
36920                                           !BCC_EOS
36921                                           ! 5364         } else {
36922 A5EF           EB           00            jmp .75F
36923                       0000A5F1            .75D:
36924                                           ! 5365           ;
36925                                           !BCC_EOS
36926                                           ! 5366         }
36927                                           ! 5367       }
36928                       0000A5F1            .75F:
36929                                           ! 5368       regs.u.r8.ah = regs.u.r8.bl;
36930                       0000A5F1            .75B:
36931                       0000A5F1            .75A:
36932                       0000A5F1            .757:
36933                       0000A5F1            .754:
36934                                           ! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
36935 A5F1           8A46         0C            mov	al,$C[bp]
36936 A5F4           8846         13            mov	$13[bp],al
36937                                           !BCC_EOS
36938                                           ! 5369       iret_addr.flags.u.r8.flagsl |= 0x01;
36939                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36940 A5F7           8A46         1A            mov	al,$1A[bp]
36941 A5FA           0C                     01  or	al,*1
36942 A5FC           8846         1A            mov	$1A[bp],al
36943                                           !BCC_EOS
36944                                           ! 5370       break;
36945 A5FF           EB           33            jmp .73A
36946                                           !BCC_EOS
36947                                           ! 5371     default:
36948                                           ! 5372       iret_addr.flags.u.r8.flagsl |= 0x01;
36949                       0000A601            .760:
36950                                           ! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
36951 A601           8A46         1A            mov	al,$1A[bp]
36952 A604           0C                     01  or	al,*1
36953 A606           8846         1A            mov	$1A[bp],al
36954                                           !BCC_EOS
36955                                           ! 5373     }
36956                                           ! 5374 }
36957 A609           EB           29            jmp .73A
36958                       0000A60B            .73C:
36959 A60B           2C                     00  sub	al,*0
36960 A60D           72           F2            jb 	.760
36961 A60F           3C                     07  cmp	al,*7
36962 A611           77           1B            ja  	.761
36963 A613           30E4                       xor	ah,ah
36964 A615           D1E0                       shl	ax,*1
36965 A617           89C3                       mov	bx,ax
36966 A619           2E                         seg	cs
36967 A61A           FFA7       A61E            br	.762[bx]
36968                       0000A61E            .762:
36969 A61E                      A302            .word	.73D
36970 A620                      A326            .word	.73E
36971 A622                      A349            .word	.73F
36972 A624                      A3A2            .word	.742
36973 A626                      A41C            .word	.745
36974 A628                      A474            .word	.748
36975 A62A                      A4FD            .word	.74B
36976 A62C                      A593            .word	.750
36977                       0000A62E            .761:
36978 A62E           2C                     B1  sub	al,#$B1
36979 A630           74           94            je 	.751
36980 A632           EB           CD            jmp	.760
36981                       0000A634            .73A:
36982                       FFFFFFFC            ..FFDA	=	-4
36983 A634           89EC                       mov	sp,bp
36984 A636           5D                         pop	bp
36985 A637           C3                         ret
36986                                           ! 5375   void
36987                                           ! 5376 int70_function(regs, ds, iret_addr)
36988                                           ! 5377   pusha_regs_t regs;
36989                                           export	_int70_function
36990                       0000A638            _int70_function:
36991                                           !BCC_EOS
36992                                           ! 5378   Bit16u ds;
36993                                           !BCC_EOS
36994                                           ! 5379   iret_addr_t iret_addr;
36995                                           !BCC_EOS
36996                                           ! 5380 {
36997                                           ! 5381   Bit8u registerB = 0, registerC = 0;
36998 A638           55                         push	bp
36999 A639           89E5                       mov	bp,sp
37000 A63B           4C                         dec	sp
37001                                           ! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
37002 A63C           30C0                       xor	al,al
37003 A63E           8846         FF            mov	-1[bp],al
37004 A641           4C                         dec	sp
37005                                           ! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
37006 A642           30C0                       xor	al,al
37007 A644           8846         FE            mov	-2[bp],al
37008                                           !BCC_EOS
37009                                           ! 5382   registerB = in
37010                                           ! 5382 b_cmos( 0xB );
37011                                           ! Debug: list int = const $B (used reg = )
37012 A647           B8                   000B  mov	ax,*$B
37013 A64A           50                         push	ax
37014                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37015 A64B           E8         5F35            call	_inb_cmos
37016 A64E           44                         inc	sp
37017 A64F           44                         inc	sp
37018                                           ! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
37019 A650           8846         FF            mov	-1[bp],al
37020                                           !BCC_EOS
37021                                           ! 5383   registerC = inb_cmos( 0xC );
37022                                           ! Debug: list int = const $C (used reg = )
37023 A653           B8                   000C  mov	ax,*$C
37024 A656           50                         push	ax
37025                                           ! Debug: func () unsigned char = inb_cmos+0 (used reg = )
37026 A657           E8         5F29            call	_inb_cmos
37027 A65A           44                         inc	sp
37028 A65B           44                         inc	sp
37029                                           ! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
37030 A65C           8846         FE            mov	-2[bp],al
37031                                           !BCC_EOS
37032                                           ! 5384   if( ( registerB & 0x60 ) != 0 ) {
37033                                           ! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
37034 A65F           8A46         FF            mov	al,-1[bp]
37035 A662           24                     60  and	al,*$60
37036                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37037 A664           84C0                       test	al,al
37038 A666         0F84         00EF            beq 	.763
37039                       0000A66A            .764:
37040                                           ! 5385     if( ( registerC & 0x20 ) != 0 ) {
37041                                           ! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
37042 A66A           8A46         FE            mov	al,-2[bp]
37043 A66D           24                     20  and	al,*$20
37044                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37045 A66F           84C0                       test	al,al
37046 A671           74           04            je  	.765
37047                       0000A673            .766:
37048                                           ! 5386 #asm
37049                                           !BCC_EOS
37050                                           !BCC_ASM
37051                       00000000            _int70_function.registerC	set	0
37052                       FFFFFFFE            .int70_function.registerC	set	-2
37053                       00000016            _int70_function.ds	set	$16
37054                       00000014            .int70_function.ds	set	$14
37055                       00000001            _int70_function.registerB	set	1
37056                       FFFFFFFF            .int70_function.registerB	set	-1
37057                       00000018            _int70_function.iret_addr	set	$18
37058                       00000016            .int70_function.iret_addr	set	$16
37059                       00000006            _int70_function.regs	set	6
37060                       00000004            .int70_function.regs	set	4
37061 A673           FB                               sti
37062 A674           CD                     4A        int #0x4a
37063 A676           FA                               cli
37064                                           ! 5390 endasm
37065                                           !BCC_ENDASM
37066                                           !BCC_EOS
37067                                           ! 5391     }
37068                                           ! 5392     if( ( registerC & 0x40 ) != 0 ) {
37069                       0000A677            .765:
37070                                           ! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
37071 A677           8A46         FE            mov	al,-2[bp]
37072 A67A           24                     40  and	al,*$40
37073                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37074 A67C           84C0                       test	al,al
37075 A67E         0F84         00D7            beq 	.767
37076                       0000A682            .768:
37077                                           ! 5393       if( read_byte( 0x40, 0xA0 ) != 0 ) {
37078                                           ! Debug: list int = const $A0 (used reg = )
37079 A682           B8                   00A0  mov	ax,#$A0
37080 A685           50                         push	ax
37081                                           ! Debug: list int = const $40 (used reg = )
37082 A686           B8                   0040  mov	ax,*$40
37083 A689           50                         push	ax
37084                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37085 A68A           E8         5F67            call	_read_byte
37086 A68D           83C4                   04  add	sp,*4
37087                                           ! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
37088 A690           84C0                       test	al,al
37089 A692         0F84         00C3            beq 	.769
37090                       0000A696            .76A:
37091                                           ! 5394         Bit32u time, toggle;
37092                                           !BCC_EOS
37093                                           ! 5395         time = read_dword( 0x40, 0x9C );
37094 A696           83C4                   F8  add	sp,*-8
37095                                           ! Debug: list int = const $9C (used reg = )
37096 A699           B8                   009C  mov	ax,#$9C
37097 A69C           50                         push	ax
37098                                           ! Debug: list int = const $40 (used reg = )
37099 A69D           B8                   0040  mov	ax,*$40
37100 A6A0           50                         push	ax
37101                                           ! Debug: func () unsigned long = read_dword+0 (used reg = )
37102 A6A1           E8         59DF            call	_read_dword
37103 A6A4           89D3                       mov	bx,dx
37104 A6A6           83C4                   04  add	sp,*4
37105                                           ! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
37106 A6A9           8946         FA            mov	-6[bp],ax
37107 A6AC           895E         FC            mov	-4[bp],bx
37108                                           !BCC_EOS
37109                                           ! 5396         if( time < 0x3D1 ) {
37110                                           ! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
37111 A6AF           B8                   03D1  mov	ax,#$3D1
37112 A6B2           31DB                       xor	bx,bx
37113 A6B4           8D7E         FA            lea	di,-6[bp]
37114 A6B7           E8         5A11            call	lcmpul
37115 A6BA           76           6A            jbe 	.76B
37116                       0000A6BC            .76C:
37117                                           ! 5397           Bit16u segment, offset;
37118                                           !BCC_EOS
37119                                           ! 5398           segment = read_word( 0x40, 0x98 );
37120 A6BC           83C4                   FC  add	sp,*-4
37121                                           ! Debug: list int = const $98 (used reg = )
37122 A6BF           B8                   0098  mov	ax,#$98
37123 A6C2           50                         push	ax
37124                                           ! Debug: list int = const $40 (used reg = )
37125 A6C3           B8                   0040  mov	ax,*$40
37126 A6C6           50                         push	ax
37127                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
37128 A6C7           E8         5F3D            call	_read_word
37129 A6CA           83C4                   04  add	sp,*4
37130                                           ! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
37131 A6CD           8946         F4            mov	-$C[bp],ax
37132                                           !BCC_EOS
37133                                           ! 5399           offset = read_word( 0x40, 0x9A );
37134                                           ! Debug: list int = const $9A (used reg = )
37135 A6D0           B8                   009A  mov	ax,#$9A
37136 A6D3           50                         push	ax
37137                                           ! Debug: list int = const $40 (used reg = )
37138 A6D4           B8                   0040  mov	ax,*$40
37139 A6D7           50                         push	ax
37140                                           ! Debug: func () unsigned short = read_word+0 (used reg = )
37141 A6D8           E8         5F2C            call	_read_word
37142 A6DB           83C4                   04  add	sp,*4
37143                                           ! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
37144 A6DE           8946         F2            mov	-$E[bp],ax
37145                                           !BCC_EOS
37146                                           ! 5400           write_byte( 0x40, 0xA0, 0 );
37147                                           ! Debug: list int = const 0 (used reg = )
37148 A6E1           31C0                       xor	ax,ax
37149 A6E3           50                         push	ax
37150                                           ! Debug: list int = const $A0 (used reg = )
37151 A6E4           B8                   00A0  mov	ax,#$A0
37152 A6E7           50                         push	ax
37153                                           ! Debug: list int = const $40 (used reg = )
37154 A6E8           B8                   0040  mov	ax,*$40
37155 A6EB           50                         push	ax
37156                                           ! Debug: func () void = write_byte+0 (used reg = )
37157 A6EC           E8         5F2B            call	_write_byte
37158 A6EF           83C4                   06  add	sp,*6
37159                                           !BCC_EOS
37160                                           ! 5401           outb_cmos( 0xB, registerB & 0x37 );
37161                                           ! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
37162 A6F2           8A46         FF            mov	al,-1[bp]
37163 A6F5           24                     37  and	al,*$37
37164                                           ! Debug: list unsigned char = al+0 (used reg = )
37165 A6F7           30E4                       xor	ah,ah
37166 A6F9           50                         push	ax
37167                                           ! Debug: list int = const $B (used reg = )
37168 A6FA           B8                   000B  mov	ax,*$B
37169 A6FD           50                         push	ax
37170                                           ! Debug: func () void = outb_cmos+0 (used reg = )
37171 A6FE           E8         5E73            call	_outb_cmos
37172 A701           83C4                   04  add	sp,*4
37173                                           !BCC_EOS
37174                                           ! 5402           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
37175                                           ! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
37176 A704           FF76         F2            push	-$E[bp]
37177                                           ! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
37178 A707           FF76         F4            push	-$C[bp]
37179                                           ! Debug: func () unsigned char = read_byte+0 (used reg = )
37180 A70A           E8         5EE7            call	_read_byte
37181 A70D           83C4                   04  add	sp,*4
37182                                           ! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
37183 A710           0C                     80  or	al,#$80
37184                                           ! Debug: list unsigned char = al+0 (used reg = )
37185 A712           30E4                       xor	ah,ah
37186 A714           50                         push	ax
37187                                           ! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
37188 A715           FF76         F2            push	-$E[bp]
37189                                           ! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
37190 A718           FF76         F4            push	-$C[bp]
37191                                           ! Debug: func () void = write_byte+0 (used reg = )
37192 A71B           E8         5EFC            call	_write_byte
37193 A71E           83C4                   06  add	sp,*6
37194                                           !BCC_EOS
37195                                           ! 5403         } else {
37196 A721           83C4                   04  add	sp,*4
37197 A724           EB           30            jmp .76D
37198                       0000A726            .76B:
37199                                           ! 5404           time -= 0x3D1;
37200                                           ! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
37201 A726           B8                   03D1  mov	ax,#$3D1
37202 A729           31DB                       xor	bx,bx
37203 A72B           53                         push	bx
37204 A72C           50                         push	ax
37205 A72D           8B46         FA            mov	ax,-6[bp]
37206 A730           8B5E         FC            mov	bx,-4[bp]
37207 A733           8D7E         F2            lea	di,-$E[bp]
37208 A736           E8         59A8            call	lsubul
37209 A739           8946         FA            mov	-6[bp],ax
37210 A73C           895E         FC            mov	-4[bp],bx
37211 A73F           83C4                   04  add	sp,*4
37212                                           !BCC_EOS
37213                                           ! 5405           write_dword( 0x40, 0x9C, time );
37214                                           ! Debug: list unsigned long time = [S+$C-8] (used reg = )
37215 A742           FF76         FC            push	-4[bp]
37216 A745           FF76         FA            push	-6[bp]
37217                                           ! Debug: list int = const $9C (used reg = )
37218 A748           B8                   009C  mov	ax,#$9C
37219 A74B           50                         push	ax
37220                                           ! Debug: list int = const $40 (used reg = )
37221 A74C           B8                   0040  mov	ax,*$40
37222 A74F           50                         push	ax
37223                                           ! Debug: func () void = write_dword+0 (used reg = )
37224 A750           E8         5948            call	_write_dword
37225 A753           83C4                   08  add	sp,*8
37226                                           !BCC_EOS
37227                                           ! 5406         }
37228                                           ! 5407       }
37229                       0000A756            .76D:
37230 A756           83C4                   08  add	sp,*8
37231                                           ! 5408     }
37232                       0000A759            .769:
37233                                           ! 5409   }
37234                       0000A759            .767:
37235                                           ! 5410 #asm
37236                       0000A759            .763:
37237                                           !BCC_EOS
37238                                           !BCC_ASM
37239                       00000000            _int70_function.registerC	set	0
37240                       FFFFFFFE            .int70_function.registerC	set	-2
37241                       00000016            _int70_function.ds	set	$16
37242                       00000014            .int70_function.ds	set	$14
37243                       00000001            _int70_function.registerB	set	1
37244                       FFFFFFFF            .int70_function.registerB	set	-1
37245                       00000018            _int70_function.iret_addr	set	$18
37246                       00000016            .int70_function.iret_addr	set	$16
37247                       00000006            _int70_function.regs	set	6
37248                       00000004            .int70_function.regs	set	4
37249 A759           E8         03FC              call eoi_both_pics
37250                                           ! 5412 endasm
37251                                           !BCC_ENDASM
37252                                           !BCC_EOS
37253                                           ! 5413 }
37254 A75C           89EC                       mov	sp,bp
37255 A75E           5D                         pop	bp
37256 A75F           C3                         ret
37257                                           ! 5414 #asm
37258                                           !BCC_ASM
37259                       00000012            _int70_function.ds	set	$12
37260                       00000014            _int70_function.iret_addr	set	$14
37261                       00000002            _int70_function.regs	set	2
37262                                           ;------------------------------------------
37263                                           ;- INT74h : PS/2 mouse hardware interrupt -
37264                                           ;------------------------------------------
37265                       0000A760            int74_handler:
37266 A760           FB                           sti
37267 A761           60                           pusha
37268 A762           1E                           push ds ;; save DS
37269 A763           6A                     00    push #0x00 ;; placeholder for status
37270 A765           6A                     00    push #0x00 ;; placeholder for X
37271 A767           6A                     00    push #0x00 ;; placeholder for Y
37272 A769           6A                     00    push #0x00 ;; placeholder for Z
37273 A76B           6A                     00    push #0x00 ;; placeholder for make_far_call boolean
37274 A76D           E8         BF84              call _int74_function
37275 A770           59                           pop cx ;; remove make_far_call from stack
37276 A771           E3           0C              jcxz int74_done
37277                                             ;; make far call to EBDA:0022
37278 A773           6A                     00    push #0x00
37279 A775           1F                           pop ds
37280 A776           FF36       040E              push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
37281 A77A           1F                           pop ds
37282 A77B           FF1E       0022              call far ptr[0x22]
37283                       0000A77F            int74_done:
37284 A77F           FA                           cli
37285 A780           E8         03D5              call eoi_both_pics
37286 A783           83C4                   08    add sp, #8 ;; pop status, x, y, z
37287 A786           1F                           pop ds ;; restore DS
37288 A787           61                           popa
37289 A788           CF                           iret
37290                                           ;; This will perform an IRET, but will retain value of current CF
37291                                           ;; by altering flags on stack. Better than RETF #02.
37292                       0000A789            iret_modify_cf:
37293 A789           72           09              jc carry_set
37294 A78B           55                           push bp
37295 A78C           89E5                         mov bp, sp
37296 A78E           8066         06        FE    and BYTE [bp + 0x06], #0xfe
37297 A792           5D                           pop bp
37298 A793           CF                           iret
37299                       0000A794            carry_set:
37300 A794           55                           push bp
37301 A795           89E5                         mov bp, sp
37302 A797           804E         06        01    or BYTE [bp + 0x06], #0x01
37303 A79B           5D                           pop bp
37304 A79C           CF                           iret
37305                                           ;----------------------
37306                                           ;- INT13h (relocated) -
37307                                           ;----------------------
37308                                           ;
37309                                           ; int13_relocated is a little bit messed up since I played with it
37310                                           ; I have to rewrite it:
37311                                           ; - call a function that detect which function to call
37312                                           ; - make all called C function get the same parameters list
37313                                           ;
37314                       0000A79D            int13_relocated:
37315                                             ;; check for an eltorito function
37316 A79D           80FC                   4A    cmp ah,#0x4a
37317 A7A0           72           10              jb int13_not_eltorito
37318 A7A2           80FC                   4D    cmp ah,#0x4d
37319 A7A5           77           0B              ja int13_not_eltorito
37320 A7A7           60                           pusha
37321 A7A8           06                           push es
37322 A7A9           1E                           push ds
37323 A7AA           16                           push ss
37324 A7AB           1F                           pop ds
37325 A7AC           68                   A824    push #int13_out
37326 A7AF           E9         DA06              jmp _int13_eltorito ;; ELDX not used
37327                       0000A7B2            int13_not_eltorito:
37328 A7B2           50                           push ax
37329 A7B3           53                           push bx
37330 A7B4           51                           push cx
37331 A7B5           52                           push dx
37332                                             ;; check if emulation active
37333 A7B6           E8         96CB              call _cdemu_isactive
37334 A7B9           3C                     00    cmp al,#0x00
37335 A7BB           74           2B              je int13_cdemu_inactive
37336                                             ;; check if access to the emulated drive
37337 A7BD           E8         96EB              call _cdemu_emulated_drive
37338 A7C0           5A                           pop dx
37339 A7C1           52                           push dx
37340 A7C2           38D0                         cmp al,dl ;; int13 on emulated drive
37341 A7C4           75           0F              jne int13_nocdemu
37342 A7C6           5A                           pop dx
37343 A7C7           59                           pop cx
37344 A7C8           5B                           pop bx
37345 A7C9           58                           pop ax
37346 A7CA           60                           pusha
37347 A7CB           06                           push es
37348 A7CC           1E                           push ds
37349 A7CD           16                           push ss
37350 A7CE           1F                           pop ds
37351 A7CF           68                   A824    push #int13_out
37352 A7D2           E9         DC1D              jmp _int13_cdemu ;; ELDX not used
37353                       0000A7D5            int13_nocdemu:
37354 A7D5           80E2                   E0    and dl,#0xE0 ;; mask to get device class, including cdroms
37355 A7D8           38D0                         cmp al,dl ;; al is 0x00 or 0x80
37356 A7DA           75           0C              jne int13_cdemu_inactive ;; inactive for device class
37357 A7DC           5A                           pop dx
37358 A7DD           59                           pop cx
37359 A7DE           5B                           pop bx
37360 A7DF           58                           pop ax
37361 A7E0           50                           push ax
37362 A7E1           51                           push cx
37363 A7E2           52                           push dx
37364 A7E3           53                           push bx
37365 A7E4           FECA                         dec dl ;; real drive is dl - 1
37366 A7E6           EB           08              jmp int13_legacy
37367                       0000A7E8            int13_cdemu_inactive:
37368 A7E8           5A                           pop dx
37369 A7E9           59                           pop cx
37370 A7EA           5B                           pop bx
37371 A7EB           58                           pop ax
37372                       0000A7EC            int13_noeltorito:
37373 A7EC           50                           push ax
37374 A7ED           51                           push cx
37375 A7EE           52                           push dx
37376 A7EF           53                           push bx
37377                       0000A7F0            int13_legacy:
37378 A7F0           52                           push dx ;; push eltorito value of dx instead of sp
37379 A7F1           55                           push bp
37380 A7F2           56                           push si
37381 A7F3           57                           push di
37382 A7F4           06                           push es
37383 A7F5           1E                           push ds
37384 A7F6           16                           push ss
37385 A7F7           1F                           pop ds
37386                                             ;; now the 16-bit registers can be restored with:
37387                                             ;; pop ds; pop es; popa; iret
37388                                             ;; arguments passed to functions should be
37389                                             ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
37390 A7F8           F6C2                   80    test dl, #0x80
37391 A7FB           75           06              jnz int13_notfloppy
37392 A7FD           68                   A824    push #int13_out
37393 A800           E9         E605              jmp _int13_diskette_function
37394                       0000A803            int13_notfloppy:
37395 A803           80FA                   E0    cmp dl, #0xE0
37396 A806           72           0F              jb int13_notcdrom
37397 A808     66    C1EB                   10    shr ebx, #16
37398 A80C           53                           push bx
37399 A80D           E8         CEE3              call _int13_cdrom
37400 A810           5B                           pop bx
37401 A811     66    C1E3                   10    shl ebx, #16
37402 A815           EB           0D              jmp int13_out
37403                       0000A817            int13_notcdrom:
37404                       0000A817            int13_disk:
37405                                             ;; int13_harddisk modifies high word of EAX
37406 A817     66    C1E8                   10    shr eax, #16
37407 A81B           50                           push ax
37408 A81C           E8         BFF0              call _int13_harddisk
37409 A81F           58                           pop ax
37410 A820     66    C1E0                   10    shl eax, #16
37411                       0000A824            int13_out:
37412 A824           1F                           pop ds
37413 A825           07                           pop es
37414 A826           61                           popa
37415 A827           CF                           iret
37416                                           ;----------
37417                                           ;- INT18h -
37418                                           ;----------
37419                       0000A828            int18_handler: ;; Boot Failure recovery: try the next device.
37420                                             ;; Reset SP and SS
37421 A828           B8                   0FFE    mov ax, #0x0ffe
37422 A82B           89C4                         mov sp, ax
37423 A82D           B8                   9E00    mov ax, #0x9e00
37424 A830           8ED0                         mov ss, ax
37425                                             ;; The first time we do this it will have been set to -1 so
37426                                             ;; we will start from device 0.
37427 A832           31C0                         xor ax, ax
37428 A834           8ED8                         mov ds, ax
37429 A836           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
37430 A83A           8EDB                         mov ds, bx ;; Set segment
37431 A83C           8B1E       0382              mov bx, 0x0382 ;; BX is now the sequence number
37432 A840           43                           inc bx ;; ++
37433 A841           891E       0382              mov 0x0382, bx ;; Write it back
37434 A845           8ED8                         mov ds, ax ;; and reset the segment to zero.
37435                                             ;; Call the C code for the next boot device
37436 A847           53                           push bx
37437 A848           E8         F839              call _int18_function
37438                                             ;; Boot failed: invoke the boot recovery function...
37439 A84B           CD                     18    int #0x18
37440                                           ;----------
37441                                           ;- INT19h -
37442                                           ;----------
37443                       0000A84D            int19_relocated: ;; Boot function, relocated
37444                                             ;;
37445                                             ;; *** Warning: INT 19h resets the whole machine ***
37446                                             ;;
37447                                             ;; Because PV drivers in HVM guests detach some of the emulated devices,
37448                                             ;; it is not safe to do a soft reboot by just dropping to real mode and
37449                                             ;; invoking INT 19h -- the boot drives might have disappeared!
37450                                             ;; If the user asks for a soft reboot, the only thing we can do is
37451                                             ;; reset the whole machine. When it comes back up, the normal BIOS
37452                                             ;; boot sequence will start, which is more or less the required behaviour.
37453                                             ;;
37454                                             ;; Reset SP and SS
37455 A84D           B8                   0FFE    mov ax, #0x0ffe
37456 A850           89C4                         mov sp, ax
37457 A852           B8                   9E00    mov ax, #0x9e00
37458 A855           8ED0                         mov ss, ax
37459 A857           E8         6A6D              call _machine_reset
37460                                           ;----------
37461                                           ;- INT1Ch -
37462                                           ;----------
37463                       0000A85A            int1c_handler: ;; User Timer Tick
37464 A85A           CF                           iret
37465                                           ;----------------------
37466                                           ;- POST: Floppy Drive -
37467                                           ;----------------------
37468                       0000A85B            floppy_drive_post:
37469 A85B           31C0                         xor ax, ax
37470 A85D           8ED8                         mov ds, ax
37471 A85F           B0                     00    mov al, #0x00
37472 A861           A2         043E              mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
37473 A864           A2         043F              mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
37474 A867           A2         0440              mov 0x0440, al ;; diskette motor timeout counter: not active
37475 A86A           A2         0441              mov 0x0441, al ;; diskette controller status return code
37476 A86D           A2         0442              mov 0x0442, al ;; disk & diskette controller status register 0
37477 A870           A2         0443              mov 0x0443, al ;; diskette controller status register 1
37478 A873           A2         0444              mov 0x0444, al ;; diskette controller status register 2
37479 A876           A2         0445              mov 0x0445, al ;; diskette controller cylinder number
37480 A879           A2         0446              mov 0x0446, al ;; diskette controller head number
37481 A87C           A2         0447              mov 0x0447, al ;; diskette controller sector number
37482 A87F           A2         0448              mov 0x0448, al ;; diskette controller bytes written
37483 A882           A2         048B              mov 0x048b, al ;; diskette configuration data
37484                                             ;; -----------------------------------------------------------------
37485                                             ;; (048F) diskette controller information
37486                                             ;;
37487 A885           B0                     10    mov al, #0x10 ;; get CMOS diskette drive type
37488 A887           E6                     70    out 0x70, AL
37489 A889           E4                     71    in AL, 0x71
37490 A88B           88C4                         mov ah, al ;; save byte to AH
37491                       0000A88D            look_drive0:
37492 A88D           C0E8                   04    shr al, #4 ;; look at top 4 bits for drive 0
37493 A890           74           04              jz f0_missing ;; jump if no drive0
37494 A892           B3                     07    mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
37495 A894           EB           02              jmp look_drive1
37496                       0000A896            f0_missing:
37497 A896           B3                     00    mov bl, #0x00 ;; no drive0
37498                       0000A898            look_drive1:
37499 A898           88E0                         mov al, ah ;; restore from AH
37500 A89A           24                     0F    and al, #0x0f ;; look at bottom 4 bits for drive 1
37501 A89C           74           03              jz f1_missing ;; jump if no drive1
37502 A89E           80CB                   70    or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
37503                       0000A8A1            f1_missing:
37504                                                              ;; leave high bits in BL zerod
37505 A8A1           881E       048F              mov 0x048f, bl ;; put new val in BDA (diskette controller information)
37506                                             ;; -----------------------------------------------------------------
37507 A8A5           B0                     00    mov al, #0x00
37508 A8A7           A2         0490              mov 0x0490, al ;; diskette 0 media state
37509 A8AA           A2         0491              mov 0x0491, al ;; diskette 1 media state
37510                                                              ;; diskette 0,1 operational starting state
37511                                                              ;; drive type has not been determined,
37512                                                              ;; has no changed detection line
37513 A8AD           A2         0492              mov 0x0492, al
37514 A8B0           A2         0493              mov 0x0493, al
37515 A8B3           A2         0494              mov 0x0494, al ;; diskette 0 current cylinder
37516 A8B6           A2         0495              mov 0x0495, al ;; diskette 1 current cylinder
37517 A8B9           B0                     02    mov al, #0x02
37518 A8BB           E6                     0A    out #0x0a, al ;; clear DMA-1 channel 2 mask bit
37519                                             SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
 +a   A8BD           B8                   EFDE    mov ax,  #diskette_param_table2
 +a   A8C0           A3         0078              mov 0x1E*4, ax
 +a   A8C3           B8                   F000    mov ax,  #0xF000
 +a   A8C6           A3         007A              mov 0x1E*4+2, ax
37520                                             SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
 +a   A8C9           B8                   EC59    mov ax,  #int13_diskette
 +a   A8CC           A3         0100              mov 0x40*4, ax
 +a   A8CF           B8                   F000    mov ax,  #0xF000
 +a   A8D2           A3         0102              mov 0x40*4+2, ax
37521                                             SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
 +a   A8D5           B8                   EF57    mov ax,  #int0e_handler
 +a   A8D8           A3         0038              mov 0x0E*4, ax
 +a   A8DB           B8                   F000    mov ax,  #0xF000
 +a   A8DE           A3         003A              mov 0x0E*4+2, ax
37522 A8E1           C3                           ret
37523                                           ;--------------------
37524                                           ;- POST: HARD DRIVE -
37525                                           ;--------------------
37526                                           ; relocated here because the primary POST area isnt big enough.
37527                       0000A8E2            hard_drive_post:
37528 A8E2           B0                     0A    mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
37529 A8E4           BA                   03F6    mov dx, #0x03f6
37530 A8E7           EE                           out dx, al
37531 A8E8           31C0                         xor ax, ax
37532 A8EA           8ED8                         mov ds, ax
37533 A8EC           A2         0474              mov 0x0474, al
37534 A8EF           A2         0477              mov 0x0477, al
37535 A8F2           A2         048C              mov 0x048c, al
37536 A8F5           A2         048D              mov 0x048d, al
37537 A8F8           A2         048E              mov 0x048e, al
37538 A8FB           B0                     01    mov al, #0x01
37539 A8FD           A2         0475              mov 0x0475, al
37540 A900           B0                     C0    mov al, #0xc0
37541 A902           A2         0476              mov 0x0476, al
37542                                             SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
 +a   A905           B8                   E3FE    mov ax,  #int13_handler
 +a   A908           A3         004C              mov 0x13*4, ax
 +a   A90B           B8                   F000    mov ax,  #0xF000
 +a   A90E           A3         004E              mov 0x13*4+2, ax
37543                                             SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
 +a   A911           B8                   ABE7    mov ax,  #int76_handler
 +a   A914           A3         01D8              mov 0x76*4, ax
 +a   A917           B8                   F000    mov ax,  #0xF000
 +a   A91A           A3         01DA              mov 0x76*4+2, ax
37544                                             ;; INT 41h: hard disk 0 configuration pointer
37545                                             ;; INT 46h: hard disk 1 configuration pointer
37546                                             SET_INT_VECTOR(0x41, word ptr [0x40E], #0x003D)
 +a   A91D           B8                   003D    mov ax,  #0x003D
 +a   A920           A3         0104              mov 0x41*4, ax
 +a   A923           A1         040E              mov ax,  word ptr [0x40E]
 +a   A926           A3         0106              mov 0x41*4+2, ax
37547                                             SET_INT_VECTOR(0x46, word ptr [0x40E], #0x004D)
 +a   A929           B8                   004D    mov ax,  #0x004D
 +a   A92C           A3         0118              mov 0x46*4, ax
 +a   A92F           A1         040E              mov ax,  word ptr [0x40E]
 +a   A932           A3         011A              mov 0x46*4+2, ax
37548                                             ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
37549 A935           B0                     12    mov al, #0x12
37550 A937           E6                     70    out #0x70, al
37551 A939           E4                     71    in al, #0x71
37552 A93B           24                     F0    and al, #0xf0
37553 A93D           3C                     F0    cmp al, #0xf0
37554 A93F           74           03              je post_d0_extended
37555 A941           E9         00D8              jmp check_for_hd1
37556                       0000A944            post_d0_extended:
37557 A944           B0                     19    mov al, #0x19
37558 A946           E6                     70    out #0x70, al
37559 A948           E4                     71    in al, #0x71
37560 A94A           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
37561 A94C           74           07              je post_d0_type47
37562                                             HALT(9030)
 +a   A94E           BA                   0400    mov dx,#0x400
 +a   A951           B8                   2346    mov ax,#9030
 +a   A954           EF                           out dx,ax
37563                       0000A955            post_d0_type47:
37564                                             ;; CMOS purpose param table offset
37565                                             ;; 1b cylinders low 0
37566                                             ;; 1c cylinders high 1
37567                                             ;; 1d heads 2
37568                                             ;; 1e write pre-comp low 5
37569                                             ;; 1f write pre-comp high 6
37570                                             ;; 20 retries/bad map/heads>8 8
37571                                             ;; 21 landing zone low C
37572                                             ;; 22 landing zone high D
37573                                             ;; 23 sectors/track E
37574 A955           31C0                         xor ax, ax
37575 A957           8ED8                         mov ds, ax
37576 A959           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
37577 A95C           8ED8                         mov ds, ax
37578                                             ;;; Filling EBDA table for hard disk 0.
37579 A95E           B0                     1F    mov al, #0x1f
37580 A960           E6                     70    out #0x70, al
37581 A962           E4                     71    in al, #0x71
37582 A964           88C4                         mov ah, al
37583 A966           B0                     1E    mov al, #0x1e
37584 A968           E6                     70    out #0x70, al
37585 A96A           E4                     71    in al, #0x71
37586 A96C           A3         0042              mov (0x003d + 0x05), ax ;; write precomp word
37587 A96F           B0                     20    mov al, #0x20
37588 A971           E6                     70    out #0x70, al
37589 A973           E4                     71    in al, #0x71
37590 A975           A2         0045              mov (0x003d + 0x08), al ;; drive control byte
37591 A978           B0                     22    mov al, #0x22
37592 A97A           E6                     70    out #0x70, al
37593 A97C           E4                     71    in al, #0x71
37594 A97E           88C4                         mov ah, al
37595 A980           B0                     21    mov al, #0x21
37596 A982           E6                     70    out #0x70, al
37597 A984           E4                     71    in al, #0x71
37598 A986           A3         0049              mov (0x003d + 0x0C), ax ;; landing zone word
37599 A989           B0                     1C    mov al, #0x1c ;; get cylinders word in AX
37600 A98B           E6                     70    out #0x70, al
37601 A98D           E4                     71    in al, #0x71 ;; high byte
37602 A98F           88C4                         mov ah, al
37603 A991           B0                     1B    mov al, #0x1b
37604 A993           E6                     70    out #0x70, al
37605 A995           E4                     71    in al, #0x71 ;; low byte
37606 A997           89C3                         mov bx, ax ;; BX = cylinders
37607 A999           B0                     1D    mov al, #0x1d
37608 A99B           E6                     70    out #0x70, al
37609 A99D           E4                     71    in al, #0x71
37610 A99F           88C1                         mov cl, al ;; CL = heads
37611 A9A1           B0                     23    mov al, #0x23
37612 A9A3           E6                     70    out #0x70, al
37613 A9A5           E4                     71    in al, #0x71
37614 A9A7           88C2                         mov dl, al ;; DL = sectors
37615 A9A9           81FB                 0400    cmp bx, #1024
37616 A9AD           77           0E              jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
37617                       0000A9AF            hd0_post_physical_chs:
37618                                             ;; no logical CHS mapping used, just physical CHS
37619                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
37620 A9AF           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
37621 A9B3           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
37622 A9B7           8816       004B              mov (0x003d + 0x0E), dl ;; number of physical sectors
37623 A9BB           EB           5F              jmp check_for_hd1
37624                       0000A9BD            hd0_post_logical_chs:
37625                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
37626 A9BD           891E       0046              mov (0x003d + 0x09), bx ;; number of physical cylinders
37627 A9C1           880E       0048              mov (0x003d + 0x0b), cl ;; number of physical heads
37628 A9C5           8816       0041              mov (0x003d + 0x04), dl ;; number of physical sectors
37629 A9C9           8816       004B              mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
37630 A9CD           B0                     A0    mov al, #0xa0
37631 A9CF           A2         0040              mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
37632 A9D2           81FB                 0800    cmp bx, #2048
37633 A9D6           77           06              jnbe hd0_post_above_2048
37634                                             ;; 1024 < c <= 2048 cylinders
37635 A9D8           D1EB                         shr bx, #0x01
37636 A9DA           D0E1                         shl cl, #0x01
37637 A9DC           EB           22              jmp hd0_post_store_logical
37638                       0000A9DE            hd0_post_above_2048:
37639 A9DE           81FB                 1000    cmp bx, #4096
37640 A9E2           77           08              jnbe hd0_post_above_4096
37641                                             ;; 2048 < c <= 4096 cylinders
37642 A9E4           C1EB                   02    shr bx, #0x02
37643 A9E7           C0E1                   02    shl cl, #0x02
37644 A9EA           EB           14              jmp hd0_post_store_logical
37645                       0000A9EC            hd0_post_above_4096:
37646 A9EC           81FB                 2000    cmp bx, #8192
37647 A9F0           77           08              jnbe hd0_post_above_8192
37648                                             ;; 4096 < c <= 8192 cylinders
37649 A9F2           C1EB                   03    shr bx, #0x03
37650 A9F5           C0E1                   03    shl cl, #0x03
37651 A9F8           EB           06              jmp hd0_post_store_logical
37652                       0000A9FA            hd0_post_above_8192:
37653                                             ;; 8192 < c <= 16384 cylinders
37654 A9FA           C1EB                   04    shr bx, #0x04
37655 A9FD           C0E1                   04    shl cl, #0x04
37656                       0000AA00            hd0_post_store_logical:
37657 AA00           891E       003D              mov (0x003d + 0x00), bx ;; number of physical cylinders
37658 AA04           880E       003F              mov (0x003d + 0x02), cl ;; number of physical heads
37659                                             ;; checksum
37660 AA08           B1                     0F    mov cl, #0x0f ;; repeat count
37661 AA0A           BE                   003D    mov si, #0x003d ;; offset to disk0 FDPT
37662 AA0D           B0                     00    mov al, #0x00 ;; sum
37663                       0000AA0F            hd0_post_checksum_loop:
37664 AA0F           0204                         add al, [si]
37665 AA11           46                           inc si
37666 AA12           FEC9                         dec cl
37667 AA14           75           F9              jnz hd0_post_checksum_loop
37668 AA16           F6D0                         not al ;; now take 2s complement
37669 AA18           FEC0                         inc al
37670 AA1A           8804                         mov [si], al
37671                                           ;;; Done filling EBDA table for hard disk 0.
37672                       0000AA1C            check_for_hd1:
37673                                             ;; is there really a second hard disk? if not, return now
37674 AA1C           B0                     12    mov al, #0x12
37675 AA1E           E6                     70    out #0x70, al
37676 AA20           E4                     71    in al, #0x71
37677 AA22           24                     0F    and al, #0x0f
37678 AA24           75           01              jnz post_d1_exists
37679 AA26           C3                           ret
37680                       0000AA27            post_d1_exists:
37681                                             ;; check that the hd type is really 0x0f.
37682 AA27           3C                     0F    cmp al, #0x0f
37683 AA29           74           07              jz post_d1_extended
37684                                             HALT(9169)
 +a   AA2B           BA                   0400    mov dx,#0x400
 +a   AA2E           B8                   23D1    mov ax,#9169
 +a   AA31           EF                           out dx,ax
37685                       0000AA32            post_d1_extended:
37686                                             ;; check that the extended type is 47 - user definable
37687 AA32           B0                     1A    mov al, #0x1a
37688 AA34           E6                     70    out #0x70, al
37689 AA36           E4                     71    in al, #0x71
37690 AA38           3C                     2F    cmp al, #47 ;; decimal 47 - user definable
37691 AA3A           74           07              je post_d1_type47
37692                                             HALT(9177)
 +a   AA3C           BA                   0400    mov dx,#0x400
 +a   AA3F           B8                   23D9    mov ax,#9177
 +a   AA42           EF                           out dx,ax
37693                       0000AA43            post_d1_type47:
37694                                             ;; Table for disk1.
37695                                             ;; CMOS purpose param table offset
37696                                             ;; 0x24 cylinders low 0
37697                                             ;; 0x25 cylinders high 1
37698                                             ;; 0x26 heads 2
37699                                             ;; 0x27 write pre-comp low 5
37700                                             ;; 0x28 write pre-comp high 6
37701                                             ;; 0x29 heads>8 8
37702                                             ;; 0x2a landing zone low C
37703                                             ;; 0x2b landing zone high D
37704                                             ;; 0x2c sectors/track E
37705                                           ;;; Fill EBDA table for hard disk 1.
37706 AA43           31C0                         xor ax, ax
37707 AA45           8ED8                         mov ds, ax
37708 AA47           A1         040E              mov ax, word ptr [0x40E] ;; EBDA segment
37709 AA4A           8ED8                         mov ds, ax
37710 AA4C           B0                     28    mov al, #0x28
37711 AA4E           E6                     70    out #0x70, al
37712 AA50           E4                     71    in al, #0x71
37713 AA52           88C4                         mov ah, al
37714 AA54           B0                     27    mov al, #0x27
37715 AA56           E6                     70    out #0x70, al
37716 AA58           E4                     71    in al, #0x71
37717 AA5A           A3         0052              mov (0x004d + 0x05), ax ;; write precomp word
37718 AA5D           B0                     29    mov al, #0x29
37719 AA5F           E6                     70    out #0x70, al
37720 AA61           E4                     71    in al, #0x71
37721 AA63           A2         0055              mov (0x004d + 0x08), al ;; drive control byte
37722 AA66           B0                     2B    mov al, #0x2b
37723 AA68           E6                     70    out #0x70, al
37724 AA6A           E4                     71    in al, #0x71
37725 AA6C           88C4                         mov ah, al
37726 AA6E           B0                     2A    mov al, #0x2a
37727 AA70           E6                     70    out #0x70, al
37728 AA72           E4                     71    in al, #0x71
37729 AA74           A3         0059              mov (0x004d + 0x0C), ax ;; landing zone word
37730 AA77           B0                     25    mov al, #0x25 ;; get cylinders word in AX
37731 AA79           E6                     70    out #0x70, al
37732 AA7B           E4                     71    in al, #0x71 ;; high byte
37733 AA7D           88C4                         mov ah, al
37734 AA7F           B0                     24    mov al, #0x24
37735 AA81           E6                     70    out #0x70, al
37736 AA83           E4                     71    in al, #0x71 ;; low byte
37737 AA85           89C3                         mov bx, ax ;; BX = cylinders
37738 AA87           B0                     26    mov al, #0x26
37739 AA89           E6                     70    out #0x70, al
37740 AA8B           E4                     71    in al, #0x71
37741 AA8D           88C1                         mov cl, al ;; CL = heads
37742 AA8F           B0                     2C    mov al, #0x2c
37743 AA91           E6                     70    out #0x70, al
37744 AA93           E4                     71    in al, #0x71
37745 AA95           88C2                         mov dl, al ;; DL = sectors
37746 AA97           81FB                 0400    cmp bx, #1024
37747 AA9B           77           0D              jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
37748                       0000AA9D            hd1_post_physical_chs:
37749                                             ;; no logical CHS mapping used, just physical CHS
37750                                             ;; use Standard Fixed Disk Parameter Table (FDPT)
37751 AA9D           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
37752 AAA1           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
37753 AAA5           8816       005B              mov (0x004d + 0x0E), dl ;; number of physical sectors
37754 AAA9           C3                           ret
37755                       0000AAAA            hd1_post_logical_chs:
37756                                             ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
37757 AAAA           891E       0056              mov (0x004d + 0x09), bx ;; number of physical cylinders
37758 AAAE           880E       0058              mov (0x004d + 0x0b), cl ;; number of physical heads
37759 AAB2           8816       0051              mov (0x004d + 0x04), dl ;; number of physical sectors
37760 AAB6           8816       005B              mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
37761 AABA           B0                     A0    mov al, #0xa0
37762 AABC           A2         0050              mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
37763 AABF           81FB                 0800    cmp bx, #2048
37764 AAC3           77           06              jnbe hd1_post_above_2048
37765                                             ;; 1024 < c <= 2048 cylinders
37766 AAC5           D1EB                         shr bx, #0x01
37767 AAC7           D0E1                         shl cl, #0x01
37768 AAC9           EB           22              jmp hd1_post_store_logical
37769                       0000AACB            hd1_post_above_2048:
37770 AACB           81FB                 1000    cmp bx, #4096
37771 AACF           77           08              jnbe hd1_post_above_4096
37772                                             ;; 2048 < c <= 4096 cylinders
37773 AAD1           C1EB                   02    shr bx, #0x02
37774 AAD4           C0E1                   02    shl cl, #0x02
37775 AAD7           EB           14              jmp hd1_post_store_logical
37776                       0000AAD9            hd1_post_above_4096:
37777 AAD9           81FB                 2000    cmp bx, #8192
37778 AADD           77           08              jnbe hd1_post_above_8192
37779                                             ;; 4096 < c <= 8192 cylinders
37780 AADF           C1EB                   03    shr bx, #0x03
37781 AAE2           C0E1                   03    shl cl, #0x03
37782 AAE5           EB           06              jmp hd1_post_store_logical
37783                       0000AAE7            hd1_post_above_8192:
37784                                             ;; 8192 < c <= 16384 cylinders
37785 AAE7           C1EB                   04    shr bx, #0x04
37786 AAEA           C0E1                   04    shl cl, #0x04
37787                       0000AAED            hd1_post_store_logical:
37788 AAED           891E       004D              mov (0x004d + 0x00), bx ;; number of physical cylinders
37789 AAF1           880E       004F              mov (0x004d + 0x02), cl ;; number of physical heads
37790                                             ;; checksum
37791 AAF5           B1                     0F    mov cl, #0x0f ;; repeat count
37792 AAF7           BE                   004D    mov si, #0x004d ;; offset to disk0 FDPT
37793 AAFA           B0                     00    mov al, #0x00 ;; sum
37794                       0000AAFC            hd1_post_checksum_loop:
37795 AAFC           0204                         add al, [si]
37796 AAFE           46                           inc si
37797 AAFF           FEC9                         dec cl
37798 AB01           75           F9              jnz hd1_post_checksum_loop
37799 AB03           F6D0                         not al ;; now take 2s complement
37800 AB05           FEC0                         inc al
37801 AB07           8804                         mov [si], al
37802                                           ;;; Done filling EBDA table for hard disk 1.
37803 AB09           C3                           ret
37804                                           ;--------------------
37805                                           ;- POST: EBDA segment
37806                                           ;--------------------
37807                                           ; relocated here because the primary POST area isnt big enough.
37808                       0000AB0A            ebda_post:
37809 AB0A           B8                   9FC0    mov ax, #0x9FC0
37810 AB0D           8ED8                         mov ds, ax
37811 AB0F           C606       0000        01    mov byte ptr [0x0], #1
37812 AB14           31C0                         xor ax, ax ; mov EBDA seg into 40E
37813 AB16           8ED8                         mov ds, ax
37814 AB18           C706       040E      9FC0    mov word ptr [0x40E], #0x9FC0
37815 AB1E           C3                           ret;;
37816                                           ;--------------------
37817                                           ;- POST: EOI + jmp via [0x40:67)
37818                                           ;--------------------
37819                                           ; relocated here because the primary POST area isnt big enough.
37820                       0000AB1F            eoi_jmp_post:
37821 AB1F           B0                     20    mov al, #0x20
37822 AB21           E6                     A0    out #0xA0, al ;; slave PIC EOI
37823 AB23           B0                     20    mov al, #0x20
37824 AB25           E6                     20    out #0x20, al ;; master PIC EOI
37825                       0000AB27            jmp_post_0x467:
37826 AB27           31C0                         xor ax, ax
37827 AB29           8ED8                         mov ds, ax
37828 AB2B           FF2E       0467              jmp far ptr [0x467]
37829                       0000AB2F            iret_post_0x467:
37830 AB2F           31C0                         xor ax, ax
37831 AB31           8ED8                         mov ds, ax
37832 AB33           8B26       0467              mov sp, [0x467]
37833 AB37           8E16       0469              mov ss, [0x469]
37834 AB3B           CF                           iret
37835                       0000AB3C            retf_post_0x467:
37836 AB3C           31C0                         xor ax, ax
37837 AB3E           8ED8                         mov ds, ax
37838 AB40           8B26       0467              mov sp, [0x467]
37839 AB44           8E16       0469              mov ss, [0x469]
37840 AB48           CB                           retf
37841                       0000AB49            s3_post:
37842 AB49           E8         6E05              call _s3_resume
37843 AB4C           B3                     00    mov bl, #0x00
37844 AB4E           21C0                         and ax, ax
37845 AB50   7503    E9         3552              jz normal_post
37846 AB55           E8         67E3              call _s3_resume_panic
37847                                           ;--------------------
37848                       0000AB58            eoi_both_pics:
37849 AB58           B0                     20    mov al, #0x20
37850 AB5A           E6                     A0    out #0xA0, al ;; slave PIC EOI
37851                       0000AB5C            eoi_master_pic:
37852 AB5C           B0                     20    mov al, #0x20
37853 AB5E           E6                     20    out #0x20, al ;; master PIC EOI
37854 AB60           C3                           ret
37855                                           ;--------------------
37856                       0000AB61            BcdToBin:
37857                                             ;; in: AL in BCD format
37858                                             ;; out: AL in binary format, AH will always be 0
37859                                             ;; trashes BX
37860 AB61           88C3                         mov bl, al
37861 AB63           80E3                   0F    and bl, #0x0f ;; bl has low digit
37862 AB66           C0E8                   04    shr al, #4 ;; al has high digit
37863 AB69           B7                     0A    mov bh, #10
37864 AB6B           F6E7                         mul al, bh ;; multiply high digit by 10 (result in AX)
37865 AB6D           00D8                         add al, bl ;; then add low digit
37866 AB6F           C3                           ret
37867                                           ;--------------------
37868                       0000AB70            timer_tick_post:
37869                                             ;; Setup the Timer Ticks Count (0x46C:dword) and
37870                                             ;; Timer Ticks Roller Flag (0x470:byte)
37871                                             ;; The Timer Ticks Count needs to be set according to
37872                                             ;; the current CMOS time, as if ticks have been occurring
37873                                             ;; at 18.2hz since midnight up to this point. Calculating
37874                                             ;; this is a little complicated. Here are the factors I gather
37875                                             ;; regarding this. 14,318,180 hz was the original clock speed,
37876                                             ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
37877                                             ;; at the time, or 4 to drive the CGA video adapter. The div3
37878                                             ;; source was divided again by 4 to feed a 1.193Mhz signal to
37879                                             ;; the timer. With a maximum 16bit timer count, this is again
37880                                             ;; divided down by 65536 to 18.2hz.
37881                                             ;;
37882                                             ;; 14,318,180 Hz clock
37883                                             ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
37884                                             ;; /4 = 1,193,181 Hz fed to timer
37885                                             ;; /65536 (maximum timer count) = 18.20650736 ticks/second
37886                                             ;; 1 second = 18.20650736 ticks
37887                                             ;; 1 minute = 1092.390442 ticks
37888                                             ;; 1 hour = 65543.42651 ticks
37889                                             ;;
37890                                             ;; Given the values in the CMOS clock, one could calculate
37891                                             ;; the number of ticks by the following:
37892                                             ;; ticks = (BcdToBin(seconds) * 18.206507) +
37893                                             ;; (BcdToBin(minutes) * 1092.3904)
37894                                             ;; (BcdToBin(hours) * 65543.427)
37895                                             ;; To get a little more accuracy, since Im using integer
37896                                             ;; arithmatic, I use:
37897                                             ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
37898                                             ;; (BcdToBin(minutes) * 10923904) / 10000 +
37899                                             ;; (BcdToBin(hours) * 65543427) / 1000
37900                                             ;; assuming DS=0000
37901                                             ;; get CMOS seconds
37902 AB70     66    31C0                         xor eax, eax ;; clear EAX
37903 AB73           B0                     00    mov al, #0x00
37904 AB75           E6                     70    out #0x70, al
37905 AB77           E4                     71    in al, #0x71 ;; AL has CMOS seconds in BCD
37906 AB79           E8         FFE5              call BcdToBin ;; EAX now has seconds in binary
37907 AB7C     66    BA               0115CF2B    mov edx, #18206507
37908 AB82     66    F7E2                         mul eax, edx
37909 AB85     66    BB               000F4240    mov ebx, #1000000
37910 AB8B     66    31D2                         xor edx, edx
37911 AB8E     66    F7F3                         div eax, ebx
37912 AB91     66    89C1                         mov ecx, eax ;; ECX will accumulate total ticks
37913                                             ;; get CMOS minutes
37914 AB94     66    31C0                         xor eax, eax ;; clear EAX
37915 AB97           B0                     02    mov al, #0x02
37916 AB99           E6                     70    out #0x70, al
37917 AB9B           E4                     71    in al, #0x71 ;; AL has CMOS minutes in BCD
37918 AB9D           E8         FFC1              call BcdToBin ;; EAX now has minutes in binary
37919 ABA0     66    BA               00A6AF80    mov edx, #10923904
37920 ABA6     66    F7E2                         mul eax, edx
37921 ABA9     66    BB               00002710    mov ebx, #10000
37922 ABAF     66    31D2                         xor edx, edx
37923 ABB2     66    F7F3                         div eax, ebx
37924 ABB5     66    01C1                         add ecx, eax ;; add to total ticks
37925                                             ;; get CMOS hours
37926 ABB8     66    31C0                         xor eax, eax ;; clear EAX
37927 ABBB           B0                     04    mov al, #0x04
37928 ABBD           E6                     70    out #0x70, al
37929 ABBF           E4                     71    in al, #0x71 ;; AL has CMOS hours in BCD
37930 ABC1           E8         FF9D              call BcdToBin ;; EAX now has hours in binary
37931 ABC4     66    BA               03E81D03    mov edx, #65543427
37932 ABCA     66    F7E2                         mul eax, edx
37933 ABCD     66    BB               000003E8    mov ebx, #1000
37934 ABD3     66    31D2                         xor edx, edx
37935 ABD6     66    F7F3                         div eax, ebx
37936 ABD9     66    01C1                         add ecx, eax ;; add to total ticks
37937 ABDC     66    890E       046C              mov 0x46C, ecx ;; Timer Ticks Count
37938 ABE1           30C0                         xor al, al
37939 ABE3           A2         0470              mov 0x470, al ;; Timer Ticks Rollover Flag
37940 ABE6           C3                           ret
37941                                           ;--------------------
37942                       0000ABE7            int76_handler:
37943                                             ;; record completion in BIOS task complete flag
37944 ABE7           50                           push ax
37945 ABE8           1E                           push ds
37946 ABE9           B8                   0040    mov ax, #0x0040
37947 ABEC           8ED8                         mov ds, ax
37948 ABEE           C706       008E      00FF    mov 0x008E, #0xff
37949 ABF4           E8         FF61              call eoi_both_pics
37950 ABF7           1F                           pop ds
37951 ABF8           58                           pop ax
37952 ABF9           CF                           iret
37953                                           ;--------------------
37954                                           use32 386
37955                       0000ABFA            apm32_out_str:
37956 ABFA           50                           push eax
37957 ABFB           53                           push ebx
37958 ABFC           89C3                         mov ebx, eax
37959                       0000ABFE            apm32_out_str1:
37960 ABFE           2E                           SEG CS
37961 ABFF   67      8A07                         mov al, byte ptr [bx]
37962 AC02           3C                     00    cmp al, #0
37963 AC04           74           04              je apm32_out_str2
37964 AC06           EE                           outb dx, al
37965 AC07           43                           inc ebx
37966 AC08           EB           F4              jmp apm32_out_str1
37967                       0000AC0A            apm32_out_str2:
37968 AC0A           5B                           pop ebx
37969 AC0B           58                           pop eax
37970 AC0C           C3                           ret
37971                       0000AC0D            apm32_07_poweroff_str:
37972 AC0D                        53              .ascii "Shutdown"
37973 AC15                        00              db 0
37974                       0000AC16            apm32_07_suspend_str:
37975 AC16                        53              .ascii "Suspend"
37976 AC1D                        00              db 0
37977                       0000AC1E            apm32_07_standby_str:
37978 AC1E                        53              .ascii "Standby"
37979 AC25                        00              db 0
37980                       0000AC26            _apm32_entry:
37981 AC26     66    9C                           pushf
37982                                           ;-----------------
37983                                           ; APM interface disconnect
37984                       0000AC28            apm32_04:
37985 AC28           3C                     04    cmp al, #0x04
37986 AC2A           75           05              jne apm32_05
37987 AC2C           E9     000000A5              jmp apm32_ok
37988                                           ;-----------------
37989                                           ; APM cpu idle
37990                       0000AC31            apm32_05:
37991 AC31           3C                     05    cmp al, #0x05
37992 AC33           75           0B              jne apm32_07
37993 AC35     66    9C                           pushf ; XEN
37994 AC37           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
37995 AC38           F4                           hlt
37996 AC39     66    9D                           popf ; XEN
37997 AC3B           E9     00000096              jmp apm32_ok
37998                                           ;-----------------
37999                                           ; APM Set Power State
38000                       0000AC40            apm32_07:
38001 AC40           3C                     07    cmp al, #0x07
38002 AC42           75           52              jne apm32_08
38003 AC44     66    83FB                   01    cmp bx, #1
38004 AC48   7405    E9     00000087              jne apm32_ok
38005 AC4F     66    83F9                   03    cmp cx, #3
38006 AC53           74           0E              je apm32_07_poweroff
38007 AC55     66    83F9                   02    cmp cx, #2
38008 AC59           74           19              je apm32_07_suspend
38009 AC5B     66    83F9                   01    cmp cx, #1
38010 AC5F           74           24              je apm32_07_standby
38011 AC61           75           73              jne apm32_ok
38012                       0000AC63            apm32_07_poweroff:
38013 AC63           FA                           cli
38014 AC64     66    BA                   8900    mov dx, #0x8900
38015 AC68     66    B8                   AC0D    mov ax, #apm32_07_poweroff_str
38016 AC6C           E8     FFFFFF89              call apm32_out_str
38017                       0000AC71            apm32_07_1:
38018 AC71           F4                           hlt
38019 AC72           EB           FD              jmp apm32_07_1
38020                       0000AC74            apm32_07_suspend:
38021 AC74           52                           push edx
38022 AC75     66    BA                   8900    mov dx, #0x8900
38023 AC79     66    B8                   AC16    mov ax, #apm32_07_suspend_str
38024 AC7D           E8     FFFFFF78              call apm32_out_str
38025 AC82           5A                           pop edx
38026 AC83           EB           51              jmp apm32_ok
38027                       0000AC85            apm32_07_standby:
38028 AC85           52                           push edx
38029 AC86     66    BA                   8900    mov dx, #0x8900
38030 AC8A     66    B8                   AC1E    mov ax, #apm32_07_standby_str
38031 AC8E           E8     FFFFFF67              call apm32_out_str
38032 AC93           5A                           pop edx
38033 AC94           EB           40              jmp apm32_ok
38034                                           ;-----------------
38035                                           ; APM Enable / Disable
38036                       0000AC96            apm32_08:
38037 AC96           3C                     08    cmp al, #0x08
38038 AC98           75           02              jne apm32_0a
38039 AC9A           EB           3A              jmp apm32_ok
38040                                           ;-----------------
38041                                           ; Get Power Status
38042                       0000AC9C            apm32_0a:
38043 AC9C           3C                     0A    cmp al, #0x0a
38044 AC9E           75           12              jne apm32_0b
38045 ACA0           B7                     01    mov bh, #0x01
38046 ACA2           B3                     FF    mov bl, #0xff
38047 ACA4           B5                     80    mov ch, #0x80
38048 ACA6           B1                     FF    mov cl, #0xff
38049 ACA8     66    BA                   FFFF    mov dx, #0xffff
38050 ACAC     66    BE                   0000    mov si, #0
38051 ACB0           EB           24              jmp apm32_ok
38052                                           ;-----------------
38053                                           ; Get PM Event
38054                       0000ACB2            apm32_0b:
38055 ACB2           3C                     0B    cmp al, #0x0b
38056 ACB4           75           04              jne apm32_0e
38057 ACB6           B4                     80    mov ah, #0x80
38058 ACB8           EB           20              jmp apm32_error
38059                                           ;-----------------
38060                                           ; APM Driver Version
38061                       0000ACBA            apm32_0e:
38062 ACBA           3C                     0E    cmp al, #0x0e
38063 ACBC           75           06              jne apm32_0f
38064 ACBE           B4                     01    mov ah, #1
38065 ACC0           B0                     02    mov al, #2
38066 ACC2           EB           12              jmp apm32_ok
38067                                           ;-----------------
38068                                           ; APM Engage / Disengage
38069                       0000ACC4            apm32_0f:
38070 ACC4           3C                     0F    cmp al, #0x0f
38071 ACC6           75           02              jne apm32_10
38072 ACC8           EB           0C              jmp apm32_ok
38073                                           ;-----------------
38074                                           ; APM Get Capabilities
38075                       0000ACCA            apm32_10:
38076 ACCA           3C                     10    cmp al, #0x10
38077 ACCC           75           0C              jne apm32_unimplemented
38078 ACCE           B3                     00    mov bl, #0
38079 ACD0     66    B9                   0000    mov cx, #0
38080 ACD4           EB           00              jmp apm32_ok
38081                                           ;-----------------
38082                       0000ACD6            apm32_ok:
38083 ACD6     66    9D                           popf
38084 ACD8           F8                           clc
38085 ACD9           CB                           retf
38086                       0000ACDA            apm32_unimplemented:
38087                       0000ACDA            apm32_error:
38088 ACDA     66    9D                           popf
38089 ACDC           F9                           stc
38090 ACDD           CB                           retf
38091                                           use16 386
38092                       0000ACDE            apm16_out_str:
38093 ACDE     66    50                           push eax
38094 ACE0     66    53                           push ebx
38095 ACE2     66    89C3                         mov ebx, eax
38096                       0000ACE5            apm16_out_str1:
38097 ACE5           2E                           SEG CS
38098 ACE6           8A07                         mov al, byte ptr [bx]
38099 ACE8           3C                     00    cmp al, #0
38100 ACEA           74           05              je apm16_out_str2
38101 ACEC           EE                           outb dx, al
38102 ACED     66    43                           inc ebx
38103 ACEF           EB           F4              jmp apm16_out_str1
38104                       0000ACF1            apm16_out_str2:
38105 ACF1     66    5B                           pop ebx
38106 ACF3     66    58                           pop eax
38107 ACF5           C3                           ret
38108                       0000ACF6            apm16_07_poweroff_str:
38109 ACF6                        53              .ascii "Shutdown"
38110 ACFE                        00              db 0
38111                       0000ACFF            apm16_07_suspend_str:
38112 ACFF                        53              .ascii "Suspend"
38113 AD06                        00              db 0
38114                       0000AD07            apm16_07_standby_str:
38115 AD07                        53              .ascii "Standby"
38116 AD0E                        00              db 0
38117                       0000AD0F            _apm16_entry:
38118 AD0F           9C                           pushf
38119                                           ;-----------------
38120                                           ; APM interface disconnect
38121                       0000AD10            apm16_04:
38122 AD10           3C                     04    cmp al, #0x04
38123 AD12           75           03              jne apm16_05
38124 AD14           E9         008D              jmp apm16_ok
38125                                           ;-----------------
38126                                           ; APM cpu idle
38127                       0000AD17            apm16_05:
38128 AD17           3C                     05    cmp al, #0x05
38129 AD19           75           07              jne apm16_07
38130 AD1B           9C                           pushf ; XEN
38131 AD1C           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
38132 AD1D           F4                           hlt
38133 AD1E           9D                           popf ; XEN
38134 AD1F           E9         0082              jmp apm16_ok
38135                                           ;-----------------
38136                                           ; APM Set Power State
38137                       0000AD22            apm16_07:
38138 AD22           3C                     07    cmp al, #0x07
38139 AD24           75           41              jne apm16_08
38140 AD26           83FB                   01    cmp bx, #1
38141 AD29           75           79              jne apm16_ok
38142 AD2B           83F9                   03    cmp cx, #3
38143 AD2E           74           0C              je apm16_07_poweroff
38144 AD30           83F9                   02    cmp cx, #2
38145 AD33           74           14              je apm16_07_suspend
38146 AD35           83F9                   01    cmp cx, #1
38147 AD38           74           1E              je apm16_07_standby
38148 AD3A           75           68              jne apm16_ok
38149                       0000AD3C            apm16_07_poweroff:
38150 AD3C           FA                           cli
38151 AD3D           BA                   8900    mov dx, #0x8900
38152 AD40           B8                   ACF6    mov ax, #apm16_07_poweroff_str
38153 AD43           E8         FF98              call apm16_out_str
38154                       0000AD46            apm16_07_1:
38155 AD46           F4                           hlt
38156 AD47           EB           FD              jmp apm16_07_1
38157                       0000AD49            apm16_07_suspend:
38158 AD49     66    52                           push edx
38159 AD4B           BA                   8900    mov dx, #0x8900
38160 AD4E           B8                   ACFF    mov ax, #apm16_07_suspend_str
38161 AD51           E8         FF8A              call apm16_out_str
38162 AD54     66    5A                           pop edx
38163 AD56           EB           4C              jmp apm16_ok
38164                       0000AD58            apm16_07_standby:
38165 AD58     66    52                           push edx
38166 AD5A           BA                   8900    mov dx, #0x8900
38167 AD5D           B8                   AD07    mov ax, #apm16_07_standby_str
38168 AD60           E8         FF7B              call apm16_out_str
38169 AD63     66    5A                           pop edx
38170 AD65           EB           3D              jmp apm16_ok
38171                                           ;-----------------
38172                                           ; APM Enable / Disable
38173                       0000AD67            apm16_08:
38174 AD67           3C                     08    cmp al, #0x08
38175 AD69           75           02              jne apm16_0a
38176 AD6B           EB           37              jmp apm16_ok
38177                                           ;-----------------
38178                                           ; Get Power Status
38179                       0000AD6D            apm16_0a:
38180 AD6D           3C                     0A    cmp al, #0x0a
38181 AD6F           75           10              jne apm16_0b
38182 AD71           B7                     01    mov bh, #0x01
38183 AD73           B3                     FF    mov bl, #0xff
38184 AD75           B5                     80    mov ch, #0x80
38185 AD77           B1                     FF    mov cl, #0xff
38186 AD79           BA                   FFFF    mov dx, #0xffff
38187 AD7C           BE                   0000    mov si, #0
38188 AD7F           EB           23              jmp apm16_ok
38189                                           ;-----------------
38190                                           ; Get PM Event
38191                       0000AD81            apm16_0b:
38192 AD81           3C                     0B    cmp al, #0x0b
38193 AD83           75           04              jne apm16_0e
38194 AD85           B4                     80    mov ah, #0x80
38195 AD87           EB           1E              jmp apm16_error
38196                                           ;-----------------
38197                                           ; APM Driver Version
38198                       0000AD89            apm16_0e:
38199 AD89           3C                     0E    cmp al, #0x0e
38200 AD8B           75           06              jne apm16_0f
38201 AD8D           B4                     01    mov ah, #1
38202 AD8F           B0                     02    mov al, #2
38203 AD91           EB           11              jmp apm16_ok
38204                                           ;-----------------
38205                                           ; APM Engage / Disengage
38206                       0000AD93            apm16_0f:
38207 AD93           3C                     0F    cmp al, #0x0f
38208 AD95           75           02              jne apm16_10
38209 AD97           EB           0B              jmp apm16_ok
38210                                           ;-----------------
38211                                           ; APM Get Capabilities
38212                       0000AD99            apm16_10:
38213 AD99           3C                     10    cmp al, #0x10
38214 AD9B           75           0A              jne apm16_unimplemented
38215 AD9D           B3                     00    mov bl, #0
38216 AD9F           B9                   0000    mov cx, #0
38217 ADA2           EB           00              jmp apm16_ok
38218                                           ;-----------------
38219                       0000ADA4            apm16_ok:
38220 ADA4           9D                           popf
38221 ADA5           F8                           clc
38222 ADA6           CB                           retf
38223                       0000ADA7            apm16_unimplemented:
38224                       0000ADA7            apm16_error:
38225 ADA7           9D                           popf
38226 ADA8           F9                           stc
38227 ADA9           CB                           retf
38228                       0000ADAA            apmreal_out_str:
38229 ADAA     66    50                           push eax
38230 ADAC     66    53                           push ebx
38231 ADAE     66    89C3                         mov ebx, eax
38232                       0000ADB1            apmreal_out_str1:
38233 ADB1           2E                           SEG CS
38234 ADB2           8A07                         mov al, byte ptr [bx]
38235 ADB4           3C                     00    cmp al, #0
38236 ADB6           74           05              je apmreal_out_str2
38237 ADB8           EE                           outb dx, al
38238 ADB9     66    43                           inc ebx
38239 ADBB           EB           F4              jmp apmreal_out_str1
38240                       0000ADBD            apmreal_out_str2:
38241 ADBD     66    5B                           pop ebx
38242 ADBF     66    58                           pop eax
38243 ADC1           C3                           ret
38244                       0000ADC2            apmreal_07_poweroff_str:
38245 ADC2                        53              .ascii "Shutdown"
38246 ADCA                        00              db 0
38247                       0000ADCB            apmreal_07_suspend_str:
38248 ADCB                        53              .ascii "Suspend"
38249 ADD2                        00              db 0
38250                       0000ADD3            apmreal_07_standby_str:
38251 ADD3                        53              .ascii "Standby"
38252 ADDA                        00              db 0
38253 ADDB           9C                           pushf
38254                       0000ADDC            _apmreal_entry:
38255                                           ;-----------------
38256                                           ; APM installation check
38257                       0000ADDC            apmreal_00:
38258 ADDC           3C                     00    cmp al, #0x00
38259 ADDE           75           0E              jne apmreal_01
38260 ADE0           B4                     01    mov ah, #1
38261 ADE2           B0                     02    mov al, #2
38262 ADE4           B7                     50    mov bh, #0x50
38263 ADE6           B3                     4D    mov bl, #0x4d
38264 ADE8           B9                   0003    mov cx, #0x3
38265 ADEB           E9         00D0              jmp apmreal_ok
38266                                           ;-----------------
38267                                           ; APM real mode interface connect
38268                       0000ADEE            apmreal_01:
38269 ADEE           3C                     01    cmp al, #0x01
38270 ADF0           75           03              jne apmreal_02
38271 ADF2           E9         00C9              jmp apmreal_ok
38272                                           ;-----------------
38273                                           ; APM 16 bit protected mode interface connect
38274                       0000ADF5            apmreal_02:
38275 ADF5           3C                     02    cmp al, #0x02
38276 ADF7           75           12              jne apmreal_03
38277 ADF9           BB                   AD0F    mov bx, #_apm16_entry
38278 ADFC           B8                   F000    mov ax, #0xf000
38279 ADFF           BE                   FFF0    mov si, #0xfff0
38280 AE02           B9                   F000    mov cx, #0xf000
38281 AE05           BF                   FFF0    mov di, #0xfff0
38282 AE08           E9         00B3              jmp apmreal_ok
38283                                           ;-----------------
38284                                           ; APM 32 bit protected mode interface connect
38285                       0000AE0B            apmreal_03:
38286 AE0B           3C                     03    cmp al, #0x03
38287 AE0D           75           1B              jne apmreal_04
38288 AE0F           B8                   F000    mov ax, #0xf000
38289 AE12     66    BB               0000AC26    mov ebx, #_apm32_entry
38290 AE18           B9                   F000    mov cx, #0xf000
38291 AE1B     66    BE               FFF0FFF0    mov esi, #0xfff0fff0
38292 AE21           BA                   F000    mov dx, #0xf000
38293 AE24           BF                   FFF0    mov di, #0xfff0
38294 AE27           E9         0094              jmp apmreal_ok
38295                                           ;-----------------
38296                                           ; APM interface disconnect
38297                       0000AE2A            apmreal_04:
38298 AE2A           3C                     04    cmp al, #0x04
38299 AE2C           75           03              jne apmreal_05
38300 AE2E           E9         008D              jmp apmreal_ok
38301                                           ;-----------------
38302                                           ; APM cpu idle
38303                       0000AE31            apmreal_05:
38304 AE31           3C                     05    cmp al, #0x05
38305 AE33           75           07              jne apmreal_07
38306 AE35           9C                           pushf ; XEN
38307 AE36           FB                           sti ; XEN: OS calls us with ints disabled -- better re-enable here!
38308 AE37           F4                           hlt
38309 AE38           9D                           popf ; XEN
38310 AE39           E9         0082              jmp apmreal_ok
38311                                           ;-----------------
38312                                           ; APM Set Power State
38313                       0000AE3C            apmreal_07:
38314 AE3C           3C                     07    cmp al, #0x07
38315 AE3E           75           41              jne apmreal_08
38316 AE40           83FB                   01    cmp bx, #1
38317 AE43           75           79              jne apmreal_ok
38318 AE45           83F9                   03    cmp cx, #3
38319 AE48           74           0C              je apmreal_07_poweroff
38320 AE4A           83F9                   02    cmp cx, #2
38321 AE4D           74           14              je apmreal_07_suspend
38322 AE4F           83F9                   01    cmp cx, #1
38323 AE52           74           1E              je apmreal_07_standby
38324 AE54           75           68              jne apmreal_ok
38325                       0000AE56            apmreal_07_poweroff:
38326 AE56           FA                           cli
38327 AE57           BA                   8900    mov dx, #0x8900
38328 AE5A           B8                   ADC2    mov ax, #apmreal_07_poweroff_str
38329 AE5D           E8         FF4A              call apmreal_out_str
38330                       0000AE60            apmreal_07_1:
38331 AE60           F4                           hlt
38332 AE61           EB           FD              jmp apmreal_07_1
38333                       0000AE63            apmreal_07_suspend:
38334 AE63     66    52                           push edx
38335 AE65           BA                   8900    mov dx, #0x8900
38336 AE68           B8                   ADCB    mov ax, #apmreal_07_suspend_str
38337 AE6B           E8         FF3C              call apmreal_out_str
38338 AE6E     66    5A                           pop edx
38339 AE70           EB           4C              jmp apmreal_ok
38340                       0000AE72            apmreal_07_standby:
38341 AE72     66    52                           push edx
38342 AE74           BA                   8900    mov dx, #0x8900
38343 AE77           B8                   ADD3    mov ax, #apmreal_07_standby_str
38344 AE7A           E8         FF2D              call apmreal_out_str
38345 AE7D     66    5A                           pop edx
38346 AE7F           EB           3D              jmp apmreal_ok
38347                                           ;-----------------
38348                                           ; APM Enable / Disable
38349                       0000AE81            apmreal_08:
38350 AE81           3C                     08    cmp al, #0x08
38351 AE83           75           02              jne apmreal_0a
38352 AE85           EB           37              jmp apmreal_ok
38353                                           ;-----------------
38354                                           ; Get Power Status
38355                       0000AE87            apmreal_0a:
38356 AE87           3C                     0A    cmp al, #0x0a
38357 AE89           75           10              jne apmreal_0b
38358 AE8B           B7                     01    mov bh, #0x01
38359 AE8D           B3                     FF    mov bl, #0xff
38360 AE8F           B5                     80    mov ch, #0x80
38361 AE91           B1                     FF    mov cl, #0xff
38362 AE93           BA                   FFFF    mov dx, #0xffff
38363 AE96           BE                   0000    mov si, #0
38364 AE99           EB           23              jmp apmreal_ok
38365                                           ;-----------------
38366                                           ; Get PM Event
38367                       0000AE9B            apmreal_0b:
38368 AE9B           3C                     0B    cmp al, #0x0b
38369 AE9D           75           04              jne apmreal_0e
38370 AE9F           B4                     80    mov ah, #0x80
38371 AEA1           EB           20              jmp apmreal_error
38372                                           ;-----------------
38373                                           ; APM Driver Version
38374                       0000AEA3            apmreal_0e:
38375 AEA3           3C                     0E    cmp al, #0x0e
38376 AEA5           75           06              jne apmreal_0f
38377 AEA7           B4                     01    mov ah, #1
38378 AEA9           B0                     02    mov al, #2
38379 AEAB           EB           11              jmp apmreal_ok
38380                                           ;-----------------
38381                                           ; APM Engage / Disengage
38382                       0000AEAD            apmreal_0f:
38383 AEAD           3C                     0F    cmp al, #0x0f
38384 AEAF           75           02              jne apmreal_10
38385 AEB1           EB           0B              jmp apmreal_ok
38386                                           ;-----------------
38387                                           ; APM Get Capabilities
38388                       0000AEB3            apmreal_10:
38389 AEB3           3C                     10    cmp al, #0x10
38390 AEB5           75           0C              jne apmreal_unimplemented
38391 AEB7           B3                     00    mov bl, #0
38392 AEB9           B9                   0000    mov cx, #0
38393 AEBC           EB           00              jmp apmreal_ok
38394                                           ;-----------------
38395                       0000AEBE            apmreal_ok:
38396 AEBE           9D                           popf
38397 AEBF           F8                           clc
38398 AEC0           E9         F8C6              jmp iret_modify_cf
38399                       0000AEC3            apmreal_unimplemented:
38400                       0000AEC3            apmreal_error:
38401 AEC3           9D                           popf
38402 AEC4           F9                           stc
38403 AEC5           E9         F8C1              jmp iret_modify_cf
38404 AEC8                  00000010                .align 16
38405                       0000AED0            gdt_base:
38406 AED0                      0000                .word 0,0
38407 AED4                        00                .byte 0,0,0,0
38408                       0000AED8            gdt_entry_pm_32bit_cs:
38409 AED8                      FFFF                .word 0xffff, 0x0000
38410 AEDC                        00                .byte 0x00, 0x9b, 0xcf, 0x00
38411                       0000AEE0            gdt_entry_pm_16bit_cs:
38412 AEE0                      FFFF                .word 0xffff, 0x0000
38413 AEE4                        0F                .byte 0xf0000 >> 16, 0x9b, 0x8f, 0x0
38414                       0000AEE8            gdt_entry_pm_32bit_ds:
38415 AEE8                      FFFF                .word 0xffff, 0x0000
38416 AEEC                        00                .byte 0x0, 0x93, 0xcf, 0x0
38417                       0000AEF0            gdt_entry_pm_16bit_ds:
38418 AEF0                      FFFF                .word 0xffff, 0x0000
38419 AEF4                        00                .byte 0x0, 0x93, 0x8f, 0x0
38420                       0000AEF8            gdt_entry_end:
38421                       0000AEF8            protmode_gdtdesc:
38422 AEF8                      0027                .word (gdt_entry_end - gdt_base) - 1
38423 AEFA                  000FAED0                .long gdt_base | 0xf0000
38424                       0000AEFE            realmode_gdtdesc:
38425 AEFE                      FFFF                .word 0xffff
38426 AF00                  00000000                .long 0x0
38427                       0000AF04            Upcall:
38428                                               ; Do an upcall into 32 bit space
38429                                               ;
38430                                               ; Input:
38431                                               ; bx: index of function to call
38432                                               ; Ouput:
38433                                               ; dx, ax: 32 bit result of call (even if 'void' is expected)
38434                                               ; Save caller state, stack frame offsets listed below
38435 AF04           9C                             pushf
38436 AF05           FA                             cli
38437 AF06           1E                             push ds
38438 AF07           06                             push es
38439 AF08           16                             push ss
38440 AF09     66    54                             push esp
38441                                               ; Calculate protected-mode esp from ss:sp
38442 AF0B     66    81E4             0000FFFF      and esp, #0xffff
38443 AF12     66    31C0                           xor eax, eax
38444 AF15           8CD0                           mov ax, ss
38445 AF17     66    C1E0                   04      shl eax, #4
38446 AF1B     66    01C4                           add esp, eax
38447                                               ; Switch to protected mode
38448 AF1E           2E                             seg cs
38449 AF1F         0F0116       AEF8                lgdt protmode_gdtdesc
38450 AF24         0F20C0                           mov eax, cr0
38451 AF27           0C                     01      or al, #0x1 ; protected mode on
38452 AF29         0F22C0                           mov cr0, eax
38453 AF2C     66    EA     000FAF34      0008      jmpf DWORD (0xf0000|upcall1), #(gdt_entry_pm_32bit_cs - gdt_base)
38454                       0000AF34            upcall1:
38455                                               USE32
38456 AF34     66    B8                   0018      mov ax, #(gdt_entry_pm_32bit_ds - gdt_base)
38457 AF38           8ED8                           mov ds, ax
38458 AF3A           8EC0                           mov es, ax
38459 AF3C           8ED0                           mov ss, ax
38460                                               ; Marshal arguments and call 32-bit function
38461 AF3E           B9               00000008      mov ecx, #32/4
38462                       0000AF43            upcall2:
38463 AF43           FF7424       2A                push 32 -4+14[esp]
38464 AF47           E2           FA                loop upcall2
38465 AF49           A1     000EA000                mov eax, [0x000EA000 + 0]
38466 AF4E           FFD0                           call eax
38467 AF50           83C4                   20      add esp, #32
38468 AF53           89C1                           mov ecx, eax ; Result in ecx
38469                                               ; Restore real-mode stack pointer
38470 AF55           31C0                           xor eax, eax
38471 AF57     66    8B4424       04                mov ax, 4[esp]
38472 AF5C     66    89C3                           mov bx, ax ; Real-mode ss in bx
38473 AF5F           C1E0                   04      shl eax, 4
38474 AF62           29C4                           sub esp, eax
38475                                               ; Return to real mode
38476 AF64           EA     0000AF6B      0010      jmpf upcall3, #(gdt_entry_pm_16bit_cs - gdt_base)
38477                       0000AF6B            upcall3:
38478                                               USE16
38479 AF6B           B8                   0020      mov ax, #(gdt_entry_pm_16bit_ds - gdt_base)
38480 AF6E           8ED8                           mov ds, ax
38481 AF70           8EC0                           mov es, ax
38482 AF72           8ED0                           mov ss, ax
38483 AF74         0F20C0                           mov eax, cr0
38484 AF77           24                     FE      and al, #0xfe ; protected mode off
38485 AF79         0F22C0                           mov cr0, eax
38486 AF7C           EA         AF81      F000      jmpf upcall4, #0xf0000>>4
38487                       0000AF81            upcall4:
38488 AF81           2E                             seg cs
38489 AF82         0F0116       AEFE                lgdt realmode_gdtdesc
38490                                               ; Restore real-mode ss
38491 AF87           8ED3                           mov ss, bx
38492                                               ; Convert result into dx:ax format
38493 AF89     66    89C8                           mov eax, ecx
38494 AF8C     66    C1C8                   10      ror eax, #16
38495 AF90           89C2                           mov dx, ax
38496 AF92     66    C1C8                   10      ror eax, #16
38497                                               ; Restore caller state and return
38498 AF96     66    5C                             pop esp
38499 AF98           5B                             pop bx ; skip ss
38500 AF99           07                             pop es
38501 AF9A           1F                             pop ds
38502 AF9B           9D                             popf
38503 AF9C           C3                             ret
38504                                           MACRO DoUpcall
38505                                               mov bx, #?1
38506                                               jmp Upcall
38507                                           MEND
38508                       0000AF9D            _TCGInterruptHandler: DoUpcall(0)
 +a   AF9D           BB                   0000      mov bx, #0
 +a   AFA0           E9         FF61                jmp Upcall
38509                       0000AFA3            _tcpa_acpi_init: DoUpcall(1)
 +a   AFA3           BB                   0001      mov bx, #1
 +a   AFA6           E9         FF5B                jmp Upcall
38510                       0000AFA9            _tcpa_extend_acpi_log: DoUpcall(2)
 +a   AFA9           BB                   0002      mov bx, #2
 +a   AFAC           E9         FF55                jmp Upcall
38511                       0000AFAF            _tcpa_calling_int19h: DoUpcall(3)
 +a   AFAF           BB                   0003      mov bx, #3
 +a   AFB2           E9         FF4F                jmp Upcall
38512                       0000AFB5            _tcpa_returned_int19h: DoUpcall(4)
 +a   AFB5           BB                   0004      mov bx, #4
 +a   AFB8           E9         FF49                jmp Upcall
38513                       0000AFBB            _tcpa_add_event_separators: DoUpcall(5)
 +a   AFBB           BB                   0005      mov bx, #5
 +a   AFBE           E9         FF43                jmp Upcall
38514                       0000AFC1            _tcpa_wake_event: DoUpcall(6)
 +a   AFC1           BB                   0006      mov bx, #6
 +a   AFC4           E9         FF3D                jmp Upcall
38515                       0000AFC7            _tcpa_add_bootdevice: DoUpcall(7)
 +a   AFC7           BB                   0007      mov bx, #7
 +a   AFCA           E9         FF37                jmp Upcall
38516                       0000AFCD            _tcpa_start_option_rom_scan: DoUpcall(8)
 +a   AFCD           BB                   0008      mov bx, #8
 +a   AFD0           E9         FF31                jmp Upcall
38517                       0000AFD3            _tcpa_option_rom: DoUpcall(9)
 +a   AFD3           BB                   0009      mov bx, #9
 +a   AFD6           E9         FF2B                jmp Upcall
38518                       0000AFD9            _tcpa_ipl: DoUpcall(10)
 +a   AFD9           BB                   000A      mov bx, #10
 +a   AFDC           E9         FF25                jmp Upcall
38519                       0000AFDF            _tcpa_measure_post: DoUpcall(11)
 +a   AFDF           BB                   000B      mov bx, #11
 +a   AFE2           E9         FF1F                jmp Upcall
38520                       0000AFE5            _tcpa_initialize_tpm: DoUpcall(12)
 +a   AFE5           BB                   000C      mov bx, #12
 +a   AFE8           E9         FF19                jmp Upcall
38521                       0000AFEB            _get_s3_waking_vector: DoUpcall(13)
 +a   AFEB           BB                   000D      mov bx, #13
 +a   AFEE           E9         FF13                jmp Upcall
38522                       0000AFF1            _pmm: DoUpcall(14)
 +a   AFF1           BB                   000E      mov bx, #14
 +a   AFF4           E9         FF0D                jmp Upcall
38523                                           ! 6676 endasm
38524                                           !BCC_ENDASM
38525                                           ! 6677 #asm
38526                                           !BCC_ASM
38527                       00000012            _int70_function.ds	set	$12
38528                       00000014            _int70_function.iret_addr	set	$14
38529                       00000002            _int70_function.regs	set	2
38530                                           MACRO POST_MEASURE
38531                                            push word #0x000f
38532                                            push #?2
38533                                            push word #0x000f
38534                                            push #?1
38535                                            call _tcpa_measure_post
38536                                            add sp, #8
38537                                           MEND
38538                                           ! 6686 endasm
38539                                           !BCC_ENDASM
38540                                           ! 6687 void
38541                                           ! Register BX used in function int70_function
38542                                           ! 6688 tcpa_do_measure_POSTs()
38543                                           ! 6689 {
38544                                           export	_tcpa_do_measure_POSTs
38545                       0000AFF7            _tcpa_do_measure_POSTs:
38546                                           ! 6690 #asm
38547                                           !BCC_ASM
38548                                            POST_MEASURE(post, nmi)
 +a   AFF7           6A                     0F   push word #0x000f
 +a   AFF9           68                   E2C3   push # nmi
 +a   AFFC           6A                     0F   push word #0x000f
 +a   AFFE           68                   E05B   push #post
 +a   B001           E8         FFDB             call _tcpa_measure_post
 +a   B004           83C4                   08   add sp, #8
38549                                            POST_MEASURE(floppy_drive_post, hard_drive_post)
 +a   B007           6A                     0F   push word #0x000f
 +a   B009           68                   A8E2   push # hard_drive_post
 +a   B00C           6A                     0F   push word #0x000f
 +a   B00E           68                   A85B   push #floppy_drive_post
 +a   B011           E8         FFCB             call _tcpa_measure_post
 +a   B014           83C4                   08   add sp, #8
38550                                            POST_MEASURE(hard_drive_post, ebda_post)
 +a   B017           6A                     0F   push word #0x000f
 +a   B019           68                   AB0A   push # ebda_post
 +a   B01C           6A                     0F   push word #0x000f
 +a   B01E           68                   A8E2   push #hard_drive_post
 +a   B021           E8         FFBB             call _tcpa_measure_post
 +a   B024           83C4                   08   add sp, #8
38551                                            POST_MEASURE(ebda_post, eoi_jmp_post)
 +a   B027           6A                     0F   push word #0x000f
 +a   B029           68                   AB1F   push # eoi_jmp_post
 +a   B02C           6A                     0F   push word #0x000f
 +a   B02E           68                   AB0A   push #ebda_post
 +a   B031           E8         FFAB             call _tcpa_measure_post
 +a   B034           83C4                   08   add sp, #8
38552                                            POST_MEASURE(eoi_jmp_post, timer_tick_post)
 +a   B037           6A                     0F   push word #0x000f
 +a   B039           68                   AB70   push # timer_tick_post
 +a   B03C           6A                     0F   push word #0x000f
 +a   B03E           68                   AB1F   push #eoi_jmp_post
 +a   B041           E8         FF9B             call _tcpa_measure_post
 +a   B044           83C4                   08   add sp, #8
38553                                            POST_MEASURE(timer_tick_post, int76_handler)
 +a   B047           6A                     0F   push word #0x000f
 +a   B049           68                   ABE7   push # int76_handler
 +a   B04C           6A                     0F   push word #0x000f
 +a   B04E           68                   AB70   push #timer_tick_post
 +a   B051           E8         FF8B             call _tcpa_measure_post
 +a   B054           83C4                   08   add sp, #8
38554 B057           C3                          ret
38555                                           ! 6698 endasm
38556                                           !BCC_ENDASM
38557                                           ! 6699 }
38558 B058           C3                         ret
38559                                           ! 6700   void
38560                                           ! 6701 int1a_function32(regs, ES, DS, FLAGS)
38561                                           ! 6702   pushad_regs_t regs;
38562                                           export	_int1a_function32
38563                       0000B059            _int1a_function32:
38564                                           !BCC_EOS
38565                                           ! 6703   Bit16u ES, DS, FLAGS;
38566                                           !BCC_EOS
38567                                           ! 6704 {
38568                                           ! 6705  Bit16u rc;
38569                                           !BCC_EOS
38570                                           ! 6706  ;
38571 B059           55                         push	bp
38572 B05A           89E5                       mov	bp,sp
38573 B05C           4C                         dec	sp
38574 B05D           4C                         dec	sp
38575                                           !BCC_EOS
38576                                           ! 6707  switch (regs.u.r8.ah) {
38577 B05E           8A46         21            mov	al,$21[bp]
38578 B061           E9         00BC            br 	.770
38579                                           ! 6708  case 0xbb:
38580                                           ! 6709   if (regs.u.r8.al != 0 &&
38581                       0000B064            .771:
38582                                           ! 6710       regs.u.r32.ebx != 0x41504354L) {
38583                                           ! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
38584 B064           8A46         20            mov	al,$20[bp]
38585 B067           84C0                       test	al,al
38586 B069           74           25            je  	.772
38587                       0000B06B            .774:
38588                                           ! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
38589                                           ! Debug: expression subtree swapping
38590 B06B           B8                   4354  mov	ax,#$4354
38591 B06E           BB                   4150  mov	bx,#$4150
38592 B071           53                         push	bx
38593 B072           50                         push	ax
38594 B073           8B46         14            mov	ax,$14[bp]
38595 B076           8B5E         16            mov	bx,$16[bp]
38596 B079           8D7E         FA            lea	di,-2+..FFD9[bp]
38597 B07C           E8         504C            call	lcmpul
38598 B07F           8D66         FE            lea	sp,2+..FFD9[bp]
38599 B082           74           0C            je  	.772
38600                       0000B084            .773:
38601                                           ! 6711       FLAGS |= 0x0001;
38602                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38603 B084           8B46         28            mov	ax,$28[bp]
38604 B087           0C                     01  or	al,*1
38605 B089           8946         28            mov	$28[bp],ax
38606                                           !BCC_EOS
38607                                           ! 6712       return;
38608 B08C           89EC                       mov	sp,bp
38609 B08E           5D                         pop	bp
38610 B08F           C3                         ret
38611                                           !BCC_EOS
38612                                           ! 6713   }
38613                                           ! 6714   switch(regs.u.r8.al) {
38614                       0000B090            .772:
38615 B090           8A46         20            mov	al,$20[bp]
38616 B093           EB           58            jmp .777
38617                                           ! 6715   case 0x00:
38618                                           ! 6716   case 0x01:
38619                       0000B095            .778:
38620                                           ! 6717   case 0x02:
38621                       0000B095            .779:
38622                                           ! 6718   case 0x03:
38623                       0000B095            .77A:
38624                                           ! 6719   case 0x04:
38625                       0000B095            .77B:
38626                                           ! 6720   case 0x05:
38627                       0000B095            .77C:
38628                                           ! 6721   case 0x06:
38629                       0000B095            .77D:
38630                                           ! 6722   case 0x07:
38631                       0000B095            .77E:
38632                                           ! 6723    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
38633                       0000B095            .77F:
38634                                           ! 6724                        ES, DS,
38635                                           ! 6725                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
38636                                           ! Debug: expression subtree swapping
38637                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
38638 B095           E8         55B5            call	_get_SS
38639                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
38640 B098           31DB                       xor	bx,bx
38641                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
38642 B09A           BF                   0004  mov	di,*4
38643 B09D           E8         50A7            call	lslul
38644 B0A0           53                         push	bx
38645 B0A1           50                         push	ax
38646                                           ! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
38647 B0A2           89E8                       mov	ax,bp
38648 B0A4           05                   0028  add	ax,*$28
38649 B0A7           31DB                       xor	bx,bx
38650                                           ! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
38651 B0A9           8D7E         FA            lea	di,-2+..FFD9[bp]
38652 B0AC           E8         5014            call	laddul
38653 B0AF           83C4                   04  add	sp,*4
38654                                           ! Debug: list unsigned long = bx+0 (used reg = )
38655 B0B2           53                         push	bx
38656 B0B3           50                         push	ax
38657                                           ! Debug: list unsigned short DS = [S+8+$24] (used reg = )
38658 B0B4           FF76         26            push	$26[bp]
38659                                           ! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
38660 B0B7           FF76         24            push	$24[bp]
38661                                           ! Debug: expression subtree swapping
38662                                           ! Debug: func () unsigned short = get_SS+0 (used reg = )
38663 B0BA           E8         5590            call	_get_SS
38664                                           ! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
38665 B0BD           31DB                       xor	bx,bx
38666                                           ! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
38667 B0BF           BF                   0004  mov	di,*4
38668 B0C2           E8         5082            call	lslul
38669 B0C5           53                         push	bx
38670 B0C6           50                         push	ax
38671                                           ! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
38672 B0C7           89E8                       mov	ax,bp
38673 B0C9           05                   0004  add	ax,*4
38674 B0CC           31DB                       xor	bx,bx
38675                                           ! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
38676 B0CE           8D7E         F2            lea	di,-$A+..FFD9[bp]
38677 B0D1           E8         4FEF            call	laddul
38678 B0D4           83C4                   04  add	sp,*4
38679                                           ! Debug: list unsigned long = bx+0 (used reg = )
38680 B0D7           53                         push	bx
38681 B0D8           50                         push	ax
38682                                           ! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
38683 B0D9           E8         FEC1            call	_TCGInterruptHandler
38684 B0DC           89D3                       mov	bx,dx
38685 B0DE           83C4                   0C  add	sp,*$C
38686                                           !BCC_EOS
38687                                           ! 6726    break;
38688 B0E1           EB           2F            jmp .775
38689                                           !BCC_EOS
38690                                           ! 6727   default:
38691                                           ! 6728    FLAGS |= 0x0001;
38692                       0000B0E3            .780:
38693                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38694 B0E3           8B46         28            mov	ax,$28[bp]
38695 B0E6           0C                     01  or	al,*1
38696 B0E8           8946         28            mov	$28[bp],ax
38697                                           !BCC_EOS
38698                                           ! 6729   }
38699                                           ! 6730   break;
38700 B0EB           EB           25            jmp .775
38701                       0000B0ED            .777:
38702 B0ED           2C                     00  sub	al,*0
38703 B0EF           72           F2            jb 	.780
38704 B0F1           3C                     07  cmp	al,*7
38705 B0F3           77           1B            ja  	.781
38706 B0F5           30E4                       xor	ah,ah
38707 B0F7           D1E0                       shl	ax,*1
38708 B0F9           89C3                       mov	bx,ax
38709 B0FB           2E                         seg	cs
38710 B0FC           FFA7       B100            br	.782[bx]
38711                       0000B100            .782:
38712 B100                      B095            .word	.778
38713 B102                      B095            .word	.779
38714 B104                      B095            .word	.77A
38715 B106                      B095            .word	.77B
38716 B108                      B095            .word	.77C
38717 B10A                      B095            .word	.77D
38718 B10C                      B095            .word	.77E
38719 B10E                      B095            .word	.77F
38720                       0000B110            .781:
38721 B110           EB           D1            jmp	.780
38722                       0000B112            .775:
38723 B112           EB           14            jmp .76E
38724                                           !BCC_EOS
38725                                           ! 6731  default:
38726                                           ! 6732   FLAGS |= 0x0001;
38727                       0000B114            .783:
38728                                           ! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
38729 B114           8B46         28            mov	ax,$28[bp]
38730 B117           0C                     01  or	al,*1
38731 B119           8946         28            mov	$28[bp],ax
38732                                           !BCC_EOS
38733                                           ! 6733   break;
38734 B11C           EB           0A            jmp .76E
38735                                           !BCC_EOS
38736                                           ! 6734  }
38737                                           ! 6735  ;
38738 B11E           EB           08            jmp .76E
38739                       0000B120            .770:
38740 B120           2C                     BB  sub	al,#$BB
38741 B122         0F84         FF3E            beq 	.771
38742 B126           EB           EC            jmp	.783
38743                       0000B128            .76E:
38744                       FFFFFFFC            ..FFD9	=	-4
38745                                           !BCC_EOS
38746                                           ! 6736 }
38747 B128           89EC                       mov	sp,bp
38748 B12A           5D                         pop	bp
38749 B12B           C3                         ret
38750                                           ! 6737 #asm
38751                                           !BCC_ASM
38752                       00000026            _int1a_function32.FLAGS	set	$26
38753                       00000024            _int1a_function32.DS	set	$24
38754                       00000022            _int1a_function32.ES	set	$22
38755                       00000002            _int1a_function32.regs	set	2
38756                                           ;--------------------
38757                                           use32 386
38758 B12C                  00000010            .align 16
38759                       0000B130            bios32_structure:
38760 B130                        5F              db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
38761 B134                      B140              dw bios32_entry_point, 0xf ;; 32 bit physical address
38762 B138                        00              db 0 ;; revision level
38763                                             ;; length in paragraphs and checksum stored in a word to prevent errors
38764 B139                      DC01              dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
38765 B13B                        00              db 0,0,0,0,0 ;; reserved
38766 B140                  00000010            .align 16
38767                       0000B140            bios32_entry_point:
38768 B140           9C                           pushfd
38769 B141           3D               49435024    cmp eax, #0x49435024 ;; "$PCI"
38770 B146           75           29              jne unknown_service
38771 B148           B8               80000000    mov eax, #0x80000000
38772 B14D     66    BA                   0CF8    mov dx, #0x0cf8
38773 B151           EF                           out dx, eax
38774 B152     66    BA                   0CFC    mov dx, #0x0cfc
38775 B156           ED                           in eax, dx
38776 B157           3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
38777 B15C           75           13              jne unknown_service
38778 B15E           BB               000F0000    mov ebx, #0x000f0000
38779 B163           B9               00000000    mov ecx, #0
38780 B168           BA               0000B180    mov edx, #pcibios_protected
38781 B16D           30C0                         xor al, al
38782 B16F           EB           02              jmp bios32_end
38783                       0000B171            unknown_service:
38784 B171           B0                     80    mov al, #0x80
38785                       0000B173            bios32_end:
38786 B173           9D                           popfd
38787 B174           CB                           retf
38788 B175                  00000010            .align 16
38789                       0000B180            pcibios_protected:
38790 B180           9C                           pushfd
38791 B181           FA                           cli
38792 B182           56                           push esi
38793 B183           57                           push edi
38794 B184           3C                     01    cmp al, #0x01 ;; installation check
38795 B186           75           14              jne pci_pro_f02
38796 B188     66    BB                   0210    mov bx, #0x0210
38797 B18C     66    B9                   0000    mov cx, #0
38798 B190           BA               20494350    mov edx, #0x20494350 ;; "PCI "
38799 B195           B0                     01    mov al, #0x01
38800 B197           E9     0000011B              jmp pci_pro_ok
38801                       0000B19C            pci_pro_f02: ;; find pci device
38802 B19C           3C                     02    cmp al, #0x02
38803 B19E           75           38              jne pci_pro_f03
38804 B1A0           C1E1                   10    shl ecx, #16
38805 B1A3     66    89D1                         mov cx, dx
38806 B1A6     66    31DB                         xor bx, bx
38807 B1A9     66    BF                   0000    mov di, #0x00
38808                       0000B1AD            pci_pro_devloop:
38809 B1AD           E8     0000010C              call pci_pro_select_reg
38810 B1B2     66    BA                   0CFC    mov dx, #0x0cfc
38811 B1B6           ED                           in eax, dx
38812 B1B7           39C8                         cmp eax, ecx
38813 B1B9           75           0D              jne pci_pro_nextdev
38814 B1BB     66    83FE                   00    cmp si, #0
38815 B1BF   7505    E9     000000F1              je pci_pro_ok
38816 B1C6     66    4E                           dec si
38817                       0000B1C8            pci_pro_nextdev:
38818 B1C8     66    43                           inc bx
38819 B1CA     66    81FB                 0100    cmp bx, #0x0100
38820 B1CF           75           DC              jne pci_pro_devloop
38821 B1D1           B4                     86    mov ah, #0x86
38822 B1D3           E9     000000DA              jmp pci_pro_fail
38823                       0000B1D8            pci_pro_f03: ;; find class code
38824 B1D8           3C                     03    cmp al, #0x03
38825 B1DA           75           35              jne pci_pro_f08
38826 B1DC     66    31DB                         xor bx, bx
38827 B1DF     66    BF                   0008    mov di, #0x08
38828                       0000B1E3            pci_pro_devloop2:
38829 B1E3           E8     000000D6              call pci_pro_select_reg
38830 B1E8     66    BA                   0CFC    mov dx, #0x0cfc
38831 B1EC           ED                           in eax, dx
38832 B1ED           C1E8                   08    shr eax, #8
38833 B1F0           39C8                         cmp eax, ecx
38834 B1F2           75           0D              jne pci_pro_nextdev2
38835 B1F4     66    83FE                   00    cmp si, #0
38836 B1F8   7505    E9     000000B8              je pci_pro_ok
38837 B1FF     66    4E                           dec si
38838                       0000B201            pci_pro_nextdev2:
38839 B201     66    43                           inc bx
38840 B203     66    81FB                 0100    cmp bx, #0x0100
38841 B208           75           D9              jne pci_pro_devloop2
38842 B20A           B4                     86    mov ah, #0x86
38843 B20C           E9     000000A1              jmp pci_pro_fail
38844                       0000B211            pci_pro_f08: ;; read configuration byte
38845 B211           3C                     08    cmp al, #0x08
38846 B213           75           1B              jne pci_pro_f09
38847 B215           E8     000000A4              call pci_pro_select_reg
38848 B21A           52                           push edx
38849 B21B     66    89FA                         mov dx, di
38850 B21E     66    83E2                   03    and dx, #0x03
38851 B222     66    81C2                 0CFC    add dx, #0x0cfc
38852 B227           EC                           in al, dx
38853 B228           5A                           pop edx
38854 B229           88C1                         mov cl, al
38855 B22B           E9     00000087              jmp pci_pro_ok
38856                       0000B230            pci_pro_f09: ;; read configuration word
38857 B230           3C                     09    cmp al, #0x09
38858 B232           75           1A              jne pci_pro_f0a
38859 B234           E8     00000085              call pci_pro_select_reg
38860 B239           52                           push edx
38861 B23A     66    89FA                         mov dx, di
38862 B23D     66    83E2                   02    and dx, #0x02
38863 B241     66    81C2                 0CFC    add dx, #0x0cfc
38864 B246     66    ED                           in ax, dx
38865 B248           5A                           pop edx
38866 B249     66    89C1                         mov cx, ax
38867 B24C           EB           69              jmp pci_pro_ok
38868                       0000B24E            pci_pro_f0a: ;; read configuration dword
38869 B24E           3C                     0A    cmp al, #0x0a
38870 B250           75           10              jne pci_pro_f0b
38871 B252           E8     00000067              call pci_pro_select_reg
38872 B257           52                           push edx
38873 B258     66    BA                   0CFC    mov dx, #0x0cfc
38874 B25C           ED                           in eax, dx
38875 B25D           5A                           pop edx
38876 B25E           89C1                         mov ecx, eax
38877 B260           EB           55              jmp pci_pro_ok
38878                       0000B262            pci_pro_f0b: ;; write configuration byte
38879 B262           3C                     0B    cmp al, #0x0b
38880 B264           75           18              jne pci_pro_f0c
38881 B266           E8     00000053              call pci_pro_select_reg
38882 B26B           52                           push edx
38883 B26C     66    89FA                         mov dx, di
38884 B26F     66    83E2                   03    and dx, #0x03
38885 B273     66    81C2                 0CFC    add dx, #0x0cfc
38886 B278           88C8                         mov al, cl
38887 B27A           EE                           out dx, al
38888 B27B           5A                           pop edx
38889 B27C           EB           39              jmp pci_pro_ok
38890                       0000B27E            pci_pro_f0c: ;; write configuration word
38891 B27E           3C                     0C    cmp al, #0x0c
38892 B280           75           1A              jne pci_pro_f0d
38893 B282           E8     00000037              call pci_pro_select_reg
38894 B287           52                           push edx
38895 B288     66    89FA                         mov dx, di
38896 B28B     66    83E2                   02    and dx, #0x02
38897 B28F     66    81C2                 0CFC    add dx, #0x0cfc
38898 B294     66    89C8                         mov ax, cx
38899 B297     66    EF                           out dx, ax
38900 B299           5A                           pop edx
38901 B29A           EB           1B              jmp pci_pro_ok
38902                       0000B29C            pci_pro_f0d: ;; write configuration dword
38903 B29C           3C                     0D    cmp al, #0x0d
38904 B29E           75           10              jne pci_pro_unknown
38905 B2A0           E8     00000019              call pci_pro_select_reg
38906 B2A5           52                           push edx
38907 B2A6     66    BA                   0CFC    mov dx, #0x0cfc
38908 B2AA           89C8                         mov eax, ecx
38909 B2AC           EF                           out dx, eax
38910 B2AD           5A                           pop edx
38911 B2AE           EB           07              jmp pci_pro_ok
38912                       0000B2B0            pci_pro_unknown:
38913 B2B0           B4                     81    mov ah, #0x81
38914                       0000B2B2            pci_pro_fail:
38915 B2B2           5F                           pop edi
38916 B2B3           5E                           pop esi
38917 B2B4           9D                           popfd
38918 B2B5           F9                           stc
38919 B2B6           CB                           retf
38920                       0000B2B7            pci_pro_ok:
38921 B2B7           30E4                         xor ah, ah
38922 B2B9           5F                           pop edi
38923 B2BA           5E                           pop esi
38924 B2BB           9D                           popfd
38925 B2BC           F8                           clc
38926 B2BD           CB                           retf
38927                       0000B2BE            pci_pro_select_reg:
38928 B2BE           52                           push edx
38929 B2BF           B8               00800000    mov eax, #0x800000
38930 B2C4     66    89D8                         mov ax, bx
38931 B2C7           C1E0                   08    shl eax, #8
38932 B2CA     66    81E7                 00FF    and di, #0xff
38933 B2CF     66    09F8                         or ax, di
38934 B2D2           24                     FC    and al, #0xfc
38935 B2D4     66    BA                   0CF8    mov dx, #0x0cf8
38936 B2D8           EF                           out dx, eax
38937 B2D9           5A                           pop edx
38938 B2DA           C3                           ret
38939                                           use16 386
38940                       0000B2DB            pcibios_real:
38941 B2DB     66    50                           push eax
38942 B2DD           52                           push dx
38943 B2DE     66    B8               80000000    mov eax, #0x80000000
38944 B2E4           BA                   0CF8    mov dx, #0x0cf8
38945 B2E7     66    EF                           out dx, eax
38946 B2E9           BA                   0CFC    mov dx, #0x0cfc
38947 B2EC     66    ED                           in eax, dx
38948 B2EE     66    3D               12378086    cmp eax, #0x12378086 ;; i440FX PCI bridge
38949 B2F4           74           07              je pci_present
38950 B2F6           5A                           pop dx
38951 B2F7     66    58                           pop eax
38952 B2F9           B4                     FF    mov ah, #0xff
38953 B2FB           F9                           stc
38954 B2FC           C3                           ret
38955                       0000B2FD            pci_present:
38956 B2FD           5A                           pop dx
38957 B2FE     66    58                           pop eax
38958 B300           3C                     01    cmp al, #0x01 ;; installation check
38959 B302           75           1A              jne pci_real_f02
38960 B304           B8                   0001    mov ax, #0x0001
38961 B307           BB                   0210    mov bx, #0x0210
38962 B30A           B9                   0000    mov cx, #0
38963 B30D     66    BA               20494350    mov edx, #0x20494350 ;; "PCI "
38964 B313     66    BF               000F0000    mov edi, #0xf0000
38965 B319           BF                   B180    mov di, #pcibios_protected
38966 B31C           F8                           clc
38967 B31D           C3                           ret
38968                       0000B31E            pci_real_f02: ;; find pci device
38969 B31E     66    56                           push esi
38970 B320     66    57                           push edi
38971 B322           3C                     02    cmp al, #0x02
38972 B324           75           34              jne pci_real_f03
38973 B326     66    C1E1                   10    shl ecx, #16
38974 B32A           89D1                         mov cx, dx
38975 B32C           31DB                         xor bx, bx
38976 B32E           BF                   0000    mov di, #0x00
38977                       0000B331            pci_real_devloop:
38978 B331           E8         012F              call pci_real_select_reg
38979 B334           BA                   0CFC    mov dx, #0x0cfc
38980 B337     66    ED                           in eax, dx
38981 B339     66    39C8                         cmp eax, ecx
38982 B33C           75           09              jne pci_real_nextdev
38983 B33E           83FE                   00    cmp si, #0
38984 B341   7503    E9         0115              je pci_real_ok
38985 B346           4E                           dec si
38986                       0000B347            pci_real_nextdev:
38987 B347           43                           inc bx
38988 B348           81FB                 0100    cmp bx, #0x0100
38989 B34C           75           E3              jne pci_real_devloop
38990 B34E           89CA                         mov dx, cx
38991 B350     66    C1E9                   10    shr ecx, #16
38992 B354           B8                   8602    mov ax, #0x8602
38993 B357           E9         00FB              jmp pci_real_fail
38994                       0000B35A            pci_real_f03: ;; find class code
38995 B35A           3C                     03    cmp al, #0x03
38996 B35C           75           32              jne pci_real_f08
38997 B35E           31DB                         xor bx, bx
38998 B360           BF                   0008    mov di, #0x08
38999                       0000B363            pci_real_devloop2:
39000 B363           E8         00FD              call pci_real_select_reg
39001 B366           BA                   0CFC    mov dx, #0x0cfc
39002 B369     66    ED                           in eax, dx
39003 B36B     66    C1E8                   08    shr eax, #8
39004 B36F     66    39C8                         cmp eax, ecx
39005 B372           75           09              jne pci_real_nextdev2
39006 B374           83FE                   00    cmp si, #0
39007 B377   7503    E9         00DF              je pci_real_ok
39008 B37C           4E                           dec si
39009                       0000B37D            pci_real_nextdev2:
39010 B37D           43                           inc bx
39011 B37E           81FB                 0100    cmp bx, #0x0100
39012 B382           75           DF              jne pci_real_devloop2
39013 B384           89CA                         mov dx, cx
39014 B386     66    C1E9                   10    shr ecx, #16
39015 B38A           B8                   8603    mov ax, #0x8603
39016 B38D           E9         00C5              jmp pci_real_fail
39017                       0000B390            pci_real_f08: ;; read configuration byte
39018 B390           3C                     08    cmp al, #0x08
39019 B392           75           14              jne pci_real_f09
39020 B394           E8         00CC              call pci_real_select_reg
39021 B397           52                           push dx
39022 B398           89FA                         mov dx, di
39023 B39A           83E2                   03    and dx, #0x03
39024 B39D           81C2                 0CFC    add dx, #0x0cfc
39025 B3A1           EC                           in al, dx
39026 B3A2           5A                           pop dx
39027 B3A3           88C1                         mov cl, al
39028 B3A5           E9         00B3              jmp pci_real_ok
39029                       0000B3A8            pci_real_f09: ;; read configuration word
39030 B3A8           3C                     09    cmp al, #0x09
39031 B3AA           75           14              jne pci_real_f0a
39032 B3AC           E8         00B4              call pci_real_select_reg
39033 B3AF           52                           push dx
39034 B3B0           89FA                         mov dx, di
39035 B3B2           83E2                   02    and dx, #0x02
39036 B3B5           81C2                 0CFC    add dx, #0x0cfc
39037 B3B9           ED                           in ax, dx
39038 B3BA           5A                           pop dx
39039 B3BB           89C1                         mov cx, ax
39040 B3BD           E9         009B              jmp pci_real_ok
39041                       0000B3C0            pci_real_f0a: ;; read configuration dword
39042 B3C0           3C                     0A    cmp al, #0x0a
39043 B3C2           75           10              jne pci_real_f0b
39044 B3C4           E8         009C              call pci_real_select_reg
39045 B3C7           52                           push dx
39046 B3C8           BA                   0CFC    mov dx, #0x0cfc
39047 B3CB     66    ED                           in eax, dx
39048 B3CD           5A                           pop dx
39049 B3CE     66    89C1                         mov ecx, eax
39050 B3D1           E9         0087              jmp pci_real_ok
39051                       0000B3D4            pci_real_f0b: ;; write configuration byte
39052 B3D4           3C                     0B    cmp al, #0x0b
39053 B3D6           75           13              jne pci_real_f0c
39054 B3D8           E8         0088              call pci_real_select_reg
39055 B3DB           52                           push dx
39056 B3DC           89FA                         mov dx, di
39057 B3DE           83E2                   03    and dx, #0x03
39058 B3E1           81C2                 0CFC    add dx, #0x0cfc
39059 B3E5           88C8                         mov al, cl
39060 B3E7           EE                           out dx, al
39061 B3E8           5A                           pop dx
39062 B3E9           EB           70              jmp pci_real_ok
39063                       0000B3EB            pci_real_f0c: ;; write configuration word
39064 B3EB           3C                     0C    cmp al, #0x0c
39065 B3ED           75           13              jne pci_real_f0d
39066 B3EF           E8         0071              call pci_real_select_reg
39067 B3F2           52                           push dx
39068 B3F3           89FA                         mov dx, di
39069 B3F5           83E2                   02    and dx, #0x02
39070 B3F8           81C2                 0CFC    add dx, #0x0cfc
39071 B3FC           89C8                         mov ax, cx
39072 B3FE           EF                           out dx, ax
39073 B3FF           5A                           pop dx
39074 B400           EB           59              jmp pci_real_ok
39075                       0000B402            pci_real_f0d: ;; write configuration dword
39076 B402           3C                     0D    cmp al, #0x0d
39077 B404           75           0F              jne pci_real_f0e
39078 B406           E8         005A              call pci_real_select_reg
39079 B409           52                           push dx
39080 B40A           BA                   0CFC    mov dx, #0x0cfc
39081 B40D     66    89C8                         mov eax, ecx
39082 B410     66    EF                           out dx, eax
39083 B412           5A                           pop dx
39084 B413           EB           46              jmp pci_real_ok
39085                       0000B415            pci_real_f0e: ;; get irq routing options
39086 B415           3C                     0E    cmp al, #0x0e
39087 B417           75           3A              jne pci_real_unknown
39088 B419           26                           SEG ES
39089 B41A           833D                   60    cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39090 B41D           72           2B              jb pci_real_too_small
39091 B41F           26                           SEG ES
39092 B420           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39093 B424           9C                           pushf
39094 B425           1E                           push ds
39095 B426           06                           push es
39096 B427           51                           push cx
39097 B428           56                           push si
39098 B429           57                           push di
39099 B42A           FC                           cld
39100 B42B           BE                   B4A0    mov si, #pci_routing_table_structure_start
39101 B42E           0E                           push cs
39102 B42F           1F                           pop ds
39103 B430           26                           SEG ES
39104 B431           8B4D         02              mov cx, [di+2]
39105 B434           26                           SEG ES
39106 B435           8E45         04              mov es, [di+4]
39107 B438           89CF                         mov di, cx
39108 B43A           B9                   0060    mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
39109 B43D           F3                           rep
39110 B43E           A4                               movsb
39111 B43F           5F                           pop di
39112 B440           5E                           pop si
39113 B441           59                           pop cx
39114 B442           07                           pop es
39115 B443           1F                           pop ds
39116 B444           9D                           popf
39117 B445           BB                   0A00    mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
39118 B448           EB           11              jmp pci_real_ok
39119                       0000B44A            pci_real_too_small:
39120 B44A           26                           SEG ES
39121 B44B           C705                 0060    mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
39122 B44F           B4                     89    mov ah, #0x89
39123 B451           EB           02              jmp pci_real_fail
39124                       0000B453            pci_real_unknown:
39125 B453           B4                     81    mov ah, #0x81
39126                       0000B455            pci_real_fail:
39127 B455     66    5F                           pop edi
39128 B457     66    5E                           pop esi
39129 B459           F9                           stc
39130 B45A           C3                           ret
39131                       0000B45B            pci_real_ok:
39132 B45B           30E4                         xor ah, ah
39133 B45D     66    5F                           pop edi
39134 B45F     66    5E                           pop esi
39135 B461           F8                           clc
39136 B462           C3                           ret
39137                       0000B463            pci_real_select_reg:
39138 B463           52                           push dx
39139 B464     66    B8               00800000    mov eax, #0x800000
39140 B46A           89D8                         mov ax, bx
39141 B46C     66    C1E0                   08    shl eax, #8
39142 B470           81E7                 00FF    and di, #0xff
39143 B474           09F8                         or ax, di
39144 B476           24                     FC    and al, #0xfc
39145 B478           BA                   0CF8    mov dx, #0x0cf8
39146 B47B     66    EF                           out dx, eax
39147 B47D           5A                           pop dx
39148 B47E           C3                           ret
39149 B47F                  00000010            .align 16
39150                       0000B480            pci_routing_table_structure:
39151 B480                        24              db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
39152 B484                        00              db 0, 1 ;; version
39153 B486                      0080              dw 32 + (6 * 16) ;; table size
39154 B488                        00              db 0 ;; PCI interrupt router bus
39155 B489                        08              db 0x08 ;; PCI interrupt router DevFunc
39156 B48A                      0000              dw 0x0000 ;; PCI exclusive IRQs
39157 B48C                      8086              dw 0x8086 ;; compatible PCI interrupt router vendor ID
39158 B48E                      122E              dw 0x122e ;; compatible PCI interrupt router device ID
39159 B490                      0000              dw 0,0 ;; Miniport data
39160 B494                        00              db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
39161 B49F                        37              db 0x37 ;; checksum
39162                       0000B4A0            pci_routing_table_structure_start:
39163                                             ;; first slot entry PCI-to-ISA (embedded)
39164 B4A0                        00              db 0 ;; pci bus number
39165 B4A1                        08              db 0x08 ;; pci device number (bit 7-3)
39166 B4A2                        61              db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
39167 B4A3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39168 B4A5                        62              db 0x62 ;; link value INTB#
39169 B4A6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39170 B4A8                        63              db 0x63 ;; link value INTC#
39171 B4A9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39172 B4AB                        60              db 0x60 ;; link value INTD#
39173 B4AC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39174 B4AE                        00              db 0 ;; physical slot (0 = embedded)
39175 B4AF                        00              db 0 ;; reserved
39176                                             ;; second slot entry: 1st PCI slot
39177 B4B0                        00              db 0 ;; pci bus number
39178 B4B1                        10              db 0x10 ;; pci device number (bit 7-3)
39179 B4B2                        62              db 0x62 ;; link value INTA#
39180 B4B3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39181 B4B5                        63              db 0x63 ;; link value INTB#
39182 B4B6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39183 B4B8                        60              db 0x60 ;; link value INTC#
39184 B4B9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39185 B4BB                        61              db 0x61 ;; link value INTD#
39186 B4BC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39187 B4BE                        01              db 1 ;; physical slot (0 = embedded)
39188 B4BF                        00              db 0 ;; reserved
39189                                             ;; third slot entry: 2nd PCI slot
39190 B4C0                        00              db 0 ;; pci bus number
39191 B4C1                        18              db 0x18 ;; pci device number (bit 7-3)
39192 B4C2                        63              db 0x63 ;; link value INTA#
39193 B4C3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39194 B4C5                        60              db 0x60 ;; link value INTB#
39195 B4C6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39196 B4C8                        61              db 0x61 ;; link value INTC#
39197 B4C9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39198 B4CB                        62              db 0x62 ;; link value INTD#
39199 B4CC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39200 B4CE                        02              db 2 ;; physical slot (0 = embedded)
39201 B4CF                        00              db 0 ;; reserved
39202                                             ;; 4th slot entry: 3rd PCI slot
39203 B4D0                        00              db 0 ;; pci bus number
39204 B4D1                        20              db 0x20 ;; pci device number (bit 7-3)
39205 B4D2                        60              db 0x60 ;; link value INTA#
39206 B4D3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39207 B4D5                        61              db 0x61 ;; link value INTB#
39208 B4D6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39209 B4D8                        62              db 0x62 ;; link value INTC#
39210 B4D9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39211 B4DB                        63              db 0x63 ;; link value INTD#
39212 B4DC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39213 B4DE                        03              db 3 ;; physical slot (0 = embedded)
39214 B4DF                        00              db 0 ;; reserved
39215                                             ;; 5th slot entry: 4rd PCI slot
39216 B4E0                        00              db 0 ;; pci bus number
39217 B4E1                        28              db 0x28 ;; pci device number (bit 7-3)
39218 B4E2                        61              db 0x61 ;; link value INTA#
39219 B4E3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39220 B4E5                        62              db 0x62 ;; link value INTB#
39221 B4E6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39222 B4E8                        63              db 0x63 ;; link value INTC#
39223 B4E9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39224 B4EB                        60              db 0x60 ;; link value INTD#
39225 B4EC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39226 B4EE                        04              db 4 ;; physical slot (0 = embedded)
39227 B4EF                        00              db 0 ;; reserved
39228                                             ;; 6th slot entry: 5rd PCI slot
39229 B4F0                        00              db 0 ;; pci bus number
39230 B4F1                        30              db 0x30 ;; pci device number (bit 7-3)
39231 B4F2                        62              db 0x62 ;; link value INTA#
39232 B4F3                      0C20              dw 0x0c20 ;; IRQ bitmap INTA#
39233 B4F5                        63              db 0x63 ;; link value INTB#
39234 B4F6                      0C20              dw 0x0c20 ;; IRQ bitmap INTB#
39235 B4F8                        60              db 0x60 ;; link value INTC#
39236 B4F9                      0C20              dw 0x0c20 ;; IRQ bitmap INTC#
39237 B4FB                        61              db 0x61 ;; link value INTD#
39238 B4FC                      0C20              dw 0x0c20 ;; IRQ bitmap INTD#
39239 B4FE                        05              db 5 ;; physical slot (0 = embedded)
39240 B4FF                        00              db 0 ;; reserved
39241                       0000B500            pci_routing_table_structure_end:
39242                                           ; according to POST Memory Manager Specification Version 1.01
39243 B500                  00000010            .align 16
39244                       0000B500            pmm_structure:
39245 B500                        24              db 0x24,0x50,0x4d,0x4d ;; "$PMM" signature
39246 B504                        01              db 0x01 ;; revision
39247 B505                        10              db 16 ;; length
39248 B506                        2C              db (-((pmm_entry_point>>8)+pmm_entry_point+0x20f))&0xff;; checksum
39249 B507                      B510              dw pmm_entry_point,0xf000 ;; far call entrypoint
39250 B50B                        00              db 0,0,0,0,0 ;; reserved
39251                       0000B510            pmm_entry_point:
39252 B510           9C                           pushf
39253 B511     66    60                           pushad
39254                                           ; Calculate protected-mode address of PMM function args
39255 B513     66    31C0                         xor eax, eax
39256 B516           89E0                         mov ax, sp
39257 B518     66    31DB                         xor ebx, ebx
39258 B51B           8CD3                         mov bx, ss
39259 B51D     66    C1E3                   04    shl ebx, 4
39260 B521   6766    8D5C18       26              lea ebx, [eax+ebx+38] ;; ebx=(ss<<4)+sp+4(far call)+2(pushf)+32(pushad)
39261 B527     66    53                           push ebx
39262                                           ;
39263                                           ; Stack layout at this point:
39264                                           ;
39265                                           ; : +0x0 +0x2 +0x4 +0x6 +0x8 +0xa +0xc +0xe
39266                                           ; -----------------------------------------------------------------------
39267                                           ; sp : [&arg1 ][edi ][esi ][ebp ]
39268                                           ; sp+0x10: [esp ][ebx ][edx ][ecx ]
39269                                           ; sp+0x20: [eax ][flags ][ip ][cs ][arg1 ][arg2, ...
39270                                           ;
39271 B529           E8         FAC5              call _pmm
39272 B52C           89E3                         mov bx, sp
39273 B52E           36                         SEG SS
39274 B52F           8947         20              mov [bx+0x20], ax
39275 B532           36                         SEG SS
39276 B533           8957         18              mov [bx+0x18], dx
39277 B536     66    5B                           pop ebx
39278 B538     66    61                           popad
39279 B53A           9D                           popf
39280 B53B           CB                           retf
39281                                           ; parallel port detection: base address in DX, index in BX, timeout in CL
39282                       0000B53C            detect_parport:
39283 B53C           52                           push dx
39284 B53D           83C2                   02    add dx, #2
39285 B540           EC                           in al, dx
39286 B541           24                     DF    and al, #0xdf ; clear input mode
39287 B543           EE                           out dx, al
39288 B544           5A                           pop dx
39289 B545           B0                     AA    mov al, #0xaa
39290 B547           EE                           out dx, al
39291 B548           EC                           in al, dx
39292 B549           3C                     AA    cmp al, #0xaa
39293 B54B           75           0D              jne no_parport
39294 B54D           53                           push bx
39295 B54E           D1E3                         shl bx, #1
39296 B550           8997       0408              mov [bx+0x408], dx ; Parallel I/O address
39297 B554           5B                           pop bx
39298 B555           888F       0478              mov [bx+0x478], cl ; Parallel printer timeout
39299 B559           43                           inc bx
39300                       0000B55A            no_parport:
39301 B55A           C3                           ret
39302                                           ; serial port detection: base address in DX, index in BX, timeout in CL
39303                       0000B55B            detect_serial:
39304 B55B           52                           push dx
39305 B55C           42                           inc dx
39306 B55D           B0                     02    mov al, #0x02
39307 B55F           EE                           out dx, al
39308 B560           EC                           in al, dx
39309 B561           3C                     02    cmp al, #0x02
39310 B563           75           19              jne no_serial
39311 B565           42                           inc dx
39312 B566           EC                           in al, dx
39313 B567           3C                     02    cmp al, #0x02
39314 B569           75           13              jne no_serial
39315 B56B           4A                           dec dx
39316 B56C           30C0                         xor al, al
39317 B56E           EE                           out dx, al
39318 B56F           5A                           pop dx
39319 B570           53                           push bx
39320 B571           D1E3                         shl bx, #1
39321 B573           8997       0400              mov [bx+0x400], dx ; Serial I/O address
39322 B577           5B                           pop bx
39323 B578           888F       047C              mov [bx+0x47c], cl ; Serial timeout
39324 B57C           43                           inc bx
39325 B57D           C3                           ret
39326                       0000B57E            no_serial:
39327 B57E           5A                           pop dx
39328 B57F           C3                           ret
39329                       0000B580            rom_checksum:
39330 B580           60                           pusha
39331 B581           1E                           push ds
39332 B582           31C0                         xor ax, ax
39333 B584           31DB                         xor bx, bx
39334 B586           31C9                         xor cx, cx
39335 B588           31D2                         xor dx, dx
39336 B58A           8A2E       0002              mov ch, [2]
39337 B58E           D1E1                         shl cx, #1
39338 B590           73           05              jnc checksum_loop
39339 B592           74           03              jz checksum_loop
39340 B594           87CA                         xchg dx, cx
39341 B596           49                           dec cx
39342                       0000B597            checksum_loop:
39343 B597           0207                         add al, [bx]
39344 B599           43                           inc bx
39345 B59A           E2           FB              loop checksum_loop
39346 B59C           85D2                         test dx, dx
39347 B59E           74           11              je checksum_out
39348 B5A0           0207                         add al, [bx]
39349 B5A2           89D1                         mov cx, dx
39350 B5A4           8CDA                         mov dx, ds
39351 B5A6           80C6                   10    add dh, #0x10
39352 B5A9           8EDA                         mov ds, dx
39353 B5AB           31D2                         xor dx, dx
39354 B5AD           31DB                         xor bx, bx
39355 B5AF           EB           E6              jmp checksum_loop
39356                       0000B5B1            checksum_out:
39357 B5B1           24                     FF    and al, #0xff
39358 B5B3           1F                           pop ds
39359 B5B4           61                           popa
39360 B5B5           C3                           ret
39361                                           ;; We need a copy of this string, but we are not actually a PnP BIOS,
39362                                           ;; so make sure it is *not* aligned, so OSes will not see it if they scan.
39363 B5B6                  00000010            .align 16
39364 B5C0                        00              db 0
39365                       0000B5C1            pnp_string:
39366 B5C1                        24              .ascii "$PnP"
39367                       0000B5C5            rom_scan:
39368                                             ;; Scan for existence of valid expansion ROMS.
39369                                             ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
39370                                             ;; General ROM: from 0xC8000..0xE9FFF in 2k increments
39371                                             ;; System ROM: only 0xF0000
39372                                             ;;
39373                                             ;; Header:
39374                                             ;; Offset Value
39375                                             ;; 0 0x55
39376                                             ;; 1 0xAA
39377                                             ;; 2 ROM length in 512-byte blocks
39378                                             ;; 3 ROM initialization entry point (FAR CALL)
39379                       0000B5C5            rom_scan_loop:
39380 B5C5           50                           push ax ;; Save AX
39381 B5C6           8ED9                         mov ds, cx
39382 B5C8           B8                   0004    mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
39383 B5CB           813E       0000      AA55    cmp [0], #0xAA55 ;; look for signature
39384 B5D1   7403    E9         00C2              jne rom_scan_increment
39385 B5D6           E8         FFA7              call rom_checksum
39386 B5D9   7403    E9         00BA              jnz rom_scan_increment
39387 B5DE           A0         0002              mov al, [2] ;; change increment to ROM length in 512-byte blocks
39388                                             ;; We want our increment in 512-byte quantities, rounded to
39389                                             ;; the nearest 2k quantity, since we only scan at 2k intervals.
39390 B5E1           A8                     03    test al, #0x03
39391 B5E3           74           04              jz block_count_rounded
39392 B5E5           24                     FC    and al, #0xfc ;; needs rounding up
39393 B5E7           04                     04    add al, #0x04
39394                       0000B5E9            block_count_rounded:
39395 B5E9           50                           push ax ;; Save AX
39396 B5EA           57                           push di ;; Save DI
39397                                             ;; Push addr of ROM entry point
39398 B5EB           51                           push cx ;; Push seg
39399 B5EC           6A                     03    push #0x0003 ;; Push offset
39400                                             ;; Get the BDF into ax before invoking the option ROM
39401 B5EE           8A1E       0002              mov bl, [2]
39402 B5F2           88D8                         mov al, bl
39403 B5F4           C0E8                   07    shr al, #7
39404 B5F7           3C                     01    cmp al, #1
39405 B5F9           75           07              jne fetch_bdf
39406 B5FB           8CD8                         mov ax, ds ;; Increment the DS since rom size larger than an segment
39407 B5FD           05                   1000    add ax, #0x1000
39408 B600           8ED8                         mov ds, ax
39409                       0000B602            fetch_bdf:
39410 B602           C1E3                   09    shl bx, #9
39411 B605           31C0                         xor ax, ax
39412 B607           8A07                         mov al, [bx]
39413                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
39414                                             ;; That should stop it grabbing INT 19h; we will use its BEV instead.
39415 B609           BB                   F000    mov bx, #0xf000
39416 B60C           8EC3                         mov es, bx
39417 B60E           8D3E       B5C1              lea di, pnp_string
39418 B612           31DB                         xor bx, bx ;; Restore DS back to 0000:
39419 B614           8EDB                         mov ds, bx
39420 B616           89E5                         mov bp, sp ;; Call ROM init routine using seg:off on stack
39421 B618                        FF              db 0xff ;; call_far ss:[bp+0]
39422 B619                        5E              db 0x5e
39423 B61A                        00              db 0
39424 B61B           FA                           cli ;; In case expansion ROM BIOS turns IF on
39425 B61C           83C4                   02    add sp, #2 ;; Pop offset value
39426 B61F           59                           pop cx ;; Pop seg value (restore CX)
39427                                             ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
39428                                             ;; to init all the ROMs and then go back and build an IPL table of
39429                                             ;; all the bootable devices, but we can get away with one pass.
39430 B620           8ED9                         mov ds, cx ;; ROM base
39431 B622           8B1E       001A              mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
39432 B626           8B07                         mov ax, [bx] ;; the offset of PnP expansion header, where...
39433 B628           3D                   5024    cmp ax, #0x5024 ;; we look for signature "$PnP"
39434 B62B           75           69              jne no_bev
39435 B62D           8B47         02              mov ax, 2[bx]
39436 B630           3D                   506E    cmp ax, #0x506e
39437 B633           75           61              jne no_bev
39438 B635           8B47         16              mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
39439 B638           3D                   0000    cmp ax, #0x0000
39440 B63B           74           17              je no_bcv
39441                                             ;; Option ROM has BCV. Run it now.
39442 B63D           51                           push cx ;; Push seg
39443 B63E           50                           push ax ;; Push offset
39444                                             ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
39445 B63F           BB                   F000    mov bx, #0xf000
39446 B642           8EC3                         mov es, bx
39447 B644           8D3E       B5C1              lea di, pnp_string
39448 B648           89E5                         mov bp, sp ;; Call ROM BCV routine using seg:off on stack
39449 B64A                        FF              db 0xff ;; call_far ss:[bp+0]
39450 B64B                        5E              db 0x5e
39451 B64C                        00              db 0
39452 B64D           FA                           cli ;; In case expansion ROM BIOS turns IF on
39453 B64E           83C4                   02    add sp, #2 ;; Pop offset value
39454 B651           59                           pop cx ;; Pop seg value (restore CX)
39455 B652           EB           42              jmp no_bev
39456                       0000B654            no_bcv:
39457 B654           8B47         1A              mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
39458 B657           3D                   0000    cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
39459 B65A           74           3A              je no_bev
39460                                             ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
39461 B65C           8B7F         10              mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
39462 B65F           31DB                         xor bx, bx
39463 B661           8EDB                         mov ds, bx
39464 B663           8B1E       040E              mov bx, word ptr [0x40E] ;; EBDA segment
39465 B667           8EDB                         mov ds, bx ;; Go to the segment where the IPL table lives
39466 B669           8B1E       0380              mov bx, 0x0380 ;; Read the number of entries so far
39467 B66D           83FB                   08    cmp bx, #8
39468 B670           74           24              je no_bev ;; Get out if the table is full
39469 B672           C1E3                   04    shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
39470 B675           C787       0300      0080    mov 0x0300 +0[bx], #0x80 ;; This entry is a BEV device
39471 B67B           898F       0306              mov 0x0300 +6[bx], cx ;; Build a far pointer from the segment...
39472 B67F           8987       0304              mov 0x0300 +4[bx], ax ;; and the offset
39473 B683           83FF                   00    cmp di, #0x0000
39474 B686           74           06              je no_prod_str
39475 B688           894F         0A              mov 0xA[bx], cx ;; Build a far pointer from the segment...
39476 B68B           897F         08              mov 8[bx], di ;; and the offset
39477                       0000B68E            no_prod_str:
39478 B68E           C1EB                   04    shr bx, #0x4 ;; Turn the offset back into a count
39479 B691           43                           inc bx ;; We have one more entry now
39480 B692           891E       0380              mov 0x0380, bx ;; Remember that.
39481                       0000B696            no_bev:
39482 B696           5F                           pop di ;; Restore DI
39483 B697           58                           pop ax ;; Restore AX
39484                       0000B698            rom_scan_increment:
39485 B698           C1E0                   05    shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
39486                                                           ;; because the segment selector is shifted left 4 bits.
39487 B69B           01C1                         add cx, ax
39488 B69D           58                           pop ax ;; Restore AX
39489 B69E           39C1                         cmp cx, ax
39490 B6A0   7703    E9         FF20              jbe rom_scan_loop
39491 B6A5           31C0                         xor ax, ax ;; Restore DS back to 0000:
39492 B6A7           8ED8                         mov ds, ax
39493 B6A9           C3                           ret
39494                                           ; Copy the SMBIOS entry point from where hvmloader left it.
39495                                           ; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
39496                                           ; but the tables themselves can be elsewhere.
39497                       0000B6AA            smbios_init:
39498 B6AA           50                           push ax
39499 B6AB           51                           push cx
39500 B6AC           06                           push es
39501 B6AD           1E                           push ds
39502 B6AE           57                           push di
39503 B6AF           56                           push si
39504 B6B0           B9                   001F    mov cx, #0x001f ; 0x1f bytes to copy
39505 B6B3           B8                   F000    mov ax, #0xf000
39506 B6B6           8EC0                         mov es, ax ; destination segment is 0xf0000
39507 B6B8           BF                   B700    mov di, #smbios_entry_point ; destination offset
39508 B6BB           B8                   EB00    mov ax, #(0x000EB000>>4)
39509 B6BE           8ED8                         mov ds, ax
39510 B6C0           BE                   0000    mov si, #(0x000EB000&15)
39511 B6C3           FC                           cld
39512 B6C4           F3                           rep
39513 B6C5           A4                             movsb
39514 B6C6           5E                           pop si
39515 B6C7           5F                           pop di
39516 B6C8           1F                           pop ds
39517 B6C9           07                           pop es
39518 B6CA           59                           pop cx
39519 B6CB           58                           pop ax
39520 B6CC           C3                           ret
39521                       0000B6CD            post_init_pic:
39522 B6CD           B0                     11    mov al, #0x11 ; send initialisation commands
39523 B6CF           E6                     20    out 0x20, al
39524 B6D1           E6                     A0    out 0xa0, al
39525 B6D3           B0                     08    mov al, #0x08
39526 B6D5           E6                     21    out 0x21, al
39527 B6D7           B0                     70    mov al, #0x70
39528 B6D9           E6                     A1    out 0xa1, al
39529 B6DB           B0                     04    mov al, #0x04
39530 B6DD           E6                     21    out 0x21, al
39531 B6DF           B0                     02    mov al, #0x02
39532 B6E1           E6                     A1    out 0xa1, al
39533 B6E3           B0                     01    mov al, #0x01
39534 B6E5           E6                     21    out 0x21, al
39535 B6E7           E6                     A1    out 0xa1, al
39536 B6E9           B0                     B8    mov al, #0xb8
39537 B6EB           E6                     21    out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
39538 B6ED           B0                     8F    mov al, #0x8f
39539 B6EF           E6                     A1    out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
39540 B6F1           C3                           ret
39541 B6F2                  00000010              .align 16
39542                       0000B700            smbios_entry_point:
39543 B700                        00              db 0,0,0,0,0,0,0,0 ; 8 bytes
39544 B708                        00              db 0,0,0,0,0,0,0,0 ; 16 bytes
39545 B710                        00              db 0,0,0,0,0,0,0,0 ; 24 bytes
39546 B718                        00              db 0,0,0,0,0,0,0 ; 31 bytes
39547                                           ;; the following area can be used to write dynamically generated tables
39548 B71F                  00000010              .align 16
39549                       0000B720            bios_table_area_start:
39550 B720                        5F              db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
39551 B728                  000018D0              dd bios_table_area_end - bios_table_area_start
39552                                           ;--------
39553                                           ;- POST -
39554                                           ;--------
39555 E05B                                      .org 0xe05b ; POST Entry Point
39556                       0000E05B            post:
39557 E05B           31C0                         xor ax, ax
39558                                             ;; first reset the DMA controllers
39559 E05D           E6                     0D    out 0x0d,al
39560 E05F           E6                     DA    out 0xda,al
39561                                             ;; then initialize the DMA controllers
39562 E061           B0                     C0    mov al, #0xC0
39563 E063           E6                     D6    out 0xD6, al ; cascade mode of channel 4 enabled
39564 E065           B0                     00    mov al, #0x00
39565 E067           E6                     D4    out 0xD4, al ; unmask channel 4
39566                                             ;; Examine CMOS shutdown status.
39567 E069           B0                     0F    mov AL, #0x0f
39568 E06B           E6                     70    out 0x70, AL
39569 E06D           E4                     71    in AL, 0x71
39570                                             ;; backup status
39571 E06F           88C3                         mov bl, al
39572                                             ;; Reset CMOS shutdown status.
39573 E071           B0                     0F    mov AL, #0x0f
39574 E073           E6                     70    out 0x70, AL ; select CMOS register Fh
39575 E075           B0                     00    mov AL, #0x00
39576 E077           E6                     71    out 0x71, AL ; set shutdown action to normal
39577                                             ;; Examine CMOS shutdown status.
39578 E079           88D8                         mov al, bl
39579                                             ;; 0x00, 0x09, 0x0D+ = normal startup
39580 E07B           3C                     00    cmp AL, #0x00
39581 E07D           74           28              jz normal_post
39582 E07F           3C                     0D    cmp AL, #0x0d
39583 E081           73           24              jae normal_post
39584 E083           3C                     09    cmp AL, #0x09
39585 E085           74           20              je normal_post
39586                                             ;; 0x05 = eoi + jmp via [0x40:0x67] jump
39587 E087           3C                     05    cmp al, #0x05
39588 E089   7503    E9         CA91              je eoi_jmp_post
39589                                             ;; 0x0A = jmp via [0x40:0x67] jump
39590 E08E           3C                     0A    cmp al, #0x0a
39591 E090   7503    E9         CA92              je jmp_post_0x467
39592                                             ;; 0x0B = iret via [0x40:0x67]
39593 E095           3C                     0B    cmp al, #0x0b
39594 E097   7503    E9         CA93              je iret_post_0x467
39595                                             ;; 0x0C = retf via [0x40:0x67]
39596 E09C           3C                     0C    cmp al, #0x0c
39597 E09E   7503    E9         CA99              je retf_post_0x467
39598                                             ;; Examine CMOS shutdown status.
39599                                             ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08 = Unimplemented shutdown status.
39600 E0A3           53                           push bx
39601 E0A4           E8         327C              call _shutdown_status_panic
39602                       0000E0A7            normal_post:
39603                                             ; case 0: normal startup
39604 E0A7           FA                           cli
39605 E0A8           B8                   0FFE    mov ax, #0x0ffe
39606 E0AB           89C4                         mov sp, ax
39607 E0AD           B8                   9E00    mov ax, #0x9e00
39608 E0B0           8ED0                         mov ss, ax
39609                                             ;; Save shutdown status
39610 E0B2           881E       04B0              mov 0x04b0, bl
39611 E0B6           80FB                   FE    cmp bl, #0xfe
39612 E0B9   7503    E9         CA8B              jz s3_post
39613                                             ;; zero out BIOS data area (40:00..40:ff)
39614 E0BE           8EC0                         mov es, ax
39615 E0C0           B9                   0080    mov cx, #0x0080 ;; 128 words
39616 E0C3           BF                   0400    mov di, #0x0400
39617 E0C6           FC                           cld
39618 E0C7           F3                           rep
39619 E0C8           AB                             stosw
39620 E0C9           E8         380A              call _log_bios_start
39621                                             ;; set all interrupts to default handler
39622 E0CC           31DB                         xor bx, bx ;; offset index
39623 E0CE           B9                   0100    mov cx, #0x0100 ;; counter (256 interrupts)
39624 E0D1           B8                   FF53    mov ax, #dummy_iret_handler
39625 E0D4           BA                   F000    mov dx, #0xF000
39626                       0000E0D7            post_default_ints:
39627 E0D7           8907                         mov [bx], ax
39628 E0D9           83C3                   02    add bx, #2
39629 E0DC           8917                         mov [bx], dx
39630 E0DE           83C3                   02    add bx, #2
39631 E0E1           E2           F4              loop post_default_ints
39632                                             ;; set vector 0x79 to zero
39633                                             ;; this is used by 'gardian angel' protection system
39634                                             SET_INT_VECTOR(0x79, #0, #0)
 +a   E0E3           B8                   0000    mov ax,  #0
 +a   E0E6           A3         01E4              mov 0x79*4, ax
 +a   E0E9           B8                   0000    mov ax,  #0
 +a   E0EC           A3         01E6              mov 0x79*4+2, ax
39635                                             ;; base memory in K 40:13 (word)
39636 E0EF           B8                   027F    mov ax, #(640 - 1)
39637 E0F2           A3         0413              mov 0x0413, ax
39638                                             ;; Manufacturing Test 40:12
39639                                             ;; zerod out above
39640                                             ;; Warm Boot Flag 0040:0072
39641                                             ;; value of 1234h = skip memory checks
39642                                             ;; zerod out above
39643                                             ;; Printer Services vector
39644                                             SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
 +a   E0F5           B8                   EFD2    mov ax,  #int17_handler
 +a   E0F8           A3         005C              mov 0x17*4, ax
 +a   E0FB           B8                   F000    mov ax,  #0xF000
 +a   E0FE           A3         005E              mov 0x17*4+2, ax
39645                                             ;; Bootstrap failure vector
39646                                             SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
 +a   E101           B8                   A828    mov ax,  #int18_handler
 +a   E104           A3         0060              mov 0x18*4, ax
 +a   E107           B8                   F000    mov ax,  #0xF000
 +a   E10A           A3         0062              mov 0x18*4+2, ax
39647                                             ;; Bootstrap Loader vector
39648                                             SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
 +a   E10D           B8                   E6F2    mov ax,  #int19_handler
 +a   E110           A3         0064              mov 0x19*4, ax
 +a   E113           B8                   F000    mov ax,  #0xF000
 +a   E116           A3         0066              mov 0x19*4+2, ax
39649                                             ;; User Timer Tick vector
39650                                             SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
 +a   E119           B8                   A85A    mov ax,  #int1c_handler
 +a   E11C           A3         0070              mov 0x1c*4, ax
 +a   E11F           B8                   F000    mov ax,  #0xF000
 +a   E122           A3         0072              mov 0x1c*4+2, ax
39651                                             ;; Memory Size Check vector
39652                                             SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
 +a   E125           B8                   F841    mov ax,  #int12_handler
 +a   E128           A3         0048              mov 0x12*4, ax
 +a   E12B           B8                   F000    mov ax,  #0xF000
 +a   E12E           A3         004A              mov 0x12*4+2, ax
39653                                             ;; Equipment Configuration Check vector
39654                                             SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
 +a   E131           B8                   F84D    mov ax,  #int11_handler
 +a   E134           A3         0044              mov 0x11*4, ax
 +a   E137           B8                   F000    mov ax,  #0xF000
 +a   E13A           A3         0046              mov 0x11*4+2, ax
39655                                             ;; System Services
39656                                             SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
 +a   E13D           B8                   F859    mov ax,  #int15_handler
 +a   E140           A3         0054              mov 0x15*4, ax
 +a   E143           B8                   F000    mov ax,  #0xF000
 +a   E146           A3         0056              mov 0x15*4+2, ax
39657                                             ;; EBDA setup
39658 E149           E8         C9BE              call ebda_post
39659                                             ;; PIT setup
39660                                             SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
 +a   E14C           B8                   FEA5    mov ax,  #int08_handler
 +a   E14F           A3         0020              mov 0x08*4, ax
 +a   E152           B8                   F000    mov ax,  #0xF000
 +a   E155           A3         0022              mov 0x08*4+2, ax
39661                                             ;; int 1C already points at dummy_iret_handler (above)
39662 E158           B0                     34    mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
39663 E15A           E6                     43    out 0x43, al
39664 E15C           B0                     0B    mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
39665 E15E           E6                     40    out 0x40, al ; lsb
39666 E160           B0                     E9    mov al, #0xe9
39667 E162           E6                     40    out 0x40, al ; msb
39668                                             ;; Keyboard
39669                                             SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
 +a   E164           B8                   E987    mov ax,  #int09_handler
 +a   E167           A3         0024              mov 0x09*4, ax
 +a   E16A           B8                   F000    mov ax,  #0xF000
 +a   E16D           A3         0026              mov 0x09*4+2, ax
39670                                             SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
 +a   E170           B8                   E82E    mov ax,  #int16_handler
 +a   E173           A3         0058              mov 0x16*4, ax
 +a   E176           B8                   F000    mov ax,  #0xF000
 +a   E179           A3         005A              mov 0x16*4+2, ax
39671 E17C           31C0                         xor ax, ax
39672 E17E           8ED8                         mov ds, ax
39673 E180           A2         0417              mov 0x0417, al
39674 E183           A2         0418              mov 0x0418, al
39675 E186           A2         0419              mov 0x0419, al
39676 E189           A2         0471              mov 0x0471, al
39677 E18C           A2         0497              mov 0x0497, al
39678 E18F           B0                     10    mov al, #0x10
39679 E191           A2         0496              mov 0x0496, al
39680 E194           BB                   001E    mov bx, #0x001E
39681 E197           891E       041A              mov 0x041A, bx
39682 E19B           891E       041C              mov 0x041C, bx
39683 E19F           BB                   001E    mov bx, #0x001E
39684 E1A2           891E       0480              mov 0x0480, bx
39685 E1A6           BB                   003E    mov bx, #0x003E
39686 E1A9           891E       0482              mov 0x0482, bx
39687 E1AD           E8         2C3E              call _keyboard_init
39688                                             ;; mov CMOS Equipment Byte to BDA Equipment Word
39689 E1B0           A1         0410              mov ax, 0x0410
39690 E1B3           B0                     14    mov al, #0x14
39691 E1B5           E6                     70    out 0x70, al
39692 E1B7           E4                     71    in al, 0x71
39693 E1B9           A3         0410              mov 0x0410, ax
39694                                             ;; Parallel setup
39695                                             SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
 +a   E1BC           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1BF           A3         003C              mov 0x0F*4, ax
 +a   E1C2           B8                   F000    mov ax,  #0xF000
 +a   E1C5           A3         003E              mov 0x0F*4+2, ax
39696 E1C8           31C0                         xor ax, ax
39697 E1CA           8ED8                         mov ds, ax
39698 E1CC           31DB                         xor bx, bx
39699 E1CE           B1                     14    mov cl, #0x14 ; timeout value
39700 E1D0           BA                   0378    mov dx, #0x378 ; Parallel I/O address, port 1
39701 E1D3           E8         D366              call detect_parport
39702 E1D6           BA                   0278    mov dx, #0x278 ; Parallel I/O address, port 2
39703 E1D9           E8         D360              call detect_parport
39704 E1DC           C1E3                   0E    shl bx, #0x0e
39705 E1DF           A1         0410              mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
39706 E1E2           25                   3FFF    and ax, #0x3fff
39707 E1E5           09D8                         or ax, bx ; set number of parallel ports
39708 E1E7           A3         0410              mov 0x410, ax
39709                                             ;; Serial setup
39710                                             SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
 +a   E1EA           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E1ED           A3         0030              mov 0x0C*4, ax
 +a   E1F0           B8                   F000    mov ax,  #0xF000
 +a   E1F3           A3         0032              mov 0x0C*4+2, ax
39711                                             SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
 +a   E1F6           B8                   E739    mov ax,  #int14_handler
 +a   E1F9           A3         0050              mov 0x14*4, ax
 +a   E1FC           B8                   F000    mov ax,  #0xF000
 +a   E1FF           A3         0052              mov 0x14*4+2, ax
39712 E202           31DB                         xor bx, bx
39713 E204           B1                     0A    mov cl, #0x0a ; timeout value
39714 E206           BA                   03F8    mov dx, #0x03f8 ; Serial I/O address, port 1
39715 E209           E8         D34F              call detect_serial
39716 E20C           BA                   02F8    mov dx, #0x02f8 ; Serial I/O address, port 2
39717 E20F           E8         D349              call detect_serial
39718 E212           BA                   03E8    mov dx, #0x03e8 ; Serial I/O address, port 3
39719 E215           E8         D343              call detect_serial
39720 E218           BA                   02E8    mov dx, #0x02e8 ; Serial I/O address, port 4
39721 E21B           E8         D33D              call detect_serial
39722 E21E           C1E3                   09    shl bx, #0x09
39723 E221           A1         0410              mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
39724 E224           25                   F1FF    and ax, #0xf1ff
39725 E227           09D8                         or ax, bx ; set number of serial port
39726 E229           A3         0410              mov 0x410, ax
39727                                             ;; CMOS RTC
39728                                             SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
 +a   E22C           B8                   FE6E    mov ax,  #int1a_handler
 +a   E22F           A3         0068              mov 0x1A*4, ax
 +a   E232           B8                   F000    mov ax,  #0xF000
 +a   E235           A3         006A              mov 0x1A*4+2, ax
39729                                             SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
 +a   E238           B8                   FF53    mov ax,  #dummy_iret_handler
 +a   E23B           A3         0128              mov 0x4A*4, ax
 +a   E23E           B8                   F000    mov ax,  #0xF000
 +a   E241           A3         012A              mov 0x4A*4+2, ax
39730                                             SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
 +a   E244           B8                   FE93    mov ax,  #int70_handler
 +a   E247           A3         01C0              mov 0x70*4, ax
 +a   E24A           B8                   F000    mov ax,  #0xF000
 +a   E24D           A3         01C2              mov 0x70*4+2, ax
39731                                             ;; BIOS DATA AREA 0x4CE ???
39732 E250           E8         C91D              call timer_tick_post
39733                                             ;; PS/2 mouse setup
39734                                             SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
 +a   E253           B8                   A760    mov ax,  #int74_handler
 +a   E256           A3         01D0              mov 0x74*4, ax
 +a   E259           B8                   F000    mov ax,  #0xF000
 +a   E25C           A3         01D2              mov 0x74*4+2, ax
39735                                             ;; IRQ13 (FPU exception) setup
39736                                             SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
 +a   E25F           B8                   E2C7    mov ax,  #int75_handler
 +a   E262           A3         01D4              mov 0x75*4, ax
 +a   E265           B8                   F000    mov ax,  #0xF000
 +a   E268           A3         01D6              mov 0x75*4+2, ax
39737                                             ;; Video setup
39738                                             SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
 +a   E26B           B8                   F065    mov ax,  #int10_handler
 +a   E26E           A3         0040              mov 0x10*4, ax
 +a   E271           B8                   F000    mov ax,  #0xF000
 +a   E274           A3         0042              mov 0x10*4+2, ax
39739                                             ;; PIC
39740 E277           E8         D453              call post_init_pic
39741 E27A           B9                   C000    mov cx, #0xc000 ;; init vga bios
39742 E27D           B8                   C780    mov ax, #0xc780
39743 E280           E8         D342              call rom_scan
39744 E283           E8         30C7              call _print_bios_banner
39745                                             ;;
39746                                             ;; Floppy setup
39747                                             ;;
39748 E286           E8         C5D2              call floppy_drive_post
39749                                             ;;
39750                                             ;; Hard Drive setup
39751                                             ;;
39752 E289           E8         C656              call hard_drive_post
39753                                             ;;
39754                                             ;; ATA/ATAPI driver setup
39755                                             ;;
39756 E28C           E8         374F              call _ata_init
39757 E28F           E8         3B7D              call _ata_detect
39758                                             ;;
39759                                             ;;
39760                                             ;; eltorito floppy/harddisk emulation from cd
39761                                             ;;
39762 E292           E8         5BC5              call _cdemu_init
39763                                             ;;
39764 E295           E8         23FC              call _enable_rom_write_access
39765 E298           E8         3072              call _clobber_entry_point
39766 E29B           E8         23B2              call _fixup_base_mem_in_k
39767 E29E           E8         D409              call smbios_init
39768 E2A1           E8         3102              call _init_boot_vectors
39769 E2A4           B9                   C800    mov cx, #(0x000C8000 >> 4) ;; init option roms
39770 E2A7           B8                   EA00    mov ax, #(0x000EA000 >> 4)
39771 E2AA           E8         D318              call rom_scan
39772 E2AD           E8         23F5              call _disable_rom_write_access
39773 E2B0           E8         32B1              call _interactive_bootkey
39774 E2B3           FB                           sti ;; enable interrupts
39775                                             ;; Start the boot sequence. See the comments in int19_relocated
39776                                             ;; for why we use INT 18h instead of INT 19h here.
39777 E2B4           CD                     18    int #0x18
39778 E2C3                                      .org 0xe2c3 ; NMI Handler Entry Point
39779                       0000E2C3            nmi:
39780                                             ;; FIXME the NMI handler should not panic
39781                                             ;; but iret when called from int75 (fpu exception)
39782 E2C3           E8         35EC              call _nmi_handler_msg
39783 E2C6           CF                           iret
39784                       0000E2C7            int75_handler:
39785 E2C7           E6                     F0    out 0xf0, al
39786 E2C9           E8         C88C              call eoi_both_pics
39787 E2CC           CD                     02    int 2
39788 E2CE           CF                           iret
39789                                           ;-------------------------------------------
39790                                           ;- INT 13h Fixed Disk Services Entry Point -
39791                                           ;-------------------------------------------
39792 E3FE                                      .org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
39793                       0000E3FE            int13_handler:
39794 E3FE           E9         C39C              jmp int13_relocated
39795 E401                                      .org 0xe401 ; Fixed Disk Parameter Table
39796                                           ;----------
39797                                           ;- INT19h -
39798                                           ;----------
39799 E6F2                                      .org 0xe6f2 ; INT 19h Boot Load Service Entry Point
39800                       0000E6F2            int19_handler:
39801 E6F2           E9         C158              jmp int19_relocated
39802                                           ;-------------------------------------------
39803                                           ;- System BIOS Configuration Data Table
39804                                           ;-------------------------------------------
39805 E6F5                                      .org 0xe6f5
39806 E6F5                        08            db 0x08 ; Table size (bytes) -Lo
39807 E6F6                        00            db 0x00 ; Table size (bytes) -Hi
39808 E6F7                        FC            db 0xFC
39809 E6F8                        00            db 0x00
39810 E6F9                        01            db 1
39811                                           ; Feature byte 1
39812                                           ; b7: 1=DMA channel 3 used by hard disk
39813                                           ; b6: 1=2 interrupt controllers present
39814                                           ; b5: 1=RTC present
39815                                           ; b4: 1=BIOS calls int 15h/4Fh every key
39816                                           ; b3: 1=wait for extern event supported (Int 15h/41h)
39817                                           ; b2: 1=extended BIOS data area used
39818                                           ; b1: 0=AT or ESDI bus, 1=MicroChannel
39819                                           ; b0: 1=Dual bus (MicroChannel + ISA)
39820 E6FA                        74            db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
39821                                           ; Feature byte 2
39822                                           ; b7: 1=32-bit DMA supported
39823                                           ; b6: 1=int16h, function 9 supported
39824                                           ; b5: 1=int15h/C6h (get POS data) supported
39825                                           ; b4: 1=int15h/C7h (get mem map info) supported
39826                                           ; b3: 1=int15h/C8h (en/dis CPU) supported
39827                                           ; b2: 1=non-8042 kb controller
39828                                           ; b1: 1=data streaming supported
39829                                           ; b0: reserved
39830 E6FB                        40            db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
39831                                           ; Feature byte 3
39832                                           ; b7: not used
39833                                           ; b6: reserved
39834                                           ; b5: reserved
39835                                           ; b4: POST supports ROM-to-RAM enable/disable
39836                                           ; b3: SCSI on system board
39837                                           ; b2: info panel installed
39838                                           ; b1: Initial Machine Load (IML) system - BIOS on disk
39839                                           ; b0: SCSI supported in IML
39840 E6FC                        00            db 0x00
39841                                           ; Feature byte 4
39842                                           ; b7: IBM private
39843                                           ; b6: EEPROM present
39844                                           ; b5-3: ABIOS presence (011 = not supported)
39845                                           ; b2: private
39846                                           ; b1: memory split above 16Mb supported
39847                                           ; b0: POSTEXT directly supported by POST
39848 E6FD                        00            db 0x00
39849                                           ; Feature byte 5 (IBM)
39850                                           ; b1: enhanced mouse
39851                                           ; b0: flash EPROM
39852 E6FE                        00            db 0x00
39853 E729                                      .org 0xe729 ; Baud Rate Generator Table
39854                                           ;----------
39855                                           ;- INT14h -
39856                                           ;----------
39857 E739                                      .org 0xe739 ; INT 14h Serial Communications Service Entry Point
39858                       0000E739            int14_handler:
39859 E739           1E                           push ds
39860 E73A           60                           pusha
39861 E73B           31C0                         xor ax, ax
39862 E73D           8ED8                         mov ds, ax
39863 E73F           E8         5F33              call _int14_function
39864 E742           61                           popa
39865 E743           1F                           pop ds
39866 E744           CF                           iret
39867                                           ;----------------------------------------
39868                                           ;- INT 16h Keyboard Service Entry Point -
39869                                           ;----------------------------------------
39870 E82E                                      .org 0xe82e
39871                       0000E82E            int16_handler:
39872 E82E           FB                           sti
39873 E82F           1E                           push ds
39874 E830           9C                           pushf
39875 E831           60                           pusha
39876 E832           80FC                   00    cmp ah, #0x00
39877 E835           74           24              je int16_F00
39878 E837           80FC                   10    cmp ah, #0x10
39879 E83A           74           1F              je int16_F00
39880 E83C           BB                   F000    mov bx, #0xf000
39881 E83F           8EDB                         mov ds, bx
39882 E841           E8         7053              call _int16_function
39883 E844           61                           popa
39884 E845           9D                           popf
39885 E846           1F                           pop ds
39886 E847           74           09              jz int16_zero_set
39887                       0000E849            int16_zero_clear:
39888 E849           55                           push bp
39889 E84A           89E5                         mov bp, sp
39890 E84C           8066         06        BF    and BYTE [bp + 0x06], #0xbf
39891 E850           5D                           pop bp
39892 E851           CF                           iret
39893                       0000E852            int16_zero_set:
39894 E852           55                           push bp
39895 E853           89E5                         mov bp, sp
39896 E855           804E         06        40    or BYTE [bp + 0x06], #0x40
39897 E859           5D                           pop bp
39898 E85A           CF                           iret
39899                       0000E85B            int16_F00:
39900 E85B           BB                   0040    mov bx, #0x0040
39901 E85E           8EDB                         mov ds, bx
39902                       0000E860            int16_wait_for_key:
39903 E860           FA                           cli
39904 E861           8B1E       001A              mov bx, 0x001a
39905 E865           3B1E       001C              cmp bx, 0x001c
39906 E869           75           04              jne int16_key_found
39907 E86B           FB                           sti
39908 E86C           F4                           hlt
39909 E86D           EB           F1              jmp int16_wait_for_key
39910                       0000E86F            int16_key_found:
39911 E86F           BB                   F000    mov bx, #0xf000
39912 E872           8EDB                         mov ds, bx
39913 E874           E8         7020              call _int16_function
39914 E877           61                           popa
39915 E878           9D                           popf
39916 E879           1F                           pop ds
39917 E87A           CF                           iret
39918                                           ;-------------------------------------------------
39919                                           ;- INT09h : Keyboard Hardware Service Entry Point -
39920                                           ;-------------------------------------------------
39921 E987                                      .org 0xe987
39922                       0000E987            int09_handler:
39923 E987           FA                           cli
39924 E988           50                           push ax
39925 E989           B0                     AD    mov al, #0xAD ;;disable keyboard
39926 E98B           E6                     64    out #0x64, al
39927 E98D           B0                     0B    mov al, #0x0B
39928 E98F           E6                     20    out #0x20, al
39929 E991           E4                     20    in al, #0x20
39930 E993           24                     02    and al, #0x02
39931 E995           74           3E              jz int09_finish
39932 E997           E4                     60    in al, #0x60 ;;read key from keyboard controller
39933 E999           FB                           sti
39934 E99A           1E                           push ds
39935 E99B           60                           pusha
39936 E99C           B4                     4F    mov ah, #0x4f ;; allow for keyboard intercept
39937 E99E           F9                           stc
39938 E99F           CD                     15    int #0x15
39939 E9A1           73           2C              jnc int09_done
39940                                             ;; check for extended key
39941 E9A3           3C                     E0    cmp al, #0xe0
39942 E9A5           75           0E              jne int09_check_pause
39943 E9A7           31C0                         xor ax, ax
39944 E9A9           8ED8                         mov ds, ax
39945 E9AB           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x02
39946 E9AE           0C                     02    or al, #0x02
39947 E9B0           A2         0496              mov BYTE [0x496], al
39948 E9B3           EB           1A              jmp int09_done
39949                       0000E9B5            int09_check_pause: ;; check for pause key
39950 E9B5           3C                     E1    cmp al, #0xe1
39951 E9B7           75           0E              jne int09_process_key
39952 E9B9           31C0                         xor ax, ax
39953 E9BB           8ED8                         mov ds, ax
39954 E9BD           A0         0496              mov al, BYTE [0x496] ;; mf2_state |= 0x01
39955 E9C0           0C                     01    or al, #0x01
39956 E9C2           A2         0496              mov BYTE [0x496], al
39957 E9C5           EB           08              jmp int09_done
39958                       0000E9C7            int09_process_key:
39959 E9C7           BB                   F000    mov bx, #0xf000
39960 E9CA           8EDB                         mov ds, bx
39961 E9CC           E8         761E              call _int09_function
39962                       0000E9CF            int09_done:
39963 E9CF           61                           popa
39964 E9D0           1F                           pop ds
39965 E9D1           FA                           cli
39966 E9D2           E8         C187              call eoi_master_pic
39967                       0000E9D5            int09_finish:
39968 E9D5           B0                     AE    mov al, #0xAE ;;enable keyboard
39969 E9D7           E6                     64    out #0x64, al
39970 E9D9           58                           pop ax
39971 E9DA           CF                           iret
39972                                           ;----------------------------------------
39973                                           ;- INT 13h Diskette Service Entry Point -
39974                                           ;----------------------------------------
39975 EC59                                      .org 0xec59
39976                       0000EC59            int13_diskette:
39977 EC59           E9         BB90              jmp int13_noeltorito
39978                                           ;---------------------------------------------
39979                                           ;- INT 0Eh Diskette Hardware ISR Entry Point -
39980                                           ;---------------------------------------------
39981 EF57                                      .org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
39982                       0000EF57            int0e_handler:
39983 EF57           50                           push ax
39984 EF58           52                           push dx
39985 EF59           BA                   03F4    mov dx, #0x03f4
39986 EF5C           EC                           in al, dx
39987 EF5D           24                     C0    and al, #0xc0
39988 EF5F           3C                     C0    cmp al, #0xc0
39989 EF61           74           1E              je int0e_normal
39990 EF63           BA                   03F5    mov dx, #0x03f5
39991 EF66           B0                     08    mov al, #0x08 ; sense interrupt status
39992 EF68           EE                           out dx, al
39993                       0000EF69            int0e_loop1:
39994 EF69           BA                   03F4    mov dx, #0x03f4
39995 EF6C           EC                           in al, dx
39996 EF6D           24                     C0    and al, #0xc0
39997 EF6F           3C                     C0    cmp al, #0xc0
39998 EF71           75           F6              jne int0e_loop1
39999                       0000EF73            int0e_loop2:
40000 EF73           BA                   03F5    mov dx, #0x03f5
40001 EF76           EC                           in al, dx
40002 EF77           BA                   03F4    mov dx, #0x03f4
40003 EF7A           EC                           in al, dx
40004 EF7B           24                     C0    and al, #0xc0
40005 EF7D           3C                     C0    cmp al, #0xc0
40006 EF7F           74           F2              je int0e_loop2
40007                       0000EF81            int0e_normal:
40008 EF81           1E                           push ds
40009 EF82           31C0                         xor ax, ax ;; segment 0000
40010 EF84           8ED8                         mov ds, ax
40011 EF86           E8         BBD3              call eoi_master_pic
40012 EF89           A0         043E              mov al, 0x043e
40013 EF8C           0C                     80    or al, #0x80 ;; diskette interrupt has occurred
40014 EF8E           A2         043E              mov 0x043e, al
40015 EF91           1F                           pop ds
40016 EF92           5A                           pop dx
40017 EF93           58                           pop ax
40018 EF94           CF                           iret
40019 EFC7                                      .org 0xefc7 ; Diskette Controller Parameter Table
40020                       0000EFC7            diskette_param_table:
40021                                           ;; Since no provisions are made for multiple drive types, most
40022                                           ;; values in this table are ignored. I set parameters for 1.44M
40023                                           ;; floppy here
40024 EFC7                        AF            db 0xAF
40025 EFC8                        02            db 0x02 ;; head load time 0000001, DMA used
40026 EFC9                        25            db 0x25
40027 EFCA                        02            db 0x02
40028 EFCB                        12            db 18
40029 EFCC                        1B            db 0x1B
40030 EFCD                        FF            db 0xFF
40031 EFCE                        6C            db 0x6C
40032 EFCF                        F6            db 0xF6
40033 EFD0                        0F            db 0x0F
40034 EFD1                        08            db 0x08
40035                                           ;----------------------------------------
40036                                           ;- INT17h : Printer Service Entry Point -
40037                                           ;----------------------------------------
40038 EFD2                                      .org 0xefd2
40039                       0000EFD2            int17_handler:
40040 EFD2           1E                           push ds
40041 EFD3           60                           pusha
40042 EFD4           31C0                         xor ax, ax
40043 EFD6           8ED8                         mov ds, ax
40044 EFD8           E8         AF71              call _int17_function
40045 EFDB           61                           popa
40046 EFDC           1F                           pop ds
40047 EFDD           CF                           iret
40048                       0000EFDE            diskette_param_table2:
40049                                           ;; New diskette parameter table adding 3 parameters from IBM
40050                                           ;; Since no provisions are made for multiple drive types, most
40051                                           ;; values in this table are ignored. I set parameters for 1.44M
40052                                           ;; floppy here
40053 EFDE                        AF            db 0xAF
40054 EFDF                        02            db 0x02 ;; head load time 0000001, DMA used
40055 EFE0                        25            db 0x25
40056 EFE1                        02            db 0x02
40057 EFE2                        12            db 18
40058 EFE3                        1B            db 0x1B
40059 EFE4                        FF            db 0xFF
40060 EFE5                        6C            db 0x6C
40061 EFE6                        F6            db 0xF6
40062 EFE7                        0F            db 0x0F
40063 EFE8                        08            db 0x08
40064 EFE9                        4F            db 79 ;; maximum track
40065 EFEA                        00            db 0 ;; data transfer rate
40066 EFEB                        04            db 4 ;; drive type in cmos
40067 F045                                      .org 0xf045 ; INT 10 Functions 0-Fh Entry Point
40068                                             HALT(11460)
 +a   F045           BA                   0400    mov dx,#0x400
 +a   F048           B8                   2CC4    mov ax,#11460
 +a   F04B           EF                           out dx,ax
40069 F04C           CF                           iret
40070                                           ;----------
40071                                           ;- INT10h -
40072                                           ;----------
40073 F065                                      .org 0xf065 ; INT 10h Video Support Service Entry Point
40074                       0000F065            int10_handler:
40075                                             ;; dont do anything, since the VGA BIOS handles int10h requests
40076 F065           CF                           iret
40077 F0A4                                      .org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
40078                                           ;----------
40079                                           ;- INT12h -
40080                                           ;----------
40081 F841                                      .org 0xf841 ; INT 12h Memory Size Service Entry Point
40082                                           ; ??? different for Pentium (machine check)?
40083                       0000F841            int12_handler:
40084 F841           1E                           push ds
40085 F842           B8                   0040    mov ax, #0x0040
40086 F845           8ED8                         mov ds, ax
40087 F847           A1         0013              mov ax, 0x0013
40088 F84A           1F                           pop ds
40089 F84B           CF                           iret
40090                                           ;----------
40091                                           ;- INT11h -
40092                                           ;----------
40093 F84D                                      .org 0xf84d ; INT 11h Equipment List Service Entry Point
40094                       0000F84D            int11_handler:
40095 F84D           1E                           push ds
40096 F84E           B8                   0040    mov ax, #0x0040
40097 F851           8ED8                         mov ds, ax
40098 F853           A1         0010              mov ax, 0x0010
40099 F856           1F                           pop ds
40100 F857           CF                           iret
40101                                           ;----------
40102                                           ;- INT15h -
40103                                           ;----------
40104 F859                                      .org 0xf859 ; INT 15h System Services Entry Point
40105                       0000F859            int15_handler:
40106 F859           9C                           pushf
40107 F85A           80FC                   53    cmp ah, #0x53
40108 F85D           74           1C              je apm_call
40109 F85F           1E                           push ds
40110 F860           06                           push es
40111 F861           80FC                   86    cmp ah, #0x86
40112 F864           74           1D              je int15_handler32
40113 F866           80FC                   E8    cmp ah, #0xE8
40114 F869           74           18              je int15_handler32
40115 F86B           60                           pusha
40116 F86C           80FC                   C2    cmp ah, #0xC2
40117 F86F           74           0D              je int15_handler_mouse
40118 F871           E8         5074              call _int15_function
40119                       0000F874            int15_handler_mouse_ret:
40120 F874           61                           popa
40121                       0000F875            int15_handler32_ret:
40122 F875           07                           pop es
40123 F876           1F                           pop ds
40124 F877           9D                           popf
40125 F878           E9         AF0E              jmp iret_modify_cf
40126                       0000F87B            apm_call:
40127 F87B           E9         B55E              jmp _apmreal_entry
40128                       0000F87E            int15_handler_mouse:
40129 F87E           E8         5563              call _int15_function_mouse
40130 F881           EB           F1              jmp int15_handler_mouse_ret
40131                       0000F883            int15_handler32:
40132 F883     66    60                           pushad
40133 F885           E8         5CA3              call _int15_function32
40134 F888     66    61                           popad
40135 F88A           EB           E9              jmp int15_handler32_ret
40136                                           ;; Protected mode IDT descriptor
40137                                           ;;
40138                                           ;; I just make the limit 0, so the machine will shutdown
40139                                           ;; if an exception occurs during protected mode memory
40140                                           ;; transfers.
40141                                           ;;
40142                                           ;; Set base to f0000 to correspond to beginning of BIOS,
40143                                           ;; in case I actually define an IDT later
40144                                           ;; Set limit to 0
40145                       0000F88C            pmode_IDT_info:
40146 F88C                      0000            dw 0x0000 ;; limit 15:00
40147 F88E                      0000            dw 0x0000 ;; base 15:00
40148 F890                        0F            db 0x0f ;; base 23:16
40149                                           ;; Real mode IDT descriptor
40150                                           ;;
40151                                           ;; Set to typical real-mode values.
40152                                           ;; base = 000000
40153                                           ;; limit = 03ff
40154                       0000F891            rmode_IDT_info:
40155 F891                      03FF            dw 0x03ff ;; limit 15:00
40156 F893                      0000            dw 0x0000 ;; base 15:00
40157 F895                        00            db 0x00 ;; base 23:16
40158                                           ;----------
40159                                           ;- INT1Ah -
40160                                           ;----------
40161 FE6E                                      .org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
40162                       0000FE6E            int1a_handler:
40163 FE6E           80FC                   B1    cmp ah, #0xb1
40164 FE71           75           14              jne int1a_normal
40165 FE73           E8         B465              call pcibios_real
40166 FE76           72           03              jc pcibios_error
40167 FE78           CA                   0002    retf 2
40168                       0000FE7B            pcibios_error:
40169 FE7B           88E3                         mov bl, ah
40170 FE7D           B4                     B1    mov ah, #0xb1
40171 FE7F           1E                           push ds
40172 FE80           60                           pusha
40173 FE81           8CD0                         mov ax, ss ; set readable descriptor to ds, for calling pcibios
40174 FE83           8ED8                         mov ds, ax ; on 16bit protected mode.
40175 FE85           EB           06              jmp int1a_callfunction
40176                       0000FE87            int1a_normal:
40177 FE87           1E                           push ds
40178 FE88           60                           pusha
40179 FE89           31C0                         xor ax, ax
40180 FE8B           8ED8                         mov ds, ax
40181                       0000FE8D            int1a_callfunction:
40182 FE8D           E8         A466              call _int1a_function
40183 FE90           61                           popa
40184 FE91           1F                           pop ds
40185 FE92           CF                           iret
40186                                           ;;
40187                                           ;; int70h: IRQ8 - CMOS RTC
40188                                           ;;
40189                       0000FE93            int70_handler:
40190 FE93           1E                           push ds
40191 FE94     66    60                           pushad
40192 FE96           31C0                         xor ax, ax
40193 FE98           8ED8                         mov ds, ax
40194 FE9A           E8         A79B              call _int70_function
40195 FE9D     66    61                           popad
40196 FE9F           1F                           pop ds
40197 FEA0           CF                           iret
40198                                           ;---------
40199                                           ;- INT08 -
40200                                           ;---------
40201 FEA5                                      .org 0xfea5 ; INT 08h System Timer ISR Entry Point
40202                       0000FEA5            int08_handler:
40203 FEA5           FB                           sti
40204 FEA6     66    50                           push eax
40205 FEA8           1E                           push ds
40206 FEA9           31C0                         xor ax, ax
40207 FEAB           8ED8                         mov ds, ax
40208                                             ;; time to turn off drive(s)?
40209 FEAD           A0         0440              mov al,0x0440
40210 FEB0           08C0                         or al,al
40211 FEB2           74           10              jz int08_floppy_off
40212 FEB4           FEC8                         dec al
40213 FEB6           A2         0440              mov 0x0440,al
40214 FEB9           75           09              jnz int08_floppy_off
40215                                             ;; turn motor(s) off
40216 FEBB           52                           push dx
40217 FEBC           BA                   03F2    mov dx,#0x03f2
40218 FEBF           EC                           in al,dx
40219 FEC0           24                     CF    and al,#0xcf
40220 FEC2           EE                           out dx,al
40221 FEC3           5A                           pop dx
40222                       0000FEC4            int08_floppy_off:
40223 FEC4     66    A1         046C              mov eax, 0x046c ;; get ticks dword
40224 FEC8     66    40                           inc eax
40225                                             ;; compare eax to one days worth of timer ticks at 18.2 hz
40226 FECA     66    3D               001800B0    cmp eax, #0x001800B0
40227 FED0           72           07              jb int08_store_ticks
40228                                             ;; there has been a midnight rollover at this point
40229 FED2     66    31C0                         xor eax, eax ;; zero out counter
40230 FED5           FE06       0470              inc BYTE 0x0470 ;; increment rollover flag
40231                       0000FED9            int08_store_ticks:
40232 FED9     66    A3         046C              mov 0x046c, eax ;; store new ticks dword
40233                                             ;; chain to user timer tick INT #0x1c
40234 FEDD           CD                     1C    int #0x1c
40235 FEDF           FA                           cli
40236 FEE0           E8         AC79              call eoi_master_pic
40237 FEE3           1F                           pop ds
40238 FEE4     66    58                           pop eax
40239 FEE6           CF                           iret
40240 FEF3                                      .org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
40241 FF00                                      .org 0xff00
40242 FF00                        28            .ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
40243                                           ;------------------------------------------------
40244                                           ;- IRET Instruction for Dummy Interrupt Handler -
40245                                           ;------------------------------------------------
40246 FF53                                      .org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
40247                       0000FF53            dummy_iret_handler:
40248 FF53           CF                           iret
40249 FF54                                      .org 0xff54 ; INT 05h Print Screen Service Entry Point
40250                                             HALT(11694)
 +a   FF54           BA                   0400    mov dx,#0x400
 +a   FF57           B8                   2DAE    mov ax,#11694
 +a   FF5A           EF                           out dx,ax
40251 FF5B           CF                           iret
40252 FFF0                                      .org 0xfff0 ; Power-up Entry Point
40253 FFF0           EA         E05B      F000     jmp 0xf000:post
40254 FFF5                                      .org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
40255 FFF5                        30            .ascii "06/23/99"
40256 FFFE                                      .org 0xfffe ; System Model ID
40257 FFFE                        FC            db 0xFC
40258 FFFF                        00            db 0x00 ; filler
40259 FA6E                                      .org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
40260                                           ! 8242 endasm
40261                                           !BCC_ENDASM
40262                                           ! 8243 static Bit8u vgafont8[128*8]=
40263                                           ! Register BX used in function int1a_function32
40264                                           ! 8244 {
40265                                           
40266                       0000FA6E            _vgafont8:
40267                                           ! 8245  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40268 FA6E                        00            .byte	0
40269 FA6F                        00            .byte	0
40270 FA70                        00            .byte	0
40271 FA71                        00            .byte	0
40272 FA72                        00            .byte	0
40273 FA73                        00            .byte	0
40274 FA74                        00            .byte	0
40275 FA75                        00            .byte	0
40276                                           ! 8246  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
40277 FA76                        7E            .byte	$7E
40278 FA77                        81            .byte	$81
40279 FA78                        A5            .byte	$A5
40280 FA79                        81            .byte	$81
40281 FA7A                        BD            .byte	$BD
40282 FA7B                        99            .byte	$99
40283 FA7C                        81            .byte	$81
40284 FA7D                        7E            .byte	$7E
40285                                           ! 8247  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
40286 FA7E                        7E            .byte	$7E
40287 FA7F                        FF            .byte	$FF
40288 FA80                        DB            .byte	$DB
40289 FA81                        FF            .byte	$FF
40290 FA82                        C3            .byte	$C3
40291 FA83                        E7            .byte	$E7
40292 FA84                        FF            .byte	$FF
40293 FA85                        7E            .byte	$7E
40294                                           ! 8248  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40295 FA86                        6C            .byte	$6C
40296 FA87                        FE            .byte	$FE
40297 FA88                        FE            .byte	$FE
40298 FA89                        FE            .byte	$FE
40299 FA8A                        7C            .byte	$7C
40300 FA8B                        38            .byte	$38
40301 FA8C                        10            .byte	$10
40302 FA8D                        00            .byte	0
40303                                           ! 8249  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
40304 FA8E                        10            .byte	$10
40305 FA8F                        38            .byte	$38
40306 FA90                        7C            .byte	$7C
40307 FA91                        FE            .byte	$FE
40308 FA92                        7C            .byte	$7C
40309 FA93                        38            .byte	$38
40310 FA94                        10            .byte	$10
40311 FA95                        00            .byte	0
40312                                           ! 8250  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
40313 FA96                        38            .byte	$38
40314 FA97                        7C            .byte	$7C
40315 FA98                        38            .byte	$38
40316 FA99                        FE            .byte	$FE
40317 FA9A                        FE            .byte	$FE
40318 FA9B                        7C            .byte	$7C
40319 FA9C                        38            .byte	$38
40320 FA9D                        7C            .byte	$7C
40321                                           ! 8251  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
40322 FA9E                        10            .byte	$10
40323 FA9F                        10            .byte	$10
40324 FAA0                        38            .byte	$38
40325 FAA1                        7C            .byte	$7C
40326 FAA2                        FE            .byte	$FE
40327 FAA3                        7C            .byte	$7C
40328 FAA4                        38            .byte	$38
40329 FAA5                        7C            .byte	$7C
40330                                           ! 8252  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
40331 FAA6                        00            .byte	0
40332 FAA7                        00            .byte	0
40333 FAA8                        18            .byte	$18
40334 FAA9                        3C            .byte	$3C
40335 FAAA                        3C            .byte	$3C
40336 FAAB                        18            .byte	$18
40337 FAAC                        00            .byte	0
40338 FAAD                        00            .byte	0
40339                                           ! 8253  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
40340 FAAE                        FF            .byte	$FF
40341 FAAF                        FF            .byte	$FF
40342 FAB0                        E7            .byte	$E7
40343 FAB1                        C3            .byte	$C3
40344 FAB2                        C3            .byte	$C3
40345 FAB3                        E7            .byte	$E7
40346 FAB4                        FF            .byte	$FF
40347 FAB5                        FF            .byte	$FF
40348                                           ! 8254  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
40349 FAB6                        00            .byte	0
40350 FAB7                        3C            .byte	$3C
40351 FAB8                        66            .byte	$66
40352 FAB9                        42            .byte	$42
40353 FABA                        42            .byte	$42
40354 FABB                        66            .byte	$66
40355 FABC                        3C            .byte	$3C
40356 FABD                        00            .byte	0
40357                                           ! 8255  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
40358 FABE                        FF            .byte	$FF
40359 FABF                        C3            .byte	$C3
40360 FAC0                        99            .byte	$99
40361 FAC1                        BD            .byte	$BD
40362 FAC2                        BD            .byte	$BD
40363 FAC3                        99            .byte	$99
40364 FAC4                        C3            .byte	$C3
40365 FAC5                        FF            .byte	$FF
40366                                           ! 8256  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
40367 FAC6                        0F            .byte	$F
40368 FAC7                        07            .byte	7
40369 FAC8                        0F            .byte	$F
40370 FAC9                        7D            .byte	$7D
40371 FACA                        CC            .byte	$CC
40372 FACB                        CC            .byte	$CC
40373 FACC                        CC            .byte	$CC
40374 FACD                        78            .byte	$78
40375                                           ! 8257  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
40376 FACE                        3C            .byte	$3C
40377 FACF                        66            .byte	$66
40378 FAD0                        66            .byte	$66
40379 FAD1                        66            .byte	$66
40380 FAD2                        3C            .byte	$3C
40381 FAD3                        18            .byte	$18
40382 FAD4                        7E            .byte	$7E
40383 FAD5                        18            .byte	$18
40384                                           ! 8258  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
40385 FAD6                        3F            .byte	$3F
40386 FAD7                        33            .byte	$33
40387 FAD8                        3F            .byte	$3F
40388 FAD9                        30            .byte	$30
40389 FADA                        30            .byte	$30
40390 FADB                        70            .byte	$70
40391 FADC                        F0            .byte	$F0
40392 FADD                        E0            .byte	$E0
40393                                           ! 8259  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
40394 FADE                        7F            .byte	$7F
40395 FADF                        63            .byte	$63
40396 FAE0                        7F            .byte	$7F
40397 FAE1                        63            .byte	$63
40398 FAE2                        63            .byte	$63
40399 FAE3                        67            .byte	$67
40400 FAE4                        E6            .byte	$E6
40401 FAE5                        C0            .byte	$C0
40402                                           ! 8260  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
40403 FAE6                        99            .byte	$99
40404 FAE7                        5A            .byte	$5A
40405 FAE8                        3C            .byte	$3C
40406 FAE9                        E7            .byte	$E7
40407 FAEA                        E7            .byte	$E7
40408 FAEB                        3C            .byte	$3C
40409 FAEC                        5A            .byte	$5A
40410 FAED                        99            .byte	$99
40411                                           ! 8261  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0x
40412 FAEE                        80            .byte	$80
40413 FAEF                        E0            .byte	$E0
40414 FAF0                        F8            .byte	$F8
40415 FAF1                        FE            .byte	$FE
40416 FAF2                        F8            .byte	$F8
40417                                           ! 8261 e0, 0x80, 0x00,
40418 FAF3                        E0            .byte	$E0
40419 FAF4                        80            .byte	$80
40420 FAF5                        00            .byte	0
40421                                           ! 8262  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
40422 FAF6                        02            .byte	2
40423 FAF7                        0E            .byte	$E
40424 FAF8                        3E            .byte	$3E
40425 FAF9                        FE            .byte	$FE
40426 FAFA                        3E            .byte	$3E
40427 FAFB                        0E            .byte	$E
40428 FAFC                        02            .byte	2
40429 FAFD                        00            .byte	0
40430                                           ! 8263  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
40431 FAFE                        18            .byte	$18
40432 FAFF                        3C            .byte	$3C
40433 FB00                        7E            .byte	$7E
40434 FB01                        18            .byte	$18
40435 FB02                        18            .byte	$18
40436 FB03                        7E            .byte	$7E
40437 FB04                        3C            .byte	$3C
40438 FB05                        18            .byte	$18
40439                                           ! 8264  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
40440 FB06                        66            .byte	$66
40441 FB07                        66            .byte	$66
40442 FB08                        66            .byte	$66
40443 FB09                        66            .byte	$66
40444 FB0A                        66            .byte	$66
40445 FB0B                        00            .byte	0
40446 FB0C                        66            .byte	$66
40447 FB0D                        00            .byte	0
40448                                           ! 8265  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
40449 FB0E                        7F            .byte	$7F
40450 FB0F                        DB            .byte	$DB
40451 FB10                        DB            .byte	$DB
40452 FB11                        7B            .byte	$7B
40453 FB12                        1B            .byte	$1B
40454 FB13                        1B            .byte	$1B
40455 FB14                        1B            .byte	$1B
40456 FB15                        00            .byte	0
40457                                           ! 8266  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
40458 FB16                        3E            .byte	$3E
40459 FB17                        63            .byte	$63
40460 FB18                        38            .byte	$38
40461 FB19                        6C            .byte	$6C
40462 FB1A                        6C            .byte	$6C
40463 FB1B                        38            .byte	$38
40464 FB1C                        CC            .byte	$CC
40465 FB1D                        78            .byte	$78
40466                                           ! 8267  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
40467 FB1E                        00            .byte	0
40468 FB1F                        00            .byte	0
40469 FB20                        00            .byte	0
40470 FB21                        00            .byte	0
40471 FB22                        7E            .byte	$7E
40472 FB23                        7E            .byte	$7E
40473 FB24                        7E            .byte	$7E
40474 FB25                        00            .byte	0
40475                                           ! 8268  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
40476 FB26                        18            .byte	$18
40477 FB27                        3C            .byte	$3C
40478 FB28                        7E            .byte	$7E
40479 FB29                        18            .byte	$18
40480 FB2A                        7E            .byte	$7E
40481 FB2B                        3C            .byte	$3C
40482 FB2C                        18            .byte	$18
40483 FB2D                        FF            .byte	$FF
40484                                           ! 8269  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
40485 FB2E                        18            .byte	$18
40486 FB2F                        3C            .byte	$3C
40487 FB30                        7E            .byte	$7E
40488 FB31                        18            .byte	$18
40489 FB32                        18            .byte	$18
40490 FB33                        18            .byte	$18
40491 FB34                        18            .byte	$18
40492 FB35                        00            .byte	0
40493                                           ! 8270  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
40494 FB36                        18            .byte	$18
40495 FB37                        18            .byte	$18
40496 FB38                        18            .byte	$18
40497 FB39                        18            .byte	$18
40498 FB3A                        7E            .byte	$7E
40499 FB3B                        3C            .byte	$3C
40500 FB3C                        18            .byte	$18
40501 FB3D                        00            .byte	0
40502                                           ! 8271  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
40503 FB3E                        00            .byte	0
40504 FB3F                        18            .byte	$18
40505 FB40                        0C            .byte	$C
40506 FB41                        FE            .byte	$FE
40507 FB42                        0C            .byte	$C
40508 FB43                        18            .byte	$18
40509 FB44                        00            .byte	0
40510 FB45                        00            .byte	0
40511                                           ! 8272  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
40512 FB46                        00            .byte	0
40513 FB47                        30            .byte	$30
40514 FB48                        60            .byte	$60
40515 FB49                        FE            .byte	$FE
40516 FB4A                        60            .byte	$60
40517 FB4B                        30            .byte	$30
40518 FB4C                        00            .byte	0
40519 FB4D                        00            .byte	0
40520                                           ! 8273  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
40521 FB4E                        00            .byte	0
40522 FB4F                        00            .byte	0
40523 FB50                        C0            .byte	$C0
40524 FB51                        C0            .byte	$C0
40525 FB52                        C0            .byte	$C0
40526 FB53                        FE            .byte	$FE
40527 FB54                        00            .byte	0
40528 FB55                        00            .byte	0
40529                                           ! 8274  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
40530 FB56                        00            .byte	0
40531 FB57                        24            .byte	$24
40532 FB58                        66            .byte	$66
40533 FB59                        FF            .byte	$FF
40534 FB5A                        66            .byte	$66
40535 FB5B                        24            .byte	$24
40536 FB5C                        00            .byte	0
40537 FB5D                        00            .byte	0
40538                                           ! 8275  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
40539 FB5E                        00            .byte	0
40540 FB5F                        18            .byte	$18
40541 FB60                        3C            .byte	$3C
40542 FB61                        7E            .byte	$7E
40543 FB62                        FF            .byte	$FF
40544 FB63                        FF            .byte	$FF
40545 FB64                        00            .byte	0
40546 FB65                        00            .byte	0
40547                                           ! 8276  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
40548 FB66                        00            .byte	0
40549 FB67                        FF            .byte	$FF
40550 FB68                        FF            .byte	$FF
40551 FB69                        7E            .byte	$7E
40552 FB6A                        3C            .byte	$3C
40553 FB6B                        18            .byte	$18
40554 FB6C                        00            .byte	0
40555 FB6D                        00            .byte	0
40556                                           ! 8277  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
40557 FB6E                        00            .byte	0
40558 FB6F                        00            .byte	0
40559 FB70                        00            .byte	0
40560 FB71                        00            .byte	0
40561 FB72                        00            .byte	0
40562 FB73                        00            .byte	0
40563 FB74                        00            .byte	0
40564 FB75                        00            .byte	0
40565                                           ! 8278  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
40566 FB76                        30            .byte	$30
40567 FB77                        78            .byte	$78
40568 FB78                        78            .byte	$78
40569 FB79                        30            .byte	$30
40570 FB7A                        30            .byte	$30
40571 FB7B                        00            .byte	0
40572 FB7C                        30            .byte	$30
40573 FB7D                        00            .byte	0
40574                                           ! 8279  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
40575 FB7E                        6C            .byte	$6C
40576 FB7F                        6C            .byte	$6C
40577 FB80                        6C            .byte	$6C
40578 FB81                        00            .byte	0
40579 FB82                        00            .byte	0
40580 FB83                        00            .byte	0
40581 FB84                        00            .byte	0
40582 FB85                        00            .byte	0
40583                                           ! 8280  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
40584 FB86                        6C            .byte	$6C
40585 FB87                        6C            .byte	$6C
40586 FB88                        FE            .byte	$FE
40587 FB89                        6C            .byte	$6C
40588 FB8A                        FE            .byte	$FE
40589 FB8B                        6C            .byte	$6C
40590 FB8C                        6C            .byte	$6C
40591 FB8D                        00            .byte	0
40592                                           ! 8281  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
40593 FB8E                        30            .byte	$30
40594 FB8F                        7C            .byte	$7C
40595 FB90                        C0            .byte	$C0
40596 FB91                        78            .byte	$78
40597 FB92                        0C            .byte	$C
40598 FB93                        F8            .byte	$F8
40599 FB94                        30            .byte	$30
40600 FB95                        00            .byte	0
40601                                           ! 8282  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
40602 FB96                        00            .byte	0
40603 FB97                        C6            .byte	$C6
40604 FB98                        CC            .byte	$CC
40605 FB99                        18            .byte	$18
40606 FB9A                        30            .byte	$30
40607 FB9B                        66            .byte	$66
40608 FB9C                        C6            .byte	$C6
40609 FB9D                        00            .byte	0
40610                                           ! 8283  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
40611 FB9E                        38            .byte	$38
40612 FB9F                        6C            .byte	$6C
40613 FBA0                        38            .byte	$38
40614 FBA1                        76            .byte	$76
40615 FBA2                        DC            .byte	$DC
40616 FBA3                        CC            .byte	$CC
40617 FBA4                        76            .byte	$76
40618 FBA5                        00            .byte	0
40619                                           ! 8284  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
40620 FBA6                        60            .byte	$60
40621 FBA7                        60            .byte	$60
40622 FBA8                        C0            .byte	$C0
40623 FBA9                        00            .byte	0
40624 FBAA                        00            .byte	0
40625 FBAB                        00            .byte	0
40626 FBAC                        00            .byte	0
40627 FBAD                        00            .byte	0
40628                                           ! 8285  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
40629 FBAE                        18            .byte	$18
40630 FBAF                        30            .byte	$30
40631 FBB0                        60            .byte	$60
40632 FBB1                        60            .byte	$60
40633 FBB2                        60            .byte	$60
40634 FBB3                        30            .byte	$30
40635 FBB4                        18            .byte	$18
40636 FBB5                        00            .byte	0
40637                                           ! 8286  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
40638 FBB6                        60            .byte	$60
40639 FBB7                        30            .byte	$30
40640 FBB8                        18            .byte	$18
40641 FBB9                        18            .byte	$18
40642 FBBA                        18            .byte	$18
40643 FBBB                        30            .byte	$30
40644 FBBC                        60            .byte	$60
40645 FBBD                        00            .byte	0
40646                                           ! 8287  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
40647 FBBE                        00            .byte	0
40648 FBBF                        66            .byte	$66
40649 FBC0                        3C            .byte	$3C
40650 FBC1                        FF            .byte	$FF
40651 FBC2                        3C            .byte	$3C
40652 FBC3                        66            .byte	$66
40653 FBC4                        00            .byte	0
40654 FBC5                        00            .byte	0
40655                                           ! 8288  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
40656 FBC6                        00            .byte	0
40657 FBC7                        30            .byte	$30
40658 FBC8                        30            .byte	$30
40659 FBC9                        FC            .byte	$FC
40660 FBCA                        30            .byte	$30
40661 FBCB                        30            .byte	$30
40662 FBCC                        00            .byte	0
40663 FBCD                        00            .byte	0
40664                                           ! 8289  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
40665 FBCE                        00            .byte	0
40666 FBCF                        00            .byte	0
40667 FBD0                        00            .byte	0
40668 FBD1                        00            .byte	0
40669 FBD2                        00            .byte	0
40670 FBD3                        30            .byte	$30
40671 FBD4                        30            .byte	$30
40672 FBD5                        60            .byte	$60
40673                                           ! 8290  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
40674 FBD6                        00            .byte	0
40675 FBD7                        00            .byte	0
40676 FBD8                        00            .byte	0
40677 FBD9                        FC            .byte	$FC
40678 FBDA                        00            .byte	0
40679 FBDB                        00            .byte	0
40680 FBDC                        00            .byte	0
40681 FBDD                        00            .byte	0
40682                                           ! 8291  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
40683 FBDE                        00            .byte	0
40684 FBDF                        00            .byte	0
40685 FBE0                        00            .byte	0
40686 FBE1                        00            .byte	0
40687 FBE2                        00            .byte	0
40688 FBE3                        30            .byte	$30
40689 FBE4                        30            .byte	$30
40690 FBE5                        00            .byte	0
40691                                           ! 8292  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
40692 FBE6                        06            .byte	6
40693 FBE7                        0C            .byte	$C
40694 FBE8                        18            .byte	$18
40695 FBE9                        30            .byte	$30
40696 FBEA                        60            .byte	$60
40697 FBEB                        C0            .byte	$C0
40698 FBEC                        80            .byte	$80
40699 FBED                        00            .byte	0
40700                                           ! 8293  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
40701 FBEE                        7C            .byte	$7C
40702 FBEF                        C6            .byte	$C6
40703 FBF0                        CE            .byte	$CE
40704 FBF1                        DE            .byte	$DE
40705 FBF2                        F6            .byte	$F6
40706 FBF3                        E6            .byte	$E6
40707 FBF4                        7C            .byte	$7C
40708 FBF5                        00            .byte	0
40709                                           ! 8294  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
40710 FBF6                        30            .byte	$30
40711 FBF7                        70            .byte	$70
40712 FBF8                        30            .byte	$30
40713 FBF9                        30            .byte	$30
40714 FBFA                        30            .byte	$30
40715 FBFB                        30            .byte	$30
40716 FBFC                        FC            .byte	$FC
40717 FBFD                        00            .byte	0
40718                                           ! 8295  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
40719 FBFE                        78            .byte	$78
40720 FBFF                        CC            .byte	$CC
40721 FC00                        0C            .byte	$C
40722 FC01                        38            .byte	$38
40723 FC02                        60            .byte	$60
40724 FC03                        CC            .byte	$CC
40725 FC04                        FC            .byte	$FC
40726 FC05                        00            .byte	0
40727                                           ! 8296  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
40728 FC06                        78            .byte	$78
40729 FC07                        CC            .byte	$CC
40730 FC08                        0C            .byte	$C
40731 FC09                        38            .byte	$38
40732 FC0A                        0C            .byte	$C
40733 FC0B                        CC            .byte	$CC
40734 FC0C                        78            .byte	$78
40735 FC0D                        00            .byte	0
40736                                           ! 8297  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
40737 FC0E                        1C            .byte	$1C
40738 FC0F                        3C            .byte	$3C
40739 FC10                        6C            .byte	$6C
40740 FC11                        CC            .byte	$CC
40741 FC12                        FE            .byte	$FE
40742 FC13                        0C            .byte	$C
40743 FC14                        1E            .byte	$1E
40744 FC15                        00            .byte	0
40745                                           ! 8298  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
40746 FC16                        FC            .byte	$FC
40747 FC17                        C0            .byte	$C0
40748 FC18                        F8            .byte	$F8
40749 FC19                        0C            .byte	$C
40750 FC1A                        0C            .byte	$C
40751 FC1B                        CC            .byte	$CC
40752 FC1C                        78            .byte	$78
40753 FC1D                        00            .byte	0
40754                                           ! 8299  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
40755 FC1E                        38            .byte	$38
40756 FC1F                        60            .byte	$60
40757 FC20                        C0            .byte	$C0
40758 FC21                        F8            .byte	$F8
40759 FC22                        CC            .byte	$CC
40760 FC23                        CC            .byte	$CC
40761 FC24                        78            .byte	$78
40762 FC25                        00            .byte	0
40763                                           ! 8300  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
40764 FC26                        FC            .byte	$FC
40765 FC27                        CC            .byte	$CC
40766 FC28                        0C            .byte	$C
40767 FC29                        18            .byte	$18
40768 FC2A                        30            .byte	$30
40769 FC2B                        30            .byte	$30
40770 FC2C                        30            .byte	$30
40771 FC2D                        00            .byte	0
40772                                           ! 8301  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
40773 FC2E                        78            .byte	$78
40774 FC2F                        CC            .byte	$CC
40775 FC30                        CC            .byte	$CC
40776 FC31                        78            .byte	$78
40777 FC32                        CC            .byte	$CC
40778 FC33                        CC            .byte	$CC
40779 FC34                        78            .byte	$78
40780 FC35                        00            .byte	0
40781                                           ! 8302  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
40782 FC36                        78            .byte	$78
40783 FC37                        CC            .byte	$CC
40784 FC38                        CC            .byte	$CC
40785 FC39                        7C            .byte	$7C
40786 FC3A                        0C            .byte	$C
40787 FC3B                        18            .byte	$18
40788 FC3C                        70            .byte	$70
40789 FC3D                        00            .byte	0
40790                                           ! 8303  0x00, 0x30, 0x30, 0x00
40791 FC3E                        00            .byte	0
40792 FC3F                        30            .byte	$30
40793 FC40                        30            .byte	$30
40794                                           ! 8303 , 0x00, 0x30, 0x30, 0x00,
40795 FC41                        00            .byte	0
40796 FC42                        00            .byte	0
40797 FC43                        30            .byte	$30
40798 FC44                        30            .byte	$30
40799 FC45                        00            .byte	0
40800                                           ! 8304  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
40801 FC46                        00            .byte	0
40802 FC47                        30            .byte	$30
40803 FC48                        30            .byte	$30
40804 FC49                        00            .byte	0
40805 FC4A                        00            .byte	0
40806 FC4B                        30            .byte	$30
40807 FC4C                        30            .byte	$30
40808 FC4D                        60            .byte	$60
40809                                           ! 8305  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
40810 FC4E                        18            .byte	$18
40811 FC4F                        30            .byte	$30
40812 FC50                        60            .byte	$60
40813 FC51                        C0            .byte	$C0
40814 FC52                        60            .byte	$60
40815 FC53                        30            .byte	$30
40816 FC54                        18            .byte	$18
40817 FC55                        00            .byte	0
40818                                           ! 8306  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
40819 FC56                        00            .byte	0
40820 FC57                        00            .byte	0
40821 FC58                        FC            .byte	$FC
40822 FC59                        00            .byte	0
40823 FC5A                        00            .byte	0
40824 FC5B                        FC            .byte	$FC
40825 FC5C                        00            .byte	0
40826 FC5D                        00            .byte	0
40827                                           ! 8307  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
40828 FC5E                        60            .byte	$60
40829 FC5F                        30            .byte	$30
40830 FC60                        18            .byte	$18
40831 FC61                        0C            .byte	$C
40832 FC62                        18            .byte	$18
40833 FC63                        30            .byte	$30
40834 FC64                        60            .byte	$60
40835 FC65                        00            .byte	0
40836                                           ! 8308  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
40837 FC66                        78            .byte	$78
40838 FC67                        CC            .byte	$CC
40839 FC68                        0C            .byte	$C
40840 FC69                        18            .byte	$18
40841 FC6A                        30            .byte	$30
40842 FC6B                        00            .byte	0
40843 FC6C                        30            .byte	$30
40844 FC6D                        00            .byte	0
40845                                           ! 8309  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
40846 FC6E                        7C            .byte	$7C
40847 FC6F                        C6            .byte	$C6
40848 FC70                        DE            .byte	$DE
40849 FC71                        DE            .byte	$DE
40850 FC72                        DE            .byte	$DE
40851 FC73                        C0            .byte	$C0
40852 FC74                        78            .byte	$78
40853 FC75                        00            .byte	0
40854                                           ! 8310  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
40855 FC76                        30            .byte	$30
40856 FC77                        78            .byte	$78
40857 FC78                        CC            .byte	$CC
40858 FC79                        CC            .byte	$CC
40859 FC7A                        FC            .byte	$FC
40860 FC7B                        CC            .byte	$CC
40861 FC7C                        CC            .byte	$CC
40862 FC7D                        00            .byte	0
40863                                           ! 8311  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
40864 FC7E                        FC            .byte	$FC
40865 FC7F                        66            .byte	$66
40866 FC80                        66            .byte	$66
40867 FC81                        7C            .byte	$7C
40868 FC82                        66            .byte	$66
40869 FC83                        66            .byte	$66
40870 FC84                        FC            .byte	$FC
40871 FC85                        00            .byte	0
40872                                           ! 8312  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
40873 FC86                        3C            .byte	$3C
40874 FC87                        66            .byte	$66
40875 FC88                        C0            .byte	$C0
40876 FC89                        C0            .byte	$C0
40877 FC8A                        C0            .byte	$C0
40878 FC8B                        66            .byte	$66
40879 FC8C                        3C            .byte	$3C
40880 FC8D                        00            .byte	0
40881                                           ! 8313  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
40882 FC8E                        F8            .byte	$F8
40883 FC8F                        6C            .byte	$6C
40884 FC90                        66            .byte	$66
40885 FC91                        66            .byte	$66
40886 FC92                        66            .byte	$66
40887 FC93                        6C            .byte	$6C
40888 FC94                        F8            .byte	$F8
40889 FC95                        00            .byte	0
40890                                           ! 8314  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
40891 FC96                        FE            .byte	$FE
40892 FC97                        62            .byte	$62
40893 FC98                        68            .byte	$68
40894 FC99                        78            .byte	$78
40895 FC9A                        68            .byte	$68
40896 FC9B                        62            .byte	$62
40897 FC9C                        FE            .byte	$FE
40898 FC9D                        00            .byte	0
40899                                           ! 8315  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
40900 FC9E                        FE            .byte	$FE
40901 FC9F                        62            .byte	$62
40902 FCA0                        68            .byte	$68
40903 FCA1                        78            .byte	$78
40904 FCA2                        68            .byte	$68
40905 FCA3                        60            .byte	$60
40906 FCA4                        F0            .byte	$F0
40907 FCA5                        00            .byte	0
40908                                           ! 8316  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
40909 FCA6                        3C            .byte	$3C
40910 FCA7                        66            .byte	$66
40911 FCA8                        C0            .byte	$C0
40912 FCA9                        C0            .byte	$C0
40913 FCAA                        CE            .byte	$CE
40914 FCAB                        66            .byte	$66
40915 FCAC                        3E            .byte	$3E
40916 FCAD                        00            .byte	0
40917                                           ! 8317  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
40918 FCAE                        CC            .byte	$CC
40919 FCAF                        CC            .byte	$CC
40920 FCB0                        CC            .byte	$CC
40921 FCB1                        FC            .byte	$FC
40922 FCB2                        CC            .byte	$CC
40923 FCB3                        CC            .byte	$CC
40924 FCB4                        CC            .byte	$CC
40925 FCB5                        00            .byte	0
40926                                           ! 8318  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
40927 FCB6                        78            .byte	$78
40928 FCB7                        30            .byte	$30
40929 FCB8                        30            .byte	$30
40930 FCB9                        30            .byte	$30
40931 FCBA                        30            .byte	$30
40932 FCBB                        30            .byte	$30
40933 FCBC                        78            .byte	$78
40934 FCBD                        00            .byte	0
40935                                           ! 8319  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
40936 FCBE                        1E            .byte	$1E
40937 FCBF                        0C            .byte	$C
40938 FCC0                        0C            .byte	$C
40939 FCC1                        0C            .byte	$C
40940 FCC2                        CC            .byte	$CC
40941 FCC3                        CC            .byte	$CC
40942 FCC4                        78            .byte	$78
40943 FCC5                        00            .byte	0
40944                                           ! 8320  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
40945 FCC6                        E6            .byte	$E6
40946 FCC7                        66            .byte	$66
40947 FCC8                        6C            .byte	$6C
40948 FCC9                        78            .byte	$78
40949 FCCA                        6C            .byte	$6C
40950 FCCB                        66            .byte	$66
40951 FCCC                        E6            .byte	$E6
40952 FCCD                        00            .byte	0
40953                                           ! 8321  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
40954 FCCE                        F0            .byte	$F0
40955 FCCF                        60            .byte	$60
40956 FCD0                        60            .byte	$60
40957 FCD1                        60            .byte	$60
40958 FCD2                        62            .byte	$62
40959 FCD3                        66            .byte	$66
40960 FCD4                        FE            .byte	$FE
40961 FCD5                        00            .byte	0
40962                                           ! 8322  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
40963 FCD6                        C6            .byte	$C6
40964 FCD7                        EE            .byte	$EE
40965 FCD8                        FE            .byte	$FE
40966 FCD9                        FE            .byte	$FE
40967 FCDA                        D6            .byte	$D6
40968 FCDB                        C6            .byte	$C6
40969 FCDC                        C6            .byte	$C6
40970 FCDD                        00            .byte	0
40971                                           ! 8323  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
40972 FCDE                        C6            .byte	$C6
40973 FCDF                        E6            .byte	$E6
40974 FCE0                        F6            .byte	$F6
40975 FCE1                        DE            .byte	$DE
40976 FCE2                        CE            .byte	$CE
40977 FCE3                        C6            .byte	$C6
40978 FCE4                        C6            .byte	$C6
40979 FCE5                        00            .byte	0
40980                                           ! 8324  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
40981 FCE6                        38            .byte	$38
40982 FCE7                        6C            .byte	$6C
40983 FCE8                        C6            .byte	$C6
40984 FCE9                        C6            .byte	$C6
40985 FCEA                        C6            .byte	$C6
40986 FCEB                        6C            .byte	$6C
40987 FCEC                        38            .byte	$38
40988 FCED                        00            .byte	0
40989                                           ! 8325  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
40990 FCEE                        FC            .byte	$FC
40991 FCEF                        66            .byte	$66
40992 FCF0                        66            .byte	$66
40993 FCF1                        7C            .byte	$7C
40994 FCF2                        60            .byte	$60
40995 FCF3                        60            .byte	$60
40996 FCF4                        F0            .byte	$F0
40997 FCF5                        00            .byte	0
40998                                           ! 8326  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
40999 FCF6                        78            .byte	$78
41000 FCF7                        CC            .byte	$CC
41001 FCF8                        CC            .byte	$CC
41002 FCF9                        CC            .byte	$CC
41003 FCFA                        DC            .byte	$DC
41004 FCFB                        78            .byte	$78
41005 FCFC                        1C            .byte	$1C
41006 FCFD                        00            .byte	0
41007                                           ! 8327  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
41008 FCFE                        FC            .byte	$FC
41009 FCFF                        66            .byte	$66
41010 FD00                        66            .byte	$66
41011 FD01                        7C            .byte	$7C
41012 FD02                        6C            .byte	$6C
41013 FD03                        66            .byte	$66
41014 FD04                        E6            .byte	$E6
41015 FD05                        00            .byte	0
41016                                           ! 8328  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
41017 FD06                        78            .byte	$78
41018 FD07                        CC            .byte	$CC
41019 FD08                        E0            .byte	$E0
41020 FD09                        70            .byte	$70
41021 FD0A                        1C            .byte	$1C
41022 FD0B                        CC            .byte	$CC
41023 FD0C                        78            .byte	$78
41024 FD0D                        00            .byte	0
41025                                           ! 8329  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41026 FD0E                        FC            .byte	$FC
41027 FD0F                        B4            .byte	$B4
41028 FD10                        30            .byte	$30
41029 FD11                        30            .byte	$30
41030 FD12                        30            .byte	$30
41031 FD13                        30            .byte	$30
41032 FD14                        78            .byte	$78
41033 FD15                        00            .byte	0
41034                                           ! 8330  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
41035 FD16                        CC            .byte	$CC
41036 FD17                        CC            .byte	$CC
41037 FD18                        CC            .byte	$CC
41038 FD19                        CC            .byte	$CC
41039 FD1A                        CC            .byte	$CC
41040 FD1B                        CC            .byte	$CC
41041 FD1C                        FC            .byte	$FC
41042 FD1D                        00            .byte	0
41043                                           ! 8331  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41044 FD1E                        CC            .byte	$CC
41045 FD1F                        CC            .byte	$CC
41046 FD20                        CC            .byte	$CC
41047 FD21                        CC            .byte	$CC
41048 FD22                        CC            .byte	$CC
41049 FD23                        78            .byte	$78
41050 FD24                        30            .byte	$30
41051 FD25                        00            .byte	0
41052                                           ! 8332  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
41053 FD26                        C6            .byte	$C6
41054 FD27                        C6            .byte	$C6
41055 FD28                        C6            .byte	$C6
41056 FD29                        D6            .byte	$D6
41057 FD2A                        FE            .byte	$FE
41058 FD2B                        EE            .byte	$EE
41059 FD2C                        C6            .byte	$C6
41060 FD2D                        00            .byte	0
41061                                           ! 8333  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
41062 FD2E                        C6            .byte	$C6
41063 FD2F                        C6            .byte	$C6
41064 FD30                        6C            .byte	$6C
41065 FD31                        38            .byte	$38
41066 FD32                        38            .byte	$38
41067 FD33                        6C            .byte	$6C
41068 FD34                        C6            .byte	$C6
41069 FD35                        00            .byte	0
41070                                           ! 8334  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
41071 FD36                        CC            .byte	$CC
41072 FD37                        CC            .byte	$CC
41073 FD38                        CC            .byte	$CC
41074 FD39                        78            .byte	$78
41075 FD3A                        30            .byte	$30
41076 FD3B                        30            .byte	$30
41077 FD3C                        78            .byte	$78
41078 FD3D                        00            .byte	0
41079                                           ! 8335  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
41080 FD3E                        FE            .byte	$FE
41081 FD3F                        C6            .byte	$C6
41082 FD40                        8C            .byte	$8C
41083 FD41                        18            .byte	$18
41084 FD42                        32            .byte	$32
41085 FD43                        66            .byte	$66
41086 FD44                        FE            .byte	$FE
41087 FD45                        00            .byte	0
41088                                           ! 8336  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
41089 FD46                        78            .byte	$78
41090 FD47                        60            .byte	$60
41091 FD48                        60            .byte	$60
41092 FD49                        60            .byte	$60
41093 FD4A                        60            .byte	$60
41094 FD4B                        60            .byte	$60
41095 FD4C                        78            .byte	$78
41096 FD4D                        00            .byte	0
41097                                           ! 8337  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
41098 FD4E                        C0            .byte	$C0
41099 FD4F                        60            .byte	$60
41100 FD50                        30            .byte	$30
41101 FD51                        18            .byte	$18
41102 FD52                        0C            .byte	$C
41103 FD53                        06            .byte	6
41104 FD54                        02            .byte	2
41105 FD55                        00            .byte	0
41106                                           ! 8338  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
41107 FD56                        78            .byte	$78
41108 FD57                        18            .byte	$18
41109 FD58                        18            .byte	$18
41110 FD59                        18            .byte	$18
41111 FD5A                        18            .byte	$18
41112 FD5B                        18            .byte	$18
41113 FD5C                        78            .byte	$78
41114 FD5D                        00            .byte	0
41115                                           ! 8339  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
41116 FD5E                        10            .byte	$10
41117 FD5F                        38            .byte	$38
41118 FD60                        6C            .byte	$6C
41119 FD61                        C6            .byte	$C6
41120 FD62                        00            .byte	0
41121 FD63                        00            .byte	0
41122 FD64                        00            .byte	0
41123 FD65                        00            .byte	0
41124                                           ! 8340  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
41125 FD66                        00            .byte	0
41126 FD67                        00            .byte	0
41127 FD68                        00            .byte	0
41128 FD69                        00            .byte	0
41129 FD6A                        00            .byte	0
41130 FD6B                        00            .byte	0
41131 FD6C                        00            .byte	0
41132 FD6D                        FF            .byte	$FF
41133                                           ! 8341  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
41134 FD6E                        30            .byte	$30
41135 FD6F                        30            .byte	$30
41136 FD70                        18            .byte	$18
41137 FD71                        00            .byte	0
41138 FD72                        00            .byte	0
41139 FD73                        00            .byte	0
41140 FD74                        00            .byte	0
41141 FD75                        00            .byte	0
41142                                           ! 8342  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
41143 FD76                        00            .byte	0
41144 FD77                        00            .byte	0
41145 FD78                        78            .byte	$78
41146 FD79                        0C            .byte	$C
41147 FD7A                        7C            .byte	$7C
41148 FD7B                        CC            .byte	$CC
41149 FD7C                        76            .byte	$76
41150 FD7D                        00            .byte	0
41151                                           ! 8343  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
41152 FD7E                        E0            .byte	$E0
41153 FD7F                        60            .byte	$60
41154 FD80                        60            .byte	$60
41155 FD81                        7C            .byte	$7C
41156 FD82                        66            .byte	$66
41157 FD83                        66            .byte	$66
41158 FD84                        DC            .byte	$DC
41159 FD85                        00            .byte	0
41160                                           ! 8344  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
41161 FD86                        00            .byte	0
41162 FD87                        00            .byte	0
41163 FD88                        78            .byte	$78
41164 FD89                        CC            .byte	$CC
41165 FD8A                        C0            .byte	$C0
41166 FD8B                        CC            .byte	$CC
41167 FD8C                        78            .byte	$78
41168 FD8D                        00            .byte	0
41169                                           ! 8345  0x1c, 0x0c, 
41170 FD8E                        1C            .byte	$1C
41171 FD8F                        0C            .byte	$C
41172                                           ! 8345 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
41173 FD90                        0C            .byte	$C
41174 FD91                        7C            .byte	$7C
41175 FD92                        CC            .byte	$CC
41176 FD93                        CC            .byte	$CC
41177 FD94                        76            .byte	$76
41178 FD95                        00            .byte	0
41179                                           ! 8346  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
41180 FD96                        00            .byte	0
41181 FD97                        00            .byte	0
41182 FD98                        78            .byte	$78
41183 FD99                        CC            .byte	$CC
41184 FD9A                        FC            .byte	$FC
41185 FD9B                        C0            .byte	$C0
41186 FD9C                        78            .byte	$78
41187 FD9D                        00            .byte	0
41188                                           ! 8347  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
41189 FD9E                        38            .byte	$38
41190 FD9F                        6C            .byte	$6C
41191 FDA0                        60            .byte	$60
41192 FDA1                        F0            .byte	$F0
41193 FDA2                        60            .byte	$60
41194 FDA3                        60            .byte	$60
41195 FDA4                        F0            .byte	$F0
41196 FDA5                        00            .byte	0
41197                                           ! 8348  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41198 FDA6                        00            .byte	0
41199 FDA7                        00            .byte	0
41200 FDA8                        76            .byte	$76
41201 FDA9                        CC            .byte	$CC
41202 FDAA                        CC            .byte	$CC
41203 FDAB                        7C            .byte	$7C
41204 FDAC                        0C            .byte	$C
41205 FDAD                        F8            .byte	$F8
41206                                           ! 8349  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
41207 FDAE                        E0            .byte	$E0
41208 FDAF                        60            .byte	$60
41209 FDB0                        6C            .byte	$6C
41210 FDB1                        76            .byte	$76
41211 FDB2                        66            .byte	$66
41212 FDB3                        66            .byte	$66
41213 FDB4                        E6            .byte	$E6
41214 FDB5                        00            .byte	0
41215                                           ! 8350  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
41216 FDB6                        30            .byte	$30
41217 FDB7                        00            .byte	0
41218 FDB8                        70            .byte	$70
41219 FDB9                        30            .byte	$30
41220 FDBA                        30            .byte	$30
41221 FDBB                        30            .byte	$30
41222 FDBC                        78            .byte	$78
41223 FDBD                        00            .byte	0
41224                                           ! 8351  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
41225 FDBE                        0C            .byte	$C
41226 FDBF                        00            .byte	0
41227 FDC0                        0C            .byte	$C
41228 FDC1                        0C            .byte	$C
41229 FDC2                        0C            .byte	$C
41230 FDC3                        CC            .byte	$CC
41231 FDC4                        CC            .byte	$CC
41232 FDC5                        78            .byte	$78
41233                                           ! 8352  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
41234 FDC6                        E0            .byte	$E0
41235 FDC7                        60            .byte	$60
41236 FDC8                        66            .byte	$66
41237 FDC9                        6C            .byte	$6C
41238 FDCA                        78            .byte	$78
41239 FDCB                        6C            .byte	$6C
41240 FDCC                        E6            .byte	$E6
41241 FDCD                        00            .byte	0
41242                                           ! 8353  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
41243 FDCE                        70            .byte	$70
41244 FDCF                        30            .byte	$30
41245 FDD0                        30            .byte	$30
41246 FDD1                        30            .byte	$30
41247 FDD2                        30            .byte	$30
41248 FDD3                        30            .byte	$30
41249 FDD4                        78            .byte	$78
41250 FDD5                        00            .byte	0
41251                                           ! 8354  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
41252 FDD6                        00            .byte	0
41253 FDD7                        00            .byte	0
41254 FDD8                        CC            .byte	$CC
41255 FDD9                        FE            .byte	$FE
41256 FDDA                        FE            .byte	$FE
41257 FDDB                        D6            .byte	$D6
41258 FDDC                        C6            .byte	$C6
41259 FDDD                        00            .byte	0
41260                                           ! 8355  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
41261 FDDE                        00            .byte	0
41262 FDDF                        00            .byte	0
41263 FDE0                        F8            .byte	$F8
41264 FDE1                        CC            .byte	$CC
41265 FDE2                        CC            .byte	$CC
41266 FDE3                        CC            .byte	$CC
41267 FDE4                        CC            .byte	$CC
41268 FDE5                        00            .byte	0
41269                                           ! 8356  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
41270 FDE6                        00            .byte	0
41271 FDE7                        00            .byte	0
41272 FDE8                        78            .byte	$78
41273 FDE9                        CC            .byte	$CC
41274 FDEA                        CC            .byte	$CC
41275 FDEB                        CC            .byte	$CC
41276 FDEC                        78            .byte	$78
41277 FDED                        00            .byte	0
41278                                           ! 8357  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
41279 FDEE                        00            .byte	0
41280 FDEF                        00            .byte	0
41281 FDF0                        DC            .byte	$DC
41282 FDF1                        66            .byte	$66
41283 FDF2                        66            .byte	$66
41284 FDF3                        7C            .byte	$7C
41285 FDF4                        60            .byte	$60
41286 FDF5                        F0            .byte	$F0
41287                                           ! 8358  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
41288 FDF6                        00            .byte	0
41289 FDF7                        00            .byte	0
41290 FDF8                        76            .byte	$76
41291 FDF9                        CC            .byte	$CC
41292 FDFA                        CC            .byte	$CC
41293 FDFB                        7C            .byte	$7C
41294 FDFC                        0C            .byte	$C
41295 FDFD                        1E            .byte	$1E
41296                                           ! 8359  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
41297 FDFE                        00            .byte	0
41298 FDFF                        00            .byte	0
41299 FE00                        DC            .byte	$DC
41300 FE01                        76            .byte	$76
41301 FE02                        66            .byte	$66
41302 FE03                        60            .byte	$60
41303 FE04                        F0            .byte	$F0
41304 FE05                        00            .byte	0
41305                                           ! 8360  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
41306 FE06                        00            .byte	0
41307 FE07                        00            .byte	0
41308 FE08                        7C            .byte	$7C
41309 FE09                        C0            .byte	$C0
41310 FE0A                        78            .byte	$78
41311 FE0B                        0C            .byte	$C
41312 FE0C                        F8            .byte	$F8
41313 FE0D                        00            .byte	0
41314                                           ! 8361  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
41315 FE0E                        10            .byte	$10
41316 FE0F                        30            .byte	$30
41317 FE10                        7C            .byte	$7C
41318 FE11                        30            .byte	$30
41319 FE12                        30            .byte	$30
41320 FE13                        34            .byte	$34
41321 FE14                        18            .byte	$18
41322 FE15                        00            .byte	0
41323                                           ! 8362  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
41324 FE16                        00            .byte	0
41325 FE17                        00            .byte	0
41326 FE18                        CC            .byte	$CC
41327 FE19                        CC            .byte	$CC
41328 FE1A                        CC            .byte	$CC
41329 FE1B                        CC            .byte	$CC
41330 FE1C                        76            .byte	$76
41331 FE1D                        00            .byte	0
41332                                           ! 8363  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
41333 FE1E                        00            .byte	0
41334 FE1F                        00            .byte	0
41335 FE20                        CC            .byte	$CC
41336 FE21                        CC            .byte	$CC
41337 FE22                        CC            .byte	$CC
41338 FE23                        78            .byte	$78
41339 FE24                        30            .byte	$30
41340 FE25                        00            .byte	0
41341                                           ! 8364  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
41342 FE26                        00            .byte	0
41343 FE27                        00            .byte	0
41344 FE28                        C6            .byte	$C6
41345 FE29                        D6            .byte	$D6
41346 FE2A                        FE            .byte	$FE
41347 FE2B                        FE            .byte	$FE
41348 FE2C                        6C            .byte	$6C
41349 FE2D                        00            .byte	0
41350                                           ! 8365  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
41351 FE2E                        00            .byte	0
41352 FE2F                        00            .byte	0
41353 FE30                        C6            .byte	$C6
41354 FE31                        6C            .byte	$6C
41355 FE32                        38            .byte	$38
41356 FE33                        6C            .byte	$6C
41357 FE34                        C6            .byte	$C6
41358 FE35                        00            .byte	0
41359                                           ! 8366  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
41360 FE36                        00            .byte	0
41361 FE37                        00            .byte	0
41362 FE38                        CC            .byte	$CC
41363 FE39                        CC            .byte	$CC
41364 FE3A                        CC            .byte	$CC
41365 FE3B                        7C            .byte	$7C
41366 FE3C                        0C            .byte	$C
41367 FE3D                        F8            .byte	$F8
41368                                           ! 8367  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
41369 FE3E                        00            .byte	0
41370 FE3F                        00            .byte	0
41371 FE40                        FC            .byte	$FC
41372 FE41                        98            .byte	$98
41373 FE42                        30            .byte	$30
41374 FE43                        64            .byte	$64
41375 FE44                        FC            .byte	$FC
41376 FE45                        00            .byte	0
41377                                           ! 8368  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
41378 FE46                        1C            .byte	$1C
41379 FE47                        30            .byte	$30
41380 FE48                        30            .byte	$30
41381 FE49                        E0            .byte	$E0
41382 FE4A                        30            .byte	$30
41383 FE4B                        30            .byte	$30
41384 FE4C                        1C            .byte	$1C
41385 FE4D                        00            .byte	0
41386                                           ! 8369  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
41387 FE4E                        18            .byte	$18
41388 FE4F                        18            .byte	$18
41389 FE50                        18            .byte	$18
41390 FE51                        00            .byte	0
41391 FE52                        18            .byte	$18
41392 FE53                        18            .byte	$18
41393 FE54                        18            .byte	$18
41394 FE55                        00            .byte	0
41395                                           ! 8370  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
41396 FE56                        E0            .byte	$E0
41397 FE57                        30            .byte	$30
41398 FE58                        30            .byte	$30
41399 FE59                        1C            .byte	$1C
41400 FE5A                        30            .byte	$30
41401 FE5B                        30            .byte	$30
41402 FE5C                        E0            .byte	$E0
41403 FE5D                        00            .byte	0
41404                                           ! 8371  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
41405 FE5E                        76            .byte	$76
41406 FE5F                        DC            .byte	$DC
41407 FE60                        00            .byte	0
41408 FE61                        00            .byte	0
41409 FE62                        00            .byte	0
41410 FE63                        00            .byte	0
41411 FE64                        00            .byte	0
41412 FE65                        00            .byte	0
41413                                           ! 8372  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
41414 FE66                        00            .byte	0
41415 FE67                        10            .byte	$10
41416 FE68                        38            .byte	$38
41417 FE69                        6C            .byte	$6C
41418 FE6A                        C6            .byte	$C6
41419 FE6B                        C6            .byte	$C6
41420 FE6C                        FE            .byte	$FE
41421 FE6D                        00            .byte	0
41422                                           ! 8373 };
41423                                           !BCC_EOS
41424                                           ! 8374 #asm
41425                                           !BCC_ASM
41426 CFF0                                      .org 0xcff0
41427                       0000CFF0            bios_table_area_end:
41428                                           ! 8377 endasm
41429                                           !BCC_ENDASM
41430                                           ! 8378 
41431                       0000CFF0            .723:
41432                       0000CFF0            .784:
41433 CFF0                        00            .byte	0
41434                       0000CFF1            .722:
41435                       0000CFF1            .785:
41436 CFF1                        50            .ascii	"Powering off in 30 seconds."
41437 D00C                        0A            .byte	$A
41438 D00D                        00            .byte	0
41439                       0000D00E            .721:
41440                       0000D00E            .786:
41441 D00E                        0A            .byte	$A
41442 D00F                        4E            .ascii	"No bootable device."
41443 D022                        0A            .byte	$A
41444 D023                        00            .byte	0
41445                       0000D024            .70B:
41446                       0000D024            .787:
41447 D024                        73            .ascii	"set_diskette_current_cyl(): drive > 1"
41448 D049                        0A            .byte	$A
41449 D04A                        00            .byte	0
41450                       0000D04B            .6F5:
41451                       0000D04B            .788:
41452 D04B                        66            .ascii	"floppy: int13: bad floppy type"
41453 D069                        0A            .byte	$A
41454 D06A                        00            .byte	0
41455                       0000D06B            .6DD:
41456                       0000D06B            .789:
41457 D06B                        69            .ascii	"int13_diskette_function: write error"
41458 D08F                        0A            .byte	$A
41459 D090                        00            .byte	0
41460                       0000D091            .6D7:
41461                       0000D091            .78A:
41462 D091                        69            .ascii	"int13_diskette: ctrl not ready"
41463 D0AF                        0A            .byte	$A
41464 D0B0                        00            .byte	0
41465                       0000D0B1            .6BC:
41466                       0000D0B1            .78B:
41467 D0B1                        69            .ascii	"int13_diskette_function: read error"
41468 D0D4                        0A            .byte	$A
41469 D0D5                        00            .byte	0
41470                       0000D0D6            .6B6:
41471                       0000D0D6            .78C:
41472 D0D6                        69            .ascii	"int13_diskette: ctrl not ready"
41473 D0F4                        0A            .byte	$A
41474 D0F5                        00            .byte	0
41475                       0000D0F6            .6A4:
41476                       0000D0F6            .78D:
41477 D0F6                        69            .ascii	"int13_diskette: ctrl not ready"
41478 D114                        0A            .byte	$A
41479 D115                        00            .byte	0
41480                       0000D116            .5F3:
41481                       0000D116            .78E:
41482 D116                        49            .ascii	"Int13 eltorito call with AX=%04x. Please"
41483 D13E                        20            .ascii	" report"
41484 D145                        0A            .byte	$A
41485 D146                        00            .byte	0
41486                       0000D147            .59D:
41487                       0000D147            .78F:
41488 D147                        69            .ascii	"int13_cdrom: function %02x. Can't use 64"
41489 D16F                        62            .ascii	"bits lba"
41490 D177                        0A            .byte	$A
41491 D178                        00            .byte	0
41492                       0000D179            .4A5:
41493                       0000D179            .790:
41494 D179                        73            .ascii	"setkbdcomm"
41495 D183                        00            .byte	0
41496                       0000D184            .49E:
41497                       0000D184            .791:
41498 D184                        73            .ascii	"sendmouse"
41499 D18D                        00            .byte	0
41500                       0000D18E            .49B:
41501                       0000D18E            .792:
41502 D18E                        65            .ascii	"enabmouse"
41503 D197                        00            .byte	0
41504                       0000D198            .494:
41505                       0000D198            .793:
41506 D198                        65            .ascii	"enabmouse"
41507 D1A1                        00            .byte	0
41508                       0000D1A2            .491:
41509                       0000D1A2            .794:
41510 D1A2                        69            .ascii	"inhibmouse"
41511 D1AC                        00            .byte	0
41512                       0000D1AD            .48A:
41513                       0000D1AD            .795:
41514 D1AD                        69            .ascii	"inhibmouse"
41515 D1B7                        00            .byte	0
41516                       0000D1B8            .46D:
41517                       0000D1B8            .796:
41518 D1B8                        4B            .ascii	"KBD: int16h: out of keyboard input"
41519 D1DA                        0A            .byte	$A
41520 D1DB                        00            .byte	0
41521                       0000D1DC            .43F:
41522                       0000D1DC            .797:
41523 D1DC                        4B            .ascii	"KBD: int16h: out of keyboard input"
41524 D1FE                        0A            .byte	$A
41525 D1FF                        00            .byte	0
41526                       0000D200            .3F1:
41527                       0000D200            .798:
41528 D200                        49            .ascii	"INT 15h C2 AL=6, BH=%02x"
41529 D218                        0A            .byte	$A
41530 D219                        00            .byte	0
41531                       0000D21A            .3DB:
41532                       0000D21A            .799:
41533 D21A                        4D            .ascii	"Mouse status returned %02x (should be ac"
41534 D242                        6B            .ascii	"k)"
41535 D244                        0A            .byte	$A
41536 D245                        00            .byte	0
41537                       0000D246            .3CB:
41538                       0000D246            .79A:
41539 D246                        4D            .ascii	"Mouse status returned %02x (should be ac"
41540 D26E                        6B            .ascii	"k)"
41541 D270                        0A            .byte	$A
41542 D271                        00            .byte	0
41543                       0000D272            .3C8:
41544                       0000D272            .79B:
41545 D272                        4D            .ascii	"Mouse status returned %02x (should be ac"
41546 D29A                        6B            .ascii	"k)"
41547 D29C                        0A            .byte	$A
41548 D29D                        00            .byte	0
41549                       0000D29E            .3A6:
41550                       0000D29E            .79C:
41551 D29E                        4D            .ascii	"Mouse reset returned %02x (should be ack"
41552 D2C6                        29            .ascii	")"
41553 D2C7                        0A            .byte	$A
41554 D2C8                        00            .byte	0
41555                       0000D2C9            .37E:
41556                       0000D2C9            .79D:
41557 D2C9                        45            .ascii	"EISA BIOS not present"
41558 D2DE                        0A            .byte	$A
41559 D2DF                        00            .byte	0
41560                       0000D2E0            .2E9:
41561                       0000D2E0            .79E:
41562 D2E0                        25            .ascii	"%dMB medium detected"
41563 D2F4                        0A            .byte	$A
41564 D2F5                        00            .byte	0
41565                       0000D2F6            .2E4:
41566                       0000D2F6            .79F:
41567 D2F6                        55            .ascii	"Unsupported sector size %u"
41568 D310                        0A            .byte	$A
41569 D311                        00            .byte	0
41570                       0000D312            .2DF:
41571                       0000D312            .7A0:
41572 D312                        57            .ascii	"Waiting for device to detect medium... "
41573 D339                        00            .byte	0
41574                       0000D33A            .2D1:
41575                       0000D33A            .7A1:
41576 D33A                        6E            .ascii	"not implemented for non-ATAPI device"
41577 D35E                        0A            .byte	$A
41578 D35F                        00            .byte	0
41579                       0000D360            .248:
41580                       0000D360            .7A2:
41581 D360                        0A            .byte	$A
41582 D361                        00            .byte	0
41583                       0000D362            .243:
41584                       0000D362            .7A3:
41585 D362                        6D            .ascii	"master"
41586 D368                        00            .byte	0
41587                       0000D369            .242:
41588                       0000D369            .7A4:
41589 D369                        20            .ascii	" slave"
41590 D36F                        00            .byte	0
41591                       0000D370            .241:
41592                       0000D370            .7A5:
41593 D370                        61            .ascii	"ata%d %s: Unknown device"
41594 D388                        0A            .byte	$A
41595 D389                        00            .byte	0
41596                       0000D38A            .23F:
41597                       0000D38A            .7A6:
41598 D38A                        20            .ascii	" ATAPI-%d Device"
41599 D39A                        0A            .byte	$A
41600 D39B                        00            .byte	0
41601                       0000D39C            .23D:
41602                       0000D39C            .7A7:
41603 D39C                        20            .ascii	" ATAPI-%d CD-Rom/DVD-Rom"
41604 D3B4                        0A            .byte	$A
41605 D3B5                        00            .byte	0
41606                       0000D3B6            .239:
41607                       0000D3B6            .7A8:
41608 D3B6                        25            .ascii	"%c"
41609 D3B8                        00            .byte	0
41610                       0000D3B9            .232:
41611                       0000D3B9            .7A9:
41612 D3B9                        6D            .ascii	"master"
41613 D3BF                        00            .byte	0
41614                       0000D3C0            .231:
41615                       0000D3C0            .7AA:
41616 D3C0                        20            .ascii	" slave"
41617 D3C6                        00            .byte	0
41618                       0000D3C7            .230:
41619                       0000D3C7            .7AB:
41620 D3C7                        61            .ascii	"ata%d %s: "
41621 D3D1                        00            .byte	0
41622                       0000D3D2            .22E:
41623                       0000D3D2            .7AC:
41624 D3D2                        20            .ascii	" ATA-%d Hard-Disk (%4u GBytes)"
41625 D3F0                        0A            .byte	$A
41626 D3F1                        00            .byte	0
41627                       0000D3F2            .22C:
41628                       0000D3F2            .7AD:
41629 D3F2                        20            .ascii	" ATA-%d Hard-Disk (%4u MBytes)"
41630 D410                        0A            .byte	$A
41631 D411                        00            .byte	0
41632                       0000D412            .228:
41633                       0000D412            .7AE:
41634 D412                        25            .ascii	"%c"
41635 D414                        00            .byte	0
41636                       0000D415            .221:
41637                       0000D415            .7AF:
41638 D415                        6D            .ascii	"master"
41639 D41B                        00            .byte	0
41640                       0000D41C            .220:
41641                       0000D41C            .7B0:
41642 D41C                        20            .ascii	" slave"
41643 D422                        00            .byte	0
41644                       0000D423            .21F:
41645                       0000D423            .7B1:
41646 D423                        61            .ascii	"ata%d %s: "
41647 D42D                        00            .byte	0
41648                       0000D42E            .1F4:
41649                       0000D42E            .7B2:
41650 D42E                        61            .ascii	"ata-detect: Failed to detect ATAPI devic"
41651 D456                        65            .ascii	"e"
41652 D457                        0A            .byte	$A
41653 D458                        00            .byte	0
41654                       0000D459            .1BB:
41655                       0000D459            .7B3:
41656 D459                        61            .ascii	"ata-detect: Failed to detect ATA device"
41657 D480                        0A            .byte	$A
41658 D481                        00            .byte	0
41659                       0000D482            .157:
41660                       0000D482            .7B4:
41661 D482                        49            .ascii	"INT18: BOOT FAILURE"
41662 D495                        0A            .byte	$A
41663 D496                        00            .byte	0
41664                       0000D497            .156:
41665                       0000D497            .7B5:
41666 D497                        4E            .ascii	"NMI Handler called"
41667 D4A9                        0A            .byte	$A
41668 D4AA                        00            .byte	0
41669                       0000D4AB            .155:
41670                       0000D4AB            .7B6:
41671 D4AB                        43            .ascii	"CDROM boot failure code : %04x"
41672 D4C9                        0A            .byte	$A
41673 D4CA                        00            .byte	0
41674                       0000D4CB            .154:
41675                       0000D4CB            .7B7:
41676 D4CB                        0A            .byte	$A,$A
41677 D4CD                        00            .byte	0
41678                       0000D4CE            .153:
41679                       0000D4CE            .7B8:
41680 D4CE                        3A            .ascii	": could not read the boot disk"
41681 D4EC                        00            .byte	0
41682                       0000D4ED            .151:
41683                       0000D4ED            .7B9:
41684 D4ED                        3A            .ascii	": not a bootable disk"
41685 D502                        00            .byte	0
41686                       0000D503            .14C:
41687                       0000D503            .7BA:
41688 D503                        42            .ascii	"Boot from %s failed"
41689 D516                        00            .byte	0
41690                       0000D517            .14B:
41691                       0000D517            .7BB:
41692 D517                        42            .ascii	"Bad drive type"
41693 D525                        0A            .byte	$A
41694 D526                        00            .byte	0
41695                       0000D527            .147:
41696                       0000D527            .7BC:
41697 D527                        2E            .ascii	"..."
41698 D52A                        0A            .byte	$A
41699 D52B                        00            .byte	0
41700                       0000D52C            .146:
41701                       0000D52C            .7BD:
41702 D52C                        20            .ascii	" [%S]"
41703 D531                        00            .byte	0
41704                       0000D532            .142:
41705                       0000D532            .7BE:
41706 D532                        42            .ascii	"Booting from %s"
41707 D541                        00            .byte	0
41708                       0000D542            .141:
41709                       0000D542            .7BF:
41710 D542                        42            .ascii	"Bad drive type"
41711 D550                        0A            .byte	$A
41712 D551                        00            .byte	0
41713                       0000D552            .13A:
41714                       0000D552            .7C0:
41715 D552                        0A            .byte	$A
41716 D553                        00            .byte	0
41717                       0000D554            .12E:
41718                       0000D554            .7C1:
41719 D554                        0A            .byte	$A
41720 D555                        00            .byte	0
41721                       0000D556            .12D:
41722                       0000D556            .7C2:
41723 D556                        20            .ascii	" [%S]"
41724 D55B                        00            .byte	0
41725                       0000D55C            .12A:
41726                       0000D55C            .7C3:
41727 D55C                        25            .ascii	"%s"
41728 D55E                        00            .byte	0
41729                       0000D55F            .128:
41730                       0000D55F            .7C4:
41731 D55F                        25            .ascii	"%s"
41732 D561                        0A            .byte	$A
41733 D562                        00            .byte	0
41734                       0000D563            .121:
41735                       0000D563            .7C5:
41736 D563                        25            .ascii	"%d. "
41737 D567                        00            .byte	0
41738                       0000D568            .11C:
41739                       0000D568            .7C6:
41740 D568                        53            .ascii	"Select boot device:"
41741 D57B                        0A            .byte	$A,$A
41742 D57D                        00            .byte	0
41743                       0000D57E            .112:
41744                       0000D57E            .7C7:
41745 D57E                        0A            .byte	$A,$A
41746 D580                        50            .ascii	"Press F12 for boot menu."
41747 D598                        0A            .byte	$A,$A
41748 D59A                        00            .byte	0
41749                       0000D59B            .10A:
41750                       0000D59B            .7C8:
41751 D59B                        61            .ascii	"apmbios pcibios eltorito PMM "
41752 D5B8                        0A            .byte	$A,$A
41753 D5BA                        00            .byte	0
41754                       0000D5BB            .109:
41755                       0000D5BB            .7C9:
41756 D5BB                        30            .ascii	"06/23/99"
41757 D5C3                        00            .byte	0
41758                       0000D5C4            .108:
41759                       0000D5C4            .7CA:
41760 D5C4                        42            .ascii	"Bochs BIOS - build: %s"
41761 D5DA                        0A            .byte	$A
41762 D5DB                        25            .ascii	"%s"
41763 D5DD                        0A            .byte	$A
41764 D5DE                        4F            .ascii	"Options: "
41765 D5E7                        00            .byte	0
41766                       0000D5E8            .107:
41767                       0000D5E8            .7CB:
41768 D5E8                        52            .ascii	"Returned from s3_resume."
41769 D600                        0A            .byte	$A
41770 D601                        00            .byte	0
41771                       0000D602            .106:
41772                       0000D602            .7CC:
41773 D602                        55            .ascii	"Unimplemented shutdown status: %02x"
41774 D625                        0A            .byte	$A
41775 D626                        00            .byte	0
41776                       0000D627            .105:
41777                       0000D627            .7CD:
41778 D627                        43            .ascii	"Couldn't reset the machine"
41779 D641                        0A            .byte	$A
41780 D642                        00            .byte	0
41781                       0000D643            .104:
41782                       0000D643            .7CE:
41783 D643                        4B            .ascii	"Keyboard error:%u"
41784 D654                        0A            .byte	$A
41785 D655                        00            .byte	0
41786                       0000D656            .8D:
41787                       0000D656            .7CF:
41788 D656                        62            .ascii	"bios_printf: unknown format"
41789 D671                        0A            .byte	$A
41790 D672                        00            .byte	0
41791                       0000D673            .41:
41792                       0000D673            .7D0:
41793 D673                        46            .ascii	"FATAL: "
41794 D67A                        00            .byte	0
41795 D67B                                      .bss
41796                                           
41797                                           ! 0 errors detected

Symbols:
..FFD9                      0 FFFC A   ..FFDA                      0 FFFC A   
..FFDB                      0 FFE0 A   ..FFDC                      0 FFE0 A   
..FFDD                      0 FFCA A   ..FFDE                      0 FFCA A   
..FFDF                      0 FFCA A   ..FFE0                      0 FFCA A   
..FFE1                      0 FFCA A   ..FFE2                      0 FFCA A   
..FFE3                      0 FFFC A   ..FFE4                      0 FFFC A   
..FFE5                      0 FFFC A   ..FFE6                      0 FFDE A   
..FFE7                      0 FFDE A   ..FFE8                      0 FFDE A   
..FFE9                      0 FFDE A   ..FFEA                      0 FFD2 A   
..FFEB                      0 FFDE A   ..FFEC                      0 FFD8 A   
..FFED                      0 FFD8 A   ..FFEE                      0 FFD8 A   
..FFEF                      0 FFD8 A   ..FFF0                      0 FFCA A   
..FFF1                      0 FFD8 A   ..FFF2                      0 FFF8 A   
..FFF3                      0 FFF4 A   ..FFF4                      0 FFE6 A   
..FFF5                      0 FFE6 A   ..FFF6                      0 FFF0 A   
..FFF7                      0 FFEC A   ..FFF8                      0 FFF6 A   
..FFF9                      0 F7E2 A   ..FFFA                      0 FFD4 A   
..FFFB                      0 FDBA A   ..FFFC                      0 FDBA A   
..FFFD                      0 FDD8 A   ..FFFE                      0 FDD8 A   
..FFFF                      0 FFC2 A   .1                          0 0194 A   
.10                         0 075F A   .100                        0 128A A   
.101                        0 1281 A   .102                        0 12A0 A   
.103                        0 1297 A   .104                        0 D643 A   
.105                        0 D627 A   .106                        0 D602 A   
.107                        0 D5E8 A   .108                        0 D5C4 A   
.109                        0 D5BB A   .10A                        0 D59B A   
.10B                        0 1374 A   .10C                        0 137E A   
.10D                        0 1388 A   .10E                        0 1392 A   
.10F                        0 139C A   .11                         0 0749 A   
.110                        0 1540 A   .111                        0 153A A   
.112                        0 D57E A   .113                        0 1758 A   
.114                        0 174F A   .115                        0 159B A   
.116                        0 15AB A   .117                        0 15A8 A   
.118                        0 15B7 A   .119                        0 15B0 A   
.11A                        0 15AD A   .11B                        0 15B7 A   
.11C                        0 D568 A   .11D                        0 16E7 A   
.11E                        0 16D4 A   .11F                        0 16DB A   
.12                         0 078D A   .120                        0 15DD A   
.121                        0 D563 A   .122                        0 16D4 A   
.124                        0 16B8 A   .125                        0 1619 A   
.126                        0 1619 A   .127                        0 1619 A   
.128                        0 D55F A   .129                        0 163C A   
.12A                        0 D55C A   .12B                        0 16A6 A   
.12C                        0 1665 A   .12D                        0 D556 A   
.12E                        0 D554 A   .12F                        0 16E7 A   
.13                         0 0779 A   .130                        0 173F A   
.131                        0 1738 A   .132                        0 16F0 A   
.133                        0 170C A   .134                        0 1704 A   
.135                        0 16FD A   .136                        0 1738 A   
.137                        0 1738 A   .138                        0 1716 A   
.139                        0 173F A   .13A                        0 D552 A   
.13B                        0 1758 A   .13C                        0 1776 A   
.13D                        0 1770 A   .13E                        0 1793 A   
.13F                        0 1785 A   .14                         0 076E A   
.140                        0 177D A   .141                        0 D542 A   
.142                        0 D532 A   .143                        0 1813 A   
.144                        0 17D2 A   .145                        0 17BB A   
.146                        0 D52C A   .147                        0 D527 A   
.148                        0 1844 A   .149                        0 1837 A   
.14A                        0 182F A   .14B                        0 D517 A   
.14C                        0 D503 A   .14D                        0 188E A   
.14E                        0 186B A   .14F                        0 1881 A   
.15                         0 0761 A   .150                        0 1872 A   
.151                        0 D4ED A   .152                        0 188E A   
.153                        0 D4CE A   .154                        0 D4CB A   
.155                        0 D4AB A   .156                        0 D497 A   
.157                        0 D482 A   .158                        0 1907 A   
.159                        0 18F3 A   .15A                        0 1919 A   
.15B                        0 1926 A   .15C                        0 1928 A   
.15D                        0 198B A   .15E                        0 1985 A   
.15F                        0 197A A   .16                         0 0779 A   
.160                        0 1A7C A   .161                        0 1A6E A   
.162                        0 1A75 A   .163                        0 19FE A   
.164                        0 1A7C A   .165                        0 1C4D A   
.166                        0 1C3D A   .167                        0 1C44 A   
.168                        0 1A84 A   .169                        0 1C4D A   
.16A                        0 1C94 A   .16B                        0 1C86 A   
.16C                        0 1C8D A   .16D                        0 1C54 A   
.16E                        0 1C94 A   .16F                        0 1E08 A   
.17                         0 078D A   .170                        0 1E05 A   
.171                        0 1CD7 A   .172                        0 1D04 A   
.173                        0 1CF9 A   .174                        0 1D98 A   
.175                        0 1D20 A   .176                        0 1D0B A   
.177                        0 1D18 A   .178                        0 1D14 A   
.179                        0 1D1A A   .17A                        0 1D98 A   
.17B                        0 1D44 A   .17C                        0 1D27 A   
.17D                        0 1D3D A   .17E                        0 1D39 A   
.17F                        0 1D30 A   .18                         0 0780 A   
.180                        0 1D3F A   .181                        0 1D98 A   
.182                        0 1D68 A   .183                        0 1D4B A   
.184                        0 1D61 A   .185                        0 1D5D A   
.186                        0 1D54 A   .187                        0 1D63 A   
.188                        0 1D98 A   .189                        0 1D8C A   
.18A                        0 1D6F A   .18B                        0 1D85 A   
.18C                        0 1D81 A   .18D                        0 1D78 A   
.18E                        0 1D87 A   .18F                        0 1D98 A   
.19                         0 07E2 A   .190                        0 1D98 A   
.191                        0 1D93 A   .192                        0 1DA6 A   
.193                        0 1D9F A   .194                        0 1DC6 A   
.195                        0 1DB7 A   .196                        0 1DD6 A   
.197                        0 1DCF A   .198                        0 1E05 A   
.199                        0 1E03 A   .19A                        0 1DDD A   
.19B                        0 2C87 A   .19C                        0 2C77 A   
.19D                        0 2C7E A   .19E                        0 1F45 A   
.19F                        0 1FB8 A   .1A                         0 07CC A   
.1A0                        0 1FB4 A   .1A1                        0 1FBA A   
.1A2                        0 21AE A   .1A3                        0 2069 A   
.1A4                        0 205F A   .1A5                        0 209E A   
.1A6                        0 209A A   .1A7                        0 20A0 A   
.1A8                        0 21AE A   .1A9                        0 20E6 A   
.1AA                        0 20DC A   .1AB                        0 2149 A   
.1AC                        0 2129 A   .1AD                        0 2121 A   
.1AE                        0 21AE A   .1AF                        0 2181 A   
.1B                         0 0810 A   .1B0                        0 2161 A   
.1B1                        0 2159 A   .1B2                        0 2151 A   
.1B3                        0 21AE A   .1B4                        0 21AE A   
.1B5                        0 2191 A   .1B6                        0 2189 A   
.1B7                        0 2709 A   .1B8                        0 21D4 A   
.1B9                        0 225C A   .1BA                        0 224E A   
.1BB                        0 D459 A   .1BC                        0 2275 A   
.1BD                        0 2271 A   .1BE                        0 2277 A   
.1BF                        0 2292 A   .1C                         0 07FC A   
.1C0                        0 228E A   .1C1                        0 2294 A   
.1C2                        0 232E A   .1C3                        0 22FA A   
.1C4                        0 2353 A   .1C5                        0 24B0 A   
.1C6                        0 249F A   .1C7                        0 24A8 A   
.1C8                        0 2491 A   .1C9                        0 24B0 A   
.1CA                        0 24FB A   .1CC                        0 24EB A   
.1CD                        0 24E1 A   .1CE                        0 24E3 A   
.1CF                        0 24E5 A   .1D                         0 07F1 A   
.1D0                        0 24E7 A   .1D1                        0 267A A   
.1D3                        0 2664 A   .1D4                        0 2502 A   
.1D5                        0 2505 A   .1D6                        0 255C A   
.1D7                        0 2553 A   .1D8                        0 2599 A   
.1D9                        0 256E A   .1DA                        0 2565 A   
.1DB                        0 2599 A   .1DC                        0 2580 A   
.1DD                        0 2577 A   .1DE                        0 2599 A   
.1DF                        0 2592 A   .1E                         0 07E4 A   
.1E0                        0 2589 A   .1E1                        0 2599 A   
.1E2                        0 25BA A   .1E3                        0 2635 A   
.1E4                        0 25C3 A   .1E5                        0 25EE A   
.1E6                        0 25E7 A   .1E7                        0 2635 A   
.1E8                        0 2660 A   .1E9                        0 2657 A   
.1EA                        0 2638 A   .1EB                        0 2657 A   
.1EC                        0 2655 A   .1ED                        0 2660 A   
.1EE                        0 268A A   .1EF                        0 2683 A   
.1F                         0 07FC A   .1F0                        0 2898 A   
.1F1                        0 2712 A   .1F2                        0 279A A   
.1F3                        0 278C A   .1F4                        0 D42E A   
.1F5                        0 27C8 A   .1F6                        0 27C4 A   
.1F7                        0 27CA A   .1F8                        0 27E5 A   
.1F9                        0 27E1 A   .1FA                        0 27E7 A   
.1FB                        0 2AB9 A   .1FD                        0 2AAD A   
.1FE                        0 28A1 A   .1FF                        0 2902 A   
.2                          0 05ED A   .20                         0 0810 A   
.200                        0 2963 A   .201                        0 2952 A   
.202                        0 295B A   .203                        0 2939 A   
.204                        0 2952 A   .205                        0 2950 A   
.206                        0 2963 A   .207                        0 29F1 A   
.208                        0 29DE A   .209                        0 29E7 A   
.20A                        0 296C A   .20B                        0 29F1 A   
.20C                        0 2A59 A   .20D                        0 2A48 A   
.20E                        0 2A51 A   .20F                        0 2A0B A   
.21                         0 0803 A   .210                        0 2A46 A   
.211                        0 2A28 A   .212                        0 2A48 A   
.213                        0 2A59 A   .214                        0 2AA9 A   
.215                        0 2A61 A   .216                        0 2AA9 A   
.217                        0 2A98 A   .218                        0 2AA1 A   
.219                        0 2A7B A   .21A                        0 2AA9 A   
.21B                        0 2C71 A   .21D                        0 2C61 A   
.21E                        0 2ABF A   .21F                        0 D423 A   
.22                         0 087D A   .220                        0 D41C A   
.221                        0 D415 A   .222                        0 2ACC A   
.223                        0 2AC7 A   .224                        0 2ACF A   
.225                        0 2B29 A   .226                        0 2B02 A   
.227                        0 2AED A   .228                        0 D412 A   
.229                        0 2B29 A   .22A                        0 2B52 A   
.22B                        0 2B37 A   .22C                        0 D3F2 A   
.22D                        0 2B7E A   .22E                        0 D3D2 A   
.22F                        0 2B81 A   .23                         0 0864 A   
.230                        0 D3C7 A   .231                        0 D3C0 A   
.232                        0 D3B9 A   .233                        0 2B8E A   
.234                        0 2B89 A   .235                        0 2B91 A   
.236                        0 2BEB A   .237                        0 2BC4 A   
.238                        0 2BAF A   .239                        0 D3B6 A   
.23A                        0 2BEB A   .23B                        0 2C20 A   
.23C                        0 2C09 A   .23D                        0 D39C A   
.23E                        0 2C35 A   .23F                        0 D38A A   
.24                         0 08AB A   .240                        0 2C37 A   
.241                        0 D370 A   .242                        0 D369 A   
.243                        0 D362 A   .244                        0 2C44 A   
.245                        0 2C3F A   .246                        0 2C47 A   
.247                        0 2C87 A   .248                        0 D360 A   
.249                        0 2E0B A   .24A                        0 2D87 A   
.24B                        0 2D92 A   .24C                        0 2D8E A   
.24D                        0 2D94 A   .24E                        0 2DFA A   
.24F                        0 2DCF A   .25                         0 0897 A   
.250                        0 2DC8 A   .251                        0 2DE9 A   
.252                        0 2DD6 A   .253                        0 2DFA A   
.254                        0 2EBC A   .255                        0 2EB0 A   
.256                        0 2EC4 A   .257                        0 2F0B A   
.258                        0 2F04 A   .259                        0 308C A   
.25A                        0 2F25 A   .25B                        0 302B A   
.25C                        0 2F6F A   .25D                        0 2F48 A   
.25E                        0 2F3D A   .25F                        0 2F31 A   
.26                         0 088C A   .260                        0 2F33 A   
.262                        0 30EC A   .263                        0 30E8 A   
.264                        0 30EE A   .265                        0 3137 A   
.266                        0 312E A   .267                        0 3147 A   
.268                        0 3147 A   .269                        0 3140 A   
.26A                        0 31E1 A   .26B                        0 31DE A   
.26C                        0 3148 A   .26D                        0 31CC A   
.26E                        0 31B8 A   .26F                        0 31C8 A   
.27                         0 087F A   .270                        0 31C1 A   
.271                        0 31DE A   .272                        0 31DC A   
.273                        0 31D5 A   .274                        0 31E1 A   
.275                        0 328D A   .276                        0 3281 A   
.277                        0 3295 A   .278                        0 32DC A   
.279                        0 32D5 A   .27A                        0 345D A   
.27B                        0 32F6 A   .27C                        0 33FC A   
.27D                        0 3340 A   .27E                        0 3319 A   
.27F                        0 330E A   .28                         0 0897 A   
.280                        0 3302 A   .281                        0 3304 A   
.283                        0 34BD A   .284                        0 34B9 A   
.285                        0 34BF A   .286                        0 3508 A   
.287                        0 34FF A   .288                        0 3518 A   
.289                        0 3518 A   .28A                        0 3511 A   
.28B                        0 35B4 A   .28C                        0 35B1 A   
.28D                        0 3519 A   .28E                        0 359F A   
.28F                        0 358B A   .29                         0 08AB A   
.290                        0 359B A   .291                        0 3594 A   
.292                        0 35B1 A   .293                        0 35AF A   
.294                        0 35A8 A   .295                        0 35B4 A   
.296                        0 3602 A   .297                        0 35FB A   
.298                        0 3612 A   .299                        0 360B A   
.29A                        0 367B A   .29B                        0 3676 A   
.29C                        0 3687 A   .29D                        0 3682 A   
.29E                        0 36D3 A   .29F                        0 36CC A   
.2A                         0 089E A   .2A0                        0 373E A   
.2A1                        0 373A A   .2A2                        0 3740 A   
.2A3                        0 3787 A   .2A4                        0 377E A   
.2A5                        0 3797 A   .2A6                        0 3797 A   
.2A7                        0 3790 A   .2A8                        0 37E2 A   
.2A9                        0 37CB A   .2AA                        0 3A54 A   
.2AB                        0 3A51 A   .2AC                        0 3A4E A   
.2AD                        0 37EB A   .2AE                        0 3817 A   
.2AF                        0 37F2 A   .2B                         0 091E A   
.2B0                        0 382B A   .2B1                        0 385D A   
.2B2                        0 385A A   .2B3                        0 3851 A   
.2B4                        0 386D A   .2B5                        0 3866 A   
.2B6                        0 38CC A   .2B7                        0 38B6 A   
.2B8                        0 38E0 A   .2B9                        0 390D A   
.2BA                        0 38ED A   .2BB                        0 392E A   
.2BC                        0 3948 A   .2BD                        0 3943 A   
.2BE                        0 3956 A   .2BF                        0 3951 A   
.2C                         0 090B A   .2C0                        0 3964 A   
.2C1                        0 395F A   .2C2                        0 398B A   
.2C3                        0 396D A   .2C4                        0 398B A   
.2C5                        0 3984 A   .2C6                        0 397B A   
.2C7                        0 39B2 A   .2C8                        0 3992 A   
.2C9                        0 39CA A   .2CA                        0 3A51 A   
.2CB                        0 3A64 A   .2CC                        0 3A5D A   
.2CD                        0 3AD6 A   .2CE                        0 3ACF A   
.2CF                        0 3B48 A   .2D                         0 08F5 A   
.2D0                        0 3B33 A   .2D1                        0 D33A A   
.2D2                        0 3C3A A   .2D3                        0 3C2A A   
.2D4                        0 3B7F A   .2D5                        0 3BB4 A   
.2D6                        0 3BAE A   .2D7                        0 3C0E A   
.2D8                        0 3BCD A   .2D9                        0 3BDB A   
.2DA                        0 3BD4 A   .2DB                        0 3C0E A   
.2DC                        0 3BF0 A   .2DD                        0 3BE9 A   
.2DE                        0 3BE2 A   .2DF                        0 D312 A   
.2E                         0 091E A   .2E0                        0 3C3A A   
.2E1                        0 3CE1 A   .2E2                        0 3CC6 A   
.2E3                        0 3CAE A   .2E4                        0 D2F6 A   
.2E5                        0 3D7E A   .2E6                        0 3D6C A   
.2E7                        0 3DC4 A   .2E8                        0 3DA0 A   
.2E9                        0 D2E0 A   .2EA                        0 3E0B A   
.2EB                        0 3E05 A   .2EC                        0 3E2F A   
.2ED                        0 3E29 A   .2EE                        0 3E53 A   
.2EF                        0 3E4D A   .2F                         0 09CE A   
.2F0                        0 3ED2 A   .2F1                        0 3ED8 A   
.2F2                        0 3F36 A   .2F3                        0 3F25 A   
.2F4                        0 3F2E A   .2F5                        0 3F12 A   
.2F6                        0 3F25 A   .2F7                        0 3F22 A   
.2F8                        0 3F36 A   .2F9                        0 3F45 A   
.2FA                        0 3F3E A   .2FB                        0 3F65 A   
.2FC                        0 3F65 A   .2FD                        0 3F59 A   
.2FE                        0 3F5B A   .2FF                        0 3FDC A   
.3                          0 05E2 A   .30                         0 09C0 A   
.300                        0 3FD5 A   .301                        0 3FEB A   
.302                        0 3FE4 A   .303                        0 4042 A   
.304                        0 4030 A   .305                        0 4039 A   
.306                        0 3FF3 A   .307                        0 4030 A   
.308                        0 4029 A   .309                        0 4042 A   
.30A                        0 409B A   .30B                        0 4089 A   
.30C                        0 4092 A   .30D                        0 404A A   
.30E                        0 4089 A   .30F                        0 4082 A   
.31                         0 094A A   .310                        0 409B A   
.311                        0 41D3 A   .312                        0 41CC A   
.313                        0 41E2 A   .314                        0 41DB A   
.315                        0 41F1 A   .316                        0 41EA A   
.317                        0 4200 A   .318                        0 41F9 A   
.319                        0 420F A   .31A                        0 4208 A   
.31B                        0 421E A   .31C                        0 4217 A   
.31D                        0 424D A   .31E                        0 423A A   
.31F                        0 4278 A   .32                         0 0994 A   
.320                        0 4267 A   .321                        0 4255 A   
.322                        0 4278 A   .323                        0 42CB A   
.324                        0 42C4 A   .325                        0 4490 A   
.326                        0 4489 A   .327                        0 45D8 A   
.329                        0 45C0 A   .32A                        0 44A0 A   
.32B                        0 44D6 A   .32C                        0 450C A   
.32D                        0 4542 A   .32E                        0 463B A   
.32F                        0 45E9 A   .33                         0 096E A   
.330                        0 461D A   .331                        0 45FA A   
.332                        0 463B A   .333                        0 465D A   
.334                        0 464C A   .335                        0 48DC A   
.336                        0 46B6 A   .337                        0 46AD A   
.338                        0 48DA A   .33A                        0 48C2 A   
.33B                        0 46BC A   .33C                        0 4701 A   
.33D                        0 46E3 A   .33E                        0 473A A   
.33F                        0 4778 A   .34                         0 09B4 A   
.340                        0 47CA A   .341                        0 47B1 A   
.342                        0 478B A   .343                        0 47B1 A   
.344                        0 47A4 A   .345                        0 47CA A   
.346                        0 47C3 A   .347                        0 47E2 A   
.348                        0 47D3 A   .349                        0 4800 A   
.34A                        0 47F8 A   .34B                        0 480B A   
.34C                        0 485D A   .34D                        0 4844 A   
.34E                        0 481E A   .34F                        0 4844 A   
.35                         0 09B4 A   .350                        0 4837 A   
.351                        0 485D A   .352                        0 4856 A   
.353                        0 4876 A   .354                        0 4864 A   
.355                        0 4885 A   .356                        0 4890 A   
.357                        0 48B8 A   .358                        0 48E4 A   
.359                        0 4DE0 A   .35B                        0 4D90 A   
.35C                        0 4907 A   .35D                        0 4992 A   
.35F                        0 4980 A   .36                         0 09A2 A   
.360                        0 490C A   .361                        0 4923 A   
.362                        0 493B A   .363                        0 495C A   
.364                        0 4971 A   .365                        0 4995 A   
.366                        0 49A5 A   .367                        0 49B0 A   
.368                        0 49C0 A   .369                        0 4A8A A   
.36A                        0 49C9 A   .36B                        0 4A7B A   
.36C                        0 49DF A   .36D                        0 4A88 A   
.36E                        0 4ADE A   .36F                        0 4ACA A   
.37                         0 09CE A   .370                        0 4A91 A   
.371                        0 4ADE A   .372                        0 4AE1 A   
.373                        0 4B1C A   .374                        0 4B15 A   
.375                        0 4CEE A   .376                        0 4D14 A   
.377                        0 4D0E A   .378                        0 4D1F A   
.379                        0 4D22 A   .37A                        0 4D25 A   
.37B                        0 4D35 A   .37C                        0 4D51 A   
.37D                        0 4D62 A   .37E                        0 D2C9 A   
.37F                        0 4D7F A   .38                         0 0A17 A   
.380                        0 544B A   .382                        0 5443 A   
.383                        0 4E03 A   .384                        0 5430 A   
.386                        0 540B A   .387                        0 4E09 A   
.388                        0 4F06 A   .38A                        0 4EF8 A   
.38B                        0 4E0F A   .38C                        0 4E50 A   
.38D                        0 4E25 A   .38E                        0 4E50 A   
.38F                        0 4E3F A   .39                         0 0A08 A   
.390                        0 4E38 A   .391                        0 4E65 A   
.392                        0 4E8F A   .393                        0 4E7E A   
.394                        0 4ED3 A   .395                        0 4EA5 A   
.396                        0 4ED3 A   .397                        0 4EBF A   
.398                        0 4EB8 A   .399                        0 4EE5 A   
.39A                        0 4F09 A   .39B                        0 4F09 A   
.39C                        0 4F6E A   .39D                        0 4F10 A   
.39E                        0 4F28 A   .39F                        0 4F17 A   
.3A                         0 0A0F A   .3A0                        0 500D A   
.3A1                        0 4F86 A   .3A2                        0 4FA5 A   
.3A3                        0 4F99 A   .3A4                        0 4FC0 A   
.3A5                        0 4FAC A   .3A6                        0 D29E A   
.3A7                        0 500D A   .3A8                        0 4FC7 A   
.3A9                        0 500D A   .3AA                        0 4FDA A   
.3AB                        0 500D A   .3AC                        0 4FED A   
.3AD                        0 501F A   .3AE                        0 507F A   
.3B                         0 09F7 A   .3B0                        0 505C A   
.3B1                        0 5024 A   .3B2                        0 502B A   
.3B3                        0 5032 A   .3B4                        0 5039 A   
.3B5                        0 5040 A   .3B6                        0 5047 A   
.3B7                        0 504E A   .3B8                        0 5055 A   
.3B9                        0 507D A   .3BA                        0 506F A   
.3BB                        0 50DD A   .3BC                        0 5086 A   
.3BD                        0 50CE A   .3BE                        0 5099 A   
.3BF                        0 50DB A   .3C                         0 0A08 A   
.3C0                        0 50EA A   .3C1                        0 50ED A   
.3C2                        0 5189 A   .3C3                        0 50FC A   
.3C4                        0 517A A   .3C5                        0 510F A   
.3C6                        0 5136 A   .3C7                        0 5122 A   
.3C8                        0 D272 A   .3C9                        0 516B A   
.3CA                        0 5157 A   .3CB                        0 D246 A   
.3CC                        0 5187 A   .3CD                        0 5196 A   
.3CE                        0 51A4 A   .3CF                        0 51E7 A   
.3D                         0 0A06 A   .3D0                        0 51BA A   
.3D1                        0 51F4 A   .3D2                        0 51F7 A   
.3D3                        0 536F A   .3D5                        0 535B A   
.3D6                        0 51FD A   .3D7                        0 52B1 A   
.3D8                        0 5218 A   .3D9                        0 523F A   
.3DA                        0 522B A   .3DB                        0 D21A A   
.3DC                        0 52B1 A   .3DD                        0 5248 A   
.3DE                        0 52B1 A   .3DF                        0 525D A   
.3E                         0 0A17 A   .3E0                        0 52B1 A   
.3E1                        0 5270 A   .3E2                        0 52B1 A   
.3E3                        0 5283 A   .3E4                        0 52CE A   
.3E5                        0 52CE A   .3E6                        0 52E9 A   
.3E7                        0 52DB A   .3E8                        0 52F5 A   
.3E9                        0 5315 A   .3EA                        0 52FC A   
.3EB                        0 5310 A   .3EC                        0 5312 A   
.3ED                        0 532B A   .3EE                        0 531C A   
.3EF                        0 5338 A   .3F                         0 0A5B A   
.3F0                        0 5345 A   .3F1                        0 D200 A   
.3F2                        0 5372 A   .3F3                        0 53D2 A   
.3F4                        0 53BC A   .3F5                        0 53B5 A   
.3F6                        0 53D0 A   .3F7                        0 53C5 A   
.3F8                        0 53DA A   .3F9                        0 53FC A   
.3FA                        0 542E A   .3FB                        0 541E A   
.3FC                        0 5432 A   .3FD                        0 5893 A   
.3FF                        0 5885 A   .4                          0 05CD A   
.40                         0 0A40 A   .400                        0 5544 A   
.401                        0 558A A   .402                        0 5872 A   
.404                        0 5864 A   .405                        0 5590 A   
.406                        0 55C4 A   .407                        0 55BE A   
.408                        0 565D A   .409                        0 55D9 A   
.40A                        0 55FF A   .40B                        0 55E4 A   
.40C                        0 565A A   .40D                        0 5650 A   
.40E                        0 5718 A   .40F                        0 5712 A   
.41                         0 D673 A   .410                        0 5667 A   
.411                        0 56D8 A   .412                        0 56C7 A   
.413                        0 56D0 A   .414                        0 566E A   
.415                        0 56C7 A   .416                        0 56C5 A   
.417                        0 56AD A   .418                        0 56D8 A   
.419                        0 56EB A   .41A                        0 56E0 A   
.41B                        0 5718 A   .41C                        0 573A A   
.41D                        0 577D A   .41E                        0 5777 A   
.41F                        0 57EE A   .42                         0 0DDD A   
.420                        0 57DD A   .421                        0 57E6 A   
.422                        0 5784 A   .423                        0 57DD A   
.424                        0 57DB A   .425                        0 57C3 A   
.426                        0 57EE A   .427                        0 584F A   
.428                        0 57FB A   .429                        0 584F A   
.42A                        0 5827 A   .42B                        0 585D A   
.42C                        0 5874 A   .42D                        0 597E A   
.42E                        0 58DB A   .42F                        0 5909 A   
.43                         0 0DC7 A   .430                        0 58FA A   
.431                        0 58EC A   .432                        0 5909 A   
.433                        0 597D A   .434                        0 5916 A   
.435                        0 5960 A   .436                        0 5951 A   
.437                        0 5943 A   .438                        0 5960 A   
.439                        0 5CBE A   .43B                        0 5C74 A   
.43C                        0 5988 A   .43D                        0 59AC A   
.43E                        0 599E A   .43F                        0 D1DC A   
.44                         0 0A5E A   .440                        0 59C1 A   
.441                        0 59BA A   .442                        0 59B3 A   
.443                        0 59CD A   .444                        0 59CD A   
.445                        0 59C8 A   .446                        0 59DF A   
.447                        0 5A00 A   .448                        0 59F4 A   
.449                        0 5A15 A   .44A                        0 5A0E A   
.44B                        0 5A07 A   .44C                        0 5A21 A   
.44D                        0 5A21 A   .44E                        0 5A1C A   
.44F                        0 5A3B A   .45                         0 0A73 A   
.450                        0 5A5A A   .451                        0 5A7E A   
.452                        0 5A72 A   .453                        0 5A88 A   
.454                        0 5A8B A   .455                        0 5A98 A   
.456                        0 5ADF A   .457                        0 5AC5 A   
.458                        0 5AB8 A   .459                        0 5ADF A   
.45A                        0 5AD4 A   .45B                        0 5B53 A   
.45C                        0 5AE6 A   .45D                        0 5B53 A   
.45E                        0 5AF3 A   .45F                        0 5B53 A   
.46                         0 0A65 A   .460                        0 5B48 A   
.461                        0 5AF3 A   .462                        0 5B22 A   
.463                        0 5B08 A   .464                        0 5AFB A   
.465                        0 5B22 A   .466                        0 5B17 A   
.467                        0 5B48 A   .468                        0 5B29 A   
.469                        0 5B53 A   .46A                        0 5B5C A   
.46B                        0 5B80 A   .46C                        0 5B72 A   
.46D                        0 D1B8 A   .46E                        0 5B93 A   
.46F                        0 5B8E A   .47                         0 0DC0 A   
.470                        0 5B87 A   .471                        0 5BA5 A   
.472                        0 5BC6 A   .473                        0 5BBA A   
.474                        0 5BD9 A   .475                        0 5BD4 A   
.476                        0 5BCD A   .477                        0 5BF3 A   
.478                        0 5C51 A   .479                        0 5C5E A   
.47A                        0 5C60 A   .47B                        0 5C72 A   
.47C                        0 5C67 A   .47D                        0 5C72 A   
.47E                        0 5CAD A   .47F                        0 5C87 A   
.48                         0 0DB1 A   .480                        0 5D99 A   
.481                        0 5D16 A   .482                        0 5D90 A   
.483                        0 5D69 A   .484                        0 5D7F A   
.485                        0 5D79 A   .486                        0 5D9F A   
.487                        0 5DA3 A   .488                        0 5DE9 A   
.489                        0 5DD7 A   .48A                        0 D1AD A   
.48B                        0 5E08 A   .48C                        0 5DF9 A   
.48D                        0 5DF9 A   .48E                        0 5E08 A   
.48F                        0 5E3B A   .49                         0 0A7C A   
.490                        0 5E29 A   .491                        0 D1A2 A   
.492                        0 5E96 A   .493                        0 5E84 A   
.494                        0 D198 A   .495                        0 5EB5 A   
.496                        0 5EA6 A   .497                        0 5EA6 A   
.498                        0 5EB5 A   .499                        0 5EE2 A   
.49A                        0 5ED0 A   .49B                        0 D18E A   
.49C                        0 5F3A A   .49D                        0 5F28 A   
.49E                        0 D184 A   .49F                        0 5F75 A   
.4A                         0 0AAB A   .4A0                        0 5F66 A   
.4A1                        0 5F66 A   .4A2                        0 5F75 A   
.4A3                        0 5FC2 A   .4A4                        0 5FB1 A   
.4A5                        0 D179 A   .4A6                        0 6004 A   
.4A7                        0 6000 A   .4A8                        0 660F A   
.4AA                        0 65B2 A   .4AB                        0 6042 A   
.4AC                        0 607D A   .4AD                        0 609C A   
.4AE                        0 60BB A   .4AF                        0 60DA A   
.4B                         0 0A8A A   .4B0                        0 60F9 A   
.4B1                        0 6118 A   .4B2                        0 6180 A   
.4B3                        0 6121 A   .4B4                        0 6164 A   
.4B5                        0 6146 A   .4B6                        0 6180 A   
.4B7                        0 6183 A   .4B8                        0 61EB A   
.4B9                        0 618C A   .4BA                        0 61CF A   
.4BB                        0 61B1 A   .4BC                        0 61EB A   
.4BD                        0 61EE A   .4BE                        0 6231 A   
.4BF                        0 6213 A   .4C                         0 0A83 A   
.4C0                        0 624D A   .4C1                        0 6250 A   
.4C2                        0 6293 A   .4C3                        0 6275 A   
.4C4                        0 62AF A   .4C5                        0 62B2 A   
.4C6                        0 62F3 A   .4C7                        0 62BB A   
.4C8                        0 62F6 A   .4C9                        0 631B A   
.4CA                        0 62FF A   .4CB                        0 631E A   
.4CC                        0 6359 A   .4CD                        0 6378 A   
.4CE                        0 6384 A   .4CF                        0 6381 A   
.4D                         0 0DAF A   .4D0                        0 6384 A   
.4D1                        0 6390 A   .4D2                        0 638D A   
.4D3                        0 639B A   .4D4                        0 6397 A   
.4D5                        0 63E1 A   .4D6                        0 63A4 A   
.4D7                        0 658E A   .4D8                        0 6427 A   
.4D9                        0 63EA A   .4DA                        0 658E A   
.4DB                        0 6462 A   .4DC                        0 643E A   
.4DD                        0 6430 A   .4DE                        0 6437 A   
.4DF                        0 658E A   .4E                         0 0B46 A   
.4E0                        0 64FF A   .4E1                        0 646D A   
.4E2                        0 64C2 A   .4E3                        0 648C A   
.4E4                        0 64FC A   .4E5                        0 658E A   
.4E6                        0 655A A   .4E7                        0 651E A   
.4E8                        0 658E A   .4E9                        0 659C A   
.4EA                        0 659C A   .4EB                        0 6595 A   
.4EC                        0 6620 A   .4ED                        0 6618 A   
.4EE                        0 66A6 A   .4EF                        0 66A0 A   
.4F                         0 0AD0 A   .4F0                        0 66B4 A   
.4F1                        0 66AE A   .4F2                        0 672B A   
.4F3                        0 6727 A   .4F4                        0 6764 A   
.4F5                        0 6760 A   .4F6                        0 67F1 A   
.4F7                        0 67A0 A   .4F8                        0 67EF A   
.4F9                        0 67E9 A   .4FA                        0 67F8 A   
.4FB                        0 684E A   .4FC                        0 6848 A   
.4FD                        0 6841 A   .4FE                        0 6876 A   
.4FF                        0 6870 A   .5                          0 05E2 A   
.50                         0 0AC9 A   .500                        0 769C A   
.502                        0 761E A   .503                        0 6880 A   
.504                        0 6894 A   .505                        0 68DC A   
.506                        0 68D4 A   .507                        0 68E2 A   
.508                        0 68E5 A   .509                        0 68E5 A   
.50A                        0 68E5 A   .50B                        0 6945 A   
.50C                        0 693F A   .50D                        0 6938 A   
.50E                        0 6931 A   .50F                        0 69BA A   
.51                         0 0ADD A   .510                        0 69B4 A   
.511                        0 69AC A   .512                        0 69A4 A   
.513                        0 69CC A   .514                        0 69C6 A   
.515                        0 6A88 A   .516                        0 6A16 A   
.517                        0 6A0E A   .518                        0 6AC7 A   
.519                        0 6A94 A   .51A                        0 6AF8 A   
.51B                        0 6B2B A   .51C                        0 6B1A A   
.51D                        0 6B34 A   .51E                        0 6B41 A   
.51F                        0 6C1F A   .52                         0 0AD7 A   
.520                        0 6C57 A   .521                        0 6C4F A   
.522                        0 6C68 A   .523                        0 6C6B A   
.524                        0 6D1C A   .525                        0 6D3C A   
.526                        0 6D3C A   .527                        0 6D3C A   
.528                        0 6D3C A   .529                        0 6DB6 A   
.52A                        0 6DB0 A   .52B                        0 6E1C A   
.52C                        0 6E16 A   .52D                        0 6DF2 A   
.52E                        0 6E3A A   .52F                        0 6E34 A   
.53                         0 0AEC A   .530                        0 6E28 A   
.531                        0 6E79 A   .532                        0 6E46 A   
.533                        0 6EAA A   .534                        0 6EE4 A   
.535                        0 6ED3 A   .536                        0 6EED A   
.537                        0 6EED A   .538                        0 6EF6 A   
.539                        0 6F0A A   .53A                        0 6F28 A   
.53B                        0 6F22 A   .53C                        0 7115 A   
.53D                        0 6F32 A   .53E                        0 707E A   
.53F                        0 7056 A   .54                         0 0AE4 A   
.540                        0 7006 A   .541                        0 7047 A   
.542                        0 7049 A   .544                        0 70A8 A   
.545                        0 7392 A   .546                        0 711F A   
.547                        0 71FA A   .548                        0 71F6 A   
.549                        0 71FC A   .54A                        0 7218 A   
.54B                        0 7214 A   .54C                        0 721A A   
.54D                        0 7231 A   .54E                        0 722D A   
.54F                        0 7233 A   .55                         0 0AF2 A   
.550                        0 724C A   .551                        0 7248 A   
.552                        0 724E A   .553                        0 732D A   
.554                        0 731A A   .555                        0 733E A   
.556                        0 7375 A   .557                        0 7367 A   
.558                        0 736E A   .559                        0 734A A   
.55A                        0 7375 A   .55B                        0 75D7 A   
.55C                        0 739C A   .55D                        0 7495 A   
.55E                        0 7444 A   .55F                        0 7495 A   
.56                         0 0B43 A   .560                        0 7529 A   
.561                        0 74EB A   .562                        0 7529 A   
.563                        0 75B7 A   .564                        0 75A9 A   
.565                        0 75B0 A   .566                        0 758B A   
.567                        0 75B7 A   .568                        0 75E0 A   
.569                        0 7607 A   .56B                        0 75F5 A   
.56C                        0 75E5 A   .56D                        0 75E5 A   
.56E                        0 75E5 A   .56F                        0 75E5 A   
.57                         0 0B35 A   .570                        0 75ED A   
.571                        0 760A A   .572                        0 760A A   
.573                        0 760A A   .574                        0 760A A   
.575                        0 760A A   .576                        0 7613 A   
.577                        0 7613 A   .578                        0 7613 A   
.579                        0 7613 A   .57A                        0 7613 A   
.57B                        0 7666 A   .57C                        0 7634 A   
.57D                        0 7699 A   .57E                        0 7679 A   
.57F                        0 7731 A   .58                         0 0B3C A   
.580                        0 772B A   .581                        0 7724 A   
.582                        0 7759 A   .583                        0 7753 A   
.584                        0 8161 A   .586                        0 80E3 A   
.587                        0 7763 A   .588                        0 7763 A   
.589                        0 7763 A   .58A                        0 7763 A   
.58B                        0 7763 A   .58C                        0 7763 A   
.58D                        0 7763 A   .58E                        0 7763 A   
.58F                        0 776C A   .59                         0 0AFB A   
.590                        0 776C A   .591                        0 776C A   
.592                        0 7780 A   .593                        0 77C8 A   
.594                        0 77C0 A   .595                        0 77CE A   
.596                        0 77D1 A   .597                        0 77E5 A   
.598                        0 7805 A   .599                        0 7805 A   
.59A                        0 7805 A   .59B                        0 7888 A   
.59C                        0 786C A   .59D                        0 D147 A   
.59E                        0 78BE A   .59F                        0 78B8 A   
.5A                         0 0B22 A   .5A0                        0 78AC A   
.5A1                        0 79C5 A   .5A2                        0 79B4 A   
.5A3                        0 79CE A   .5A4                        0 79DB A   
.5A5                        0 79D5 A   .5A6                        0 7AE3 A   
.5A8                        0 7AD3 A   .5A9                        0 79FE A   
.5AA                        0 7A20 A   .5AB                        0 7A05 A   
.5AC                        0 7A51 A   .5AD                        0 7A73 A   
.5AE                        0 7A58 A   .5AF                        0 7AA2 A   
.5B                         0 0B1A A   .5B0                        0 7A9E A   
.5B1                        0 7AA4 A   .5B2                        0 7AB4 A   
.5B3                        0 7ABF A   .5B4                        0 7ABB A   
.5B5                        0 7AC1 A   .5B6                        0 7AEC A   
.5B7                        0 7B21 A   .5B8                        0 7B10 A   
.5B9                        0 7B4C A   .5BA                        0 7B3B A   
.5BB                        0 7B55 A   .5BC                        0 7B73 A   
.5BD                        0 7B6D A   .5BE                        0 7C49 A   
.5BF                        0 7B7D A   .5C                         0 0B2B A   
.5C0                        0 7E4C A   .5C1                        0 7C53 A   
.5C2                        0 7D27 A   .5C3                        0 7D23 A   
.5C4                        0 7D29 A   .5C5                        0 7E2F A   
.5C6                        0 7E21 A   .5C7                        0 7E28 A   
.5C8                        0 7E04 A   .5C9                        0 7E2F A   
.5CA                        0 8091 A   .5CB                        0 7E56 A   
.5CC                        0 7F4F A   .5CD                        0 7EFE A   
.5CE                        0 7F4F A   .5CF                        0 7FE3 A   
.5D                         0 0B43 A   .5D0                        0 7FA5 A   
.5D1                        0 7FE3 A   .5D2                        0 8071 A   
.5D3                        0 8063 A   .5D4                        0 806A A   
.5D5                        0 8045 A   .5D6                        0 8071 A   
.5D7                        0 809A A   .5D8                        0 80AE A   
.5D9                        0 80D5 A   .5DB                        0 80C3 A   
.5DC                        0 80B3 A   .5DD                        0 80B3 A   
.5DE                        0 80B3 A   .5DF                        0 80B3 A   
.5E                         0 0DAA A   .5E0                        0 80BB A   
.5E1                        0 80D8 A   .5E2                        0 80D8 A   
.5E3                        0 80D8 A   .5E4                        0 80D8 A   
.5E5                        0 80D8 A   .5E6                        0 80D8 A   
.5E7                        0 80D8 A   .5E8                        0 80D8 A   
.5E9                        0 812B A   .5EA                        0 80F9 A   
.5EB                        0 815E A   .5EC                        0 813E A   
.5ED                        0 839E A   .5EF                        0 8380 A   
.5F                         0 0B62 A   .5F0                        0 81D8 A   
.5F1                        0 81D8 A   .5F2                        0 81D8 A   
.5F3                        0 D116 A   .5F4                        0 81F2 A   
.5F5                        0 8370 A   .5F6                        0 8360 A   
.5F7                        0 8377 A   .5F8                        0 8478 A   
.5F9                        0 8472 A   .5FA                        0 8459 A   
.5FB                        0 89A9 A   .5FD                        0 892E A   
.5FE                        0 8482 A   .5FF                        0 8482 A   
.6                          0 05DC A   .60                         0 0B4D A   
.600                        0 8482 A   .601                        0 8482 A   
.602                        0 8482 A   .603                        0 8482 A   
.604                        0 8482 A   .605                        0 8482 A   
.606                        0 848B A   .607                        0 848B A   
.608                        0 849F A   .609                        0 84E7 A   
.60A                        0 84DF A   .60B                        0 84ED A   
.60C                        0 84F0 A   .60D                        0 84F0 A   
.60E                        0 8585 A   .60F                        0 857F A   
.61                         0 0DAA A   .610                        0 85A3 A   
.611                        0 859D A   .612                        0 8595 A   
.613                        0 858D A   .614                        0 85B5 A   
.615                        0 85AF A   .616                        0 8812 A   
.617                        0 87F7 A   .618                        0 881B A   
.619                        0 88FA A   .61B                        0 88EE A   
.61C                        0 88C8 A   .61D                        0 88D4 A   
.61E                        0 88E0 A   .61F                        0 8910 A   
.62                         0 0CFA A   .620                        0 8924 A   
.621                        0 8924 A   .622                        0 8924 A   
.623                        0 8924 A   .624                        0 8924 A   
.625                        0 8924 A   .626                        0 8924 A   
.627                        0 8924 A   .628                        0 8924 A   
.629                        0 8924 A   .62A                        0 8924 A   
.62B                        0 8924 A   .62C                        0 8924 A   
.62D                        0 8924 A   .62E                        0 8924 A   
.62F                        0 8973 A   .63                         0 0B6B A   
.630                        0 8941 A   .631                        0 89A6 A   
.632                        0 8986 A   .633                        0 8A47 A   
.634                        0 8A3E A   .635                        0 8A32 A   
.636                        0 8A47 A   .637                        0 8A9A A   
.638                        0 8A93 A   .639                        0 8A9F A   
.63A                        0 8AE7 A   .63B                        0 8ADE A   
.63C                        0 8AD2 A   .63D                        0 8AE7 A   
.63E                        0 8B26 A   .63F                        0 8AEE A   
.64                         0 0C15 A   .640                        0 8B09 A   
.641                        0 8B00 A   .642                        0 8AEF A   
.643                        0 8B09 A   .644                        0 8B52 A   
.645                        0 8B48 A   .646                        0 8B67 A   
.647                        0 8B61 A   .648                        0 8B7B A   
.649                        0 8B74 A   .64A                        0 8BA6 A   
.64B                        0 8BA0 A   .64C                        0 8BC5 A   
.64D                        0 8BBF A   .64E                        0 8BE6 A   
.64F                        0 8BD8 A   .65                         0 0BA2 A   
.650                        0 8BEE A   .651                        0 8C08 A   
.652                        0 8BF5 A   .653                        0 8CCA A   
.654                        0 8C22 A   .655                        0 8C0F A   
.656                        0 8CCA A   .657                        0 8C3C A   
.658                        0 8C29 A   .659                        0 8CCA A   
.65A                        0 8C55 A   .65B                        0 8C43 A   
.65C                        0 8CCA A   .65D                        0 8C6E A   
.65E                        0 8C5C A   .65F                        0 8CCA A   
.66                         0 0BE9 A   .660                        0 8C87 A   
.661                        0 8C75 A   .662                        0 8CCA A   
.663                        0 8CA0 A   .664                        0 8C8E A   
.665                        0 8CCA A   .666                        0 8CBB A   
.667                        0 8CA9 A   .668                        0 8CCA A   
.669                        0 8CD9 A   .66A                        0 8CD1 A   
.66B                        0 8CDF A   .66C                        0 8D51 A   
.66D                        0 8D4A A   .66E                        0 8D37 A   
.66F                        0 8D51 A   .67                         0 0BAC A   
.670                        0 8D87 A   .671                        0 8D77 A   
.672                        0 8D95 A   .673                        0 8DE6 A   
.674                        0 8DD8 A   .675                        0 8DEE A   
.676                        0 8DFD A   .677                        0 8DF5 A   
.678                        0 8E04 A   .679                        0 9EFE A   
.67B                        0 9EBF A   .67C                        0 8E1E A   
.67D                        0 8E4B A   .67E                        0 8E2B A   
.67F                        0 8E6C A   .68                         0 0C12 A   
.680                        0 8E5E A   .681                        0 8E74 A   
.682                        0 8E9B A   .683                        0 8E7B A   
.684                        0 8EC8 A   .685                        0 8F06 A   
.686                        0 8EFE A   .687                        0 8F0A A   
.688                        0 8F0A A   .689                        0 8F0A A   
.68A                        0 8F7D A   .68B                        0 8F53 A   
.68C                        0 8F4C A   .68D                        0 8F45 A   
.68E                        0 8F3E A   .68F                        0 8F37 A   
.69                         0 0CF7 A   .690                        0 8FB6 A   
.691                        0 8F8C A   .692                        0 8FFE A   
.693                        0 8FC5 A   .694                        0 8FFE A   
.695                        0 8FD4 A   .696                        0 93BB A   
.697                        0 9007 A   .698                        0 9037 A   
.699                        0 9030 A   .69A                        0 9080 A   
.69B                        0 9056 A   .69C                        0 9227 A   
.69D                        0 9220 A   .69E                        0 91C8 A   
.69F                        0 920D A   .6A                         0 0C48 A   
.6A0                        0 91E0 A   .6A1                        0 9227 A   
.6A2                        0 927D A   .6A3                        0 926F A   
.6A4                        0 D0F6 A   .6A5                        0 9390 A   
.6A6                        0 9366 A   .6A7                        0 9792 A   
.6A8                        0 976A A   .6A9                        0 93C4 A   
.6AA                        0 93F4 A   .6AB                        0 93ED A   
.6AC                        0 943D A   .6AD                        0 9413 A   
.6AE                        0 95D6 A   .6AF                        0 95CF A   
.6B                         0 0C1C A   .6B0                        0 9577 A   
.6B1                        0 95BC A   .6B2                        0 958F A   
.6B3                        0 95D6 A   .6B4                        0 962C A   
.6B5                        0 961E A   .6B6                        0 D0D6 A   
.6B7                        0 9740 A   .6B8                        0 9715 A   
.6B9                        0 9732 A   .6BA                        0 971E A   
.6BB                        0 9740 A   .6BC                        0 D0B1 A   
.6BD                        0 9792 A   .6BE                        0 9795 A   
.6BF                        0 97F4 A   .6C                         0 0CF7 A   
.6C0                        0 97D8 A   .6C1                        0 97D1 A   
.6C2                        0 97CA A   .6C3                        0 97C3 A   
.6C4                        0 97BC A   .6C5                        0 9823 A   
.6C6                        0 9803 A   .6C7                        0 986B A   
.6C8                        0 9832 A   .6C9                        0 986B A   
.6CA                        0 9841 A   .6CB                        0 989B A   
.6CC                        0 9894 A   .6CD                        0 98E3 A   
.6CE                        0 98B9 A   .6CF                        0 9A3B A   
.6D                         0 0CF7 A   .6D0                        0 9A34 A   
.6D1                        0 99E6 A   .6D2                        0 9A21 A   
.6D3                        0 99FE A   .6D4                        0 9A3B A   
.6D5                        0 9A91 A   .6D6                        0 9A83 A   
.6D7                        0 D091 A   .6D8                        0 9BA5 A   
.6D9                        0 9B7A A   .6DA                        0 9B97 A   
.6DB                        0 9B83 A   .6DC                        0 9BA5 A   
.6DD                        0 D06B A   .6DE                        0 9BD2 A   
.6DF                        0 9C14 A   .6E                         0 0C58 A   
.6E0                        0 9BDF A   .6E1                        0 9C35 A   
.6E2                        0 9C2E A   .6E3                        0 9C45 A   
.6E4                        0 9C3E A   .6E5                        0 9C5C A   
.6E6                        0 9C4E A   .6E7                        0 9C64 A   
.6E8                        0 9D81 A   .6EA                        0 9D5A A   
.6EB                        0 9C9E A   .6EC                        0 9CB0 A   
.6ED                        0 9CC4 A   .6EE                        0 9CD8 A   
.6EF                        0 9CEC A   .6F                         0 0C4F A   
.6F0                        0 9D00 A   .6F1                        0 9D13 A   
.6F2                        0 9D25 A   .6F3                        0 9D37 A   
.6F4                        0 9D4A A   .6F5                        0 D04B A   
.6F6                        0 9D7F A   .6F7                        0 9D6D A   
.6F8                        0 9D9A A   .6F9                        0 9DBD A   
.6FA                        0 9DA7 A   .6FB                        0 9DDE A   
.6FC                        0 9DD0 A   .6FD                        0 9DE6 A   
.6FE                        0 9E01 A   .6FF                        0 9DF5 A   
.7                          0 05ED A   .70                         0 0C65 A   
.700                        0 9E0C A   .701                        0 9E10 A   
.702                        0 9E3D A   .703                        0 9E1D A   
.704                        0 9E5D A   .705                        0 9E7D A   
.706                        0 9E9D A   .707                        0 9EE4 A   
.708                        0 9ED2 A   .709                        0 9F31 A   
.70A                        0 9F24 A   .70B                        0 D024 A   
.70C                        0 A078 A   .70D                        0 9F85 A   
.70E                        0 9F7C A   .70F                        0 9F72 A   
.71                         0 0C5F A   .710                        0 A00C A   
.711                        0 9FA6 A   .712                        0 A00C A   
.713                        0 9FF5 A   .714                        0 9FEE A   
.715                        0 A00C A   .716                        0 A005 A   
.717                        0 A04A A   .718                        0 A013 A   
.719                        0 A06E A   .71A                        0 A066 A   
.71B                        0 A080 A   .71C                        0 A121 A   
.71D                        0 A0F7 A   .71E                        0 A15D A   
.71F                        0 A15D A   .72                         0 0C74 A   
.720                        0 A128 A   .721                        0 D00E A   
.722                        0 CFF1 A   .723                        0 CFF0 A   
.724                        0 A179 A   .725                        0 A175 A   
.726                        0 A2D4 A   .728                        0 A2B8 A   
.729                        0 A18E A   .72A                        0 A18E A   
.72B                        0 A19A A   .72C                        0 A196 A   
.72D                        0 A19C A   .72E                        0 A1EC A   
.72F                        0 A1DB A   .73                         0 0C6C A   
.730                        0 A225 A   .731                        0 A203 A   
.732                        0 A1F4 A   .733                        0 A225 A   
.734                        0 A215 A   .735                        0 A23E A   
.736                        0 A264 A   .737                        0 A24B A   
.738                        0 A296 A   .739                        0 A2B2 A   
.73A                        0 A634 A   .73C                        0 A60B A   
.73D                        0 A302 A   .73E                        0 A326 A   
.73F                        0 A349 A   .74                         0 0C7A A   
.740                        0 A35B A   .741                        0 A350 A   
.742                        0 A3A2 A   .743                        0 A3AC A   
.744                        0 A3A9 A   .745                        0 A41C A   
.746                        0 A433 A   .747                        0 A428 A   
.748                        0 A474 A   .749                        0 A489 A   
.74A                        0 A47B A   .74B                        0 A4FD A   
.74C                        0 A522 A   .74D                        0 A517 A   
.74E                        0 A52C A   .74F                        0 A529 A   
.75                         0 0CF7 A   .750                        0 A593 A   
.751                        0 A5C6 A   .752                        0 A5CF A   
.753                        0 A5CD A   .754                        0 A5F1 A   
.755                        0 A5D8 A   .756                        0 A5D6 A   
.757                        0 A5F1 A   .758                        0 A5E1 A   
.759                        0 A5DF A   .75A                        0 A5F1 A   
.75B                        0 A5F1 A   .75C                        0 A5E8 A   
.75D                        0 A5F1 A   .75E                        0 A5EF A   
.75F                        0 A5F1 A   .76                         0 0CE9 A   
.760                        0 A601 A   .761                        0 A62E A   
.762                        0 A61E A   .763                        0 A759 A   
.764                        0 A66A A   .765                        0 A677 A   
.766                        0 A673 A   .767                        0 A759 A   
.768                        0 A682 A   .769                        0 A759 A   
.76A                        0 A696 A   .76B                        0 A726 A   
.76C                        0 A6BC A   .76D                        0 A756 A   
.76E                        0 B128 A   .77                         0 0CF0 A   
.770                        0 B120 A   .771                        0 B064 A   
.772                        0 B090 A   .773                        0 B084 A   
.774                        0 B06B A   .775                        0 B112 A   
.777                        0 B0ED A   .778                        0 B095 A   
.779                        0 B095 A   .77A                        0 B095 A   
.77B                        0 B095 A   .77C                        0 B095 A   
.77D                        0 B095 A   .77E                        0 B095 A   
.77F                        0 B095 A   .78                         0 0C83 A   
.780                        0 B0E3 A   .781                        0 B110 A   
.782                        0 B100 A   .783                        0 B114 A   
.784                        0 CFF0 A   .785                        0 CFF1 A   
.786                        0 D00E A   .787                        0 D024 A   
.788                        0 D04B A   .789                        0 D06B A   
.78A                        0 D091 A   .78B                        0 D0B1 A   
.78C                        0 D0D6 A   .78D                        0 D0F6 A   
.78E                        0 D116 A   .78F                        0 D147 A   
.79                         0 0CD6 A   .790                        0 D179 A   
.791                        0 D184 A   .792                        0 D18E A   
.793                        0 D198 A   .794                        0 D1A2 A   
.795                        0 D1AD A   .796                        0 D1B8 A   
.797                        0 D1DC A   .798                        0 D200 A   
.799                        0 D21A A   .79A                        0 D246 A   
.79B                        0 D272 A   .79C                        0 D29E A   
.79D                        0 D2C9 A   .79E                        0 D2E0 A   
.79F                        0 D2F6 A   .7A                         0 0CCE A   
.7A0                        0 D312 A   .7A1                        0 D33A A   
.7A2                        0 D360 A   .7A3                        0 D362 A   
.7A4                        0 D369 A   .7A5                        0 D370 A   
.7A6                        0 D38A A   .7A7                        0 D39C A   
.7A8                        0 D3B6 A   .7A9                        0 D3B9 A   
.7AA                        0 D3C0 A   .7AB                        0 D3C7 A   
.7AC                        0 D3D2 A   .7AD                        0 D3F2 A   
.7AE                        0 D412 A   .7AF                        0 D415 A   
.7B                         0 0CDF A   .7B0                        0 D41C A   
.7B1                        0 D423 A   .7B2                        0 D42E A   
.7B3                        0 D459 A   .7B4                        0 D482 A   
.7B5                        0 D497 A   .7B6                        0 D4AB A   
.7B7                        0 D4CB A   .7B8                        0 D4CE A   
.7B9                        0 D4ED A   .7BA                        0 D503 A   
.7BB                        0 D517 A   .7BC                        0 D527 A   
.7BD                        0 D52C A   .7BE                        0 D532 A   
.7BF                        0 D542 A   .7C                         0 0CF7 A   
.7C0                        0 D552 A   .7C1                        0 D554 A   
.7C2                        0 D556 A   .7C3                        0 D55C A   
.7C4                        0 D55F A   .7C5                        0 D563 A   
.7C6                        0 D568 A   .7C7                        0 D57E A   
.7C8                        0 D59B A   .7C9                        0 D5BB A   
.7CA                        0 D5C4 A   .7CB                        0 D5E8 A   
.7CC                        0 D602 A   .7CD                        0 D627 A   
.7CE                        0 D643 A   .7CF                        0 D656 A   
.7D                         0 0DAA A   .7D0                        0 D673 A   
.7E                         0 0D39 A   .7F                         0 0D01 A   
.8                          0 06F1 A   .80                         0 0D25 A   
.81                         0 0D0B A   .82                         0 0D37 A   
.83                         0 0DAA A   .84                         0 0D52 A   
.85                         0 0D40 A   .86                         0 0DAA A   
.87                         0 0D87 A   .88                         0 0D59 A   
.89                         0 0DAA A   .8A                         0 0D9C A   
.8B                         0 0D8E A   .8C                         0 0DAA A   
.8D                         0 D656 A   .8E                         0 0DC0 A   
.8F                         0 0DDD A   .9                          0 06E2 A   
.90                         0 0DEA A   .91                         0 0DE6 A   
.92                         0 0E22 A   .93                         0 0E08 A   
.94                         0 0DFB A   .95                         0 0E22 A   
.96                         0 0E17 A   .97                         0 0E60 A   
.98                         0 0E55 A   .99                         0 0E2A A   
.9A                         0 0E55 A   .9B                         0 0E46 A   
.9C                         0 0E60 A   .9D                         0 0E9D A   
.9E                         0 0E83 A   .9F                         0 0E76 A   
.A                          0 0709 A   .A0                         0 0E9D A   
.A1                         0 0E92 A   .A2                         0 0EAC A   
.A3                         0 0EA4 A   .A4                         0 0EDC A   
.A5                         0 0EC2 A   .A6                         0 0EB4 A   
.A7                         0 0EDC A   .A8                         0 0ED1 A   
.A9                         0 0EEC A   .AA                         0 0EE3 A   
.AB                         0 0F02 A   .AC                         0 0EF9 A   
.AD                         0 0F40 A   .AE                         0 0F26 A   
.AF                         0 0F18 A   .B                          0 06FA A   
.B0                         0 0F40 A   .B1                         0 0F35 A   
.B2                         0 0F50 A   .B3                         0 0F47 A   
.B4                         0 0F80 A   .B5                         0 0F66 A   
.B6                         0 0F58 A   .B7                         0 0F80 A   
.B8                         0 0F75 A   .B9                         0 0F90 A   
.BA                         0 0F87 A   .BB                         0 0FA6 A   
.BC                         0 0F9D A   .BD                         0 1000 A   
.BE                         0 0FE6 A   .BF                         0 0FD8 A   
.C                          0 072D A   .C0                         0 1000 A   
.C1                         0 0FF5 A   .C2                         0 1010 A   
.C3                         0 1007 A   .C4                         0 1040 A   
.C5                         0 1026 A   .C6                         0 1018 A   
.C7                         0 1040 A   .C8                         0 1035 A   
.C9                         0 1050 A   .CA                         0 1047 A   
.CB                         0 1066 A   .CC                         0 105D A   
.CD                         0 1096 A   .CE                         0 107C A   
.CF                         0 106E A   .D                          0 0712 A   
.D0                         0 1096 A   .D1                         0 108B A   
.D2                         0 10A6 A   .D3                         0 109D A   
.D4                         0 10BC A   .D5                         0 10B3 A   
.D6                         0 10FA A   .D7                         0 10E0 A   
.D8                         0 10D2 A   .D9                         0 10FA A   
.DA                         0 10EF A   .DB                         0 110A A   
.DC                         0 1101 A   .DD                         0 113A A   
.DE                         0 1120 A   .DF                         0 1112 A   
.E                          0 0722 A   .E0                         0 113A A   
.E1                         0 112F A   .E2                         0 114A A   
.E3                         0 1141 A   .E4                         0 1160 A   
.E5                         0 1157 A   .E6                         0 119E A   
.E7                         0 1184 A   .E8                         0 1176 A   
.E9                         0 119E A   .EA                         0 1193 A   
.EB                         0 11AE A   .EC                         0 11A5 A   
.ED                         0 11EC A   .EE                         0 11D2 A   
.EF                         0 11C4 A   .F                          0 0719 A   
.F0                         0 11EC A   .F1                         0 11E1 A   
.F2                         0 11FC A   .F3                         0 11F3 A   
.F4                         0 123A A   .F5                         0 1220 A   
.F6                         0 1212 A   .F7                         0 123A A   
.F8                         0 122F A   .F9                         0 124A A   
.FA                         0 1241 A   .FB                         0 127A A   
.FC                         0 1260 A   .FD                         0 1252 A   
.FE                         0 127A A   .FF                         0 126F A   
.FFDD                       0 89E0 A   .FFDE                       0 89CA A   
.FFDF                       0 89B4 A   .FFE0                       0 89D6 A   
.FFE2                       0 89A9 A   .FFE3                       0 83CB A   
.FFE4                       0 839E A   .FFE6                       0 819B A   
.FFE7                       0 8185 A   .FFE8                       0 816F A   
.FFE9                       0 8191 A   .FFEB                       0 8164 A   
.FFEC                       0 76AA A   .FFED                       0 76D6 A   
.FFEE                       0 76C0 A   .FFEF                       0 76CC A   
.FFF1                       0 769F A   .FFF4                       0 5874 A   
.FFFA                       0 3C41 A   BcdToBin                    0 AB61 A   
Upcall                      0 AF04 A   _TCGInterruptHandler        0 AF9D A   
_apm16_entry                0 AD0F A   _apm32_entry                0 AC26 A   
_apmreal_entry              0 ADDC A   _ata_cmd_data_in            0 2E27 A E 
_ata_cmd_data_out           0 31F8 A E _ata_cmd_non_data           0 2E20 A E 
_ata_cmd_packet             0 35CB A E _ata_detect                 0 1E0F A E 
_ata_init                   0 19DE A E _ata_reset                  0 2CD3 A E 
_atapi_get_sense            0 3A7B A E _atapi_is_cdrom             0 3DE8 A E 
_atapi_is_ready             0 3B00 A E _await_ide                  0 1CB8 A   
_bios_cvs_version_string    0 0194 A   _bios_printf                0 0A1B A E 
_cdemu_emulated_drive       0 3EAB A E _cdemu_init                 0 3E5A A E 
_cdemu_isactive             0 3E84 A E _cdrom_boot                 0 3EF0 A E 
_check_for_keystroke        0 09D4 A E _clobber_entry_point        0 130D A E 
_debugger_off               0 1940 A E _debugger_on                0 192E A E 
_delay_ticks                0 0922 A E _delay_ticks_and_check_for+ 0 09EA A E 
_dequeue_key                0 5CC2 A E _determine_floppy_media     0 9F4B A E 
_disable_rom_write_access   0 06A5 A E _drivetypes                 0 1374 A   
_eltorito                   0 3ED8 A   _enable_mouse_int_and_even+ 0 5E70 A E 
_enable_rom_write_access    0 0694 A E _enqueue_key                0 6640 A E 
_fixup_base_mem_in_k        0 0650 A E _floppy_drive_exists        0 8DC0 A E 
_floppy_drive_recal         0 8D0D A E _floppy_media_known         0 8B2A A E 
_floppy_media_sense         0 8BAD A E _floppy_prepare_controller  0 8A4B A E 
_floppy_reset_controller    0 89FD A E _get_CS                     0 064A A E 
_get_SS                     0 064D A E _get_boot_vector            0 1503 A   
_get_keystroke              0 09E2 A E _get_mouse_data             0 5F5E A E 
_get_s3_waking_vector       0 AFEB A   _inb                        0 053E A E 
_inb_cmos                   0 0583 A E _inhibit_mouse_int_and_eve+ 0 5DC3 A E 
_init_boot_vectors          0 13A6 A   _init_rtc                   0 058F A E 
_int09_function             0 5FED A E _int13_cdemu                0 83F2 A E 
_int13_cdrom                0 76F3 A E _int13_diskette_function    0 8E08 A E 
_int13_eltorito             0 81B8 A E _int13_harddisk             0 680F A E 
_int14_function             0 4675 A E _int15_function             0 48E8 A E 
_int15_function32           0 552B A E _int15_function_mouse       0 4DE4 A E 
_int16_function             0 5897 A E _int17_function             0 9F4C A E 
_int18_function             0 A084 A E _int18_panic_msg            0 18C4 A E 
_int1a_function             0 A2F6 A E _int1a_function32           0 B059 A E 
_int70_function             0 A638 A E _int74_function             0 66F4 A E 
_interactive_bootkey        0 1564 A E _inw                        0 0549 A E 
_isotag                     0 3ED2 A   _keyboard_init              0 0DEE A E 
_keyboard_panic             0 12B2 A E _log_bios_start             0 18D6 A E 
_machine_reset              0 12C7 A E _memcpyb                    0 0024 A E 
_memcpyd                    0 0053 A E _memsetb                    0 0000 A E 
_nmi_handler_msg            0 18B2 A E _outb                       0 0554 A E 
_outb_cmos                  0 0574 A E _outw                       0 0564 A E 
_panic_msg_keyb_buffer_ful+ 0 5DA3 A   _pmm                        0 AFF1 A   
_print_bios_banner          0 134D A E _print_boot_device          0 175C A E 
_print_boot_failure         0 1825 A E _print_cdromboot_failure    0 189D A E 
_put_int                    0 072F A E _put_luint                  0 0837 A E 
_put_str                    0 08EE A E _put_uint                   0 07B4 A E 
_read_byte                  0 05F4 A E _read_dword                 0 0083 A E 
_read_word                  0 0607 A E _rtc_updating               0 05C0 A E 
_s3_resume                  0 1951 A E _s3_resume_panic            0 133B A E 
_scan_to_scanascii          0 01C4 A   _send                       0 06C7 A E 
_send_to_mouse_ctrl         0 5F14 A E _set_diskette_current_cyl   0 9F1A A E 
_set_diskette_ret_status    0 9F02 A E _set_e820_range             0 544F A E 
_set_enable_a20             0 18DB A E _set_kbd_command_byte       0 5F9F A E 
_shutdown_status_panic      0 1323 A E _tcpa_acpi_init             0 AFA3 A   
_tcpa_add_bootdevice        0 AFC7 A   _tcpa_add_event_separators  0 AFBB A   
_tcpa_calling_int19h        0 AFAF A   _tcpa_do_measure_POSTs      0 AFF7 A E 
_tcpa_extend_acpi_log       0 AFA9 A   _tcpa_initialize_tpm        0 AFE5 A   
_tcpa_ipl                   0 AFD9 A   _tcpa_measure_post          0 AFDF A   
_tcpa_option_rom            0 AFD3 A   _tcpa_returned_int19h       0 AFB5 A   
_tcpa_start_option_rom_sca+ 0 AFCD A   _tcpa_wake_event            0 AFC1 A   
_vgafont8                   0 FA6E A   _wrch                       0 06B7 A E 
_write_byte                 0 061A A E _write_dword                0 009B A E 
_write_word                 0 0632 A E apm16_04                    0 AD10 A   
apm16_05                    0 AD17 A   apm16_07                    0 AD22 A   
apm16_07_1                  0 AD46 A   apm16_07_poweroff           0 AD3C A   
apm16_07_poweroff_str       0 ACF6 A   apm16_07_standby            0 AD58 A   
apm16_07_standby_str        0 AD07 A   apm16_07_suspend            0 AD49 A   
apm16_07_suspend_str        0 ACFF A   apm16_08                    0 AD67 A   
apm16_0a                    0 AD6D A   apm16_0b                    0 AD81 A   
apm16_0e                    0 AD89 A   apm16_0f                    0 AD93 A   
apm16_10                    0 AD99 A   apm16_error                 0 ADA7 A   
apm16_ok                    0 ADA4 A   apm16_out_str               0 ACDE A   
apm16_out_str1              0 ACE5 A   apm16_out_str2              0 ACF1 A   
apm16_unimplemented         0 ADA7 A   apm32_04                    0 AC28 A   
apm32_05                    0 AC31 A   apm32_07                    0 AC40 A   
apm32_07_1                  0 AC71 A   apm32_07_poweroff           0 AC63 A   
apm32_07_poweroff_str       0 AC0D A   apm32_07_standby            0 AC85 A   
apm32_07_standby_str        0 AC1E A   apm32_07_suspend            0 AC74 A   
apm32_07_suspend_str        0 AC16 A   apm32_08                    0 AC96 A   
apm32_0a                    0 AC9C A   apm32_0b                    0 ACB2 A   
apm32_0e                    0 ACBA A   apm32_0f                    0 ACC4 A   
apm32_10                    0 ACCA A   apm32_error                 0 ACDA A   
apm32_ok                    0 ACD6 A   apm32_out_str               0 ABFA A   
apm32_out_str1              0 ABFE A   apm32_out_str2              0 AC0A A   
apm32_unimplemented         0 ACDA A   apm_call                    0 F87B A   
apmreal_00                  0 ADDC A   apmreal_01                  0 ADEE A   
apmreal_02                  0 ADF5 A   apmreal_03                  0 AE0B A   
apmreal_04                  0 AE2A A   apmreal_05                  0 AE31 A   
apmreal_07                  0 AE3C A   apmreal_07_1                0 AE60 A   
apmreal_07_poweroff         0 AE56 A   apmreal_07_poweroff_str     0 ADC2 A   
apmreal_07_standby          0 AE72 A   apmreal_07_standby_str      0 ADD3 A   
apmreal_07_suspend          0 AE63 A   apmreal_07_suspend_str      0 ADCB A   
apmreal_08                  0 AE81 A   apmreal_0a                  0 AE87 A   
apmreal_0b                  0 AE9B A   apmreal_0e                  0 AEA3 A   
apmreal_0f                  0 AEAD A   apmreal_10                  0 AEB3 A   
apmreal_error               0 AEC3 A   apmreal_ok                  0 AEBE A   
apmreal_out_str             0 ADAA A   apmreal_out_str1            0 ADB1 A   
apmreal_out_str2            0 ADBD A   apmreal_unimplemented       0 AEC3 A   
ata_in_16                   0 316E A   ata_in_32                   0 3172 A   
ata_in_adjust               0 315A A   ata_in_done                 0 3175 A   
ata_in_no_adjust            0 3161 A   ata_out_16                  0 353F A   
ata_out_32                  0 3544 A   ata_out_adjust              0 352B A   
ata_out_done                0 3548 A   ata_out_no_adjust           0 3532 A   
ata_packet_after            0 3A06 A   ata_packet_done             0 3A20 A   
ata_packet_in_16            0 39FF A   ata_packet_in_32            0 3A03 A   
ata_packet_in_after_16      0 3A13 A   ata_packet_in_after_32      0 3A18 A   
ata_packet_in_after_32_loo+ 0 3A1A A   ata_packet_in_before_16     0 39DD A   
ata_packet_in_before_32     0 39E2 A   ata_packet_in_before_32_lo+ 0 39E4 A   
ata_packet_no_before        0 39EA A   bios32_end                  0 B173 A   
bios32_entry_point          0 B140 A   bios32_structure            0 B130 A   
bios_table_area_end         0 CFF0 A   bios_table_area_start       0 B720 A   
block_count_rounded         0 B5E9 A   carry_set                   0 A794 A   
check_for_hd1               0 AA1C A   checksum_loop               0 B597 A   
checksum_out                0 B5B1 A   detect_parport              0 B53C A   
detect_serial               0 B55B A   diskette_param_table        0 EFC7 A   
diskette_param_table2       0 EFDE A   done                        0 09E1 A   
dummy_iret_handler          0 FF53 A   ebda_post                   0 AB0A A   
eoi_both_pics               0 AB58 A   eoi_jmp_post                0 AB1F A   
eoi_master_pic              0 AB5C A   f0_missing                  0 A896 A   
f1_missing                  0 A8A1 A   fetch_bdf                   0 B602 A   
floppy_drive_post           0 A85B A   gdt_base                    0 AED0 A   
gdt_entry_end               0 AEF8 A   gdt_entry_pm_16bit_cs       0 AEE0 A   
gdt_entry_pm_16bit_ds       0 AEF0 A   gdt_entry_pm_32bit_cs       0 AED8 A   
gdt_entry_pm_32bit_ds       0 AEE8 A   halt2_loop                  0 0DE7 A   
hard_drive_post             0 A8E2 A   hd0_post_above_2048         0 A9DE A   
hd0_post_above_4096         0 A9EC A   hd0_post_above_8192         0 A9FA A   
hd0_post_checksum_loop      0 AA0F A   hd0_post_logical_chs        0 A9BD A   
hd0_post_physical_chs       0 A9AF A   hd0_post_store_logical      0 AA00 A   
hd1_post_above_2048         0 AACB A   hd1_post_above_4096         0 AAD9 A   
hd1_post_above_8192         0 AAE7 A   hd1_post_checksum_loop      0 AAFC A   
hd1_post_logical_chs        0 AAAA A   hd1_post_physical_chs       0 AA9D A   
hd1_post_store_logical      0 AAED A   idiv_                       0 0165 A   
idiv_u                      0 0169 A   int08_floppy_off            0 FEC4 A   
int08_handler               0 FEA5 A   int08_store_ticks           0 FED9 A   
int09_check_pause           0 E9B5 A   int09_done                  0 E9CF A   
int09_finish                0 E9D5 A   int09_handler               0 E987 A   
int09_process_key           0 E9C7 A   int0e_handler               0 EF57 A   
int0e_loop1                 0 EF69 A   int0e_loop2                 0 EF73 A   
int0e_normal                0 EF81 A   int10_handler               0 F065 A   
int11_handler               0 F84D A   int12_handler               0 F841 A   
int13_cdemu_inactive        0 A7E8 A   int13_cdrom_rme_end         0 7B33 A   
int13_disk                  0 A817 A   int13_diskette              0 EC59 A   
int13_handler               0 E3FE A   int13_legacy                0 A7F0 A   
int13_nocdemu               0 A7D5 A   int13_noeltorito            0 A7EC A   
int13_not_eltorito          0 A7B2 A   int13_notcdrom              0 A817 A   
int13_notfloppy             0 A803 A   int13_out                   0 A824 A   
int13_relocated             0 A79D A   int14_handler               0 E739 A   
int1586_tick                0 5579 A   int1586_tick_end            0 5587 A   
int15_handler               0 F859 A   int15_handler32             0 F883 A   
int15_handler32_ret         0 F875 A   int15_handler_mouse         0 F87E A   
int15_handler_mouse_ret     0 F874 A   int16_F00                   0 E85B A   
int16_handler               0 E82E A   int16_key_found             0 E86F A   
int16_wait_for_key          0 E860 A   int16_zero_clear            0 E849 A   
int16_zero_set              0 E852 A   int17_handler               0 EFD2 A   
int18_handler               0 A828 A   int19_handler               0 E6F2 A   
int19_load_done             0 A1CF A   int19_relocated             0 A84D A   
int1a_callfunction          0 FE8D A   int1a_handler               0 FE6E A   
int1a_normal                0 FE87 A   int1c_handler               0 A85A A   
int70_handler               0 FE93 A   int74_done                  0 A77F A   
int74_handler               0 A760 A   int75_handler               0 E2C7 A   
int76_handler               0 ABE7 A   iret_modify_cf              0 A789 A   
iret_post_0x467             0 AB2F A   jmp_post_0x467              0 AB27 A   
laddl                       0 00C3 A   laddul                      0 00C3 A   
landl                       0 00BB A   landul                      0 00BB A   
lcmpl                       0 00CB A   lcmpul                      0 00CB A   
ldecl                       0 0102 A   ldecul                      0 0102 A   
ldivul                      0 016E A   lincl                       0 010F A   
lincul                      0 010F A   lmull                       0 00E9 A   
lmulul                      0 00E9 A   look_drive0                 0 A88D A   
look_drive1                 0 A898 A   lorl                        0 0107 A   
lorul                       0 0107 A   lsl_exit                    0 0164 A   
lsl_loop                    0 0158 A   lsll                        0 0147 A   
lslul                       0 0147 A   lsr_exit                    0 0146 A   
lsr_loop                    0 013A A   lsrul                       0 0129 A   
lsubl                       0 00E1 A   lsubul                      0 00E1 A   
ltstl                       0 0114 A   ltstul                      0 0114 A   
memcpyb_end                 0 004B A   memcpyd_end                 0 007B A   
memsetb_end                 0 001E A   nmi                         0 E2C3 A   
no_bcv                      0 B654 A   no_bev                      0 B696 A   
no_key                      0 09DF A   no_parport                  0 B55A A   
no_prod_str                 0 B68E A   no_serial                   0 B57E A   
normal_post                 0 E0A7 A   pci_present                 0 B2FD A   
pci_pro_devloop             0 B1AD A   pci_pro_devloop2            0 B1E3 A   
pci_pro_f02                 0 B19C A   pci_pro_f03                 0 B1D8 A   
pci_pro_f08                 0 B211 A   pci_pro_f09                 0 B230 A   
pci_pro_f0a                 0 B24E A   pci_pro_f0b                 0 B262 A   
pci_pro_f0c                 0 B27E A   pci_pro_f0d                 0 B29C A   
pci_pro_fail                0 B2B2 A   pci_pro_nextdev             0 B1C8 A   
pci_pro_nextdev2            0 B201 A   pci_pro_ok                  0 B2B7 A   
pci_pro_select_reg          0 B2BE A   pci_pro_unknown             0 B2B0 A   
pci_real_devloop            0 B331 A   pci_real_devloop2           0 B363 A   
pci_real_f02                0 B31E A   pci_real_f03                0 B35A A   
pci_real_f08                0 B390 A   pci_real_f09                0 B3A8 A   
pci_real_f0a                0 B3C0 A   pci_real_f0b                0 B3D4 A   
pci_real_f0c                0 B3EB A   pci_real_f0d                0 B402 A   
pci_real_f0e                0 B415 A   pci_real_fail               0 B455 A   
pci_real_nextdev            0 B347 A   pci_real_nextdev2           0 B37D A   
pci_real_ok                 0 B45B A   pci_real_select_reg         0 B463 A   
pci_real_too_small          0 B44A A   pci_real_unknown            0 B453 A   
pci_routing_table_structur+ 0 B480 A   pci_routing_table_structur+ 0 B500 A   
pci_routing_table_structur+ 0 B4A0 A   pcibios_error               0 FE7B A   
pcibios_protected           0 B180 A   pcibios_real                0 B2DB A   
pmm_entry_point             0 B510 A   pmm_structure               0 B500 A   
pmode_IDT_info              0 F88C A   pnp_string                  0 B5C1 A   
post                        0 E05B A   post_d0_extended            0 A944 A   
post_d0_type47              0 A955 A   post_d1_exists              0 AA27 A   
post_d1_extended            0 AA32 A   post_d1_type47              0 AA43 A   
post_default_ints           0 E0D7 A   post_init_pic               0 B6CD A   
protected_mode              0 4C97 A   protmode_gdtdesc            0 AEF8 A   
real_mode                   0 4CC1 A   realmode_gdtdesc            0 AEFE A   
retf_post_0x467             0 AB3C A   rmode_IDT_info              0 F891 A   
rom_checksum                0 B580 A   rom_scan                    0 B5C5 A   
rom_scan_increment          0 B698 A   rom_scan_loop               0 B5C5 A   
s3_post                     0 AB49 A   smbios_entry_point          0 B700 A   
smbios_init                 0 B6AA A   timer_tick_post             0 AB70 A   
unknown_service             0 B171 A   upcall1                     0 AF34 A   
upcall2                     0 AF43 A   upcall3                     0 AF6B A   
upcall4                     0 AF81 A   

00000 errors
00000 warnings
