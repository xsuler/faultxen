! 1 
! 1 # 1 "_rombios_.c"
! 1 struct rombios_info {
! 2     unsigned long bios32_entry;
!BCC_EOS
! 3 };
!BCC_EOS
! 4 #asm
!BCC_ASM
.rom
.org 0x0000
use16 386
MACRO HALT
  ;; the HALT macro is called with the line number of the HALT call.
  ;; The line number is then sent to the 0x400, causing Bochs/Plex
  ;; to print a BX_PANIC message. This will normally halt the simulation
  ;; with a message such as "BIOS panic at rombios.c, line 4091".
  ;; However, users can choose to make panics non-fatal and continue.
  mov dx,#0x400
  mov ax,#?1
  out dx,ax
MEND
MACRO JMP_AP
  db 0xea
  dw ?2
  dw ?1
MEND
MACRO SET_INT_VECTOR
  mov ax, ?3
  mov ?1*4, ax
  mov ax, ?2
  mov ?1*4+2, ax
MEND
! 29 endasm
!BCC_ENDASM
! 30 typedef unsigned char Bit8u;
!BCC_EOS
! 31 typedef unsigned short Bit16u;
!BCC_EOS
! 32 typedef unsigned short bx_bool;
!BCC_EOS
! 33 typedef unsigned long Bit32u;
!BCC_EOS
! 34   void memsetb(seg,offset,value,count);
!BCC_EOS
! 35   void memcpyb(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 36   void memcpyd(dseg,doffset,sseg,soffset,count);
!BCC_EOS
! 37     void
! 38   memsetb(seg,offset,value,count)
! 39     Bit16u seg;
export	_memsetb
_memsetb:
!BCC_EOS
! 40     Bit16u offset;
!BCC_EOS
! 41     Bit16u value;
!BCC_EOS
! 42     Bit16u count;
!BCC_EOS
! 43   {
! 44 #asm
!BCC_ASM
_memsetb.count	set	8
_memsetb.seg	set	2
_memsetb.value	set	6
_memsetb.offset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      mov cx, 10[bp] ; count
      test cx, cx
      je memsetb_end
      mov ax, 4[bp] ; segment
      mov es, ax
      mov ax, 6[bp] ; offset
      mov di, ax
      mov al, 8[bp] ; value
      cld
      rep
       stosb
  memsetb_end:
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 68 endasm
!BCC_ENDASM
! 69   }
ret
! 70     void
! 71   memcpyb(dseg,doffset,sseg,soffset,count)
! 72     Bit16u dseg;
export	_memcpyb
_memcpyb:
!BCC_EOS
! 73     Bit16u doffset;
!BCC_EOS
! 74     Bit16u sseg;
!BCC_EOS
! 75     Bit16u soffset;
!BCC_EOS
! 76     Bit16u count;
!BCC_EOS
! 77   {
! 78 #asm
!BCC_ASM
_memcpyb.count	set	$A
_memcpyb.sseg	set	6
_memcpyb.soffset	set	8
_memcpyb.dseg	set	2
_memcpyb.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyb_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsb
  memcpyb_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 109 endasm
!BCC_ENDASM
! 110   }
ret
! 111     void
! 112   memcpyd(dseg,doffset,sseg,soffset,count)
! 113     Bit16u dseg;
export	_memcpyd
_memcpyd:
!BCC_EOS
! 114     Bit16u doffset;
!BCC_EOS
! 115     Bit16u sseg;
!BCC_EOS
! 116     Bit16u soffset;
!BCC_EOS
! 117     Bit16u count;
!BCC_EOS
! 118   {
! 119 #asm
!BCC_ASM
_memcpyd.count	set	$A
_memcpyd.sseg	set	6
_memcpyd.soffset	set	8
_memcpyd.dseg	set	2
_memcpyd.doffset	set	4
    push bp
    mov bp, sp
      push ax
      push cx
      push es
      push di
      push ds
      push si
      mov cx, 12[bp] ; count
      test cx, cx
      je memcpyd_end
      mov ax, 4[bp] ; dsegment
      mov es, ax
      mov ax, 6[bp] ; doffset
      mov di, ax
      mov ax, 8[bp] ; ssegment
      mov ds, ax
      mov ax, 10[bp] ; soffset
      mov si, ax
      cld
      rep
       movsd
  memcpyd_end:
      pop si
      pop ds
      pop di
      pop es
      pop cx
      pop ax
    pop bp
! 150 endasm
!BCC_ENDASM
! 151   }
ret
! 152   static Bit32u read_dword();
!BCC_EOS
! 153   static void write_dword();
!BCC_EOS
! 154     Bit32u
! 155   read_dword(seg, offset)
! 156     Bit16u seg;
export	_read_dword
_read_dword:
!BCC_EOS
! 157     Bit16u offset;
!BCC_EOS
! 158   {
! 159 #asm
!BCC_ASM
_read_dword.seg	set	2
_read_dword.offset	set	4
    push bp
    mov bp, sp
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, [bx]
      add bx, #2
      mov dx, [bx]
      ;; ax = return value (word)
      ;; dx = return value (word)
      pop ds
      pop bx
    pop bp
! 175 endasm
!BCC_ENDASM
! 176   }
ret
! 177     void
! 178   write_dword(seg, offset, data)
! 179     Bit16u seg;
export	_write_dword
_write_dword:
!BCC_EOS
! 180     Bit16u offset;
!BCC_EOS
! 181     Bit32u data;
!BCC_EOS
! 182   {
! 183 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
    push bp
    mov bp, sp
      push ax
      push bx
      push ds
      mov ax, 4[bp] ; segment
      mov ds, ax
      mov bx, 6[bp] ; offset
      mov ax, 8[bp] ; data word
      mov [bx], ax ; write data word
      add bx, #2
      mov ax, 10[bp] ; data word
      mov [bx], ax ; write data word
      pop ds
      pop bx
      pop ax
    pop bp
! 201 endasm
!BCC_ENDASM
! 202   }
ret
! 203 #asm
!BCC_ASM
_write_dword.seg	set	2
_write_dword.data	set	6
_write_dword.offset	set	4
  ;; and function
  landl:
  landul:
    SEG SS
      and ax,[di]
    SEG SS
      and bx,2[di]
    ret
  ;; add function
  laddl:
  laddul:
    SEG SS
      add ax,[di]
    SEG SS
      adc bx,2[di]
    ret
  ;; cmp function
  lcmpl:
  lcmpul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    SEG SS
      cmp eax, dword ptr [di]
    ret
  ;; sub function
  lsubl:
  lsubul:
    SEG SS
    sub ax,[di]
    SEG SS
    sbb bx,2[di]
    ret
  ;; mul function
  lmull:
  lmulul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    SEG SS
    mul eax, dword ptr [di]
    mov ebx, eax
    shr ebx, #16
    ret
  ;; dec function
  ldecl:
  ldecul:
    SEG SS
    dec dword ptr [bx]
    ret
  ;; or function
  lorl:
  lorul:
    SEG SS
    or ax,[di]
    SEG SS
    or bx,2[di]
    ret
  ;; inc function
  lincl:
  lincul:
    SEG SS
    inc dword ptr [bx]
    ret
  ;; tst function
  ltstl:
  ltstul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    shr ebx, #16
    test eax, eax
    ret
  ;; sr function
  lsrul:
    mov cx,di
    jcxz lsr_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsr_loop:
    shr eax, #1
    loop lsr_loop
    mov ebx, eax
    shr ebx, #16
  lsr_exit:
    ret
  ;; sl function
  lsll:
  lslul:
    mov cx,di
    jcxz lsl_exit
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
  lsl_loop:
    shl eax, #1
    loop lsl_loop
    mov ebx, eax
    shr ebx, #16
  lsl_exit:
    ret
  idiv_:
    cwd
    idiv bx
    ret
  idiv_u:
    xor dx,dx
    div bx
    ret
  ldivul:
    and eax, #0x0000FFFF
    shl ebx, #16
    or eax, ebx
    xor edx, edx
    SEG SS
    mov bx, 2[di]
    shl ebx, #16
    SEG SS
    mov bx, [di]
    div ebx
    mov ebx, eax
    shr ebx, #16
    ret
! 329 endasm
!BCC_ENDASM
! 330 typedef struct {
! 331   unsigned char filler1[0x400];
!BCC_EOS
! 332   unsigned char filler2[0x6c];
!BCC_EOS
! 333   Bit16u ticks_low;
!BCC_EOS
! 334   Bit16u ticks_high;
!BCC_EOS
! 335   Bit8u midnight_flag;
!BCC_EOS
! 336   } bios_data_t;
!BCC_EOS
! 337   typedef struct {
! 338     Bit16u heads;
!BCC_EOS
! 339     Bit16u cylinders;
!BCC_EOS
! 340     Bit16u spt;
!BCC_EOS
! 341     } chs_t;
!BCC_EOS
! 342   typedef struct {
! 343     Bit16u iobase1;
!BCC_EOS
! 344     Bit16u iobase2;
!BCC_EOS
! 345     Bit8u prefix;
!BCC_EOS
! 346     Bit8u unused;
!BCC_EOS
! 347     Bit8u irq;
!BCC_EOS
! 348     Bit8u blkcount;
!BCC_EOS
! 349     Bit8u dma;
!BCC_EOS
! 350     Bit8u pio;
!BCC_EOS
! 351     Bit16u options;
!BCC_EOS
! 352     Bit16u reserved;
!BCC_EOS
! 353     Bit8u revision;
!BCC_EOS
! 354     Bit8u checksum;
!BCC_EOS
! 355     } dpte_t;
!BCC_EOS
! 356   typedef struct {
! 357     Bit8u iface;
!BCC_EOS
! 358     Bit16u iobase1;
!BCC_EOS
! 359     Bit16u iobase2;
!BCC_EOS
! 360     Bit8u irq;
!BCC_EOS
! 361     } ata_channel_t;
!BCC_EOS
! 362   typedef struct {
! 363     Bit8u type;
!BCC_EOS
! 364     Bit8u device;
!BCC_EOS
! 365     Bit8u removab
! 365 le;
!BCC_EOS
! 366     Bit8u lock;
!BCC_EOS
! 367     Bit8u mode;
!BCC_EOS
! 368     Bit16u blksize;
!BCC_EOS
! 369     Bit8u translation;
!BCC_EOS
! 370     chs_t lchs;
!BCC_EOS
! 371     chs_t pchs;
!BCC_EOS
! 372     Bit32u sectors_low;
!BCC_EOS
! 373     Bit32u sectors_high;
!BCC_EOS
! 374     } ata_device_t;
!BCC_EOS
! 375   typedef struct {
! 376     ata_channel_t channels[4];
!BCC_EOS
! 377     ata_device_t devices[(4*2)];
!BCC_EOS
! 378     Bit8u hdcount, hdidmap[(4*2)];
!BCC_EOS
! 379     Bit8u cdcount, cdidmap[(4*2)];
!BCC_EOS
! 380     dpte_t dpte;
!BCC_EOS
! 381     Bit16u trsfsectors;
!BCC_EOS
! 382     Bit32u trsfbytes;
!BCC_EOS
! 383     } ata_t;
!BCC_EOS
! 384   typedef struct {
! 385     Bit8u active;
!BCC_EOS
! 386     Bit8u media;
!BCC_EOS
! 387     Bit8u emulated_drive;
!BCC_EOS
! 388     Bit8u controller_index;
!BCC_EOS
! 389     Bit16u device_spec;
!BCC_EOS
! 390     Bit32u ilba;
!BCC_EOS
! 391     Bit16u buffer_segment;
!BCC_EOS
! 392     Bit16u load_segment;
!BCC_EOS
! 393     Bit16u sector_count;
!BCC_EOS
! 394     chs_t vdevice;
!BCC_EOS
! 395     } cdemu_t;
!BCC_EOS
! 396 Bit32u TCGInterruptHandler ();
!BCC_EOS
! 397 void tcpa_acpi_init ();
!BCC_EOS
! 398 Bit32u tcpa_extend_acpi_log ();
!BCC_EOS
! 399 void tcpa_calling_int19h ();
!BCC_EOS
! 400 void tcpa_returned_int19h ();
!BCC_EOS
! 401 void tcpa_add_event_separators ();
!BCC_EOS
! 402 void tcpa_wake_event ();
!BCC_EOS
! 403 void tcpa_add_bootdevice ();
!BCC_EOS
! 404 void tcpa_start_option_rom_scan ();
!BCC_EOS
! 405 void tcpa_option_rom ();
!BCC_EOS
! 406 void tcpa_ipl ();
!BCC_EOS
! 407 void tcpa_measure_post ();
!BCC_EOS
! 408 Bit32u tcpa_initialize_tpm ();
!BCC_EOS
! 409 Bit32u get_s3_waking_vector ();
!BCC_EOS
! 410 Bit32u pmm ();
!BCC_EOS
! 411   typedef struct {
! 412     unsigned char ebda_size;
!BCC_EOS
! 413     unsigned char cmos_shutdown_status;
!BCC_EOS
! 414     unsigned char filler1[0x3B];
!BCC_EOS
! 415     unsigned char fdpt0[0x10];
!BCC_EOS
! 416     unsigned char fdpt1[0x10];
!BCC_EOS
! 417     unsigned char filler2[0xC4];
!BCC_EOS
! 418     ata_t ata;
!BCC_EOS
! 419     cdemu_t cdemu;
!BCC_EOS
! 420     } ebda_data_t;
!BCC_EOS
! 421   typedef struct {
! 422     Bit8u size;
!BCC_EOS
! 423     Bit8u reserved;
!BCC_EOS
! 424     Bit16u count;
!BCC_EOS
! 425     Bit16u offset;
!BCC_EOS
! 426     Bit16u segment;
!BCC_EOS
! 427     Bit32u lba1;
!BCC_EOS
! 428     Bit32u lba2;
!BCC_EOS
! 429     } int13ext_t;
!BCC_EOS
! 430   typedef struct {
! 431     Bit16u size;
!BCC_EOS
! 432     Bit16u infos;
!BCC_EOS
! 433     Bit32u cylinders;
!BCC_EOS
! 434     Bit32u heads;
!BCC_EOS
! 435     Bit32u spt;
!BCC_EOS
! 436     Bit32u sector_count1;
!BCC_EOS
! 437     Bit32u sector_count2;
!BCC_EOS
! 438     Bit16u blksize;
!BCC_EOS
! 439     Bit16u dpte_offset;
!BCC_EOS
! 440     Bit16u dpte_segment;
!BCC_EOS
! 441     Bit16u key;
!BCC_EOS
! 442     Bit8u dpi_length;
!BCC_EOS
! 443     Bit8u reserved1;
!BCC_EOS
! 444     Bit16u reserved2;
!BCC_EOS
! 445     Bit8u host_bus[4];
!BCC_EOS
! 446     Bit8u iface_type[8];
!BCC_EOS
! 447     Bit8u iface_path[8];
!BCC_EOS
! 448     Bit8u device_path[8];
!BCC_EOS
! 449     Bit8u reserved3;
!BCC_EOS
! 450     Bit8u checksum;
!BCC_EOS
! 451     } dpt_t;
!BCC_EOS
! 452 typedef struct {
! 453   union {
! 454     struct {
! 455       Bit16u di, si, b
! 455 p, sp;
!BCC_EOS
! 456       Bit16u bx, dx, cx, ax;
!BCC_EOS
! 457       } r16;
!BCC_EOS
! 458     struct {
! 459       Bit16u filler[4];
!BCC_EOS
! 460       Bit8u bl, bh, dl, dh, cl, ch, al, ah;
!BCC_EOS
! 461       } r8;
!BCC_EOS
! 462     } u;
!BCC_EOS
! 463   } pusha_regs_t;
!BCC_EOS
! 464 typedef struct {
! 465  union {
! 466   struct {
! 467     Bit32u edi, esi, ebp, esp;
!BCC_EOS
! 468     Bit32u ebx, edx, ecx, eax;
!BCC_EOS
! 469     } r32;
!BCC_EOS
! 470   struct {
! 471     Bit16u di, filler1, si, filler2, bp, filler3, sp, filler4;
!BCC_EOS
! 472     Bit16u bx, filler5, dx, filler6, cx, filler7, ax, filler8;
!BCC_EOS
! 473     } r16;
!BCC_EOS
! 474   struct {
! 475     Bit32u filler[4];
!BCC_EOS
! 476     Bit8u bl, bh;
!BCC_EOS
! 477     Bit16u filler1;
!BCC_EOS
! 478     Bit8u dl, dh;
!BCC_EOS
! 479     Bit16u filler2;
!BCC_EOS
! 480     Bit8u cl, ch;
!BCC_EOS
! 481     Bit16u filler3;
!BCC_EOS
! 482     Bit8u al, ah;
!BCC_EOS
! 483     Bit16u filler4;
!BCC_EOS
! 484     } r8;
!BCC_EOS
! 485   } u;
!BCC_EOS
! 486 } pushad_regs_t;
!BCC_EOS
! 487 typedef struct {
! 488   union {
! 489     struct {
! 490       Bit16u flags;
!BCC_EOS
! 491       } r16;
!BCC_EOS
! 492     struct {
! 493       Bit8u flagsl;
!BCC_EOS
! 494       Bit8u flagsh;
!BCC_EOS
! 495       } r8;
!BCC_EOS
! 496     } u;
!BCC_EOS
! 497   } flags_t;
!BCC_EOS
! 498 typedef struct {
! 499   Bit16u ip;
!BCC_EOS
! 500   Bit16u cs;
!BCC_EOS
! 501   flags_t flags;
!BCC_EOS
! 502   } iret_addr_t;
!BCC_EOS
! 503 typedef struct {
! 504   Bit16u type;
!BCC_EOS
! 505   Bit16u flags;
!BCC_EOS
! 506   Bit32u vector;
!BCC_EOS
! 507   Bit32u description;
!BCC_EOS
! 508   Bit32u reserved;
!BCC_EOS
! 509   } ipl_entry_t;
!BCC_EOS
! 510 static Bit8u inb();
!BCC_EOS
! 511 static Bit8u inb_cmos();
!BCC_EOS
! 512 static void outb();
!BCC_EOS
! 513 static void outb_cmos();
!BCC_EOS
! 514 static Bit16u inw();
!BCC_EOS
! 515 static void outw();
!BCC_EOS
! 516 static void init_rtc();
!BCC_EOS
! 517 static bx_bool rtc_updating();
!BCC_EOS
! 518 static Bit8u read_byte();
!BCC_EOS
! 519 static Bit16u read_word();
!BCC_EOS
! 520 static void write_byte();
!BCC_EOS
! 521 static void write_word();
!BCC_EOS
! 522 static void bios_printf();
!BCC_EOS
! 523 static Bit8u inhibit_mouse_int_and_events();
!BCC_EOS
! 524 static void enable_mouse_int_and_events();
!BCC_EOS
! 525 static Bit8u send_to_mouse_ctrl();
!BCC_EOS
! 526 static Bit8u get_mouse_data();
!BCC_EOS
! 527 static void set_kbd_command_byte();
!BCC_EOS
! 528 static void int09_function();
!BCC_EOS
! 529 static void int13_harddisk();
!BCC_EOS
! 530 static void int13_cdrom();
!BCC_EOS
! 531 static void int13_cdemu();
!BCC_EOS
! 532 static void int13_eltorito();
!BCC_EOS
! 533 static void int13_diskette_function();
!BCC_EOS
! 534 static void int14_function();
!BCC_EOS
! 535 static void int15_function();
!BCC_EOS
! 536 static void int16_function();
!BCC_EOS
! 537 static void int17_function();
!BCC_EOS
! 538 static void int18_function();
!BCC_EOS
! 539 static void int1a_function();
!BCC_EOS
! 540 static void int70_function();
!BCC_EOS
! 541 static void int74_function();
!BCC_EOS
! 542 static Bit16u get_CS();
!BCC_EOS
! 543 static Bit16u get_SS();
!BCC_EOS
! 544 static unsigned int enqueue_key();
!BCC_EOS
! 545 static unsigned int dequeue_
! 545 key();
!BCC_EOS
! 546 static void get_hd_geometry();
!BCC_EOS
! 547 static void set_diskette_ret_status();
!BCC_EOS
! 548 static void set_diskette_current_cyl();
!BCC_EOS
! 549 static void determine_floppy_media();
!BCC_EOS
! 550 static bx_bool floppy_drive_exists();
!BCC_EOS
! 551 static bx_bool floppy_drive_recal();
!BCC_EOS
! 552 static bx_bool floppy_media_known();
!BCC_EOS
! 553 static bx_bool floppy_media_sense();
!BCC_EOS
! 554 static bx_bool set_enable_a20();
!BCC_EOS
! 555 static void debugger_on();
!BCC_EOS
! 556 static void debugger_off();
!BCC_EOS
! 557 static void keyboard_init();
!BCC_EOS
! 558 static void keyboard_panic();
!BCC_EOS
! 559 static void shutdown_status_panic();
!BCC_EOS
! 560 static void nmi_handler_msg();
!BCC_EOS
! 561 static void delay_ticks();
!BCC_EOS
! 562 static void delay_ticks_and_check_for_keystroke();
!BCC_EOS
! 563 static void interactive_bootkey();
!BCC_EOS
! 564 static void print_bios_banner();
!BCC_EOS
! 565 static void print_boot_device();
!BCC_EOS
! 566 static void print_boot_failure();
!BCC_EOS
! 567 static void print_cdromboot_failure();
!BCC_EOS
! 568 void ata_init();
!BCC_EOS
! 569 void ata_detect();
!BCC_EOS
! 570 void ata_reset();
!BCC_EOS
! 571 Bit16u ata_cmd_non_data();
!BCC_EOS
! 572 Bit16u ata_cmd_data_in();
!BCC_EOS
! 573 Bit16u ata_cmd_data_out();
!BCC_EOS
! 574 Bit16u ata_cmd_packet();
!BCC_EOS
! 575 Bit16u atapi_get_sense();
!BCC_EOS
! 576 Bit16u atapi_is_ready();
!BCC_EOS
! 577 Bit16u atapi_is_cdrom();
!BCC_EOS
! 578 void cdemu_init();
!BCC_EOS
! 579 Bit8u cdemu_isactive();
!BCC_EOS
! 580 Bit8u cdemu_emulated_drive();
!BCC_EOS
! 581 Bit16u cdrom_boot();
!BCC_EOS
! 582 static char bios_cvs_version_string[] = "$Revision: 1.221 $ $Date: 2008/12/07 17:32:29 $";
.data
_bios_cvs_version_string:
.1:
.ascii	"$Revision: 1.221 $ $Date: 2008/12/07 17:"
.ascii	"32:29 $"
.byte	0
!BCC_EOS
! 583 static struct {
! 584   Bit16u normal;
!BCC_EOS
! 585   Bit16u shift;
!BCC_EOS
! 586   Bit16u control;
!BCC_EOS
! 587   Bit16u alt;
!BCC_EOS
! 588   Bit8u lock_flags;
!BCC_EOS
! 589   } scan_to_scanascii[0x58 + 1] = {
_scan_to_scanascii:
! 590       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 591       { 0x011b, 0x011b, 0x011b, 0x0100, 0 },
.word	$11B
.word	$11B
.word	$11B
.word	$100
.byte	0
.blkb	1
! 592       { 0x0231, 0x0221, 0, 0x7800, 0 },
.word	$231
.word	$221
.word	0
.word	$7800
.byte	0
.blkb	1
! 593       { 0x0332, 0x0340, 0x0300, 0x7900, 0 },
.word	$332
.word	$340
.word	$300
.word	$7900
.byte	0
.blkb	1
! 594       { 0x0433, 0x0423, 0, 0x7a00, 0 },
.word	$433
.word	$423
.word	0
.word	$7A00
.byte	0
.blkb	1
! 595       { 0x0534, 0x0524, 0, 0x7b00, 0 },
.word	$534
.word	$524
.word	0
.word	$7B00
.byte	0
.blkb	1
! 596       { 0x0635, 0x0625, 0, 0x7c00, 0 },
.word	$635
.word	$625
.word	0
.word	$7C00
.byte	0
.blkb	1
! 597       { 0x0736, 0x075e, 0x071e, 0x7d00, 0 },
.word	$736
.word	$75E
.word	$71E
.word	$7D00
.byte	0
.blkb	1
! 598       { 0x0837, 0x0826, 0, 0x7e00, 0 },
.word	$837
.word	$826
.word	0
.word	$7E00
.byte	0
.blkb	1
! 599       { 0x0938, 0x092a, 0, 0x7f00, 0 },
.word	$938
.word	$92A
.word	0
.word	$7F00
.byte	0
.blkb	1
! 600       { 0x0a39, 0x0a28, 0, 0x8000, 0 },
.word	$A39
.word	$A28
.word	0
.word	$8000
.byte	0
.blkb	1
! 601       { 0x0b30, 0x0b29, 0, 0x8100, 0 },
.word	$B30
.word	$B29
.word	0
.word	$8100
.byte	0
.blkb	1
! 602       { 0x0c2d, 0x0c5f, 0x0c1f, 0x8200, 0 },
.word	$C2D
.word	$C5F
.word	$C1F
.word	$8200
.byte	0
.blkb	1
! 603       { 0x0d3d, 0x0d2b, 0, 0x8300, 0 },
.word	$D3D
.word	$D2B
.word	0
.word	$8300
.byte	0
.blkb	1
! 604       { 0x0e08, 0x0e08, 0x0e7f, 0, 0 },
.word	$E08
.word	$E08
.word	$E7F
.word	0
.byte	0
.blkb	1
! 605       { 0x0f09, 0x0f00, 0, 0, 0 },
.word	$F09
.word	$F00
.word	0
.word	0
.byte	0
.blkb	1
! 606       { 0x1071, 0x1051, 0x1011, 0x1000, 0x40 },
.word	$1071
.word	$1051
.word	$1011
.word	$1000
.byte	$40
.blkb	1
! 607       { 0x1177, 0x1157, 0x1117, 
.word	$1177
.word	$1157
.word	$1117
! 607 0x1100, 0x40 },
.word	$1100
.byte	$40
.blkb	1
! 608       { 0x1265, 0x1245, 0x1205, 0x1200, 0x40 },
.word	$1265
.word	$1245
.word	$1205
.word	$1200
.byte	$40
.blkb	1
! 609       { 0x1372, 0x1352, 0x1312, 0x1300, 0x40 },
.word	$1372
.word	$1352
.word	$1312
.word	$1300
.byte	$40
.blkb	1
! 610       { 0x1474, 0x1454, 0x1414, 0x1400, 0x40 },
.word	$1474
.word	$1454
.word	$1414
.word	$1400
.byte	$40
.blkb	1
! 611       { 0x1579, 0x1559, 0x1519, 0x1500, 0x40 },
.word	$1579
.word	$1559
.word	$1519
.word	$1500
.byte	$40
.blkb	1
! 612       { 0x1675, 0x1655, 0x1615, 0x1600, 0x40 },
.word	$1675
.word	$1655
.word	$1615
.word	$1600
.byte	$40
.blkb	1
! 613       { 0x1769, 0x1749, 0x1709, 0x1700, 0x40 },
.word	$1769
.word	$1749
.word	$1709
.word	$1700
.byte	$40
.blkb	1
! 614       { 0x186f, 0x184f, 0x180f, 0x1800, 0x40 },
.word	$186F
.word	$184F
.word	$180F
.word	$1800
.byte	$40
.blkb	1
! 615       { 0x1970, 0x1950, 0x1910, 0x1900, 0x40 },
.word	$1970
.word	$1950
.word	$1910
.word	$1900
.byte	$40
.blkb	1
! 616       { 0x1a5b, 0x1a7b, 0x1a1b, 0, 0 },
.word	$1A5B
.word	$1A7B
.word	$1A1B
.word	0
.byte	0
.blkb	1
! 617       { 0x1b5d, 0x1b7d, 0x1b1d, 0, 0 },
.word	$1B5D
.word	$1B7D
.word	$1B1D
.word	0
.byte	0
.blkb	1
! 618       { 0x1c0d, 0x1c0d, 0x1c0a, 0, 0 },
.word	$1C0D
.word	$1C0D
.word	$1C0A
.word	0
.byte	0
.blkb	1
! 619       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 620       { 0x1e61, 0x1e41, 0x1e01, 0x1e00, 0x40 },
.word	$1E61
.word	$1E41
.word	$1E01
.word	$1E00
.byte	$40
.blkb	1
! 621       { 0x1f73, 0x1f53, 0x1f13, 0x1f00, 0x40 },
.word	$1F73
.word	$1F53
.word	$1F13
.word	$1F00
.byte	$40
.blkb	1
! 622       { 0x2064, 0x2044, 0x2004, 0x2000, 0x40 },
.word	$2064
.word	$2044
.word	$2004
.word	$2000
.byte	$40
.blkb	1
! 623       { 0x2166, 0x2146, 0x2106, 0x2100, 0x40 },
.word	$2166
.word	$2146
.word	$2106
.word	$2100
.byte	$40
.blkb	1
! 624       { 0x2267, 0x2247, 0x2207, 0x2200, 0x40 },
.word	$2267
.word	$2247
.word	$2207
.word	$2200
.byte	$40
.blkb	1
! 625       { 0x2368, 0x2348, 0x2308, 0x2300, 0x40 },
.word	$2368
.word	$2348
.word	$2308
.word	$2300
.byte	$40
.blkb	1
! 626       { 0x246a, 0x244a, 0x240a, 0x2400, 0x40 },
.word	$246A
.word	$244A
.word	$240A
.word	$2400
.byte	$40
.blkb	1
! 627       { 0x256b, 0x254b, 0x250b, 0x2500, 0x40 },
.word	$256B
.word	$254B
.word	$250B
.word	$2500
.byte	$40
.blkb	1
! 628       { 0x266c, 0x264c, 0x260c, 0x2600, 0x40 },
.word	$266C
.word	$264C
.word	$260C
.word	$2600
.byte	$40
.blkb	1
! 629       { 0x273b, 0x273a, 0, 0, 0 },
.word	$273B
.word	$273A
.word	0
.word	0
.byte	0
.blkb	1
! 630       { 0x2827, 0x2822, 0, 0, 0 },
.word	$2827
.word	$2822
.word	0
.word	0
.byte	0
.blkb	1
! 631       { 0x2960, 0x297e, 0, 0, 0 },
.word	$2960
.word	$297E
.word	0
.word	0
.byte	0
.blkb	1
! 632       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 633       { 0x2b5c, 0x2b7c, 0x2b1c, 0, 0 },
.word	$2B5C
.word	$2B7C
.word	$2B1C
.word	0
.byte	0
.blkb	1
! 634       { 0x2c7a, 0x2c5a, 0x2c1a, 0x2c00, 0x40 },
.word	$2C7A
.word	$2C5A
.word	$2C1A
.word	$2C00
.byte	$40
.blkb	1
! 635       { 0x2d78, 0x2d58, 0x2d18, 0x2d00, 0x40 },
.word	$2D78
.word	$2D58
.word	$2D18
.word	$2D00
.byte	$40
.blkb	1
! 636       { 0x2e63, 0x2e43, 0x2e03, 0x2e00, 0x40 },
.word	$2E63
.word	$2E43
.word	$2E03
.word	$2E00
.byte	$40
.blkb	1
! 637       { 0x2f76, 0x2f56, 0x2f16, 0x2f00, 0x40 },
.word	$2F76
.word	$2F56
.word	$2F16
.word	$2F00
.byte	$40
.blkb	1
! 638       { 0x3062, 0x3042, 0x3002, 0x3000, 0x40 },
.word	$3062
.word	$3042
.word	$3002
.word	$3000
.byte	$40
.blkb	1
! 639       { 0x316e, 0x314e, 0x310e, 0x3100, 0x40 },
.word	$316E
.word	$314E
.word	$310E
.word	$3100
.byte	$40
.blkb	1
! 640       { 0x326d, 0x324d, 0x320d, 0x3200, 0x40 },
.word	$326D
.word	$324D
.word	$320D
.word	$3200
.byte	$40
.blkb	1
! 641       { 0x332c, 0x333c, 0, 0, 0 },
.word	$332C
.word	$333C
.word	0
.word	0
.byte	0
.blkb	1
! 642       { 0x342e, 0x343e, 0, 0, 0 },
.word	$342E
.word	$343E
.word	0
.word	0
.byte	0
.blkb	1
! 643       { 0x352f, 0x353f, 0, 0, 0 },
.word	$352F
.word	$353F
.word	0
.word	0
.byte	0
.blkb	1
! 644       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 645       { 0x372a, 0x372a, 0, 0, 0 },
.word	$372A
.word	$372A
.word	0
.word	0
.byte	0
.blkb	1
! 646       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 647       { 0x3920, 0x3920, 0x3920, 0x3920, 0 },
.word	$3920
.word	$3920
.word	$3920
.word	$3920
.byte	0
.blkb	1
! 648       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 649       { 0x3b00, 0x5400, 0x5e00, 0x6800, 0 },
.word	$3B00
.word	$5400
.word	$5E00
.word	$6800
.byte	0
.blkb	1
! 650       { 0x3c00, 0x5500, 0x5f00, 0x6900, 0 },
.word	$3C00
.word	$5500
.word	$5F00
.word	$6900
.byte	0
.blkb	1
! 651       { 0x3d00, 0x5600, 0x6000, 0x6a00, 0 },
.word	$3D00
.word	$5600
.word	$6000
.word	$6A00
.byte	0
.blkb	1
! 652       { 0x3e00, 0x5700, 0x6100, 0x6b00, 0 },
.word	$3E00
.word	$5700
.word	$6100
.word	$6B00
.byte	0
.blkb	1
! 653       { 0x3f00, 0x5800, 0x6200, 0x6c00, 0 },
.word	$3F00
.word	$5800
.word	$6200
.word	$6C00
.byte	0
.blkb	1
! 654       { 0x4000, 0x5900, 0x6300, 0x6d00, 0 },
.word	$4000
.word	$5900
.word	$6300
.word	$6D00
.byte	0
.blkb	1
! 655       { 0x4100, 0x5a00, 0x6400, 0x6
.word	$4100
.word	$5A00
.word	$6400
! 655 e00, 0 },
.word	$6E00
.byte	0
.blkb	1
! 656       { 0x4200, 0x5b00, 0x6500, 0x6f00, 0 },
.word	$4200
.word	$5B00
.word	$6500
.word	$6F00
.byte	0
.blkb	1
! 657       { 0x4300, 0x5c00, 0x6600, 0x7000, 0 },
.word	$4300
.word	$5C00
.word	$6600
.word	$7000
.byte	0
.blkb	1
! 658       { 0x4400, 0x5d00, 0x6700, 0x7100, 0 },
.word	$4400
.word	$5D00
.word	$6700
.word	$7100
.byte	0
.blkb	1
! 659       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 660       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 661       { 0x4700, 0x4737, 0x7700, 0, 0x20 },
.word	$4700
.word	$4737
.word	$7700
.word	0
.byte	$20
.blkb	1
! 662       { 0x4800, 0x4838, 0, 0, 0x20 },
.word	$4800
.word	$4838
.word	0
.word	0
.byte	$20
.blkb	1
! 663       { 0x4900, 0x4939, 0x8400, 0, 0x20 },
.word	$4900
.word	$4939
.word	$8400
.word	0
.byte	$20
.blkb	1
! 664       { 0x4a2d, 0x4a2d, 0, 0, 0 },
.word	$4A2D
.word	$4A2D
.word	0
.word	0
.byte	0
.blkb	1
! 665       { 0x4b00, 0x4b34, 0x7300, 0, 0x20 },
.word	$4B00
.word	$4B34
.word	$7300
.word	0
.byte	$20
.blkb	1
! 666       { 0x4c00, 0x4c35, 0, 0, 0x20 },
.word	$4C00
.word	$4C35
.word	0
.word	0
.byte	$20
.blkb	1
! 667       { 0x4d00, 0x4d36, 0x7400, 0, 0x20 },
.word	$4D00
.word	$4D36
.word	$7400
.word	0
.byte	$20
.blkb	1
! 668       { 0x4e2b, 0x4e2b, 0, 0, 0 },
.word	$4E2B
.word	$4E2B
.word	0
.word	0
.byte	0
.blkb	1
! 669       { 0x4f00, 0x4f31, 0x7500, 0, 0x20 },
.word	$4F00
.word	$4F31
.word	$7500
.word	0
.byte	$20
.blkb	1
! 670       { 0x5000, 0x5032, 0, 0, 0x20 },
.word	$5000
.word	$5032
.word	0
.word	0
.byte	$20
.blkb	1
! 671       { 0x5100, 0x5133, 0x7600, 0, 0x20 },
.word	$5100
.word	$5133
.word	$7600
.word	0
.byte	$20
.blkb	1
! 672       { 0x5200, 0x5230, 0, 0, 0x20 },
.word	$5200
.word	$5230
.word	0
.word	0
.byte	$20
.blkb	1
! 673       { 0x5300, 0x532e, 0, 0, 0x20 },
.word	$5300
.word	$532E
.word	0
.word	0
.byte	$20
.blkb	1
! 674       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 675       { 0, 0, 0, 0, 0 },
.word	0
.word	0
.word	0
.word	0
.byte	0
.blkb	1
! 676       { 0x565c, 0x567c, 0, 0, 0 },
.word	$565C
.word	$567C
.word	0
.word	0
.byte	0
.blkb	1
! 677       { 0x8500, 0x8700, 0x8900, 0x8b00, 0 },
.word	$8500
.word	$8700
.word	$8900
.word	$8B00
.byte	0
.blkb	1
! 678       { 0x8600, 0x8800, 0x8a00, 0x8c00, 0 },
.word	$8600
.word	$8800
.word	$8A00
.word	$8C00
.byte	0
.blkb	1
! 679       };
!BCC_EOS
! 680   Bit8u
! 681 inb(port)
! 682   Bit16u port;
.text
export	_inb
_inb:
!BCC_EOS
! 683 {
! 684 #asm
!BCC_ASM
_inb.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in al, dx
    pop dx
  pop bp
! 692 endasm
!BCC_ENDASM
! 693 }
ret
! 694   Bit16u
! 695 inw(port)
! 696   Bit16u port;
export	_inw
_inw:
!BCC_EOS
! 697 {
! 698 #asm
!BCC_ASM
_inw.port	set	2
  push bp
  mov bp, sp
    push dx
    mov dx, 4[bp]
    in ax, dx
    pop dx
  pop bp
! 706 endasm
!BCC_ENDASM
! 707 }
ret
! 708   void
! 709 outb(port, val)
! 710   Bit16u port;
export	_outb
_outb:
!BCC_EOS
! 711   Bit8u val;
!BCC_EOS
! 712 {
! 713 #asm
!BCC_ASM
_outb.val	set	4
_outb.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov al, 6[bp]
    out dx, al
    pop dx
    pop ax
  pop bp
! 724 endasm
!BCC_ENDASM
! 725 }
ret
! 726   void
! 727 outw(port, val)
! 728   Bit16u port;
export	_outw
_outw:
!BCC_EOS
! 729   Bit16u val;
!BCC_EOS
! 730 {
! 731 #asm
!BCC_ASM
_outw.val	set	4
_outw.port	set	2
  push bp
  mov bp, sp
    push ax
    push dx
    mov dx, 4[bp]
    mov ax, 6[bp]
    out dx, ax
    pop dx
    pop ax
  pop bp
! 742 endasm
!BCC_ENDASM
! 743 }
ret
! 744   void
! 745 outb_cmos(cmos_reg, val)
! 746   Bit8u cmos_reg;
export	_outb_cmos
_outb_cmos:
!BCC_EOS
! 747   Bit8u val;
!BCC_EOS
! 748 {
! 749 #asm
!BCC_ASM
_outb_cmos.cmos_reg	set	2
_outb_cmos.val	set	4
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    mov al, 6[bp] ;; val
    out 0x71, al
  pop bp
! 757 endasm
!BCC_ENDASM
! 758 }
ret
! 759   Bit8u
! 760 inb_cmos(cmos_reg)
! 761   Bit8u cmos_reg;
export	_inb_cmos
_inb_cmos:
!BCC_EOS
! 762 {
! 763 #asm
!BCC_ASM
_inb_cmos.cmos_reg	set	2
  push bp
  mov bp, sp
    mov al, 4[bp] ;; cmos_reg
    out 0x70, al
    in al, 0x71
  pop bp
! 770 endasm
!BCC_ENDASM
! 771 }
ret
! 772   void
! 773 init_rtc()
! 774 {
export	_init_rtc
_init_rtc:
! 775   outb_cmos(0x0a, 0x26);
push	bp
mov	bp,sp
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 776   outb_cmos(0x0b, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
mov	sp,bp
!BCC_EOS
! 777   inb_cmos(0x0c);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 778   inb_cmos(0x0d);
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
mov	sp,bp
!BCC_EOS
! 779 }
pop	bp
ret
! 780   bx_bool
! 781 rtc_u
! 781 pdating()
! 782 {
export	_rtc_updating
_rtc_updating:
! 783   Bit16u count;
!BCC_EOS
! 784   count = 25000;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const $61A8 to unsigned short count = [S+4-4] (used reg = )
mov	ax,#$61A8
mov	-2[bp],ax
!BCC_EOS
! 785   while (--count != 0) {
jmp .3
.4:
! 786     if ( (inb_cmos(0x0a) & 0x80) == 0 )
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.5
.6:
! 787       return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 788     }
.5:
! 789   return(1);
.3:
! Debug: predec unsigned short count = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.4
.7:
.2:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 790 }
! 791   Bit8u
! 792 read_byte(seg, offset)
! 793   Bit16u seg;
export	_read_byte
_read_byte:
!BCC_EOS
! 794   Bit16u offset;
!BCC_EOS
! 795 {
! 796 #asm
!BCC_ASM
_read_byte.seg	set	2
_read_byte.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, [bx]
    ;; al = return value (byte)
    pop ds
    pop bx
  pop bp
! 809 endasm
!BCC_ENDASM
! 810 }
ret
! 811   Bit16u
! 812 read_word(seg, offset)
! 813   Bit16u seg;
export	_read_word
_read_word:
!BCC_EOS
! 814   Bit16u offset;
!BCC_EOS
! 815 {
! 816 #asm
!BCC_ASM
_read_word.seg	set	2
_read_word.offset	set	4
  push bp
  mov bp, sp
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, [bx]
    ;; ax = return value (word)
    pop ds
    pop bx
  pop bp
! 829 endasm
!BCC_ENDASM
! 830 }
ret
! 831   void
! 832 write_byte(seg, offset, data)
! 833   Bit16u seg;
export	_write_byte
_write_byte:
!BCC_EOS
! 834   Bit16u offset;
!BCC_EOS
! 835   Bit8u data;
!BCC_EOS
! 836 {
! 837 #asm
!BCC_ASM
_write_byte.seg	set	2
_write_byte.data	set	6
_write_byte.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov al, 8[bp] ; data byte
    mov [bx], al ; write data byte
    pop ds
    pop bx
    pop ax
  pop bp
! 852 endasm
!BCC_ENDASM
! 853 }
ret
! 854   void
! 855 write_word(seg, offset, data)
! 856   Bit16u seg;
export	_write_word
_write_word:
!BCC_EOS
! 857   Bit16u offset;
!BCC_EOS
! 858   Bit16u data;
!BCC_EOS
! 859 {
! 860 #asm
!BCC_ASM
_write_word.seg	set	2
_write_word.data	set	6
_write_word.offset	set	4
  push bp
  mov bp, sp
    push ax
    push bx
    push ds
    mov ax, 4[bp] ; segment
    mov ds, ax
    mov bx, 6[bp] ; offset
    mov ax, 8[bp] ; data word
    mov [bx], ax ; write data word
    pop ds
    pop bx
    pop ax
  pop bp
! 875 endasm
!BCC_ENDASM
! 876 }
ret
! 877   Bit16u
! 878 get_CS()
! 879 {
export	_get_CS
_get_CS:
! 880 #asm
!BCC_ASM
  mov ax, cs
! 882 endasm
!BCC_ENDASM
! 883 }
ret
! 884   Bit16u
! 885 get_SS()
! 886 {
export	_get_SS
_get_SS:
! 887 #asm
!BCC_ASM
  mov ax, ss
! 889 endasm
!BCC_ENDASM
! 890 }
ret
! 891 void
! 892 fixup_base_mem_in_k()
! 893 {
export	_fixup_base_mem_in_k
_fixup_base_mem_in_k:
! 894   Bit32u base_mem = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 8);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base_mem = [S+6-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 895   write_word(0x40, 0x13, base_mem >> 10);
! Debug: sr int = const $A to unsigned long base_mem = [S+6-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*2
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $13 (used reg = )
mov	ax,*$13
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 896 }
mov	sp,bp
pop	bp
ret
! 897 void enable_rom_write_access()
! Register BX used in function fixup_base_mem_in_k
! 898 {
export	_enable_rom_write_access
_enable_rom_write_access:
! 899     outb(0x10, 0);
push	bp
mov	bp,sp
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 900 }
pop	bp
ret
! 901 void disable_rom_write_access()
! 902 {
export	_disable_rom_write_access
_disable_rom_write_access:
! 903     outb(0x10, 1);
push	bp
mov	bp,sp
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 904 }
pop	bp
ret
! 905   void
! 906 wrch(c)
! 907   Bit8u c;
export	_wrch
_wrch:
!BCC_EOS
! 908 {
! 909 #asm
!BCC_ASM
_wrch.c	set	2
  push bp
  mov bp, sp
  push bx
  mov ah, #0x0e
  mov al, 4[bp]
  xor bx,bx
  int #0x10
  pop bx
  pop bp
! 919 endasm
!BCC_ENDASM
! 920 }
ret
! 921   void
! 922 send(action, c)
! 923   Bit16u action;
export	_send
_send:
!BCC_EOS
! 924   Bit8u c;
!BCC_EOS
! 925 {
! 926   outb(0xE9, c);
push	bp
mov	bp,sp
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $E9 (used reg = )
mov	ax,#$E9
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 927   if (action & 8) outb(0x403, c);
! Debug: and int = const 8 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*8
test	al,al
je  	.8
.9:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $403 (used reg = )
mov	ax,#$403
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 928   if (action & 4) outb(0x402, c);
.8:
! Debug: and int = const 4 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*4
test	al,al
je  	.A
.B:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $402 (used reg = )
mov	ax,#$402
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 929   if (action & 2) {
.A:
! Debug: and int = const 2 to unsigned short action = [S+2+2] (used reg = )
mov	al,4[bp]
and	al,*2
test	al,al
je  	.C
.D:
! 930     if (c == '\n') wrc
! Debug: logeq int = const $A to unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
cmp	al,*$A
jne 	.E
.F:
! 930 h('\r');
! Debug: list int = const $D (used reg = )
mov	ax,*$D
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 931     wrch(c);
.E:
! Debug: list unsigned char c = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: func () void = wrch+0 (used reg = )
call	_wrch
mov	sp,bp
!BCC_EOS
! 932   }
! 933 }
.C:
pop	bp
ret
! 934   void
! 935 put_int(action, val, width, neg)
! 936   Bit16u action;
export	_put_int
_put_int:
!BCC_EOS
! 937   short val, width;
!BCC_EOS
! 938   bx_bool neg;
!BCC_EOS
! 939 {
! 940   short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
cwd
idiv	bx
! Debug: eq int = ax+0 to short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 941   if (nval)
mov	ax,-2[bp]
test	ax,ax
beq 	.10
.11:
! 942     put_int(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 943   else {
jmp .12
.10:
! 944     while (--width > 0) send(action, ' ');
jmp .14
.15:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 945     if (neg) send(action, '-');
.14:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.15
.16:
.13:
mov	ax,$A[bp]
test	ax,ax
je  	.17
.18:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 946   }
.17:
! 947   send(action, val - (nval * 10) + '0');
.12:
! Debug: mul int = const $A to short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub int = ax+0 to short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to int = ax+0 (used reg = )
! Debug: list int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 948 }
mov	sp,bp
pop	bp
ret
! 949   void
! Register BX used in function put_int
! 950 put_uint(action, val, width, neg)
! 951   Bit16u action;
export	_put_uint
_put_uint:
!BCC_EOS
! 952   unsigned short val;
!BCC_EOS
! 953   short width;
!BCC_EOS
! 954   bx_bool neg;
!BCC_EOS
! 955 {
! 956   unsigned short nval = val / 10;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: div int = const $A to unsigned short val = [S+4+4] (used reg = )
mov	ax,6[bp]
mov	bx,*$A
call	idiv_u
! Debug: eq unsigned int = ax+0 to unsigned short nval = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 957   if (nval)
mov	ax,-2[bp]
test	ax,ax
je  	.19
.1A:
! 958     put_uint(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+4+8] (used reg = )
push	$A[bp]
! Debug: sub int = const 1 to short width = [S+6+6] (used reg = )
mov	ax,8[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned short nval = [S+8-4] (used reg = )
push	-2[bp]
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 959   else {
jmp .1B
.19:
! 960     while (--width > 0) send(action, ' ');
jmp .1D
.1E:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 961     if (neg) send(action, '-');
.1D:
! Debug: predec short width = [S+4+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.1E
.1F:
.1C:
mov	ax,$A[bp]
test	ax,ax
je  	.20
.21:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 962   }
.20:
! 963   send(action, val - (nval * 10) + '0');
.1B:
! Debug: mul int = const $A to unsigned short nval = [S+4-4] (used reg = )
mov	ax,-2[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: sub unsigned int = ax+0 to unsigned short val = [S+4+4] (used reg = )
push	ax
mov	ax,6[bp]
sub	ax,-4[bp]
inc	sp
inc	sp
! Debug: add int = const $30 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 964 }
mov	sp,bp
pop	bp
ret
! 965   void
! Register BX used in function put_uint
! 966 put_luint(action, val, width, neg)
! 967   Bit16u action;
export	_put_luint
_put_luint:
!BCC_EOS
! 968   unsigned long val;
!BCC_EOS
! 969   short width;
!BCC_EOS
! 970   bx_bool neg;
!BCC_EOS
! 971 {
! 972   unsigned long nval = val / 10;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: div unsigned long = const $A to unsigned long val = [S+6+4] (used reg = )
mov	ax,*$A
xor	bx,bx
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long nval = [S+6-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 973   if (nval)
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
je  	.22
.23:
! 974     put_luint(action, nval, width - 1, neg);
! Debug: list unsigned short neg = [S+6+$A] (used reg = )
push	$C[bp]
! Debug: sub int = const 1 to short width = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list unsigned long nval = [S+$A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short action = [S+$E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 975   else {
jmp .24
.22:
! 976     while (--width > 0) send(action, ' ');
jmp .26
.27:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 977     if (neg) send(action, '-');
.26:
! Debug: predec short width = [S+6+8] (used reg = )
mov	ax,$A[bp]
dec	ax
mov	$A[bp],ax
! Debug: gt int = const 0 to short = ax+0 (used reg = )
test	ax,ax
jg 	.27
.28:
.25:
mov	ax,$C[bp]
test	ax,ax
je  	.29
.2A:
! Debug: list int = const $2D (used reg = )
mov	ax,*$2D
push	ax
! Debug: list unsigned short action = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 978   }
.29:
! 979   send(action, val - (nval * 10) + '0');
.24:
! Debug: mul unsigned long = const $A to unsigned long nval = [S+6-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$A
xor	bx,bx
lea	di,-4[bp]
call	lmulul
! Debug: sub unsigned long = bx+0 to unsigned long val = [S+6+4] (used reg = )
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-8[bp]
call	lsubul
add	sp,*4
! Debug: add unsigned long = const $30 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$30
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-$C[bp]
call	laddul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*6
!BCC_EOS
! 980 }
mov	sp,bp
pop	bp
ret
! 981 void put_str(action, segment, offset)
! Register BX used in function put_luint
! 982   Bit16u action;
export	_put_str
_put_str:
!BCC_EOS
! 983   Bit16u segment;
!BCC_EOS
! 984   Bit16u offset;
!BCC_EOS
! 985 {
! 986   Bit8u c;
!BCC_EOS
! 987   while (c = read_byte(segment, offset)) {
push	bp
mov	bp,sp
dec	sp
dec	sp
jmp .2C
.2D:
! 988     send(action, c);
! Debug: list unsigned char c = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 989     offset++;
! Debug: postinc unsigned short offset = [S+4+6] (used reg = )
mov	ax,8[bp]
inc	ax
mov	8[bp],ax
!BCC_EOS
! 990   }
! 991 }
.2C:
! Debug: list unsigned short offset = [S+4+6] (used reg = )
push	8[bp]
! Debug: list unsigned short segment = [S+6+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+4-3] (used reg = )
mov	-1[bp],al
test	al,al
jne	.2D
.2E:
.2B:
mov	sp,bp
pop	bp
ret
! 992   void
! 993 delay_ticks(ticks)
! 994   Bit16u ticks;
export	_delay_ticks
_delay_ticks:
!BCC_EOS
! 995 {
! 996   long ticks_to_wait, delta;
!BCC_EOS
! 997   Bit32u prev_ticks, t;
!BCC_EOS
! 998 #asm
push	bp
mov	bp,sp
add	sp,*-$10
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  pushf
  sti
! 1001 endasm
!BCC_ENDASM
!BCC_EOS
! 1002   ticks_to_wait = ticks;
! Debug: eq unsigned short ticks = [S+$12+2] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,4[bp]
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1003   prev_ticks = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 1004   do
! 1005   {
.31:
! 1006 #asm
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
    hlt
! 1008 endasm
!BCC_ENDASM
!BCC_EOS
! 1009     t = read_dword(0x0, 0x46c);
! Debug: list int = const $46C (used reg = )
mov	ax,#$46C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long t = [S+$12-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 1010     if (t > prev_ticks)
! Debug: gt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jae 	.32
.33:
! 1011     {
! 1012       delta = t - prev_ticks;
! Debug: sub unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
lea	di,-$C[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to long delta = [S+$12-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1013       ticks_to_wait -= delta;
! Debug: subab long delta = [S+$12-$A] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-8[bp]
call	lsubl
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1014     }
! 1015     else if (t < prev_ticks)
jmp .34
.32:
! Debug: lt unsigned long prev_ticks = [S+$12-$E] to unsigned long t = [S+$12-$12] (used reg = )
mov	ax,-$C[bp]
mov	bx,-$A[bp]
lea	di,-$10[bp]
call	lcmpul
jbe 	.35
.36:
! 1016     {
! 1017       ticks_to_wait -= t;
! Debug: subab unsigned long t = [S+$12-$12] to long ticks_to_wait = [S+$12-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-$10[bp]
call	lsubul
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1018     }
! 1019     prev_ticks = t;
.35:
.34:
! Debug: eq unsigned long t = [S+$12-$12] to unsigned long prev_ticks = [S+$12-$E] (used reg = )
mov	ax,-$10[bp]
mov	bx,-$E[bp]
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! 1020   } while (ticks_to_wait > 0);
.30:
! Debug: gt long = const 0 to long ticks_to_wait = [S+$12-6] (used reg = )
xor	ax,ax
xor	bx,bx
lea	di,-4[bp]
call	lcmpl
blt 	.31
.37:
!BCC_EOS
! 1021 #asm
.2F:
!BCC_EOS
!BCC_ASM
_delay_ticks.ticks	set	$14
.delay_ticks.ticks	set	4
_delay_ticks.t	set	0
.delay_ticks.t	set	-$10
_delay_ticks.prev_ticks	set	4
.delay_ticks.prev_ticks	set	-$C
_delay_ticks.delta	set	8
.delay_ticks.delta	set	-8
_delay_ticks.ticks_to_wait	set	$C
.delay_ticks.ticks_to_wait	set	-4
  cli
  popf
! 1024 endasm
!BCC_ENDASM
!BCC_EOS
! 1025 }
mov	sp,bp
pop	bp
ret
! 1026   Bit8u
! Register BX used in function delay_ticks
! 1027 check_for_keystroke()
! 1028 {
export	_check_for_keystroke
_check_for_keystroke:
! 1029 #asm
!BCC_ASM
  mov ax, #0x100
  int #0x16
  jz no_key
  mov al, #1
  jmp done
no_key:
  xor al, al
done:
! 1038 endasm
!BCC_ENDASM
! 1039 }
ret
! 1040   Bit8u
! 1041 get_keystroke()
! 1042 {
export	_get_keystroke
_get_keystroke:
! 1043 #asm
!BCC_ASM
  mov ax, #0x0
  int #0x16
  xchg ah, al
! 1047 endasm
!BCC_ENDASM
! 1048 }
ret
! 1049   void
! 1050 delay_ticks_and_check_for_keystroke(ticks, count)
! 1051   Bit16u ticks, count;
export	_delay_ticks_and_check_for_keystroke
_delay_ticks_and_check_for_keystroke:
!BCC_EOS
! 1052 {
! 1053   Bit16u i;
!BCC_EOS
! 1054   for (i = 1; i <= count; i++) {
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq int = const 1 to unsigned short i = [S+4-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
!BCC_EOS
jmp .3A
.3B:
! 1055     delay_ticks(ticks)
! 1055 ;
! Debug: list unsigned short ticks = [S+4+2] (used reg = )
push	4[bp]
! Debug: func () void = delay_ticks+0 (used reg = )
call	_delay_ticks
inc	sp
inc	sp
!BCC_EOS
! 1056     if (check_for_keystroke())
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
je  	.3C
.3D:
! 1057       break;
jmp .38
!BCC_EOS
! 1058   }
.3C:
! 1059 }
.39:
! Debug: postinc unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
inc	ax
mov	-2[bp],ax
.3A:
! Debug: le unsigned short count = [S+4+4] to unsigned short i = [S+4-4] (used reg = )
mov	ax,-2[bp]
cmp	ax,6[bp]
jbe	.3B
.3E:
.38:
mov	sp,bp
pop	bp
ret
! 1060   void
! 1061 bios_printf(action, s)
! 1062   Bit16u action;
export	_bios_printf
_bios_printf:
!BCC_EOS
! 1063   Bit8u *s;
!BCC_EOS
! 1064 {
! 1065   Bit8u c, format_char;
!BCC_EOS
! 1066   bx_bool in_format;
!BCC_EOS
! 1067   short i;
!BCC_EOS
! 1068   Bit16u *arg_ptr;
!BCC_EOS
! 1069   Bit16u arg_seg, arg, nibble, hibyte, shift_count, format_width, hexadd;
!BCC_EOS
! 1070   arg_ptr = &s;
push	bp
mov	bp,sp
add	sp,*-$16
! Debug: eq * * unsigned char s = S+$18+4 to * unsigned short arg_ptr = [S+$18-$A] (used reg = )
lea	bx,6[bp]
mov	-8[bp],bx
!BCC_EOS
! 1071   arg_seg = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short arg_seg = [S+$18-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 1072   in_format = 0;
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1073   format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1074   if ((action & (2 | 4 | 1)) == (2 | 4 | 1)) {
! Debug: and int = const 7 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*7
! Debug: logeq int = const 7 to unsigned char = al+0 (used reg = )
cmp	al,*7
jne 	.3F
.40:
! 1075     outb(0x401, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $401 (used reg = )
mov	ax,#$401
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1076     bios_printf (2, "FATAL: ");
! Debug: list * char = .41+0 (used reg = )
mov	bx,#.41
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1077   }
! 1078   while (c = read_byte(get_CS(), s)) {
.3F:
br 	.43
.44:
! 1079     if ( c == '%' ) {
! Debug: logeq int = const $25 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$25
jne 	.45
.46:
! 1080       in_format = 1;
! Debug: eq int = const 1 to unsigned short in_format = [S+$18-6] (used reg = )
mov	ax,*1
mov	-4[bp],ax
!BCC_EOS
! 1081       format_width = 0;
! Debug: eq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
xor	ax,ax
mov	-$14[bp],ax
!BCC_EOS
! 1082       }
! 1083     else if (in_format) {
br 	.47
.45:
mov	ax,-4[bp]
test	ax,ax
beq 	.48
.49:
! 1084       if ( (c>='0') && (c<='9') ) {
! Debug: ge int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$30
jb  	.4A
.4C:
! Debug: le int = const $39 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$39
ja  	.4A
.4B:
! 1085         format_width = (format_width * 10) + (c - '0');
! Debug: sub int = const $30 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
add	ax,*-$30
push	ax
! Debug: mul int = const $A to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
! Debug: add unsigned int (temp) = [S+$1A-$1A] to unsigned int = ax+0 (used reg = )
add	ax,-$18[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1086         }
! 1087       else {
br 	.4D
.4A:
! 1088         arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1089         arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1090         if (c == 'x' || c == 'X') {
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.4F
.50:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
jne 	.4E
.4F:
! 1091           if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.51
.52:
! 1092             format_width = 4;
! Debug: eq int = const 4 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*4
mov	-$14[bp],ax
!BCC_EOS
! 1093           if (c == 'x')
.51:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.53
.54:
! 1094             hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1095           else
! 1096             hexadd = 'A';
jmp .55
.53:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1097           for (i=format_width-1; i>=0; i--) {
.55:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .58
.59:
! 1098             nibble = (arg >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
! Debug: sr int = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	bx,ax
mov	ax,-$C[bp]
mov	cx,bx
shr	ax,cl
! Debug: and int = const $F to unsigned int = ax+0 (used reg = )
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short nibble = [S+$18-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 1099             send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.5A
.5B:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .5C
.5A:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.5C:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1100             }
! 1101           }
.57:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.58:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.59
.5D:
.56:
! 1102         else if (c == 'u') {
br 	.5E
.4E:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.5F
.60:
! 1103           put_uint(action, arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_uint+0 (used reg = )
call	_put_uint
add	sp,*8
!BCC_EOS
! 1104           }
! 1105         else if (c == 'l') {
br 	.61
.5F:
! Debug: logeq int = const $6C to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$6C
bne 	.62
.63:
! 1106           s++;
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1107           c = read_byte(get_CS(), s);
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1108           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1109           hibyte = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 1110           if (c == 'd') {
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
bne 	.64
.65:
! 1111             if (hibyte & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$10[bp]
and	ax,#$8000
test	ax,ax
je  	.66
.67:
! 1112               put_luint(action, 0L-(((Bit32u) hibyte << 16) | arg), format_width-1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: sub unsigned long = bx+0 to long = const 0 (used reg = )
push	bx
push	ax
xor	ax,ax
xor	bx,bx
lea	di,-$1E[bp]
call	lsubul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1113             else
! 1114               put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
jmp .68
.66:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1115            }
.68:
! 1116           else if (c == 'u') {
br 	.69
.64:
! Debug: logeq int = const $75 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$75
jne 	.6A
.6B:
! 1117             put_luint(action, ((Bit32u) hibyte << 16) | arg, format_width, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1C-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$20-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$20-$20] to unsigned long = bx+0 (used reg = )
lea	di,-$1E[bp]
call	lorul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short action = [S+$20+2] (used reg = )
push	4[bp]
! Debug: func () void = put_luint+0 (used reg = )
call	_put_luint
add	sp,*$A
!BCC_EOS
! 1118            }
! 1119           else if (c == 'x' || c == 'X')
br 	.6C
.6A:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
je  	.6E
.6F:
! Debug: logeq int = const $58 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
bne 	.6D
.6E:
! 1120            {
! 1121             if (format_width == 0)
! Debug: logeq int = const 0 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
test	ax,ax
jne 	.70
.71:
! 1122               format_width = 8;
! Debug: eq int = const 8 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,*8
mov	-$14[bp],ax
!BCC_EOS
! 1123             if (c == 'x')
.70:
! Debug: logeq int = const $78 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$78
jne 	.72
.73:
! 1124               hexadd = 'a';
! Debug: eq int = const $61 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$61
mov	-$16[bp],ax
!BCC_EOS
! 1125             else
! 1126               hexadd = 'A';
jmp .74
.72:
! Debug: eq int = const $41 to unsigned short hexadd = [S+$18-$18] (used reg = )
mov	ax,*$41
mov	-$16[bp],ax
!BCC_EOS
! 1127             for (i=format_width-1; i>=0; i--) {
.74:
! Debug: sub int = const 1 to unsigned short format_width = [S+$18-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: eq unsigned int = ax-1 to short i = [S+$18-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
!BCC_EOS
jmp .77
.78:
! 1128             
! 1128   nibble = ((((Bit32u) hibyte <<16) | arg) >> (4 * i)) & 0x000f;
! Debug: mul short i = [S+$18-8] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,-6[bp]
shl	ax,*1
shl	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short arg = [S+$1A-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short hibyte = [S+$1E-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
lea	di,-$1C[bp]
call	lorul
add	sp,*4
! Debug: sr int (temp) = [S+$1A-$1A] to unsigned long = bx+0 (used reg = )
mov	di,-$18[bp]
call	lsrul
inc	sp
inc	sp
! Debug: and unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 1129               send (action, (nibble<=9)? (nibble+'0') : (nibble-10+hexadd));
! Debug: le int = const 9 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,*9
ja  	.79
.7A:
! Debug: add int = const $30 to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
add	ax,*$30
jmp .7B
.79:
! Debug: sub int = const $A to unsigned short nibble = [S+$18-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: add unsigned short hexadd = [S+$18-$18] to unsigned int = ax-$A (used reg = )
add	ax,*-$A
add	ax,-$16[bp]
.7B:
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1130               }
! 1131            }
.76:
! Debug: postdec short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
dec	ax
mov	-6[bp],ax
.77:
! Debug: ge int = const 0 to short i = [S+$18-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jge	.78
.7C:
.75:
! 1132           }
.6D:
.6C:
.69:
! 1133         else if (c == 'd') {
br 	.7D
.62:
! Debug: logeq int = const $64 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$64
jne 	.7E
.7F:
! 1134           if (arg & 0x8000)
! Debug: and unsigned int = const $8000 to unsigned short arg = [S+$18-$E] (used reg = )
mov	ax,-$C[bp]
and	ax,#$8000
test	ax,ax
je  	.80
.81:
! 1135             put_int(action, -arg, format_width - 1, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: sub int = const 1 to unsigned short format_width = [S+$1A-$16] (used reg = )
mov	ax,-$14[bp]
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: neg unsigned short arg = [S+$1C-$E] (used reg = )
xor	ax,ax
sub	ax,-$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1136           else
! 1137             put_int(action, arg, format_width, 0);
jmp .82
.80:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short format_width = [S+$1A-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short arg = [S+$1C-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1E+2] (used reg = )
push	4[bp]
! Debug: func () void = put_int+0 (used reg = )
call	_put_int
add	sp,*8
!BCC_EOS
! 1138           }
.82:
! 1139         else if (c == 's') {
jmp .83
.7E:
! Debug: logeq int = const $73 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$73
jne 	.84
.85:
! 1140           put_str(action, get_CS(), arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1141           }
! 1142         else if (c == 'S') {
jmp .86
.84:
! Debug: logeq int = const $53 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
jne 	.87
.88:
! 1143           hibyte = arg;
! Debug: eq unsigned short arg = [S+$18-$E] to unsigned short hibyte = [S+$18-$12] (used reg = )
mov	ax,-$C[bp]
mov	-$10[bp],ax
!BCC_EOS
! 1144           arg_ptr++;
! Debug: postinc * unsigned short arg_ptr = [S+$18-$A] (used reg = )
mov	bx,-8[bp]
inc	bx
inc	bx
mov	-8[bp],bx
!BCC_EOS
! 1145           arg = read_word(arg_seg, arg_ptr);
! Debug: list * unsigned short arg_ptr = [S+$18-$A] (used reg = )
push	-8[bp]
! Debug: list unsigned short arg_seg = [S+$1A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short arg = [S+$18-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 1146           put_str(action, hibyte, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short hibyte = [S+$1A-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short action = [S+$1C+2] (used reg = )
push	4[bp]
! Debug: func () void = put_str+0 (used reg = )
call	_put_str
add	sp,*6
!BCC_EOS
! 1147           }
! 1148         else if (c == 'c') {
jmp .89
.87:
! Debug: logeq int = const $63 to unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$63
jne 	.8A
.8B:
! 1149           send(action, arg);
! Debug: list unsigned short arg = [S+$18-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1150           }
! 1151         else
! 1152           bios_printf((2 | 4 | 1), "bios_printf: unknown format\n");
jmp .8C
.8A:
! Debug: list * char = .8D+0 (used reg = )
mov	bx,#.8D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1153           in_format = 0;
.8C:
.89:
.86:
.83:
.7D:
.61:
.5E:
! Debug: eq int = const 0 to unsigned short in_format = [S+$18-6] (used reg = )
xor	ax,ax
mov	-4[bp],ax
!BCC_EOS
! 1154         }
! 1155       }
.4D:
! 1156     else {
jmp .8E
.48:
! 1157       send(action, c);
! Debug: list unsigned char c = [S+$18-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short action = [S+$1A+2] (used reg = )
push	4[bp]
! Debug: func () void = send+0 (used reg = )
call	_send
add	sp,*4
!BCC_EOS
! 1158       }
! 1159     s ++;
.8E:
.47:
! Debug: postinc * unsigned char s = [S+$18+4] (used reg = )
mov	bx,6[bp]
inc	bx
mov	6[bp],bx
!BCC_EOS
! 1160     }
! 1161   if (action & 1) {
.43:
! Debug: list * unsigned char s = [S+$18+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = get_CS+0 (used reg = )
call	_get_CS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$18-3] (used reg = )
mov	-1[bp],al
test	al,al
bne 	.44
.8F:
.42:
! Debug: and int = const 1 to unsigned short action = [S+$18+2] (used reg = )
mov	al,4[bp]
and	al,*1
test	al,al
je  	.90
.91:
! 1162 #asm
!BCC_EOS
!BCC_ASM
_bios_printf.format_width	set	2
.bios_printf.format_width	set	-$14
_bios_printf.format_char	set	$14
.bios_printf.format_char	set	-2
_bios_printf.hibyte	set	6
.bios_printf.hibyte	set	-$10
_bios_printf.arg_ptr	set	$E
.bios_printf.arg_ptr	set	-8
_bios_printf.action	set	$1A
.bios_printf.action	set	4
_bios_printf.i	set	$10
.bios_printf.i	set	-6
_bios_printf.arg_seg	set	$C
.bios_printf.arg_seg	set	-$A
_bios_printf.shift_count	set	4
.bios_printf.shift_count	set	-$12
_bios_printf.in_format	set	$12
.bios_printf.in_format	set	-4
_bios_printf.s	set	$1C
.bios_printf.s	set	6
_bios_printf.nibble	set	8
.bios_printf.nibble	set	-$E
_bios_printf.c	set	$15
.bios_printf.c	set	-1
_bios_printf.hexadd	set	0
.bios_printf.hexadd	set	-$16
_bios_printf.arg	set	$A
.bios_printf.arg	set	-$C
    cli
 halt2_loop:
    hlt
    jmp halt2_loop
! 1167 endasm
!BCC_ENDASM
!BCC_EOS
! 1168     }
! 1169 }
.90:
mov	sp,bp
pop	bp
ret
! 1170   void
! Register BX used in function bios_printf
! 1171 keyboard_init()
! 1172 {
export	_keyboard_init
_keyboard_init:
! 1173     Bit16u max;
!BCC_EOS
! 1174     max=0xffff;
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1175     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .93
.94:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1176     max=2;
.93:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.95
.96:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.94
.95:
.92:
! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
mov	ax,*2
mov	-2[bp],ax
!BCC_EOS
! 1177     while (--max > 0) {
jmp .98
.99:
! 1178         outb(0x80, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1179         if (inb(0x64) & 0x01) {
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
je  	.9A
.9B:
! 1180             inb(0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 1181             max = 2;
! Debug: eq int = const 2 to unsigned short max = [S+4-4] (used reg = )
mov	ax,*2
mov	-2[bp],ax
!BCC_EOS
! 1182             }
! 1183         }
.9A:
! 1184     outb(0x64, 0xaa);
.98:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.99
.9C:
.97:
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1185     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1186     while ( (inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x00);
jmp .9E
.9F:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1187     if (max==0x0) keyboard_panic(00);
.9E:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.A0
.A1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.9F
.A0:
.9D:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A2
.A3:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1188     max=0xffff;
.A2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1189     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x01);
jmp .A5
.A6:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1190     if (max==0x0) keyboard_panic(01);
.A5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.A7
.A8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.A6
.A7:
.A4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.A9
.AA:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1191     if ((inb(0x60) != 0x55)){
.A9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $55 to unsigned char = al+0 (used reg = )
cmp	al,*$55
je  	.AB
.AC:
! 1192         keyboard_panic(991);
! Debug: list int = const $3DF (used reg = )
mov	ax,#$3DF
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1193     }
! 1194     outb(0x64,0xab);
.AB:
! Debug: list int = const $AB (used reg = )
mov	ax,#$AB
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1195     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1196     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x10);
jmp .AE
.AF:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1197     if (max==0x0) keyboard_panic(10);
.AE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.B0
.B1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.AF
.B0:
.AD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B2
.B3:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1198     max=0xffff;
.B2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1199     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x11);
jmp .B5
.B6:
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1200     if (max==0x0) keyboard_panic(11);
.B5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.B7
.B8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.B6
.B7:
.B4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.B9
.BA:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1201     if ((inb(0x60) != 0x00)) {
.B9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.BB
.BC:
! 1202         keyboard_panic(992);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1203     }
! 1204     outb(0x64,0xae);
.BB:
! Debug: list int = const $AE (used reg = )
mov	ax,#$AE
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1205     outb(0x64,0xa8);
! Debug: list int = const $A8 (used reg = )
mov	ax,#$A8
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1206     outb(0x60, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1207     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1208     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x20)
jmp .BE
.BF:
! 1208 ;
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1209     if (max==0x0) keyboard_panic(20);
.BE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.C0
.C1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.BF
.C0:
.BD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C2
.C3:
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1210     max=0xffff;
.C2:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1211     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x21);
jmp .C5
.C6:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1212     if (max==0x0) keyboard_panic(21);
.C5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.C7
.C8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.C6
.C7:
.C4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.C9
.CA:
! Debug: list int = const $15 (used reg = )
mov	ax,*$15
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1213     if ((inb(0x60) != 0xfa)) {
.C9:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.CB
.CC:
! 1214         keyboard_panic(993);
! Debug: list int = const $3E1 (used reg = )
mov	ax,#$3E1
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1215     }
! 1216     max=0xffff;
.CB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1217     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x31);
jmp .CE
.CF:
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1218     if (max==0x0) keyboard_panic(31);
.CE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.D0
.D1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.CF
.D0:
.CD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.D2
.D3:
! Debug: list int = const $1F (used reg = )
mov	ax,*$1F
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1219     if ((inb(0x60) != 0xaa)) {
.D2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $AA to unsigned char = al+0 (used reg = )
cmp	al,#$AA
je  	.D4
.D5:
! 1220         keyboard_panic(994);
! Debug: list int = const $3E2 (used reg = )
mov	ax,#$3E2
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1221     }
! 1222     outb(0x60, 0xf5);
.D4:
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1223     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1224     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x40);
jmp .D7
.D8:
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1225     if (max==0x0) keyboard_panic(40);
.D7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.D9
.DA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.D8
.D9:
.D6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.DB
.DC:
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1226     max=0xffff;
.DB:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1227     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x41);
jmp .DE
.DF:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1228     if (max==0x0) keyboard_panic(41);
.DE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.E0
.E1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.DF
.E0:
.DD:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.E2
.E3:
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1229     if ((inb(0x60) != 0xfa)) {
.E2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.E4
.E5:
! 1230         keyboard_panic(995);
! Debug: list int = const $3E3 (used reg = )
mov	ax,#$3E3
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1231     }
! 1232     outb(0x64, 0x60);
.E4:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1233     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1234     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x50);
jmp .E7
.E8:
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1235     if (max==0x0) keyboard_panic(50);
.E7:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.E9
.EA:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.E8
.E9:
.E6:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.EB
.EC:
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1236     outb(0x60, 0x61);
.EB:
! Debug: list int = const $61 (used reg = )
mov	ax,*$61
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1237     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1238     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x60);
jmp .EE
.EF:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1239     if (max==0x0) keyboard_panic(60);
.EE:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F0
.F1:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.EF
.F0:
.ED:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F2
.F3:
! Debug: list int = const $3C (used reg = )
mov	ax,*$3C
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1240     outb(0x60, 0xf4);
.F2:
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1241     max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1242     while ((inb(0x64) & 0x02) && (--max>0)) outb(0x80, 0x70);
jmp .F5
.F6:
! Debug: list int = const $70 (used reg = )
mov	ax,*$70
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1243     if (max==0x0) keyboard_panic(70);
.F5:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.F7
.F8:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.F6
.F7:
.F4:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.F9
.FA:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1244     max=0xffff;
.F9:
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+4-4] (used reg = )
mov	ax,#$FFFF
mov	-2[bp],ax
!BCC_EOS
! 1245     while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x71);
jmp .FC
.FD:
! Debug: list int = const $71 (used reg = )
mov	ax,*$71
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1246     if (max==0x0) keyboard_panic(70);
.FC:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.FE
.FF:
! Debug: predec unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
dec	ax
mov	-2[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.FD
.FE:
.FB:
! Debug: logeq int = const 0 to unsigned short max = [S+4-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
jne 	.100
.101:
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1247     if ((inb(0x60) != 0xfa)) {
.100:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: ne int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
je  	.102
.103:
! 1248         keyboard_panic(996);
! Debug: list int = const $3E4 (used reg = )
mov	ax,#$3E4
push	ax
! Debug: func () void = keyboard_panic+0 (used reg = )
call	_keyboard_panic
inc	sp
inc	sp
!BCC_EOS
! 1249     }
! 1250     outb(0x80, 0x77);
.102:
! Debug: list int = const $77 (used reg = )
mov	ax,*$77
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1251 }
mov	sp,bp
pop	bp
ret
! 1252   void
! 1253 keyboard_panic(status)
! 1254   Bit16u status;
export	_keyboard_panic
_keyboard_panic:
!BCC_EOS
! 1255 {
! 1256   bios_printf((2 | 4 | 1), "Keyboard error:%u\n",status);
push	bp
mov	bp,sp
! Debug: list unsigned short status = [S+2+2] (used reg = )
push	4[bp]
! Debug: list * char = .104+0 (used reg = )
mov	bx,#.104
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1257 }
pop	bp
ret
! 1258   void
! Register BX used in function keyboard_panic
! 1259 machine_reset()
! 1260 {
export	_machine_reset
_machine_reset:
! 1261 #asm
!BCC_ASM
;we must check whether 0xFE is set or not
;if it is s3 resume, just jmp back to normal Post Entry
;below port io will prevent s3 resume
  mov al, #0x0f
  out 0x70, al
  in al, 0x71
  cmp al, #0xFE
  jz post
! 1270 endasm
!BCC_ENDASM
! 1271   outb(0x64, 0x60);
push	bp
mov	bp,sp
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1272   outb(0x60, 0x14);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1273   outb(0x64, 0xfe);
! Debug: list int = const $FE (used reg = )
mov	ax,#$FE
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1274   bios_printf((2 | 4 | 1), "Couldn't reset the machine\n");
! Debug: list * char = .105+0 (used reg = )
mov	bx,#.105
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1275 }
pop	bp
ret
! 1276   void
! Register BX used in function machine_reset
! 1277 clobber_entry_point()
! 1278 {
export	_clobber_entry_point
_clobber_entry_point:
! 1279     write_word(0xffff, 0x0001, machine_reset);
push	bp
mov	bp,sp
! Debug: cast * () void = const 0 to () void = machine_reset+0 (used reg = )
! Debug: list * () void = machine_reset+0 (used reg = )
mov	bx,#_machine_reset
push	bx
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 1280 }
pop	bp
ret
! 1281   void
! Register BX used in function clobber_entry_point
! 1282 shutdown_status_panic(status)
! 1283   Bit16u status;
export	_shutdown_status_panic
_shutdown_status_panic:
!BCC_EOS
! 1284 {
! 1285   bios_printf((2 | 4 | 1), "Unimplemented shutdown statu
push	bp
mov	bp,sp
! 1285 s: %02x\n",(Bit8u)status);
! Debug: list unsigned char status = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list * char = .106+0 (used reg = )
mov	bx,#.106
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1286 }
pop	bp
ret
! 1287 void s3_resume_panic()
! Register BX used in function shutdown_status_panic
! 1288 {
export	_s3_resume_panic
_s3_resume_panic:
! 1289   bios_printf((2 | 4 | 1), "Returned from s3_resume.\n");
push	bp
mov	bp,sp
! Debug: list * char = .107+0 (used reg = )
mov	bx,#.107
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1290 }
pop	bp
ret
! 1291 void
! Register BX used in function s3_resume_panic
! 1292 print_bios_banner()
! 1293 {
export	_print_bios_banner
_print_bios_banner:
! 1294   bios_printf(2, "Bochs"" BIOS - build: %s\n%s\nOptions: ", "06/23/99", bios_cvs_version_string);
push	bp
mov	bp,sp
! Debug: list * char = bios_cvs_version_string+0 (used reg = )
mov	bx,#_bios_cvs_version_string
push	bx
! Debug: list * char = .109+0 (used reg = )
mov	bx,#.109
push	bx
! Debug: list * char = .108+0 (used reg = )
mov	bx,#.108
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1295   bios_printf(2, "apmbios " "pcibios " "eltorito " "PMM " "\n\n");
! Debug: list * char = .10A+0 (used reg = )
mov	bx,#.10A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1296 }
pop	bp
ret
! 1297 static char drivetypes[][10]={"", "Floppy","Hard Disk","CD-Rom", "Network"};
! Register BX used in function print_bios_banner
.data
_drivetypes:
.10B:
.byte	0
.blkb	9
.10C:
.ascii	"Floppy"
.byte	0
.blkb	3
.10D:
.ascii	"Hard Disk"
.byte	0
.10E:
.ascii	"CD-Rom"
.byte	0
.blkb	3
.10F:
.ascii	"Network"
.byte	0
.blkb	2
!BCC_EOS
! 1298 static void
! 1299 init_boot_vectors()
! 1300 {
.text
_init_boot_vectors:
! 1301   ipl_entry_t e;
!BCC_EOS
! 1302   Bit16u count = 0;
push	bp
mov	bp,sp
add	sp,*-$12
! Debug: eq int = const 0 to unsigned short count = [S+$14-$14] (used reg = )
xor	ax,ax
mov	-$12[bp],ax
!BCC_EOS
! 1303   Bit16u ss = get_SS();
dec	sp
dec	sp
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$16-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 1304   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$18-$18] (used reg = )
mov	-$16[bp],ax
!BCC_EOS
! 1305   memsetb(ebda_seg, 0x0300, 0, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $300 (used reg = )
mov	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$1E-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 1306   write_word(ebda_seg, 0x0384, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1307   e.type = 0x01; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 1 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*1
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1308   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1309   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1310   e.type = 0x02; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 2 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*2
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1311   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1312   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1313   e.type = 0x03; e.flags = 0; e.vector = 0; e.description = 0; e.reserved = 0;
! Debug: eq int = const 3 to unsigned short e = [S+$18-$12] (used reg = )
mov	ax,*3
mov	-$10[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned short e = [S+$18-$10] (used reg = )
xor	ax,ax
mov	-$E[bp],ax
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$C[bp],ax
mov	-$A[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! Debug: eq int = const 0 to unsigned long e = [S+$18-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1314   memcpyb(ebda_seg, 0x0300 + count * sizeof (e), ss, &e, sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * struct  e = S+$1A-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$1C-$16] (used reg = )
push	-$14[bp]
! Debug: mul int = const $10 to unsigned short count = [S+$1E-$14] (used reg = )
mov	ax,-$12[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$20-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1315   count++;
! Debug: postinc unsigned short count = [S+$18-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1316   write_word(ebda_seg, 0x0380, count);
! Debug: list unsigned short count = [S+$18-$14] (used reg = )
push	-$12[bp]
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1317   write_word(ebda_seg, 0x0382, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $382 (used reg = )
mov	ax,#$382
push	ax
! Debug: list unsigned short ebda_seg = [S+$1C-$18] (used reg = )
push	-$16[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1318 }
mov	sp,bp
pop	bp
ret
! 1319 static Bit8u
! Register BX used in function init_boot_vectors
! 1320 get_boot_vector(i, e)
! 1321 Bit16u i; ipl_entry_t *e;
_get_boot_vector:
!BCC_EOS
!BCC_EOS
! 1322 {
! 1323   Bit16u count;
!BCC_EOS
! 1324   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-4
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1325   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+8-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1326   count = read_word(ebda_seg, 0x0380);
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-8] (used reg = )
push	-6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+8-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1327   if (i >= count) return 0;
! Debug: ge unsigned short count = [S+8-4] to unsigned short i = [S+8+2] (used reg = )
mov	ax,4[bp]
cmp	ax,-2[bp]
jb  	.110
.111:
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1328   memcpyb(ss, e, ebda_seg, 0x0300 + i * sizeof (*e), sizeof (*e));
.110:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned short i = [S+$A+2] (used reg = )
mov	ax,4[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-8] (used reg = )
push	-6[bp]
! Debug: list * struct  e = [S+$E+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$10-6] (used reg = )
push	-4[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1329   return 1;
mov	al,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1330 }
! 1331   void
! 1332 interactive_bootkey()
! 1333 {
export	_interactive_bootkey
_interactive_bootkey:
! 1334   ipl_entry_t e;
!BCC_EOS
! 1335   Bit16u count;
!BCC_EOS
! 1336   char description[33];
!BCC_EOS
! 1337   Bit8u scan_code;
!BCC_EOS
! 1338   Bit8u i;
!BCC_EOS
! 1339   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$38
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$3A-$3A] (used reg = )
mov	-$38[bp],ax
!BCC_EOS
! 1340   Bit16u valid_choice = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short valid_choice = [S+$3C-$3C] (used reg = )
xor	ax,ax
mov	-$3A[bp],ax
!BCC_EOS
! 1341   Bit16u ebda_seg = read_word(0x0040, 0x000E);
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$3E-$3E] (used reg = )
mov	-$3C[bp],ax
!BCC_EOS
! 1342   bios_printf(2, "\n\nPress F12 for boot menu.\n\n");
! Debug: list * char = .112+0 (used reg = )
mov	bx,#.112
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1343   while (check_for_keystroke())
! 1344   {
br 	.114
.115:
! 1345     scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1346     if (scan_code != 0x86)
! Debug: ne int = const $86 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,#$86
je  	.116
.117:
! 1347       continue;
br 	.114
!BCC_EOS
! 1348     while (check_for_keystroke())
.116:
! 1349       get_keystroke();
jmp .119
.11A:
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
!BCC_EOS
! 1350     bios_printf(2, "Select boot device:\n\n");
.119:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
jne	.11A
.11B:
.118:
! Debug: list * char = .11C+0 (used reg = )
mov	bx,#.11C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1351     count = read_word(ebda_seg, 0x0380);
! Debug: list int = const $380 (used reg = )
mov	ax,#$380
push	ax
! Debug: list unsigned short ebda_seg = [S+$40-$3E] (used reg = )
push	-$3C[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$3E-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 1352     for (i = 0; i < count; i++)
! Debug: eq int = const 0 to unsigned char i = [S+$3E-$37] (used reg = )
xor	al,al
mov	-$35[bp],al
!BCC_EOS
!BCC_EOS
! 1353     {
br 	.11F
.120:
! 1354       memcpyb(ss, &
! 1354 e, ebda_seg, 0x0300 + i * sizeof (e), sizeof (e));
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: mul int = const $10 to unsigned char i = [S+$40-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: add unsigned int = ax+0 to int = const $300 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$300 (used reg = )
add	ax,#$300
push	ax
! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
push	-$3C[bp]
! Debug: list * struct  e = S+$44-$12 (used reg = )
lea	bx,-$10[bp]
push	bx
! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1355       bios_printf(2, "%d. ", i+1);
! Debug: add int = const 1 to unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * char = .121+0 (used reg = )
mov	bx,#.121
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1356       switch(e.type)
mov	ax,-$10[bp]
! 1357       {
br 	.124
! 1358         case 0x01:
! 1359         case 0x02:
.125:
! 1360         case 0x03:
.126:
! 1361           bios_printf(2, "%s\n", drivetypes[e.type]);
.127:
! Debug: ptradd unsigned short e = [S+$3E-$12] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,-$10[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .128+0 (used reg = )
mov	bx,#.128
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1362           break;
br 	.122
!BCC_EOS
! 1363         case 0x80:
! 1364           bios_printf(2, "%s", drivetypes[4]);
.129:
! Debug: list * char = drivetypes+$28 (used reg = )
mov	bx,#_drivetypes+$28
push	bx
! Debug: list * char = .12A+0 (used reg = )
mov	bx,#.12A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1365           if (e.description != 0)
! Debug: ne unsigned long = const 0 to unsigned long e = [S+$3E-$A] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-8[bp]
mov	bx,-6[bp]
lea	di,-2+..FFFF[bp]
call	lcmpul
lea	sp,2+..FFFF[bp]
je  	.12B
.12C:
! 1366           {
! 1367             memcpyb(ss, &description, (Bit16u)(e.description >> 16), (Bit16u)(e.description & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$40-$A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-8[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: sr int = const $10 to unsigned long e = [S+$42-$A] (used reg = )
mov	ax,-8[bp]
mov	bx,-6[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$44-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$46-$3A] (used reg = )
push	-$38[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1368             description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$3E-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 1369             bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$3E-$35 (used reg = )
lea	bx,-$33[bp]
push	bx
! Debug: list unsigned short ss = [S+$40-$3A] (used reg = )
push	-$38[bp]
! Debug: list * char = .12D+0 (used reg = )
mov	bx,#.12D
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1370          }
! 1371          bios_printf(2, "\n");
.12B:
! Debug: list * char = .12E+0 (used reg = )
mov	bx,#.12E
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1372          break;
jmp .122
!BCC_EOS
! 1373       }
! 1374     }
jmp .122
.124:
sub	ax,*1
beq 	.125
sub	ax,*1
beq 	.126
sub	ax,*1
beq 	.127
sub	ax,*$7D
beq 	.129
.122:
..FFFF	=	-$3E
! 1375     count++;
.11E:
! Debug: postinc unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
inc	ax
mov	-$35[bp],al
.11F:
! Debug: lt unsigned short count = [S+$3E-$14] to unsigned char i = [S+$3E-$37] (used reg = )
mov	al,-$35[bp]
xor	ah,ah
cmp	ax,-$12[bp]
blo 	.120
.12F:
.11D:
! Debug: postinc unsigned short count = [S+$3E-$14] (used reg = )
mov	ax,-$12[bp]
inc	ax
mov	-$12[bp],ax
!BCC_EOS
! 1376     while (!valid_choice) {
jmp .131
.132:
! 1377       scan_code = get_keystroke();
! Debug: func () unsigned char = get_keystroke+0 (used reg = )
call	_get_keystroke
! Debug: eq unsigned char = al+0 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	-$34[bp],al
!BCC_EOS
! 1378       if (scan_code == 0x01 || scan_code == 0x58)
! Debug: logeq int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*1
je  	.134
.135:
! Debug: logeq int = const $58 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
cmp	al,*$58
jne 	.133
.134:
! 1379       {
! 1380         valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1381       }
! 1382       else if (scan_code <= count)
jmp .136
.133:
! Debug: le unsigned short count = [S+$3E-$14] to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
cmp	ax,-$12[bp]
ja  	.137
.138:
! 1383       {
! 1384         valid_choice = 1;
! Debug: eq int = const 1 to unsigned short valid_choice = [S+$3E-$3C] (used reg = )
mov	ax,*1
mov	-$3A[bp],ax
!BCC_EOS
! 1385         scan_code -= 1;
! Debug: subab int = const 1 to unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
dec	ax
mov	-$34[bp],al
!BCC_EOS
! 1386         write_word(ebda_seg, 0x0384, scan_code);
! Debug: list unsigned char scan_code = [S+$3E-$36] (used reg = )
mov	al,-$34[bp]
xor	ah,ah
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$42-$3E] (used reg = )
push	-$3C[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1387       }
! 1388     }
.137:
.136:
! 1389     bios_printf(2, "\n");
.131:
mov	ax,-$3A[bp]
test	ax,ax
je 	.132
.139:
.130:
! Debug: list * char = .13A+0 (used reg = )
mov	bx,#.13A
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1390     break;
jmp .113
!BCC_EOS
! 1391   }
! 1392 }
.114:
! Debug: func () unsigned char = check_for_keystroke+0 (used reg = )
call	_check_for_keystroke
test	al,al
bne 	.115
.13B:
.113:
mov	sp,bp
pop	bp
ret
! 1393 void
! Register BX used in function interactive_bootkey
! 1394 print_boot_device(type, desc)
! 1395   Bit16u type; Bit32u desc;
export	_print_boot_device
_print_boot_device:
!BCC_EOS
!BCC_EOS
! 1396 {
! 1397   char description[33];
!BCC_EOS
! 1398   Bit16u ss = get_SS();
push	bp
mov	bp,sp
add	sp,*-$24
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$26-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 1399   if (type == 0x80) type = 0x4;
! Debug: logeq int = const $80 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,#$80
jne 	.13C
.13D:
! Debug: eq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,*4
mov	4[bp],ax
!BCC_EOS
! 1400   if (type == 0 || type > 0x4) bios_printf((2 | 4 | 1), "Bad drive type\n");
.13C:
! Debug: logeq int = const 0 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
je  	.13F
.140:
! Debug: gt int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jbe 	.13E
.13F:
! Debug: list * char = .141+0 (used reg = )
mov	bx,#.141
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1401   bios_printf(2, "Booting from %s", drivetypes[type]);
.13E:
! Debug: ptradd unsigned short type = [S+$26+2] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,4[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .142+0 (used reg = )
mov	bx,#.142
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1402   if (type == 4 && desc != 0) {
! Debug: logeq int = const 4 to unsigned short type = [S+$26+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jne 	.143
.145:
! Debug: ne unsigned long = const 0 to unsigned long desc = [S+$26+4] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,6[bp]
mov	bx,8[bp]
lea	di,-$28[bp]
call	lcmpul
lea	sp,-$24[bp]
je  	.143
.144:
! 1403     memcpyb(ss, &description, (Bit16u)(desc >> 16), (Bit16u)(desc & 0xffff), 32);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: and unsigned long = const $FFFF to unsigned long desc = [S+$28+4] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,6[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: sr int = const $10 to unsigned long desc = [S+$2A+4] (used reg = )
mov	ax,6[bp]
mov	bx,8[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list * [$21] char description = S+$2C-$23 (used reg = )
lea	bx,-$21[bp]
push	bx
! Debug: list unsigned short ss = [S+$2E-$26] (used reg = )
push	-$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 1404     description[32] = 0;
! Debug: eq int = const 0 to char description = [S+$26-3] (used reg = )
xor	al,al
mov	-1[bp],al
!BCC_EOS
! 1405     bios_printf(2, " [%S]", ss, description);
! Debug: list * char description = S+$26-$23 (used reg = )
lea	bx,-$21[bp]
push	bx
! Debug: list unsigned short ss = [S+$28-$26] (used reg = )
push	-$24[bp]
! Debug: list * char = .146+0 (used reg = )
mov	bx,#.146
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1406   }
! 1407   bios_printf(2, "...\n");
.143:
! Debug: list * char = .147+0 (used reg = )
mov	bx,#.147
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1408 }
mov	sp,bp
pop	bp
ret
! 1409   void
! Register BX used in function print_boot_device
! 1410 print_boot_failure(type, reason)
! 1411   Bit16u type; Bit8u reason;
export	_print_boot_failure
_print_boot_failure:
!BCC_EOS
!BCC_EOS
! 1412 {
! 1413   if (type == 0 || type > 0x3) bios_printf((2 | 4 | 1), "Bad drive type\n");
push	bp
mov	bp,sp
! Debug: logeq int = const 0 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
je  	.149
.14A:
! Debug: gt int = const 3 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*3
jbe 	.148
.149:
! Debug: list * char = .14B+0 (used reg = )
mov	bx,#.14B
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1414   bios_printf(2, "Boot from %s failed", drivetypes[type]);
.148:
! Debug: ptradd unsigned short type = [S+2+2] to [5] [$A] char = drivetypes+0 (used reg = )
mov	bx,4[bp]
mov	dx,bx
shl	bx,*1
shl	bx,*1
add	bx,dx
shl	bx,*1
! Debug: cast * char = const 0 to [$A] char = bx+_drivetypes+0 (used reg = )
! Debug: list * char = bx+_drivetypes+0 (used reg = )
add	bx,#_drivetypes
push	bx
! Debug: list * char = .14C+0 (used reg = )
mov	bx,#.14C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1415   if (type < 4) {
! Debug: lt int = const 4 to unsigned short type = [S+2+2] (used reg = )
mov	ax,4[bp]
cmp	ax,*4
jae 	.14D
.14E:
! 1416     if (reason==0)
! Debug: logeq int = const 0 to unsigned char reason = [S+2+4] (used reg = )
mov	al,6[bp]
test	al,al
jne 	.14F
.150:
! 1417       bios_printf(2, ": not a bootable disk");
! Debug: list * char = .151+0 (used reg = )
mov	bx,#.151
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1418     else
! 1419       bios_printf(2, ": could not read the boot disk");
jmp .152
.14F:
! Debug: list * char = .153+0 (used reg = )
mov	bx,#.153
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1420   }
.152:
! 1421   bios_printf(2, "\n\n");
.14D:
! Debug: list * char = .154+0 (used reg = )
mov	bx,#.154
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1422 }
pop	bp
ret
! 1423   void
! Register BX used in function print_boot_failure
! 1424 print_cdromboot_failure( code )
! 1425   Bit16u code;
export	_print_cdromboot_failure
_print_cdromboot_failure:
!BCC_EOS
! 1426 {
! 1427   bios_printf(2 | 4, "CDROM boot failure code : %04x\n",code);
push	bp
mov	bp,sp
! Debug: list unsigned short code = [S+2+2] (used reg = )
push	4[bp]
! Debug: list * char = .155+0 (used reg = )
mov	bx,#.155
push	bx
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1428   return;
pop	bp
ret
!BCC_EOS
! 1429 }
! 1430 void
! Register BX used in function print_cdromboot_failure
! 1431 nmi_handler_msg()
! 1432 {
export	_nmi_handler_msg
_nmi_handler_msg:
! 1433   bios_printf((2 | 4
push	bp
mov	bp,sp
! 1433  | 1), "NMI Handler called\n");
! Debug: list * char = .156+0 (used reg = )
mov	bx,#.156
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1434 }
pop	bp
ret
! 1435 void
! Register BX used in function nmi_handler_msg
! 1436 int18_panic_msg()
! 1437 {
export	_int18_panic_msg
_int18_panic_msg:
! 1438   bios_printf((2 | 4 | 1), "INT18: BOOT FAILURE\n");
push	bp
mov	bp,sp
! Debug: list * char = .157+0 (used reg = )
mov	bx,#.157
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 1439 }
pop	bp
ret
! 1440 void
! Register BX used in function int18_panic_msg
! 1441 log_bios_start()
! 1442 {
export	_log_bios_start
_log_bios_start:
! 1443   ;
push	bp
mov	bp,sp
!BCC_EOS
! 1444 }
pop	bp
ret
! 1445   bx_bool
! 1446 set_enable_a20(val)
! 1447   bx_bool val;
export	_set_enable_a20
_set_enable_a20:
!BCC_EOS
! 1448 {
! 1449   Bit8u oldval;
!BCC_EOS
! 1450   oldval = inb(0x92);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char oldval = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 1451   if (val)
mov	ax,4[bp]
test	ax,ax
je  	.158
.159:
! 1452     outb(0x92, oldval | 0x02);
! Debug: or int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1453   else
! 1454     outb(0x92, oldval & 0xfd);
jmp .15A
.158:
! Debug: and int = const $FD to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1455   return((oldval & 0x02) != 0);
.15A:
! Debug: and int = const 2 to unsigned char oldval = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.15B
mov	al,*1
jmp	.15C
.15B:
xor	al,al
.15C:
! Debug: cast unsigned short = const 0 to char = al+0 (used reg = )
xor	ah,ah
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1456 }
! 1457   void
! 1458 debugger_on()
! 1459 {
export	_debugger_on
_debugger_on:
! 1460   outb(0xfedc, 0x01);
push	bp
mov	bp,sp
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1461 }
pop	bp
ret
! 1462   void
! 1463 debugger_off()
! 1464 {
export	_debugger_off
_debugger_off:
! 1465   outb(0xfedc, 0x00);
push	bp
mov	bp,sp
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned int = const $FEDC (used reg = )
mov	ax,#$FEDC
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 1466 }
pop	bp
ret
! 1467 int
! 1468 s3_resume()
! 1469 {
export	_s3_resume
_s3_resume:
! 1470     Bit32u s3_wakeup_vector;
!BCC_EOS
! 1471     Bit8u s3_resume_flag;
!BCC_EOS
! 1472     s3_resume_flag = read_byte(0x40, 0xb0);
push	bp
mov	bp,sp
add	sp,*-6
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 1473     s3_wakeup_vector = get_s3_waking_vector();
! Debug: func () unsigned long = get_s3_waking_vector+0 (used reg = )
call	_get_s3_waking_vector
mov	bx,dx
! Debug: eq unsigned long = bx+0 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 1474     ;
!BCC_EOS
! 1475     if (s3_resume_flag != 0xFE || !s3_wakeup_vector)
! Debug: ne int = const $FE to unsigned char s3_resume_flag = [S+8-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FE
jne 	.15E
.15F:
mov	ax,-4[bp]
mov	bx,-2[bp]
call	ltstl
jne 	.15D
.15E:
! 1476      return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1477     write_byte(0x40, 0xb0, 0);
.15D:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $B0 (used reg = )
mov	ax,#$B0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1478     write_word(0x40, 0xb6, (s3_wakeup_vector & 0xF));
! Debug: and unsigned long = const $F to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$F
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B6 (used reg = )
mov	ax,#$B6
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1479     write_word(0x40, 0xb8, (s3_wakeup_vector >> 4));
! Debug: sr int = const 4 to unsigned long s3_wakeup_vector = [S+8-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	di,*4
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const $B8 (used reg = )
mov	ax,#$B8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*8
!BCC_EOS
! 1480     ;
!BCC_EOS
! 1481 #asm
!BCC_EOS
!BCC_ASM
_s3_resume.s3_resume_flag	set	1
.s3_resume.s3_resume_flag	set	-5
_s3_resume.s3_wakeup_vector	set	2
.s3_resume.s3_wakeup_vector	set	-4
    jmpf [0x04b6]
! 1483 endasm
!BCC_ENDASM
!BCC_EOS
! 1484     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1485 }
! 1486 void ata_init( )
! Register BX used in function s3_resume
! 1487 {
export	_ata_init
_ata_init:
! 1488   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1489   Bit8u channel, device;
!BCC_EOS
! 1490   for (channel=0; channel<4; channel++) {
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned char channel = [S+6-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
!BCC_EOS
br 	.162
.163:
! 1491     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1492     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1493     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2,0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1494     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].irq,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char channel = [S+8-5] to [4] struct  = const $122 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1495     }
! 1496   for (device=0; device<(4*2); device++) {
.161:
! Debug: postinc unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
.162:
! Debug: lt int = const 4 to unsigned char channel = [S+6-5] (used reg = )
mov	al,-3[bp]
cmp	al,*4
jb 	.163
.164:
.160:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
br 	.167
.168:
! 1497     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1498     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1499     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1500     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lock,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1501     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1502     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1503     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1504     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1505     write_word(ebda_seg,&((ebda_data_t *) 0)->ata
! 1505 .devices[device].lchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1506     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1507     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1508     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1509     write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1510     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1511     write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$A-6] to [8] struct  = const $142 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1512     }
! 1513   for (device=0; device<(4*2); device++) {
.166:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.167:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
blo 	.168
.169:
.165:
! Debug: eq int = const 0 to unsigned char device = [S+6-6] (used reg = )
xor	al,al
mov	-4[bp],al
!BCC_EOS
!BCC_EOS
jmp .16C
.16D:
! 1514     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $233 (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1515     write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[device],(4*2));
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: ptradd unsigned char device = [S+8-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1516     }
! 1517   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount,0);
.16B:
! Debug: postinc unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
.16C:
! Debug: lt int = const 8 to unsigned char device = [S+6-6] (used reg = )
mov	al,-4[bp]
cmp	al,*8
jb 	.16D
.16E:
.16A:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1518   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1519 }
mov	sp,bp
pop	bp
ret
! 1520 Bit8u await_ide();
! Register BX used in function ata_init
!BCC_EOS
! 1521 static Bit8u await_ide(when_done,base,timeout)
! 1522   Bit8u when_done;
_await_ide:
!BCC_EOS
! 1523   Bit16u base;
!BCC_EOS
! 1524   Bit16u timeout;
!BCC_EOS
! 1525 {
! 1526   Bit32u time=0,last=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long time = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
add	sp,*-4
! Debug: eq int = const 0 to unsigned long last = [S+$A-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1527   Bit8u status;
!BCC_EOS
! 1528   Bit8u result;
!BCC_EOS
! 1529   for(;;) {
dec	sp
dec	sp
!BCC_EOS
!BCC_EOS
.171:
! 1530     status = inb(base+7);
! Debug: add int = const 7 to unsigned short base = [S+$C+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$C-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1531     time++;
! Debug: postinc unsigned long time = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	si,-2[bp]
lea	bx,-4[bp]
call	lincl
!BCC_EOS
! 1532     if (when_done == 1)
! Debug: logeq int = const 1 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jne 	.172
.173:
! 1533       result = status & 0x80;
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1534     else if (when_done == 2)
br 	.174
.172:
! Debug: logeq int = const 2 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*2
jne 	.175
.176:
! 1535       result = !(status & 0x80);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.177
.178:
mov	al,*1
jmp	.179
.177:
xor	al,al
.179:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1536     else if (when_done == 3)
br 	.17A
.175:
! Debug: logeq int = const 3 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*3
jne 	.17B
.17C:
! 1537       result = !(status & 0x80) && (status & 0x08);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.17D
.17F:
! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*8
test	al,al
je  	.17D
.17E:
mov	al,*1
jmp	.180
.17D:
xor	al,al
.180:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1538     else if (when_done == 4)
jmp .181
.17B:
! Debug: logeq int = const 4 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*4
jne 	.182
.183:
! 1539       result = !(status & 0x80) && !(status & 0x08);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.184
.186:
! Debug: and int = const 8 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*8
test	al,al
jne 	.184
.185:
mov	al,*1
jmp	.187
.184:
xor	al,al
.187:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1540     else if (when_done == 5)
jmp .188
.182:
! Debug: logeq int = const 5 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
cmp	al,*5
jne 	.189
.18A:
! 1541       result = !(status & 0x80) && (status & 0x40);
! Debug: and int = const $80 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,#$80
test	al,al
jne 	.18B
.18D:
! Debug: and int = const $40 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*$40
test	al,al
je  	.18B
.18C:
mov	al,*1
jmp	.18E
.18B:
xor	al,al
.18E:
! Debug: eq char = al+0 to unsigned char result = [S+$C-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1542     else if (when_done == 0)
jmp .18F
.189:
! Debug: logeq int = const 0 to unsigned char when_done = [S+$C+2] (used reg = )
mov	al,4[bp]
test	al,al
jne 	.190
.191:
! 1543       result = 0;
! Debug: eq int = const 0 to unsigned char result = [S+$C-$C] (used reg = )
xor	al,al
mov	-$A[bp],al
!BCC_EOS
! 1544     if (result) return status;
.190:
.18F:
.188:
.181:
.17A:
.174:
mov	al,-$A[bp]
test	al,al
je  	.192
.193:
mov	al,-9[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1545     if (time>>16 != last)
.192:
! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: ne unsigned long last = [S+$C-$A] to unsigned long = bx+0 (used reg = )
lea	di,-8[bp]
call	lcmpul
je  	.194
.195:
! 1546     {
! 1547       last = time >>16;
! Debug: sr int = const $10 to unsigned long time = [S+$C-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned long last = [S+$C-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 1548       ;
!BCC_EOS
! 1549     }
! 1550     if (status & 0x01)
.194:
! Debug: and int = const 1 to unsigned char status = [S+$C-$B] (used reg = )
mov	al,-9[bp]
and	al,*1
test	al,al
je  	.196
.197:
! 1551     {
! 1552       ;
!BCC_EOS
! 1553       return status;
mov	al,-9[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1554     }
! 1555     if ((timeout == 0) || ((time>>11) > timeout)) break;
.196:
! Debug: logeq int = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
je  	.199
.19A:
! Debug: cast unsigned long = const 0 to unsigned short timeout = [S+$C+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sr int = const $B to unsigned long time = [S+$10-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: gt unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
lea	di,-$E[bp]
call	lcmpul
lea	sp,-$A[bp]
jbe 	.198
.199:
jmp .16F
!BCC_EOS
! 1556   }
.198:
! 1557   ;
.170:
br 	.171
.16F:
!BCC_EOS
! 1558   return status;
mov	al,-9[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1559 }
! 1560 void ata_detect( )
! Register BX used in function await_ide
! 1561 {
export	_ata_detect
_ata_detect:
! 1562   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1563   Bit8u hdcount, cdcount, device, type;
!BCC_EOS
! 1564   Bit8u buffer[0x0200];
!BCC_EOS
! 1565   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iface,0x00);
add	sp,#-$204
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $122 (used reg = )
mov	ax,#$122
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1566   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].iobase1,0x1f0);
! Debug: list int = const $1F0 (used reg = )
mov	ax,#$1F0
push	ax
! Debug: list * unsigned short = const $124 (used reg = )
mov	ax,#$124
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1567   write_word(ebda_seg,&((ebda_data
! 1567 _t *) 0)->ata.channels[0].iobase2,0x3f0);
! Debug: list int = const $3F0 (used reg = )
mov	ax,#$3F0
push	ax
! Debug: list * unsigned short = const $126 (used reg = )
mov	ax,#$126
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1568   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[0].irq,14);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list * unsigned char = const $128 (used reg = )
mov	ax,#$128
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1569   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $12A (used reg = )
mov	ax,#$12A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1570   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase1,0x170);
! Debug: list int = const $170 (used reg = )
mov	ax,#$170
push	ax
! Debug: list * unsigned short = const $12C (used reg = )
mov	ax,#$12C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1571   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].iobase2,0x370);
! Debug: list int = const $370 (used reg = )
mov	ax,#$370
push	ax
! Debug: list * unsigned short = const $12E (used reg = )
mov	ax,#$12E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1572   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[1].irq,15);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned char = const $130 (used reg = )
mov	ax,#$130
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1573   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $132 (used reg = )
mov	ax,#$132
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1574   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase1,0x1e8);
! Debug: list int = const $1E8 (used reg = )
mov	ax,#$1E8
push	ax
! Debug: list * unsigned short = const $134 (used reg = )
mov	ax,#$134
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1575   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].iobase2,0x3e0);
! Debug: list int = const $3E0 (used reg = )
mov	ax,#$3E0
push	ax
! Debug: list * unsigned short = const $136 (used reg = )
mov	ax,#$136
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1576   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[2].irq,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list * unsigned char = const $138 (used reg = )
mov	ax,#$138
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1577   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iface,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $13A (used reg = )
mov	ax,#$13A
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1578   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase1,0x168);
! Debug: list int = const $168 (used reg = )
mov	ax,#$168
push	ax
! Debug: list * unsigned short = const $13C (used reg = )
mov	ax,#$13C
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1579   write_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].iobase2,0x360);
! Debug: list int = const $360 (used reg = )
mov	ax,#$360
push	ax
! Debug: list * unsigned short = const $13E (used reg = )
mov	ax,#$13E
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1580   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.channels[3].irq,11);
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: list * unsigned char = const $140 (used reg = )
mov	ax,#$140
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1581   hdcount=cdcount=0;
! Debug: eq int = const 0 to unsigned char cdcount = [S+$208-6] (used reg = )
xor	al,al
mov	-4[bp],al
! Debug: eq unsigned char = al+0 to unsigned char hdcount = [S+$208-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 1582   for(device=0; device<(4*2); device++) {
! Debug: eq int = const 0 to unsigned char device = [S+$208-7] (used reg = )
xor	al,al
mov	-5[bp],al
!BCC_EOS
!BCC_EOS
br 	.19D
.19E:
! 1583     Bit16u iobase1, iobase2;
!BCC_EOS
! 1584     Bit8u channel, slave, shift;
!BCC_EOS
! 1585     Bit8u sc, sn, cl, ch, st;
!BCC_EOS
! 1586     channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$214-$20D] (used reg = )
mov	-$20B[bp],al
!BCC_EOS
! 1587     slave = device % 2;
! Debug: mod int = const 2 to unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$214-$20E] (used reg = )
mov	-$20C[bp],al
!BCC_EOS
! 1588     iobase1 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	-$208[bp],ax
!BCC_EOS
! 1589     iobase2 =read_word(ebda_seg,&((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$214-$20D] to [4] struct  = const $122 (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$214-$20C] (used reg = )
mov	-$20A[bp],ax
!BCC_EOS
! 1590     outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$216-$20C] (used reg = )
mov	ax,-$20A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1591     outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.19F
.1A0:
mov	al,#$B0
jmp .1A1
.19F:
mov	al,#$A0
.1A1:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1592     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1593     outb(iobase1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1594     outb(iobase1+2, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1595     outb(iobase1+3, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1596     outb(iobase1+2, 0x55);
! Debug: list int = const $55 (used reg = )
mov	ax,*$55
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1597     outb(iobase1+3, 0xaa);
! Debug: list int = const $AA (used reg = )
mov	ax,#$AA
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1598     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1599     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1600     if ( (sc == 0x55) && (sn == 0xaa) ) {
! Debug: logeq int = const $55 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*$55
bne 	.1A2
.1A4:
! Debug: logeq int = const $AA to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,#$AA
bne 	.1A2
.1A3:
! 1601       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1602       ata_reset(device);
! Debug: list unsigned char device = [S+$214-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 1603       outb(iobase1+6, slave ? 0xb0 : 0xa0);
mov	al,-$20C[bp]
test	al,al
je  	.1A5
.1A6:
mov	al,#$B0
jmp .1A7
.1A5:
mov	al,#$A0
.1A7:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$216-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1604       sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$214-$210] (used reg = )
mov	-$20E[bp],al
!BCC_EOS
! 1605       sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$214-$211] (used reg = )
mov	-$20F[bp],al
!BCC_EOS
! 1606       if ((sc==0x01) && (sn==0x01)) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$214-$210] (used reg = )
mov	al,-$20E[bp]
cmp	al,*1
bne 	.1A8
.1AA:
! Debug: logeq int = const 1 to unsigned char sn = [S+$214-$211] (used reg = )
mov	al,-$20F[bp]
cmp	al,*1
bne 	.1A8
.1A9:
! 1607         cl = inb(iobase1+4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	-$210[bp],al
!BCC_EOS
! 1608         ch = inb(iobase1+5);
! Debug: add int = const 5 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	-$211[bp],al
!BCC_EOS
! 1609         st = inb(iobase1+7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$214-$20A] (used reg = )
mov	ax,-$208[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char st = [S+$214-$214] (used reg = )
mov	-$212[bp],al
!BCC_EOS
! 1610         if ((cl==0x1
! 1610 4) && (ch==0xeb)) {
! Debug: logeq int = const $14 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,*$14
jne 	.1AB
.1AD:
! Debug: logeq int = const $EB to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$EB
jne 	.1AB
.1AC:
! 1611           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x03);
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1612         } else if ((cl==0x00) && (ch==0x00) && (st!=0x00)) {
jmp .1AE
.1AB:
! Debug: logeq int = const 0 to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
test	al,al
jne 	.1AF
.1B2:
! Debug: logeq int = const 0 to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
test	al,al
jne 	.1AF
.1B1:
! Debug: ne int = const 0 to unsigned char st = [S+$214-$214] (used reg = )
mov	al,-$212[bp]
test	al,al
je  	.1AF
.1B0:
! 1613           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1614         } else if ((cl==0xff) && (ch==0xff)) {
jmp .1B3
.1AF:
! Debug: logeq int = const $FF to unsigned char cl = [S+$214-$212] (used reg = )
mov	al,-$210[bp]
cmp	al,#$FF
jne 	.1B4
.1B6:
! Debug: logeq int = const $FF to unsigned char ch = [S+$214-$213] (used reg = )
mov	al,-$211[bp]
cmp	al,#$FF
jne 	.1B4
.1B5:
! 1615           write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$216-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$218-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1616         }
! 1617       }
.1B4:
.1B3:
.1AE:
! 1618     }
.1A8:
! 1619     type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
.1A2:
! Debug: ptradd unsigned char device = [S+$214-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$216-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$214-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 1620     if(type == 0x02) {
! Debug: logeq int = const 2 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*2
bne 	.1B7
.1B8:
! 1621       Bit32u sectors_low, sectors_high;
!BCC_EOS
! 1622       Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 1623       Bit8u translation, removable, mode;
!BCC_EOS
! 1624       mode = 0x00;
add	sp,*-$14
! Debug: eq int = const 0 to unsigned char mode = [S+$228-$227] (used reg = )
xor	al,al
mov	-$225[bp],al
!BCC_EOS
! 1625       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1626       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1627       if (ata_cmd_data_in(device,0xEC, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) !=0 )
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $EC (used reg = )
mov	ax,#$EC
push	ax
! Debug: list unsigned char device = [S+$23E-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1B9
.1BA:
! 1628         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATA device\n");
! Debug: list * char = .1BB+0 (used reg = )
mov	bx,#.1BB
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1629       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
.1B9:
! Debug: list * unsigned char buffer = S+$228-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.1BC
.1BD:
mov	al,*1
jmp .1BE
.1BC:
xor	al,al
.1BE:
! Debug: eq char = al+0 to unsigned char removable = [S+$228-$226] (used reg = )
mov	-$224[bp],al
!BCC_EOS
! 1630       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
! Debug: list * unsigned char buffer = S+$228-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.1BF
.1C0:
mov	al,*1
jmp .1C1
.1BF:
xor	al,al
.1C1:
! Debug: eq char = al+0 to unsigned char mode = [S+$228-$227] (used reg = )
mov	-$225[bp],al
!BCC_EOS
! 1631       blksize = read_word(get_SS(),buffer+10);
! Debug: list * unsigned char buffer = S+$228-$1FE (used reg = )
lea	bx,-$1FC[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$228-$224] (used reg = )
mov	-$222[bp],ax
!BCC_EOS
! 1632       cylinders = read_word(get_SS(),buffer+(1*2));
! Debug: list * unsigned char buffer = S+$228-$206 (used reg = )
lea	bx,-$204[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1633       heads = read_word(get_SS(),buffer+(3*2));
! Debug: list * unsigned char buffer = S+$228-$202 (used reg = )
lea	bx,-$200[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1634       spt = read_word(get_SS(),buffer+(6*2));
! Debug: list * unsigned char buffer = S+$228-$1FC (used reg = )
lea	bx,-$1FA[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short spt = [S+$228-$222] (used reg = )
mov	-$220[bp],ax
!BCC_EOS
! 1635       if (read_word(get_SS(),buffer+(83*2)) & (1 << 10)) {
! Debug: list * unsigned char buffer = S+$228-$162 (used reg = )
lea	bx,-$160[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: and int = const $400 to unsigned short = ax+0 (used reg = )
and	ax,#$400
test	ax,ax
je  	.1C2
.1C3:
! 1636         sectors_low = read_dword(get_SS(),buffer+(100*2));
! Debug: list * unsigned char buffer = S+$228-$140 (used reg = )
lea	bx,-$13E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1637         sectors_high = read_dword(get_SS(),buffer+(102*2));
! Debug: list * unsigned char buffer = S+$228-$13C (used reg = )
lea	bx,-$13A[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1638       } else {
jmp .1C4
.1C2:
! 1639         sectors_low = read_dword(get_SS(),buffer+(60*2));
! Debug: list * unsigned char buffer = S+$228-$190 (used reg = )
lea	bx,-$18E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1640         sectors_high = 0;
! Debug: eq int = const 0 to unsigned long sectors_high = [S+$228-$21C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$21A[bp],ax
mov	-$218[bp],bx
!BCC_EOS
! 1641       }
! 1642       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0xFF);
.1C4:
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1643       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$228-$226] (used reg = )
mov	al,-$224[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1644       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$228-$227] (used reg = )
mov	al,-$225[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1645       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$228-$224] (used reg = )
push	-$222[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1646       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1647       write_word(ebda_seg,&((ebda_data_t *) 
! 1647 0)->ata.devices[device].pchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1648       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].pchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1649       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors_low);
! Debug: list unsigned long sectors_low = [S+$228-$218] (used reg = )
push	-$214[bp]
push	-$216[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1650       write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high, sectors_high);
! Debug: list unsigned long sectors_high = [S+$228-$21C] (used reg = )
push	-$218[bp]
push	-$21A[bp]
! Debug: ptradd unsigned char device = [S+$22C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1651       ;
!BCC_EOS
! 1652       translation = inb_cmos(0x39 + channel/2);
! Debug: div int = const 2 to unsigned char channel = [S+$228-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const $39 (used reg = )
! Debug: expression subtree swapping
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$228-$225] (used reg = )
mov	-$223[bp],al
!BCC_EOS
! 1653       for (shift=device%4; shift>0; shift--) translation >>= 2;
! Debug: mod int = const 4 to unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	-$20D[bp],al
!BCC_EOS
!BCC_EOS
jmp .1C7
.1C8:
! Debug: srab int = const 2 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
shr	ax,*1
shr	ax,*1
mov	-$223[bp],al
!BCC_EOS
! 1654       translation &= 0x03;
.1C6:
! Debug: postdec unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
dec	ax
mov	-$20D[bp],al
.1C7:
! Debug: gt int = const 0 to unsigned char shift = [S+$228-$20F] (used reg = )
mov	al,-$20D[bp]
test	al,al
jne	.1C8
.1C9:
.1C5:
! Debug: andab int = const 3 to unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
and	al,*3
mov	-$223[bp],al
!BCC_EOS
! 1655       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].translation, translation);
! Debug: list unsigned char translation = [S+$228-$225] (used reg = )
mov	al,-$223[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1656       switch (translation) {
mov	al,-$223[bp]
jmp .1CC
! 1657         case 0:
! 1658           ;
.1CD:
!BCC_EOS
! 1659           break;
jmp .1CA
!BCC_EOS
! 1660         case 1:
! 1661           ;
.1CE:
!BCC_EOS
! 1662           break;
jmp .1CA
!BCC_EOS
! 1663         case 2:
! 1664           ;
.1CF:
!BCC_EOS
! 1665           break;
jmp .1CA
!BCC_EOS
! 1666         case 3:
! 1667           ;
.1D0:
!BCC_EOS
! 1668           break;
jmp .1CA
!BCC_EOS
! 1669         }
! 1670       switch (translation) {
jmp .1CA
.1CC:
sub	al,*0
je 	.1CD
sub	al,*1
je 	.1CE
sub	al,*1
je 	.1CF
sub	al,*1
je 	.1D0
.1CA:
..FFFE	=	-$228
mov	al,-$223[bp]
br 	.1D3
! 1671         case 0:
! 1672           break;
.1D4:
br 	.1D1
!BCC_EOS
! 1673         case 1:
! 1674           spt = 63;
.1D5:
! Debug: eq int = const $3F to unsigned short spt = [S+$228-$222] (used reg = )
mov	ax,*$3F
mov	-$220[bp],ax
!BCC_EOS
! 1675           sectors_low /= 63;
! Debug: divab unsigned long = const $3F to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,*$3F
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
mov	-$216[bp],ax
mov	-$214[bp],bx
add	sp,*4
!BCC_EOS
! 1676           heads = sectors_low / 1024;
! Debug: div unsigned long = const $400 to unsigned long sectors_low = [S+$228-$218] (used reg = )
mov	ax,#$400
xor	bx,bx
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	-$21E[bp],ax
!BCC_EOS
! 1677           if (heads>128) heads = 255;
! Debug: gt int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,#$80
jbe 	.1D6
.1D7:
! Debug: eq int = const $FF to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$FF
mov	-$21E[bp],ax
!BCC_EOS
! 1678           else if (heads>64) heads = 128;
jmp .1D8
.1D6:
! Debug: gt int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$40
jbe 	.1D9
.1DA:
! Debug: eq int = const $80 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,#$80
mov	-$21E[bp],ax
!BCC_EOS
! 1679           else if (heads>32) heads = 64;
jmp .1DB
.1D9:
! Debug: gt int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$20
jbe 	.1DC
.1DD:
! Debug: eq int = const $40 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$40
mov	-$21E[bp],ax
!BCC_EOS
! 1680           else if (heads>16) heads = 32;
jmp .1DE
.1DC:
! Debug: gt int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jbe 	.1DF
.1E0:
! Debug: eq int = const $20 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$20
mov	-$21E[bp],ax
!BCC_EOS
! 1681           else heads=16;
jmp .1E1
.1DF:
! Debug: eq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$10
mov	-$21E[bp],ax
!BCC_EOS
! 1682           cylinders = sectors_low / heads;
.1E1:
.1DE:
.1DB:
.1D8:
! Debug: cast unsigned long = const 0 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long sectors_low = [S+$228-$218] (used reg = )
push	bx
push	ax
mov	ax,-$216[bp]
mov	bx,-$214[bp]
lea	di,-2+..FFFD[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1683           break;
br 	.1D1
!BCC_EOS
! 1684         case 3:
! 1685           if (heads==16) {
.1E2:
! Debug: logeq int = const $10 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$10
jne 	.1E3
.1E4:
! 1686             if(cylinders>61439) cylinders=61439;
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: gt long = const $EFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$EFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lcmpul
lea	sp,2+..FFFD[bp]
jbe 	.1E5
.1E6:
! Debug: eq long = const $EFFF to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$EFFF
mov	-$21C[bp],ax
!BCC_EOS
! 1687             heads=15;
.1E5:
! Debug: eq int = const $F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,*$F
mov	-$21E[bp],ax
!BCC_EOS
! 1688             cylinders = (Bit16u)((Bit32u)(cylinders)*16/15);
! Debug: cast unsigned long = const 0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
xor	bx,bx
! Debug: mul unsigned long = const $10 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$10
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	lmulul
add	sp,*8
! Debug: div unsigned long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFFD[bp]
mov	bx,0+..FFFD[bp]
lea	di,-6+..FFFD[bp]
call	ldivul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	-$21C[bp],ax
!BCC_EOS
! 1689             }
! 1690         case 2:
.1E3:
! 1691           while(cylinders > 1024) {
.1E7:
br 	.1E9
.1EA:
! 1692             cylinders >>= 1;
! Debug: srab int = const 1 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
shr	ax,*1
mov	-$21C[bp],ax
!BCC_EOS
! 1693             heads <<= 1;
! Debug: slab int = const 1 to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
shl	ax,*1
mov	-$21E[bp],ax
!BCC_EOS
! 1694             if (heads > 127) break;
! Debug: gt int = const $7F to unsigned short heads = [S+$228-$220] (used reg = )
mov	ax,-$21E[bp]
cmp	ax,*$7F
jbe 	.1EB
.1EC:
jmp .1E8
!BCC_EOS
! 1695           }
.1EB:
! 1696           break;
.1E9:
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
ja 	.1EA
.1ED:
.1E8:
jmp .1D1
!BCC_EOS
! 1697         }
! 1698       if (cylinders > 1024) cylinders=1024;
jmp .1D1
.1D3:
sub	al,*0
beq 	.1D4
sub	al,*1
beq 	.1D5
sub	al,*1
je 	.1E7
sub	al,*1
beq 	.1E2
.1D1:
..FFFD	=	-$228
! Debug: gt int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,-$21C[bp]
cmp	ax,#$400
jbe 	.1EE
.1EF:
! Debug: eq int = const $400 to unsigned short cylinders = [S+$228-$21E] (used reg = )
mov	ax,#$400
mov	-$21C[bp],ax
!BCC_EOS
! 1699       ;
.1EE:
!BCC_EOS
! 1700       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.heads, heads);
! Debug: list unsigned short heads = [S+$228-$220] (used reg = )
push	-$21E[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1701       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders, cylinders);
! Debug: list unsigned short cylinders = [S+$228-$21E] (used reg = )
push	-$21C[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1702       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].lchs.spt, spt);
! Debug: list unsigned short spt = [S+$228-$222] (used reg = )
push	-$220[bp]
! Debug: ptradd unsigned char device = [S+$22A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1703       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[hdcount], device);
! Debug: list unsigned char device = [S+$228-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char hdcount = [S+$22A-5] to [8] unsigned char = const $233 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$22C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1704       hdcount++;
! Debug: postinc unsigned char hdcount = [S+$228-5] (used reg = )
mov	al,-3[bp]
inc	ax
mov	-3[bp],al
!BCC_EOS
! 1705       }
add	sp,*$14
! 1706     if(type == 0x03) {
.1B7:
! Debug: logeq int = const 3 to unsigned char type = [S+$214-8] (used reg = )
mov	al,-6[bp]
cmp	al,*3
bne 	.1F0
.1F1:
! 1707       Bit8u type, removable,
! 1707  mode;
!BCC_EOS
! 1708       Bit16u blksize;
!BCC_EOS
! 1709       mode = 0x00;
add	sp,*-6
! Debug: eq int = const 0 to unsigned char mode = [S+$21A-$217] (used reg = )
xor	al,al
mov	-$215[bp],al
!BCC_EOS
! 1710       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device,0x05);
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1711       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1712       if (ata_cmd_data_in(device,0xA1, 1, 0, 0, 0, 0L, 0L, get_SS(),buffer) != 0)
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: list unsigned char device = [S+$230-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.1F2
.1F3:
! 1713         bios_printf((2 | 4 | 1), "ata-detect: Failed to detect ATAPI device\n");
! Debug: list * char = .1F4+0 (used reg = )
mov	bx,#.1F4
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1714       type = read_byte(get_SS(),buffer+1) & 0x1f;
.1F2:
! Debug: list * unsigned char buffer = S+$21A-$207 (used reg = )
lea	bx,-$205[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $1F to unsigned char = al+0 (used reg = )
and	al,*$1F
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$21A-$215] (used reg = )
mov	-$213[bp],al
!BCC_EOS
! 1715       removable = (read_byte(get_SS(),buffer+0) & 0x80) ? 1 : 0;
! Debug: list * unsigned char buffer = S+$21A-$208 (used reg = )
lea	bx,-$206[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
test	al,al
je  	.1F5
.1F6:
mov	al,*1
jmp .1F7
.1F5:
xor	al,al
.1F7:
! Debug: eq char = al+0 to unsigned char removable = [S+$21A-$216] (used reg = )
mov	-$214[bp],al
!BCC_EOS
! 1716       mode = read_byte(get_SS(),buffer+96) ? 0x01 : 0x00;
! Debug: list * unsigned char buffer = S+$21A-$1A8 (used reg = )
lea	bx,-$1A6[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
test	al,al
je  	.1F8
.1F9:
mov	al,*1
jmp .1FA
.1F8:
xor	al,al
.1FA:
! Debug: eq char = al+0 to unsigned char mode = [S+$21A-$217] (used reg = )
mov	-$215[bp],al
!BCC_EOS
! 1717       blksize = 2048;
! Debug: eq int = const $800 to unsigned short blksize = [S+$21A-$21A] (used reg = )
mov	ax,#$800
mov	-$218[bp],ax
!BCC_EOS
! 1718       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device, type);
! Debug: list unsigned char type = [S+$21A-$215] (used reg = )
mov	al,-$213[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1719       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].removable, removable);
! Debug: list unsigned char removable = [S+$21A-$216] (used reg = )
mov	al,-$214[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$144] (used reg = )
! Debug: list * unsigned char = bx+$144 (used reg = )
add	bx,#$144
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1720       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].mode, mode);
! Debug: list unsigned char mode = [S+$21A-$217] (used reg = )
mov	al,-$215[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1721       write_word(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, blksize);
! Debug: list unsigned short blksize = [S+$21A-$21A] (used reg = )
push	-$218[bp]
! Debug: ptradd unsigned char device = [S+$21C-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1722       write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[cdcount], device);
! Debug: list unsigned char device = [S+$21A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: ptradd unsigned char cdcount = [S+$21C-6] to [8] unsigned char = const $23C (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$21E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1723       cdcount++;
! Debug: postinc unsigned char cdcount = [S+$21A-6] (used reg = )
mov	al,-4[bp]
inc	ax
mov	-4[bp],al
!BCC_EOS
! 1724       }
add	sp,*6
! 1725       {
.1F0:
! 1726       Bit32u sizeinmb;
!BCC_EOS
! 1727       Bit16u ataversion;
!BCC_EOS
! 1728       Bit8u c, i, version, model[41];
!BCC_EOS
! 1729       switch (type) {
add	sp,*-$32
mov	al,-6[bp]
br 	.1FD
! 1730         case 0x02:
! 1731           sizeinmb = (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_high) << 21)
.1FE:
! 1732             | (read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low) >> 11);
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
push	bx
push	ax
! Debug: ptradd unsigned char device = [S+$24A-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sl int = const $15 to unsigned long = bx+0 (used reg = )
mov	cl,*5
shl	ax,cl
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$24A-$24A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFFC[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	-$216[bp],ax
mov	-$214[bp],bx
!BCC_EOS
! 1733         case 0x03:
! 1734           ataversion=((Bit16u)(read_byte(get_SS(),buffer+161))<<8)|read_byte(get_SS(),buffer+160);
.1FF:
! Debug: list * unsigned char buffer = S+$246-$168 (used reg = )
lea	bx,-$166[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list * unsigned char buffer = S+$248-$167 (used reg = )
lea	bx,-$165[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: or unsigned char (temp) = [S+$248-$248] to unsigned int = ax+0 (used reg = )
or	al,0+..FFFC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
mov	-$218[bp],ax
!BCC_EOS
! 1735           for(version=15;version>0;version--) {
! Debug: eq int = const $F to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,*$F
mov	-$21B[bp],al
!BCC_EOS
!BCC_EOS
jmp .202
.203:
! 1736             if((ataversion&(1<<version))!=0)
! Debug: sl unsigned char version = [S+$246-$21D] to int = const 1 (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
mov	bx,ax
mov	ax,*1
mov	cx,bx
shl	ax,cl
! Debug: and int = ax+0 to unsigned short ataversion = [S+$246-$21A] (used reg = )
! Debug: expression subtree swapping
and	ax,-$218[bp]
! Debug: ne int = const 0 to unsigned int = ax+0 (used reg = )
test	ax,ax
je  	.204
.205:
! 1737             break;
jmp .200
!BCC_EOS
! 1738             }
.204:
! 1739           for(i=0;i<20;i++){
.201:
! Debug: postdec unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
dec	ax
mov	-$21B[bp],al
.202:
! Debug: gt int = const 0 to unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
test	al,al
jne	.203
.206:
.200:
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
br 	.209
.20A:
! 1740             write_byte(get_SS(),model+(i*2),read_byte(get_SS(),buffer+(i*2)+54+1));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: ptradd int = const 1 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1CF (used reg = )
! Debug: list * unsigned char = bx-$1CF (used reg = )
add	bx,#-$1CF
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1741             write_byte(get_SS(),model+(i*2)+1,read_byte(get_SS(),buffer+(i*2)+54));
! Debug: mul int = const 2 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$200] unsigned char buffer = S+$246-$208 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const $36 to [$200] unsigned char = bx-$206 (used reg = )
! Debug: cast * unsigned char = const 0 to [$200] unsigned char = bx-$1D0 (used reg = )
! Debug: list * unsigned char = bx-$1D0 (used reg = )
add	bx,#-$1D0
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: mul int = const 2 to unsigned char i = [S+$248-$21C] (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
shl	ax,*1
! Debug: ptradd unsigned int = ax+0 to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	bx,bp
add	bx,ax
! Debug: ptradd int = const 1 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$243 (used reg = )
! Debug: list * unsigned char = bx-$243 (used reg = )
add	bx,#-$243
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1742           }
! 1743           write_byte(get_SS(),model+40,0x00);
.208:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
.209:
! Debug: lt int = const $14 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$14
blo 	.20A
.20B:
.207:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$21E (used reg = )
lea	bx,-$21C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1744           for(i=39;i>0;i--){
! Debug: eq int = const $27 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$27
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .20E
.20F:
! 1745             if(read_byte(get_SS(),model+i)==0x20)
! Debug: ptradd unsigned char i = [S+$246-$21C] to [$29] unsigned char model = S+$246-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const $20 to unsigned char = al+0 (used reg = )
cmp	al,*$20
jne 	.210
.211:
! 1746               write_byte(get_SS(),model+i,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1747             else break;
jmp .212
.210:
jmp .20C
!BCC_EOS
! 1748           }
.212:
! 1749           if (i>36) {
.20D:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.20E:
! Debug: gt int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
test	al,al
jne	.20F
.213:
.20C:
! Debug: gt int = const $24 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$24
jbe 	.214
.215:
! 1750           
! 1750   write_byte(get_SS(),model+36,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char model = S+$248-$222 (used reg = )
lea	bx,-$220[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1751             for(i=35;i>32;i--){
! Debug: eq int = const $23 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,*$23
mov	-$21A[bp],al
!BCC_EOS
!BCC_EOS
jmp .218
.219:
! 1752               write_byte(get_SS(),model+i,0x2E);
! Debug: list int = const $2E (used reg = )
mov	ax,*$2E
push	ax
! Debug: ptradd unsigned char i = [S+$248-$21C] to [$29] unsigned char model = S+$248-$246 (used reg = )
mov	al,-$21A[bp]
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1753             }
! 1754           }
.217:
! Debug: postdec unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
dec	ax
mov	-$21A[bp],al
.218:
! Debug: gt int = const $20 to unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
cmp	al,*$20
ja 	.219
.21A:
.216:
! 1755           break;
.214:
jmp .1FB
!BCC_EOS
! 1756         }
! 1757       switch (type) {
jmp .1FB
.1FD:
sub	al,*2
beq 	.1FE
sub	al,*1
beq 	.1FF
.1FB:
..FFFC	=	-$246
mov	al,-6[bp]
br 	.21D
! 1758         case 0x02:
! 1759           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
.21E:
mov	al,-$20C[bp]
test	al,al
je  	.222
.223:
mov	bx,#.220
jmp .224
.222:
mov	bx,#.221
.224:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .21F+0 (used reg = )
mov	bx,#.21F
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1760           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
jmp .226
.227:
! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
mov	al,-$219[bp]
xor	ah,ah
push	ax
! Debug: list * char = .228+0 (used reg = )
mov	bx,#.228
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1761    if (sizeinmb < (1UL<<16))
.226:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
dec	ax
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
mov	-$219[bp],al
test	al,al
jne	.227
.229:
.225:
! Debug: lt unsigned long = const $10000 to unsigned long sizeinmb = [S+$246-$218] (used reg = )
xor	ax,ax
mov	bx,*1
lea	di,-$216[bp]
call	lcmpul
jbe 	.22A
.22B:
! 1762             bios_printf(2, " ATA-%d Hard-Disk (%4u MBytes)\n", version, (Bit16u)sizeinmb);
! Debug: list unsigned short sizeinmb = [S+$246-$218] (used reg = )
push	-$216[bp]
! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .22C+0 (used reg = )
mov	bx,#.22C
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1763    else
! 1764             bios_printf(2, " ATA-%d Hard-Disk (%4u GBytes)\n", version, (Bit16u)(sizeinmb>>10));
jmp .22D
.22A:
! Debug: sr int = const $A to unsigned long sizeinmb = [S+$246-$218] (used reg = )
mov	ax,-$216[bp]
mov	bx,-$214[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*2
call	lsrul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned char version = [S+$248-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .22E+0 (used reg = )
mov	bx,#.22E
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1765           break;
.22D:
br 	.21B
!BCC_EOS
! 1766         case 0x03:
! 1767           bios_printf(2, "ata%d %s: ",channel,slave?" slave":"master");
.22F:
mov	al,-$20C[bp]
test	al,al
je  	.233
.234:
mov	bx,#.231
jmp .235
.233:
mov	bx,#.232
.235:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .230+0 (used reg = )
mov	bx,#.230
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1768           i=0; while(c=read_byte(get_SS(),model+i++)) bios_printf(2, "%c",c);
! Debug: eq int = const 0 to unsigned char i = [S+$246-$21C] (used reg = )
xor	al,al
mov	-$21A[bp],al
!BCC_EOS
jmp .237
.238:
! Debug: list unsigned char c = [S+$246-$21B] (used reg = )
mov	al,-$219[bp]
xor	ah,ah
push	ax
! Debug: list * char = .239+0 (used reg = )
mov	bx,#.239
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1769           if(read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device)==0x05)
.237:
! Debug: postinc unsigned char i = [S+$246-$21C] (used reg = )
mov	al,-$21A[bp]
inc	ax
mov	-$21A[bp],al
! Debug: ptradd unsigned char = al-1 to [$29] unsigned char model = S+$246-$246 (used reg = )
dec	ax
xor	ah,ah
mov	bx,bp
add	bx,ax
! Debug: cast * unsigned char = const 0 to [$29] unsigned char = bx-$244 (used reg = )
! Debug: list * unsigned char = bx-$244 (used reg = )
add	bx,#-$244
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char c = [S+$246-$21B] (used reg = )
mov	-$219[bp],al
test	al,al
jne	.238
.23A:
.236:
! Debug: ptradd unsigned char device = [S+$246-7] to [8] struct  = const $142 (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+$248-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
jne 	.23B
.23C:
! 1770             bios_printf(2, " ATAPI-%d CD-Rom/DVD-Rom\n",version);
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .23D+0 (used reg = )
mov	bx,#.23D
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1771           else
! 1772             bios_printf(2, " ATAPI-%d Device\n",version);
jmp .23E
.23B:
! Debug: list unsigned char version = [S+$246-$21D] (used reg = )
mov	al,-$21B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .23F+0 (used reg = )
mov	bx,#.23F
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 1773           break;
.23E:
jmp .21B
!BCC_EOS
! 1774         case 0x01:
! 1775           bios_printf(2, "ata%d %s: Unknown device\n",channel,slave?" slave":"master");
.240:
mov	al,-$20C[bp]
test	al,al
je  	.244
.245:
mov	bx,#.242
jmp .246
.244:
mov	bx,#.243
.246:
! Debug: list * char = bx+0 (used reg = )
push	bx
! Debug: list unsigned char channel = [S+$248-$20D] (used reg = )
mov	al,-$20B[bp]
xor	ah,ah
push	ax
! Debug: list * char = .241+0 (used reg = )
mov	bx,#.241
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 1776           break;
jmp .21B
!BCC_EOS
! 1777         }
! 1778       }
jmp .21B
.21D:
sub	al,*1
je 	.240
sub	al,*1
beq 	.21E
sub	al,*1
beq 	.22F
.21B:
..FFFB	=	-$246
add	sp,*$32
! 1779     }
add	sp,*$C
! 1780   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdcount, hdcount);
.19C:
! Debug: postinc unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
.19D:
! Debug: lt int = const 8 to unsigned char device = [S+$208-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
blo 	.19E
.247:
.19B:
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1781   write_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdcount, cdcount);
! Debug: list unsigned char cdcount = [S+$208-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $23B (used reg = )
mov	ax,#$23B
push	ax
! Debug: list unsigned short ebda_seg = [S+$20C-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1782   write_byte(0x40,0x75, hdcount);
! Debug: list unsigned char hdcount = [S+$208-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $75 (used reg = )
mov	ax,*$75
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 1783   bios_printf(2, "\n");
! Debug: list * char = .248+0 (used reg = )
mov	bx,#.248
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 1784 }
mov	sp,bp
pop	bp
ret
! 1785 void ata_reset(device)
! Register BX used in function ata_detect
! 1786 Bit16u device;
export	_ata_reset
_ata_reset:
!BCC_EOS
! 1787 {
! 1788   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1789   Bit16u iobase1, iobase2;
!BCC_EOS
! 1790   Bit8u channel, slave, sn, sc;
!BCC_EOS
! 1791   Bit8u type;
!BCC_EOS
! 1792   Bit16u max;
!BCC_EOS
! 1793   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 1794   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$A] (used reg = )
mov	-8[bp],al
!BCC_EOS
! 1795   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1796   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-9] to [4] struct  = const $122 (used reg = )
mov	al,-7[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1797   outb(iobase2+6, 0x08 | 0x02 | 0x04);
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1798   outb(0x80, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1799   outb(iobase2+6, 0x08 | 0x02);
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1800   type=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char type = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1801   if (type != 0x00) {
! Debug: ne int = const 0 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
beq 	.249
.24A:
! 1802     outb(iobase1+6, slave?0xb0:0xa0);
mov	al,-8[bp]
test	al,al
je  	.24B
.24C:
mov	al,#$B0
jmp .24D
.24B:
mov	al,#$A0
.24D:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1803     sc = inb(iobase1+2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1804     sn = inb(iobase1+3);
! Debug: add int = const 3 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sn = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1805     if ( (sc==0x01) &&
! 1805  (sn==0x01) ) {
! Debug: logeq int = const 1 to unsigned char sc = [S+$10-$C] (used reg = )
mov	al,-$A[bp]
cmp	al,*1
jne 	.24E
.250:
! Debug: logeq int = const 1 to unsigned char sn = [S+$10-$B] (used reg = )
mov	al,-9[bp]
cmp	al,*1
jne 	.24E
.24F:
! 1806       if (type == 0x02)
! Debug: logeq int = const 2 to unsigned char type = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
cmp	al,*2
jne 	.251
.252:
! 1807         await_ide(5, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1808       else
! 1809         await_ide(2, iobase1, 32000u);
jmp .253
.251:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1810     }
.253:
! 1811     await_ide(2, iobase1, 32000u);
.24E:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
!BCC_EOS
! 1812   }
! 1813   outb(iobase2+6, 0x08);
.249:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1814 }
mov	sp,bp
pop	bp
ret
! 1815 Bit16u ata_cmd_non_data()
! Register BX used in function ata_reset
! 1816 {return 0;}
export	_ata_cmd_non_data
_ata_cmd_non_data:
push	bp
mov	bp,sp
xor	ax,ax
pop	bp
ret
!BCC_EOS
! 1817 Bit16u ata_cmd_data_in(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! 1818 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_in
_ata_cmd_data_in:
!BCC_EOS
! 1819 Bit32u lba_low, lba_high;
!BCC_EOS
! 1820 {
! 1821   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1822   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1823   Bit8u channel, slave;
!BCC_EOS
! 1824   Bit8u status, current, mode;
!BCC_EOS
! 1825   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1826   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1827   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1828   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1829   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1830   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1831   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.254
.255:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1832   else blksize>>=1;
jmp .256
.254:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1833   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.256:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1834   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1835   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1836   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1837   if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.257
.258:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1838   outb(iobase2 + 6, 0x08 | 0x02);
.257:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1839   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.259
.25A:
! 1840     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.25F
mov	al,*1
jmp	.260
.25F:
xor	al,al
.260:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.25C
.25E:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.25C
.25D:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.25B
.25C:
! 1841       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1842       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1843       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1844       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1845       outb(iobase1 + 5, lba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1846       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1847       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1848       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1849       }
! 1850     sector = (Bit16u) (lba_low & 0x000000ffL);
.25B:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1851     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1852     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1853   }
! 1854   outb(iobase1 + 1, 0x00);
.259:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1855   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1856   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1857   outb(iobase1 + 4, cylinder & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1858   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1859   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.262
.263:
mov	al,#$B0
jmp .264
.262:
mov	al,#$A0
.264:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1860   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1861   status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1862   if (status
! 1862  & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.265
.266:
! 1863     ;
!BCC_EOS
! 1864     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1865     } else if ( !(status & 0x08) ) {
jmp .267
.265:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.268
.269:
! 1866     ;
!BCC_EOS
! 1867     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1868   }
! 1869 #asm
.268:
.267:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1871 endasm
!BCC_ENDASM
!BCC_EOS
! 1872   while (1) {
.26C:
! 1873 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_in.count	set	$16
.ata_cmd_data_in.count	set	8
_ata_cmd_data_in.segment	set	$26
.ata_cmd_data_in.segment	set	$18
_ata_cmd_data_in.iobase1	set	$A
.ata_cmd_data_in.iobase1	set	-4
_ata_cmd_data_in.channel	set	5
.ata_cmd_data_in.channel	set	-9
_ata_cmd_data_in.lba_low	set	$1E
.ata_cmd_data_in.lba_low	set	$10
_ata_cmd_data_in.lba_high	set	$22
.ata_cmd_data_in.lba_high	set	$14
_ata_cmd_data_in.sector	set	$1C
.ata_cmd_data_in.sector	set	$E
_ata_cmd_data_in.blksize	set	6
.ata_cmd_data_in.blksize	set	-8
_ata_cmd_data_in.head	set	$1A
.ata_cmd_data_in.head	set	$C
_ata_cmd_data_in.cylinder	set	$18
.ata_cmd_data_in.cylinder	set	$A
_ata_cmd_data_in.device	set	$12
.ata_cmd_data_in.device	set	4
_ata_cmd_data_in.ebda_seg	set	$C
.ata_cmd_data_in.ebda_seg	set	-2
_ata_cmd_data_in.status	set	3
.ata_cmd_data_in.status	set	-$B
_ata_cmd_data_in.current	set	2
.ata_cmd_data_in.current	set	-$C
_ata_cmd_data_in.command	set	$14
.ata_cmd_data_in.command	set	6
_ata_cmd_data_in.mode	set	1
.ata_cmd_data_in.mode	set	-$D
_ata_cmd_data_in.iobase2	set	8
.ata_cmd_data_in.iobase2	set	-6
_ata_cmd_data_in.offset	set	$28
.ata_cmd_data_in.offset	set	$1A
_ata_cmd_data_in.slave	set	4
.ata_cmd_data_in.slave	set	-$A
        push bp
        mov bp, sp
        mov di, _ata_cmd_data_in.offset + 2[bp]
        mov ax, _ata_cmd_data_in.segment + 2[bp]
        mov cx, _ata_cmd_data_in.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp di, #0xf800 ;;
        jbe ata_in_no_adjust
ata_in_adjust:
        sub di, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_in_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_in.iobase1 + 2[bp] ;; ATA data read port
        mov ah, _ata_cmd_data_in.mode + 2[bp]
        cmp ah, #0x01
        je ata_in_32
ata_in_16:
        rep
          insw ;; CX words transfered from port(DX) to ES:[DI]
        jmp ata_in_done
ata_in_32:
        rep
          insd ;; CX dwords transfered from port(DX) to ES:[DI]
ata_in_done:
        mov _ata_cmd_data_in.offset + 2[bp], di
        mov _ata_cmd_data_in.segment + 2[bp], es
        pop bp
! 1902 endasm
!BCC_ENDASM
!BCC_EOS
! 1903     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 1904     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1905     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 1906     status = await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1907     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.26D
.26E:
! 1908       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1909           != 0x40 ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.26F
.270:
! 1910         ;
!BCC_EOS
! 1911         return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1912         }
! 1913       break;
.26F:
jmp .26A
!BCC_EOS
! 1914       }
! 1915     else {
jmp .271
.26D:
! 1916       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 1917           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.272
.273:
! 1918         ;
!BCC_EOS
! 1919         return 5;
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1920       }
! 1921       continue;
.272:
jmp .26B
!BCC_EOS
! 1922     }
! 1923   }
.271:
! 1924   outb(iobase2+6, 0x08);
.26B:
jmp	.26C
.274:
.26A:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1925   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1926 }
! 1927 Bit16u ata_cmd_data_out(device, command, count, cylinder, head, sector, lba_low, lba_high, segment, offset)
! Register BX used in function ata_cmd_data_in
! 1928 Bit16u device, command, count, cylinder, head, sector, segment, offset;
export	_ata_cmd_data_out
_ata_cmd_data_out:
!BCC_EOS
! 1929 Bit32u lba_low, lba_high;
!BCC_EOS
! 1930 {
! 1931   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 1932   Bit16u iobase1, iobase2, blksize;
!BCC_EOS
! 1933   Bit8u channel, slave;
!BCC_EOS
! 1934   Bit8u status, current, mode;
!BCC_EOS
! 1935   channel = device / 2;
add	sp,*-$C
! Debug: div int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 1936   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$10+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$10-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 1937   iobase1 = read_word(ebda_s
! 1937 eg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 1938   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$10-$B] to [4] struct  = const $122 (used reg = )
mov	al,-9[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$10-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 1939   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$10+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$10-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 1940   blksize = 0x200;
! Debug: eq int = const $200 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,#$200
mov	-8[bp],ax
!BCC_EOS
! 1941   if (mode == 0x01) blksize>>=2;
! Debug: logeq int = const 1 to unsigned char mode = [S+$10-$F] (used reg = )
mov	al,-$D[bp]
cmp	al,*1
jne 	.275
.276:
! Debug: srab int = const 2 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1942   else blksize>>=1;
jmp .277
.275:
! Debug: srab int = const 1 to unsigned short blksize = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! 1943   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
.277:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 1944   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$16-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 1945   current = 0;
! Debug: eq int = const 0 to unsigned char current = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 1946   status = inb(iobase1 + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$10-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1947   if (status & 0x80) return 1;
! Debug: and int = const $80 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$80
test	al,al
je  	.278
.279:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1948   outb(iobase2 + 6, 0x08 | 0x02);
.278:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1949   if (sector == 0) {
! Debug: logeq int = const 0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	ax,$E[bp]
test	ax,ax
bne 	.27A
.27B:
! 1950     if ((count >= 1 << 8) || lba_high || (lba_low + count >= 1UL << 28)) {
! Debug: ge int = const $100 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
cmp	ax,#$100
jb 	.280
mov	al,*1
jmp	.281
.280:
xor	al,al
.281:
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
jne 	.27D
.27F:
mov	ax,$14[bp]
mov	bx,$16[bp]
call	ltstl
jne 	.27D
.27E:
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
lea	di,$10[bp]
call	laddul
! Debug: ge unsigned long = const $10000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$1000
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	lcmpul
lea	sp,-$E[bp]
blo 	.27C
.27D:
! 1951       outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1952       outb(iobase1 + 2, (count >> 8) & 0xff);
! Debug: sr int = const 8 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
mov	al,ah
xor	ah,ah
! Debug: and int = const $FF to unsigned int = ax+0 (used reg = )
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1953       outb(iobase1 + 3, lba_low >> 24);
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1954       outb(iobase1 + 4, lba_high & 0xff);
! Debug: and unsigned long = const $FF to unsigned long lba_high = [S+$10+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$14[bp]
call	landul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1955       outb(iobase1 + 5, lba_high >> 8);
! Debug: sr int = const 8 to unsigned long lba_high = [S+$10+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,$16[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$14-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*6
!BCC_EOS
! 1956       command |= 0x04;
! Debug: orab int = const 4 to unsigned short command = [S+$10+4] (used reg = )
mov	ax,6[bp]
or	al,*4
mov	6[bp],ax
!BCC_EOS
! 1957       count &= (1UL << 8) - 1;
! Debug: andab unsigned long = const $FF to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
xor	bx,bx
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
mov	8[bp],ax
add	sp,*8
!BCC_EOS
! 1958       lba_low &= (1UL << 24) - 1;
! Debug: andab unsigned long = const $FFFFFF to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,#$FFFF
mov	bx,#$FF
push	bx
push	ax
mov	ax,$10[bp]
mov	bx,$12[bp]
lea	di,-$12[bp]
call	landul
mov	$10[bp],ax
mov	$12[bp],bx
add	sp,*4
!BCC_EOS
! 1959       }
! 1960     sector = (Bit16u) (lba_low & 0x000000ffL);
.27C:
! Debug: and long = const $FF to unsigned long lba_low = [S+$10+$E] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,$10[bp]
call	landul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short sector = [S+$10+$C] (used reg = )
mov	$E[bp],ax
!BCC_EOS
! 1961     cylinder = (Bit16u) ((lba_low>>8) & 0x0000ffffL);
! Debug: sr int = const 8 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: and long = const $FFFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FFFF
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	$A[bp],ax
!BCC_EOS
! 1962     head = ((Bit16u) ((lba_low>>24) & 0x0000000fL)) | 0x40;
! Debug: sr int = const $18 to unsigned long lba_low = [S+$10+$E] (used reg = )
mov	ax,$10[bp]
mov	bx,$12[bp]
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: and long = const $F to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*$F
xor	bx,bx
push	bx
push	ax
mov	ax,-$12[bp]
mov	bx,-$10[bp]
lea	di,-$16[bp]
call	landul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: or int = const $40 to unsigned short = ax+0 (used reg = )
or	al,*$40
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$10+$A] (used reg = )
mov	$C[bp],ax
!BCC_EOS
! 1963   }
! 1964   outb(iobase1 + 1, 0x00);
.27A:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1965   outb(iobase1 + 2, count);
! Debug: list unsigned short count = [S+$10+6] (used reg = )
push	8[bp]
! Debug: add int = const 2 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1966   outb(iobase1 + 3, sector);
! Debug: list unsigned short sector = [S+$10+$C] (used reg = )
push	$E[bp]
! Debug: add int = const 3 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1967   outb(iobase1 + 4, cylinder & 0x00ff);
! Debug: and int = const $FF to unsigned short cylinder = [S+$10+8] (used reg = )
mov	al,$A[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1968   outb(iobase1 + 5, cylinder >> 8);
! Debug: sr int = const 8 to unsigned short cylinder = [S+$10+8] (used reg = )
mov	ax,$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1969   outb(iobase1 + 6, (slave ? 0xb0 : 0xa0) | (Bit8u) head );
mov	al,-$A[bp]
test	al,al
je  	.283
.284:
mov	al,#$B0
jmp .285
.283:
mov	al,#$A0
.285:
! Debug: or unsigned char head = [S+$10+$A] to char = al+0 (used reg = )
or	al,$C[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1970   outb(iobase1 + 7, command);
! Debug: list unsigned short command = [S+$10+4] (used reg = )
push	6[bp]
! Debug: add int = const 7 to unsigned short iobase1 = [S+$12-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 1971   status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 1972   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*1
test	al,al
je  	.286
.287:
! 1973     ;
!BCC_EOS
! 1974     return 2;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1975     } else if ( !(status & 0x08) ) {
jmp .288
.286:
! Debug: and int = const 8 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,*8
test	al,al
jne 	.289
.28A:
! 1976     ;
!BCC_EOS
! 1977     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 1978     }
! 1979 #asm
.289:
.288:
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        sti ;; enable higher priority interrupts
! 1981 endasm
!BCC_ENDASM
!BCC_EOS
! 1982   while (1) {
.28D:
! 1983 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_data_out.count	set	$16
.ata_cmd_data_out.count	set	8
_ata_cmd_data_out.segment	set	$26
.ata_cmd_data_out.segment	set	$18
_ata_cmd_data_out.iobase1	set	$A
.ata_cmd_data_out.iobase1	set	-4
_ata_cmd_data_out.channel	set	5
.ata_cmd_data_out.channel	set	-9
_ata_cmd_data_out.lba_low	set	$1E
.ata_cmd_data_out.lba_low	set	$10
_ata_cmd_data_out.lba_high	set	$22
.ata_cmd_data_out.lba_high	set	$14
_ata_cmd_data_out.sector	set	$1C
.ata_cmd_data_out.sector	set	$E
_ata_cmd_data_out.blksize	set	6
.ata_cmd_data_out.blksize	set	-8
_ata_cmd_data_out.head	set	$1A
.ata_cmd_data_out.head	set	$C
_ata_cmd_data_out.cylinder	set	$18
.ata_cmd_data_out.cylinder	set	$A
_ata_cmd_data_out.device	set	$12
.ata_cmd_data_out.device	set	4
_ata_cmd_data_out.ebda_seg	set	$C
.ata_cmd_data_out.ebda_seg	set	-2
_ata_cmd_data_out.status	set	3
.ata_cmd_data_out.status	set	-$B
_ata_cmd_data_out.current	set	2
.ata_cmd_data_out.current	set	-$C
_ata_cmd_data_out.command	set	$14
.ata_cmd_data_out.command	set	6
_ata_cmd_data_out.mode	set	1
.ata_cmd_data_out.mode	set	-$D
_ata_cmd_data_out.iobase2	set	8
.ata_cmd_data_out.iobase2	set	-6
_ata_cmd_data_out.offset	set	$28
.ata_cmd_data_out.offset	set	$1A
_ata_cmd_data_out.slave	set	4
.ata_cmd_data_out.slave	set	-$A
        push bp
        mov bp, sp
        mov si, _ata_cmd_data_out.offset + 2[bp]
        mov ax, _ata_cmd_data_out.segment + 2[bp]
        mov cx, _ata_cmd_data_out.blksize + 2[bp]
        ;; adjust if there will be an overrun. 2K max sector size
        cmp si, #0xf800 ;;
        jbe ata_out_no_adjust
ata_out_adjust:
        sub si, #0x0800 ;; sub 2 kbytes from offset
        add ax, #0x0080 ;; add 2 Kbytes to segment
ata_out_no_adjust:
        mov es, ax ;; segment in es
        mov dx, _ata_cmd_data_out.iobase1 + 2[bp] ;; ATA data write port
        mov ah, _ata_cmd_data_out.mode + 2[bp]
        cmp ah, #0x01
        je ata_out_32
ata_out_16:
        seg ES
        rep
          outsw ;; CX words transfered from port(DX) to ES:[SI]
        jmp ata_out_done
ata_out_32:
        seg ES
        rep
          outsd ;; CX dwords transfered from port(DX) to ES:[SI]
ata_out_done:
        mov _ata_cmd_data_out.offset + 2[bp], si
        mov _ata_cmd_data_out.segment + 2[bp], es
        pop bp
! 2014 endasm
!BCC_ENDASM
!BCC_EOS
! 2015     current++;
! Debug: postinc unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
inc	ax
mov	-$C[bp],al
!BCC_EOS
! 2016     write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,current);
! Debug: list unsigned char current = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2017     count--;
! Debug: postdec unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
dec	ax
mov	8[bp],ax
!BCC_EOS
! 2018     status = await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$12-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2019     if (count == 0) {
! Debug: logeq int = const 0 to unsigned short count = [S+$10+6] (used reg = )
mov	ax,8[bp]
test	ax,ax
jne 	.28E
.28F:
! 2020       if ( (status & (0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
! 2021           != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.290
.291:
! 2022         ;
!BCC_EOS
! 2023         return 6;
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2024         }
! 2025       break;
.290:
jmp .28B
!BCC_EOS
! 2026       }
! 2027     else {
jmp .292
.28E:
! 2028       if ( (status & (0x80 | 0x40 | 0x08 | 0x01) )
! 2029           != (0x40 | 0x08) ) {
! Debug: and int = const $C9 to unsigned char status = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
and	al,#$C9
! Debug: ne int = const $48 to unsigned char = al+0 (used reg = )
cmp	al,*$48
je  	.293
.294:
! 2030         ;
!BCC_EOS
! 2031         return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2032       }
! 2033       continue;
.293:
jmp .28C
!BCC_EOS
! 2034     }
! 2035   }
.292:
! 2036   outb(iobase2+6, 0x08);
.28C:
jmp	.28D
.295:
.28B:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$12-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2037   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2038 }
! 2039 Bit16u ata_cmd_packet(device, cmdlen, cmdseg, cmdoff, header, length, inout, bufseg, bufoff)
! Register BX used in function ata_cmd_data_out
! 2040 Bit8u cmdlen,inout;
export	_ata_cmd_packet
_ata_cmd_packet:
!BCC_EOS
! 2041 Bit16u device,cmdseg, cmdoff, bufseg, bufoff;
!BCC_EOS
! 2042 Bit16u header;
!BCC_EOS
! 2043 Bit32u length;
!BCC_EOS
! 2044 {
! 2045   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2046   Bit16u iobase1, iobase2;
!BCC_EOS
! 2047   Bit16u lcount, lbefore, lafter, count;
!BCC_EOS
! 2048   Bit8u channel, slave;
!BCC_EOS
! 2049   Bit8u status, mode, lmode;
!BCC_EOS
! 2050   Bit32u total, transfer;
!BCC_EOS
! 2051   channel = device / 2;
add	sp,*-$1A
! Debug: div int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$1E-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 2052   slave = device % 2;
! Debug: mod int = const 2 to unsigned short device = [S+$1E+2] (used reg = )
mov	ax,4[bp]
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char slave = [S+$1E-$12] (used reg = )
mov	-$10[bp],al
!BCC_EOS
! 2053   if (inout == 0x02) {
! Debug: logeq int = const 2 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.296
.297:
! 2054     ;
!BCC_EOS
! 2055     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2056     }
! 2057   if (header & 1) {
.296:
! Debug: and int = const 1 to unsigned short header = [S+$1E+$A] (used reg = )
mov	al,$C[bp]
and	al,*1
test	al,al
je  	.298
.299:
! 2058     ;
!BCC_EOS
! 2059     return 1;
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2060     }
! 2061   iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
.298:
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2062   iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$1E-$11] to [4] struct  = const $122 (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$1E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2063   mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned short device = [S+$1E+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$20-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$1E-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 2064   transfer= 0L;
! Debug: eq long = const 0 to unsigned long transfer = [S+$1E-$1E] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2065   if (cmdlen < 12) cmdlen=12;
! Debug: lt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jae 	.29A
.29B:
! Debug: eq int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$C
mov	6[bp],al
!BCC_EOS
! 2066   if (cmdlen > 12) cmdlen=16;
.29A:
! Debug: gt int = const $C to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
cmp	al,*$C
jbe 	.29C
.29D:
! Debug: eq int = const $10 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,*$10
mov	6[bp],al
!BCC_EOS
! 2067   cmdlen>>=1;
.29C:
! Debug: srab int = const 1 to unsigned char cmdlen = [S+$1E+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
shr	ax,*1
mov	6[bp],al
!BCC_EOS
! 2068   write_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors,0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2069   write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2070   status = inb(iobase1
! 2070  + 7);
! Debug: add int = const 7 to unsigned short iobase1 = [S+$1E-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2071   if (status & 0x80) return 2;
! Debug: and int = const $80 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$80
test	al,al
je  	.29E
.29F:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2072   outb(iobase2 + 6, 0x08 | 0x02);
.29E:
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2073   outb(iobase1 + 1, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 1 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2074   outb(iobase1 + 2, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 2 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2075   outb(iobase1 + 3, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 3 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2076   outb(iobase1 + 4, 0xfff0 & 0x00ff);
! Debug: list unsigned int = const $F0 (used reg = )
mov	ax,#$F0
push	ax
! Debug: add int = const 4 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2077   outb(iobase1 + 5, 0xfff0 >> 8);
! Debug: list unsigned int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2078   outb(iobase1 + 6, slave ? 0xb0 : 0xa0);
mov	al,-$10[bp]
test	al,al
je  	.2A0
.2A1:
mov	al,#$B0
jmp .2A2
.2A0:
mov	al,#$A0
.2A2:
! Debug: list char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 6 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2079   outb(iobase1 + 7, 0xA0);
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: add int = const 7 to unsigned short iobase1 = [S+$20-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2080   status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2081   if (status & 0x01) {
! Debug: and int = const 1 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.2A3
.2A4:
! 2082     ;
!BCC_EOS
! 2083     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2084     } else if ( !(status & 0x08) ) {
jmp .2A5
.2A3:
! Debug: and int = const 8 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,*8
test	al,al
jne 	.2A6
.2A7:
! 2085     ;
!BCC_EOS
! 2086     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2087     }
! 2088   cmdseg += (cmdoff / 16);
.2A6:
.2A5:
! Debug: div int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short cmdseg = [S+$1E+6] (used reg = )
add	ax,8[bp]
mov	8[bp],ax
!BCC_EOS
! 2089   cmdoff %= 16;
! Debug: modab int = const $10 to unsigned short cmdoff = [S+$1E+8] (used reg = )
mov	ax,$A[bp]
and	al,*$F
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 2090 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$26
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$28
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$E
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$10
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$18
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$D
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$24
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$22
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	9
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$20
.ata_cmd_packet.device	set	4
_ata_cmd_packet.ebda_seg	set	$1A
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$14
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	4
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$B
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$A
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$32
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	0
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.iobase2	set	$16
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$12
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$30
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$C
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$2E
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2A
.ata_cmd_packet.length	set	$E
      sti ;; enable higher priority interrupts
      push bp
      mov bp, sp
      mov si, _ata_cmd_packet.cmdoff + 2[bp]
      mov ax, _ata_cmd_packet.cmdseg + 2[bp]
      mov cx, _ata_cmd_packet.cmdlen + 2[bp]
      mov es, ax ;; segment in es
      mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data write port
      seg ES
      rep
        outsw ;; CX words transfered from port(DX) to ES:[SI]
      pop bp
! 2103 endasm
!BCC_ENDASM
!BCC_EOS
! 2104   if (inout == 0x00) {
! Debug: logeq int = const 0 to unsigned char inout = [S+$1E+$10] (used reg = )
mov	al,$12[bp]
test	al,al
jne 	.2A8
.2A9:
! 2105     status = await_ide(2, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$20-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$1E-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2106     }
! 2107   else {
br 	.2AA
.2A8:
! 2108         Bit16u loops = 0;
dec	sp
dec	sp
! Debug: eq int = const 0 to unsigned short loops = [S+$20-$20] (used reg = )
xor	ax,ax
mov	-$1E[bp],ax
!BCC_EOS
! 2109         Bit8u sc;
!BCC_EOS
! 2110   while (1) {
dec	sp
dec	sp
.2AD:
! 2111       if (loops == 0) {
! Debug: logeq int = const 0 to unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
test	ax,ax
jne 	.2AE
.2AF:
! 2112         status = inb(iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$22-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2113         status = await_ide(3, iobase1, 32000u);
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2114       }
! 2115       else
! 2116         status = await_ide(2, iobase1, 32000u);
jmp .2B0
.2AE:
! Debug: list unsigned int = const $7D00 (used reg = )
mov	ax,#$7D00
push	ax
! Debug: list unsigned short iobase1 = [S+$24-6] (used reg = )
push	-4[bp]
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = await_ide+0 (used reg = )
call	_await_ide
add	sp,*6
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2117       loops++;
.2B0:
! Debug: postinc unsigned short loops = [S+$22-$20] (used reg = )
mov	ax,-$1E[bp]
inc	ax
mov	-$1E[bp],ax
!BCC_EOS
! 2118       sc = inb(iobase1 + 2);
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char sc = [S+$22-$21] (used reg = )
mov	-$1F[bp],al
!BCC_EOS
! 2119       if(((inb(iobase1 + 2)&0x7)==0x3) &&
! 2120          ((status & (0x40 | 0x01)) == 0x40)) break;
! Debug: add int = const 2 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 7 to unsigned char = al+0 (used reg = )
and	al,*7
! Debug: logeq int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
jne 	.2B1
.2B3:
! Debug: and int = const $41 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*$41
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.2B1
.2B2:
br 	.2AB
!BCC_EOS
! 2121       if (status & 0x01) {
.2B1:
! Debug: and int = const 1 to unsigned char status = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
and	al,*1
test	al,al
je  	.2B4
.2B5:
! 2122         ;
!BCC_EOS
! 2123         return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2124       }
! 2125       bufseg += (bufoff / 16);
.2B4:
! Debug: div int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
mov	cl,*4
shr	ax,cl
! Debug: addab unsigned int = ax+0 to unsigned short bufseg = [S+$22+$12] (used reg = )
add	ax,$14[bp]
mov	$14[bp],ax
!BCC_EOS
! 2126       bufoff %= 16;
! Debug: modab int = const $10 to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
and	al,*$F
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 2127       lcount = ((Bit16u)(inb(iobase1 + 5))<<8)+inb(iobase1 + 4);
! Debug: add int = const 4 to unsigned short iobase1 = [S+$22-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
push	ax
! Debug: add int = const 5 to unsigned short iobase1 = [S+$24-6] (used reg = )
mov	ax,-4[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 8 to unsigned short = ax+0 (used reg = )
mov	ah,al
xor	al,al
! Debug: add unsigned char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
add	al,-$22[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 2128       if(header>lcount) {
! Debug: gt unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
cmp	ax,-8[bp]
jbe 	.2B6
.2B7:
! 2129          lbefore=lcount;
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2130          header-=lcount;
! Debug: subab unsigned short lcount = [S+$22-$A] to unsigned short header = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
sub	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 2131          lcount=0;
! Debug: eq int = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 2132          }
! 2133       else {
jmp .2B8
.2B6:
! 2134         lbefore=header;
! Debug: eq unsigned short header = [S+$22+$A] to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,$C[bp]
mov	-$A[bp],ax
!BCC_EOS
! 2135         header=0;
! Debug: eq int = const 0 to unsigned short header = [S+$22+$A] (used reg = )
xor	ax,ax
mov	$C[bp],ax
!BCC_EOS
! 2136         lcount-=lbefore;
! Debug: subab unsigned short lbefore = [S+$22-$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
sub	ax,-$A[bp]
mov	-8[bp],ax
!BCC_EOS
! 2137         }
! 2138       if(lcount>length) {
.2B8:
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: gt unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lcmpul
jbe 	.2B9
.2BA:
! 2139         lafter=lcount-length;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: sub unsigned long length = [S+$22+$C] to unsigned long = bx+0 (used reg = )
lea	di,$E[bp]
call	lsubul
! Debug: eq unsigned long = bx+0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 2140         lcount=length;
! Debug: eq unsigned long length = [S+$22+$C] to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,$E[bp]
mov	-8[bp],ax
!BCC_EOS
! 2141         length=0;
! Debug: eq int = const 0 to unsigned long length = [S+$22+$C] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$E[bp],ax
mov	$10[bp],bx
!BCC_EOS
! 2142         }
! 2143       else {
jmp .2BB
.2B9:
! 2144         lafter=0;
! Debug: eq int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 2145         length-=lcount;
! Debug: cast unsigned long = const 0 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
! Debug: subab unsigned long = bx+0 to unsigned long length = [S+$22+$C] (used reg = )
push	bx
push	ax
mov	ax,$E[bp]
mov	bx,$10[bp]
lea	di,-$24[bp]
call	lsubul
mov	$E[bp],ax
mov	$10[bp],bx
add	sp,*4
!BCC_EOS
! 2146         }
! 2147       count = lcount;
.2BB:
! Debug: eq unsigned short lcount = [S+$22-$A] to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-8[bp]
mov	-$E[bp],ax
!BCC_EOS
! 2148       ;
!BCC_EOS
! 2149       ;
!BCC_EOS
! 2150       lmode = mode;
! Debug: eq unsigned char mode = [S+$22-$14] to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$12[bp]
mov	-$13[bp],al
!BCC_EOS
! 2151       if (lbefore & 0x03) lmode=0x00;
! Debug: and int = const 3 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	al,-$A[bp]
and	al,*3
test	al,al
je  	.2BC
.2BD:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2152       if (lcount & 0x03) lmode=0x00;
.2BC:
! Debug: and int = const 3 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*3
test	al,al
je  	.2BE
.2BF:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2153     
! 2153   if (lafter & 0x03) lmode=0x00;
.2BE:
! Debug: and int = const 3 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*3
test	al,al
je  	.2C0
.2C1:
! Debug: eq int = const 0 to unsigned char lmode = [S+$22-$15] (used reg = )
xor	al,al
mov	-$13[bp],al
!BCC_EOS
! 2154       if (lcount & 0x01) {
.2C0:
! Debug: and int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	al,-8[bp]
and	al,*1
test	al,al
je  	.2C2
.2C3:
! 2155         lcount+=1;
! Debug: addab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 2156         if ((lafter > 0) && (lafter & 0x01)) {
! Debug: gt int = const 0 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.2C4
.2C6:
! Debug: and int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	al,-$C[bp]
and	al,*1
test	al,al
je  	.2C4
.2C5:
! 2157           lafter-=1;
! Debug: subab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
dec	ax
mov	-$C[bp],ax
!BCC_EOS
! 2158           }
! 2159         }
.2C4:
! 2160       if (lmode == 0x01) {
.2C2:
! Debug: logeq int = const 1 to unsigned char lmode = [S+$22-$15] (used reg = )
mov	al,-$13[bp]
cmp	al,*1
jne 	.2C7
.2C8:
! 2161         lcount>>=2; lbefore>>=2; lafter>>=2;
! Debug: srab int = const 2 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 2 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2162         }
! 2163       else {
jmp .2C9
.2C7:
! 2164         lcount>>=1; lbefore>>=1; lafter>>=1;
! Debug: srab int = const 1 to unsigned short lcount = [S+$22-$A] (used reg = )
mov	ax,-8[bp]
shr	ax,*1
mov	-8[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lbefore = [S+$22-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
mov	-$A[bp],ax
!BCC_EOS
! Debug: srab int = const 1 to unsigned short lafter = [S+$22-$E] (used reg = )
mov	ax,-$C[bp]
shr	ax,*1
mov	-$C[bp],ax
!BCC_EOS
! 2165         }
! 2166        ;
.2C9:
!BCC_EOS
! 2167 #asm
!BCC_EOS
!BCC_ASM
_ata_cmd_packet.cmdoff	set	$2A
.ata_cmd_packet.cmdoff	set	$A
_ata_cmd_packet.header	set	$2C
.ata_cmd_packet.header	set	$C
_ata_cmd_packet.count	set	$12
.ata_cmd_packet.count	set	-$E
_ata_cmd_packet.lafter	set	$14
.ata_cmd_packet.lafter	set	-$C
_ata_cmd_packet.iobase1	set	$1C
.ata_cmd_packet.iobase1	set	-4
_ata_cmd_packet.channel	set	$11
.ata_cmd_packet.channel	set	-$F
_ata_cmd_packet.cmdseg	set	$28
.ata_cmd_packet.cmdseg	set	8
_ata_cmd_packet.cmdlen	set	$26
.ata_cmd_packet.cmdlen	set	6
_ata_cmd_packet.lmode	set	$D
.ata_cmd_packet.lmode	set	-$13
_ata_cmd_packet.device	set	$24
.ata_cmd_packet.device	set	4
_ata_cmd_packet.loops	set	2
.ata_cmd_packet.loops	set	-$1E
_ata_cmd_packet.ebda_seg	set	$1E
.ata_cmd_packet.ebda_seg	set	-2
_ata_cmd_packet.lcount	set	$18
.ata_cmd_packet.lcount	set	-8
_ata_cmd_packet.total	set	8
.ata_cmd_packet.total	set	-$18
_ata_cmd_packet.status	set	$F
.ata_cmd_packet.status	set	-$11
_ata_cmd_packet.mode	set	$E
.ata_cmd_packet.mode	set	-$12
_ata_cmd_packet.bufoff	set	$36
.ata_cmd_packet.bufoff	set	$16
_ata_cmd_packet.transfer	set	4
.ata_cmd_packet.transfer	set	-$1C
_ata_cmd_packet.sc	set	1
.ata_cmd_packet.sc	set	-$1F
_ata_cmd_packet.iobase2	set	$1A
.ata_cmd_packet.iobase2	set	-6
_ata_cmd_packet.lbefore	set	$16
.ata_cmd_packet.lbefore	set	-$A
_ata_cmd_packet.bufseg	set	$34
.ata_cmd_packet.bufseg	set	$14
_ata_cmd_packet.slave	set	$10
.ata_cmd_packet.slave	set	-$10
_ata_cmd_packet.inout	set	$32
.ata_cmd_packet.inout	set	$12
_ata_cmd_packet.length	set	$2E
.ata_cmd_packet.length	set	$E
        push bp
        mov bp, sp
        mov dx, _ata_cmd_packet.iobase1 + 2[bp] ;; ATA data read port
        mov cx, _ata_cmd_packet.lbefore + 2[bp]
        jcxz ata_packet_no_before
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_before_32
ata_packet_in_before_16:
        in ax, dx
        loop ata_packet_in_before_16
        jmp ata_packet_no_before
ata_packet_in_before_32:
        push eax
ata_packet_in_before_32_loop:
        in eax, dx
        loop ata_packet_in_before_32_loop
        pop eax
ata_packet_no_before:
        mov cx, _ata_cmd_packet.lcount + 2[bp]
        jcxz ata_packet_after
        mov di, _ata_cmd_packet.bufoff + 2[bp]
        mov ax, _ata_cmd_packet.bufseg + 2[bp]
        mov es, ax
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_32
ata_packet_in_16:
        rep
          insw ;; CX words transfered tp port(DX) to ES:[DI]
        jmp ata_packet_after
ata_packet_in_32:
        rep
          insd ;; CX dwords transfered to port(DX) to ES:[DI]
ata_packet_after:
        mov cx, _ata_cmd_packet.lafter + 2[bp]
        jcxz ata_packet_done
        mov ah, _ata_cmd_packet.lmode + 2[bp]
        cmp ah, #0x01
        je ata_packet_in_after_32
ata_packet_in_after_16:
        in ax, dx
        loop ata_packet_in_after_16
        jmp ata_packet_done
ata_packet_in_after_32:
        push eax
ata_packet_in_after_32_loop:
        in eax, dx
        loop ata_packet_in_after_32_loop
        pop eax
ata_packet_done:
        pop bp
! 2220 endasm
!BCC_ENDASM
!BCC_EOS
! 2221       bufoff += count;
! Debug: addab unsigned short count = [S+$22-$10] to unsigned short bufoff = [S+$22+$14] (used reg = )
mov	ax,$16[bp]
add	ax,-$E[bp]
mov	$16[bp],ax
!BCC_EOS
! 2222       transfer += count;
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$22-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
! Debug: addab unsigned long = bx+0 to unsigned long transfer = [S+$22-$1E] (used reg = )
lea	di,-$1C[bp]
call	laddul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2223       write_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes,transfer);
! Debug: list unsigned long transfer = [S+$22-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$28-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2224       }
! 2225     }
.2AC:
br 	.2AD
.2CA:
.2AB:
add	sp,*4
! 2226   if ( (status & (
.2AA:
! 2226 0x80 | 0x40 | 0x20 | 0x08 | 0x01) )
! 2227          != 0x40 ) {
! Debug: and int = const $E9 to unsigned char status = [S+$1E-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$E9
! Debug: ne int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
je  	.2CB
.2CC:
! 2228     ;
!BCC_EOS
! 2229     return 4;
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2230     }
! 2231   outb(iobase2+6, 0x08);
.2CB:
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: add int = const 6 to unsigned short iobase2 = [S+$20-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2232   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2233 }
! 2234   Bit16u
! Register BX used in function ata_cmd_packet
! 2235 atapi_get_sense(device, seg, asc, ascq)
! 2236   Bit16u device;
export	_atapi_get_sense
_atapi_get_sense:
!BCC_EOS
! 2237 {
! 2238   Bit8u atacmd[12];
!BCC_EOS
! 2239   Bit8u buffer[18];
!BCC_EOS
! 2240   Bit8u i;
!BCC_EOS
! 2241   memsetb(get_SS(),atacmd,0,12);
push	bp
mov	bp,sp
add	sp,*-$20
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2242   atacmd[0]=0x03;
! Debug: eq int = const 3 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	al,*3
mov	-$C[bp],al
!BCC_EOS
! 2243   atacmd[4]=sizeof(buffer);
! Debug: eq int = const $12 to unsigned char atacmd = [S+$22-$A] (used reg = )
mov	al,*$12
mov	-8[bp],al
!BCC_EOS
! 2244   if (ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 18L, 0x01, get_SS(), buffer) != 0)
! Debug: list * unsigned char buffer = S+$22-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $12 (used reg = )
mov	ax,*$12
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$34+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.2CD
.2CE:
! 2245     return 0x0002;
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2246   write_byte(seg,asc,buffer[12]);
.2CD:
! Debug: list unsigned char buffer = [S+$22-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int asc = [S+$24+6] (used reg = )
push	8[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2247   write_byte(seg,ascq,buffer[13]);
! Debug: list unsigned char buffer = [S+$22-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int ascq = [S+$24+8] (used reg = )
push	$A[bp]
! Debug: list int seg = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2248   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2249 }
! 2250   Bit16u
! Register BX used in function atapi_get_sense
! 2251 atapi_is_ready(device)
! 2252   Bit16u device;
export	_atapi_is_ready
_atapi_is_ready:
!BCC_EOS
! 2253 {
! 2254   Bit8u packet[12];
!BCC_EOS
! 2255   Bit8u buf[8];
!BCC_EOS
! 2256   Bit32u block_len;
!BCC_EOS
! 2257   Bit32u sectors;
!BCC_EOS
! 2258   Bit32u timeout;
!BCC_EOS
! 2259   Bit32u time;
!BCC_EOS
! 2260   Bit8u asc, ascq;
!BCC_EOS
! 2261   Bit8u in_progress;
!BCC_EOS
! 2262   Bit16u ebda_seg = read_word(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$2A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$2C-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 2263   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03) {
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2CF
.2D0:
! 2264     bios_printf(2, "not implemented for non-ATAPI device\n");
! Debug: list * char = .2D1+0 (used reg = )
mov	bx,#.2D1
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2265     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2266   }
! 2267   ;
.2CF:
!BCC_EOS
! 2268   memsetb(get_SS(),packet, 0, sizeof packet);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$30-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2269   packet[0] = 0x25;
! Debug: eq int = const $25 to unsigned char packet = [S+$2C-$E] (used reg = )
mov	al,*$25
mov	-$C[bp],al
!BCC_EOS
! 2270   timeout = 5000;
! Debug: eq int = const $1388 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$1388
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2271   time = 0;
! Debug: eq int = const 0 to unsigned long time = [S+$2C-$26] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-$24[bp],ax
mov	-$22[bp],bx
!BCC_EOS
! 2272   in_progress = 0;
! Debug: eq int = const 0 to unsigned char in_progress = [S+$2C-$29] (used reg = )
xor	al,al
mov	-$27[bp],al
!BCC_EOS
! 2273   while (time < timeout) {
br 	.2D3
.2D4:
! 2274     if (ata_cmd_packet(device, sizeof(packet), get_SS(), packet, 0, 8L, 0x01, get_SS(), buf) == 0)
! Debug: list * unsigned char buf = S+$2C-$16 (used reg = )
lea	bx,-$14[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const 8 (used reg = )
mov	ax,*8
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char packet = S+$38-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned short device = [S+$3E+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2D5
.2D6:
! 2275       goto ok;
add	sp,#..FFFA+$2C
br 	.FFFA
!BCC_EOS
! 2276     if (atapi_get_sense(device, get_SS(), &asc, &ascq) == 0) {
.2D5:
! Debug: list * unsigned char ascq = S+$2C-$28 (used reg = )
lea	bx,-$26[bp]
push	bx
! Debug: list * unsigned char asc = S+$2E-$27 (used reg = )
lea	bx,-$25[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list unsigned short device = [S+$32+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = atapi_get_sense+0 (used reg = )
call	_atapi_get_sense
add	sp,*8
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.2D7
.2D8:
! 2277       if (asc == 0x3a) {
! Debug: logeq int = const $3A to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*$3A
jne 	.2D9
.2DA:
! 2278         ;
!BCC_EOS
! 2279         return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2280       }
! 2281       if (asc == 0x04 && ascq == 0x01 && !in_progress) {
.2D9:
! Debug: logeq int = const 4 to unsigned char asc = [S+$2C-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*4
jne 	.2DB
.2DE:
! Debug: logeq int = const 1 to unsigned char ascq = [S+$2C-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*1
jne 	.2DB
.2DD:
mov	al,-$27[bp]
test	al,al
jne 	.2DB
.2DC:
! 2282         bios_printf(2, "Waiting for device to detect medium... ");
! Debug: list * char = .2DF+0 (used reg = )
mov	bx,#.2DF
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2283         timeout = 30000;
! Debug: eq int = const $7530 to unsigned long timeout = [S+$2C-$22] (used reg = )
mov	ax,#$7530
xor	bx,bx
mov	-$20[bp],ax
mov	-$1E[bp],bx
!BCC_EOS
! 2284         in_progress = 1;
! Debug: eq int = const 1 to unsigned char in_progress = [S+$2C-$29] (used reg = )
mov	al,*1
mov	-$27[bp],al
!BCC_EOS
! 2285       }
! 2286     }
.2DB:
! 2287     time += 100;
.2D7:
! Debug: addab unsigned long = const $64 to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,*$64
xor	bx,bx
push	bx
push	ax
mov	ax,-$24[bp]
mov	bx,-$22[bp]
lea	di,-$2E[bp]
call	laddul
mov	-$24[bp],ax
mov	-$22[bp],bx
add	sp,*4
!BCC_EOS
! 2288   }
! 2289   ;
.2D3:
! Debug: lt unsigned long timeout = [S+$2C-$22] to unsigned long time = [S+$2C-$26] (used reg = )
mov	ax,-$20[bp]
mov	bx,-$1E[bp]
lea	di,-$24[bp]
call	lcmpul
bhi 	.2D4
.2E0:
.2D2:
!BCC_EOS
! 2290   return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2291 ok:
.FFFA:
..FFFA	=	-$2C
! 2292   block_len = (Bit32u) buf[4] << 24
! 2293     | (Bit32u) buf[5] << 16
! 2294     | (Bit32u) buf[6] << 8
! 2295     | (Bit32u) buf[7] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$12] (used reg = )
mov	al,-$10[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long block_len = [S+$2C-$1A] (used reg = )
mov	-$18[bp],ax
mov	-$16[bp],bx
!BCC_EOS
! 2296   ;
!BCC_EOS
! 2297   if (block_len!= 2048 && block_len!= 512)
! Debug: ne unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2E1
.2E3:
! Debug: ne unsigned long = const $200 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
je  	.2E1
.2E2:
! 2298   {
! 2299     bios_printf(2, "Unsupported sector size %u\n", block_len);
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: list * char = .2E4+0 (used reg = )
mov	bx,#.2E4
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2300     return -1;
mov	ax,#$FFFF
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2301   }
! 2302   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].blksize, block_len);
.2E1:
! Debug: list unsigned long block_len = [S+$2C-$1A] (used reg = )
push	-$16[bp]
push	-$18[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2303   sectors = (Bit32u) buf[0] << 24
! 2304     | (Bit32u) buf[1] << 16
! 2305     | (Bit32u) buf[2] << 8
! 2306     | (Bit32u) buf[3] << 0;
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$2C-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 0 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$30-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const 8 to unsigned long = bx+0 (used reg = )
mov	bh,bl
mov	bl,ah
mov	ah,al
xor	al,al
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$34-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	ax,ax
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buf = [S+$38-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
xor	bx,bx
! Debug: sl int = const $18 to unsigned long = bx+0 (used reg = )
mov	ah,al
xor	al,al
xchg	bx,ax
xor	ax,ax
! Debug: or unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$36[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$32[bp]
call	lorul
add	sp,*4
! Debug: or unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-$2E[bp]
call	lorul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2307   ;
!BCC_EOS
! 2308   if (block_len == 2048)
! Debug: logeq unsigned long = const $800 to unsigned long block_len = [S+$2C-$1A] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-$2E[bp]
call	lcmpul
lea	sp,-$2A[bp]
jne 	.2E5
.2E6:
! 2309     sectors <<= 2;
! Debug: slab int = const 2 to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	di,*2
call	lslul
mov	-$1C[bp],ax
mov	-$1A[bp],bx
!BCC_EOS
! 2310   if (sect
.2E5:
! 2310 ors != read_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low))
! Debug: ptradd unsigned short device = [S+$2C+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2E-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ne unsigned long = bx+0 to unsigned long sectors = [S+$2C-$1E] (used reg = )
! Debug: expression subtree swapping
lea	di,-$1C[bp]
call	lcmpul
je  	.2E7
.2E8:
! 2311     bios_printf(2, "%dMB medium detected\n", sectors>>(20-9));
! Debug: sr int = const $B to unsigned long sectors = [S+$2C-$1E] (used reg = )
mov	ax,-$1C[bp]
mov	bx,-$1A[bp]
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list * char = .2E9+0 (used reg = )
mov	bx,#.2E9
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*8
!BCC_EOS
! 2312   write_dword(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].sectors_low, sectors);
.2E7:
! Debug: list unsigned long sectors = [S+$2C-$1E] (used reg = )
push	-$1A[bp]
push	-$1C[bp]
! Debug: ptradd unsigned short device = [S+$30+2] to [8] struct  = const $142 (used reg = )
mov	ax,4[bp]
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$32-$2C] (used reg = )
push	-$2A[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2313   return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2314 }
! 2315   Bit16u
! Register BX used in function atapi_is_ready
! 2316 atapi_is_cdrom(device)
! 2317   Bit8u device;
export	_atapi_is_cdrom
_atapi_is_cdrom:
!BCC_EOS
! 2318 {
! 2319   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2320   if (device >= (4*2))
! Debug: ge int = const 8 to unsigned char device = [S+4+2] (used reg = )
mov	al,4[bp]
cmp	al,*8
jb  	.2EA
.2EB:
! 2321     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2322   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].type) != 0x03)
.2EA:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$142] (used reg = )
! Debug: list * unsigned char = bx+$142 (used reg = )
add	bx,#$142
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 3 to unsigned char = al+0 (used reg = )
cmp	al,*3
je  	.2EC
.2ED:
! 2323     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2324   if (read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.devices[device].device) != 0x05)
.2EC:
! Debug: ptradd unsigned char device = [S+4+2] to [8] struct  = const $142 (used reg = )
mov	al,4[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$143] (used reg = )
! Debug: list * unsigned char = bx+$143 (used reg = )
add	bx,#$143
push	bx
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 5 to unsigned char = al+0 (used reg = )
cmp	al,*5
je  	.2EE
.2EF:
! 2325     return 0;
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2326   return 1;
.2EE:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2327 }
! 2328   void
! Register BX used in function atapi_is_cdrom
! 2329 cdemu_init()
! 2330 {
export	_cdemu_init
_cdemu_init:
! 2331   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2332   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2333 }
mov	sp,bp
pop	bp
ret
! 2334   Bit8u
! 2335 cdemu_isactive()
! 2336 {
export	_cdemu_isactive
_cdemu_isactive:
! 2337   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2338   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active));
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2339 }
! 2340   Bit8u
! 2341 cdemu_emulated_drive()
! 2342 {
export	_cdemu_emulated_drive
_cdemu_emulated_drive:
! 2343   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2344   return(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: cast unsigned char = const 0 to unsigned char = al+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2345 }
! 2346 static char isotag[6]="CD001";
.data
_isotag:
.2F0:
.ascii	"CD001"
.byte	0
!BCC_EOS
! 2347 static char eltorito[24]="EL TORITO SPECIFICATION";
_eltorito:
.2F1:
.ascii	"EL TORITO SPECIFICATION"
.byte	0
!BCC_EOS
! 2348   Bit16u
! 2349 cdrom_boot()
! 2350 {
.text
export	_cdrom_boot
_cdrom_boot:
! 2351   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2352   Bit8u atacmd[12], buffer[2048];
!BCC_EOS
! 2353   Bit32u lba;
!BCC_EOS
! 2354   Bit16u boot_segment, nbsectors, i, error;
!BCC_EOS
! 2355   Bit8u device;
!BCC_EOS
! 2356   for (device=0; device<(4*2);device++) {
add	sp,#-$81A
! Debug: eq int = const 0 to unsigned char device = [S+$81E-$81D] (used reg = )
xor	al,al
mov	-$81B[bp],al
!BCC_EOS
!BCC_EOS
jmp .2F4
.2F5:
! 2357     if (atapi_is_cdrom(device)) break;
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_cdrom+0 (used reg = )
call	_atapi_is_cdrom
inc	sp
inc	sp
test	ax,ax
je  	.2F6
.2F7:
br 	.2F2
!BCC_EOS
! 2358     }
.2F6:
! 2359   if(device >= (4*2)) return 2;
.2F3:
! Debug: postinc unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
inc	ax
mov	-$81B[bp],al
.2F4:
! Debug: lt int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb 	.2F5
.2F8:
.2F2:
! Debug: ge int = const 8 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
cmp	al,*8
jb  	.2F9
.2FA:
mov	ax,*2
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2360   if(error = atapi_is_ready(device) != 0)
.2F9:
! Debug: list unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = atapi_is_ready+0 (used reg = )
call	_atapi_is_ready
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je 	.2FD
mov	al,*1
jmp	.2FE
.2FD:
xor	al,al
.2FE:
! Debug: eq char = al+0 to unsigned short error = [S+$81E-$81C] (used reg = )
xor	ah,ah
mov	-$81A[bp],ax
test	ax,ax
je  	.2FB
.2FC:
! 2361     ;
!BCC_EOS
! 2362   memsetb(get_SS(),atacmd,0,12);
.2FB:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2363   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2364   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2365   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2366   atacmd[2]=(0x11 & 0xff000000) >> 24;
! Debug: eq unsigned long = const 0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2367   atacmd[3]=(0x11 & 0x00ff0000) >> 16;
! Debug: eq long = const 0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
xor	al,al
mov	-$B[bp],al
!BCC_EOS
! 2368   atacmd[4]=(0x11 & 0x0000ff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
xor	al,al
mov	-$A[bp],al
!BCC_EOS
! 2369   atacmd[5]=(0x11 & 0x000000ff);
! Debug: eq int = const $11 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	al,*$11
mov	-9[bp],al
!BCC_EOS
! 2370   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.2FF
.300:
! 2371     return 3;
mov	ax,*3
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2372   if(buffer[0]!=0)return 4;
.2FF:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
test	al,al
je  	.301
.302:
mov	ax,*4
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2373   for(i=0;i<5;i++){
.301:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
jmp .305
.306:
! 2374     if(read_byte(get_SS(),&buffer[1+i])!=read_byte(0xf000,&isotag[i]))return 5;
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [6] char = isotag+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_isotag+0] (used reg = )
! Debug: list * char = bx+_isotag+0 (used reg = )
add	bx,#_isotag
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 1 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+1 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
inc	ax
mov	bx,bp
add	bx,ax
! Debug: address unsigned char = [bx-$80E] (used reg = )
! Debug: list * unsigned char = bx-$80E (used reg = )
add	bx,#-$80E
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
je  	.307
.308:
mov	ax,*5
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2375    }
.307:
! 2376   for(i=0;i<23;i++)
.304:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.305:
! Debug: lt int = const 5 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*5
jb 	.306
.309:
.303:
! Debug: eq int = const 0 to unsigned short i = [S+$81E-$81A] (used reg = )
xor	ax,ax
mov	-$818[bp],ax
!BCC_EOS
!BCC_EOS
! 2377     if(read_byte(get_SS(),&buffer[7+i])!=read_byte(0xf000,&eltorito[i]))return 6;
jmp .30C
.30D:
! Debug: ptradd unsigned short i = [S+$81E-$81A] to [$18] char = eltorito+0 (used reg = )
mov	bx,-$818[bp]
! Debug: address char = [bx+_eltorito+0] (used reg = )
! Debug: list * char = bx+_eltorito+0 (used reg = )
add	bx,#_eltorito
push	bx
! Debug: list unsigned int = const $F000 (used reg = )
mov	ax,#$F000
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: add unsigned short i = [S+$820-$81A] to int = const 7 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$818[bp]
! Debug: ptradd unsigned int = ax+7 to [$800] unsigned char buffer = S+$820-$810 (used reg = )
add	ax,*7
mov	bx,bp
add	bx,ax
! Debug: address unsigned char = [bx-$80E] (used reg = )
! Debug: list * unsigned char = bx-$80E (used reg = )
add	bx,#-$80E
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne unsigned char (temp) = [S+$820-$820] to unsigned char = al+0 (used reg = )
cmp	al,-$81E[bp]
lea	sp,-$81C[bp]
je  	.30E
.30F:
! 2377 
mov	ax,*6
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2378   lba=buffer[0x4A]*0x1000000+buffer[0x49]*0x10000+buffer[0x48]*0x100+buffer[0x47];
.30E:
.30B:
! Debug: postinc unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
inc	ax
mov	-$818[bp],ax
.30C:
! Debug: lt int = const $17 to unsigned short i = [S+$81E-$81A] (used reg = )
mov	ax,-$818[bp]
cmp	ax,*$17
jb 	.30D
.310:
.30A:
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7C9] (used reg = )
mov	al,-$7C7[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7C8] (used reg = )
mov	al,-$7C6[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7C7] (used reg = )
mov	al,-$7C5[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7C6] (used reg = )
mov	al,-$7C4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2379   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2380   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2381   atacmd[7]=(0x01 & 0xff00) >> 8;
! Debug: eq unsigned int = const 0 to unsigned char atacmd = [S+$81E-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 2382   atacmd[8]=(0x01 & 0x00ff);
! Debug: eq int = const 1 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	al,*1
mov	-6[bp],al
!BCC_EOS
! 2383   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2384   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2385   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2386   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2387   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, 2048L, 0x01, get_SS(), buffer)) != 0)
! Debug: list * unsigned char buffer = S+$81E-$810 (used reg = )
lea	bx,-$80E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list long = const $800 (used reg = )
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.311
.312:
! 2388     return 7;
mov	ax,*7
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2389   if(buffer[0x00]!=0x01)return 8;
.311:
! Debug: ne int = const 1 to unsigned char buffer = [S+$81E-$810] (used reg = )
mov	al,-$80E[bp]
cmp	al,*1
je  	.313
.314:
mov	ax,*8
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2390   if(buffer[0x01]!=0x00)return 9;
.313:
! Debug: ne int = const 0 to unsigned char buffer = [S+$81E-$80F] (used reg = )
mov	al,-$80D[bp]
test	al,al
je  	.315
.316:
mov	ax,*9
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2391   if(buffer[0x1E]!=0x55)return 10;
.315:
! Debug: ne int = const $55 to unsigned char buffer = [S+$81E-$7F2] (used reg = )
mov	al,-$7F0[bp]
cmp	al,*$55
je  	.317
.318:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2392   if(buffer[0x1F]!=0xAA)return 10;
.317:
! Debug: ne int = const $AA to unsigned char buffer = [S+$81E-$7F1] (used reg = )
mov	al,-$7EF[bp]
cmp	al,#$AA
je  	.319
.31A:
mov	ax,*$A
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2393   if(buffer[0x20]!=0x88)return 11;
.319:
! Debug: ne int = const $88 to unsigned char buffer = [S+$81E-$7F0] (used reg = )
mov	al,-$7EE[bp]
cmp	al,#$88
je  	.31B
.31C:
mov	ax,*$B
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2394   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media,buffer[0x21]);
.31B:
! Debug: list unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2395   if(buffer[0x21]==0){
! Debug: logeq int = const 0 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
test	al,al
jne 	.31D
.31E:
! 2396     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0xE0);
! Debug: list int = const $E0 (used reg = )
mov	ax,#$E0
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2397     }
! 2398   else if(buffer[0x21]<4)
jmp .31F
.31D:
! Debug: lt int = const 4 to unsigned char buffer = [S+$81E-$7EF] (used reg = )
mov	al,-$7ED[bp]
cmp	al,*4
jae 	.320
.321:
! 2399     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2400   else
! 2401     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive,0x80);
jmp .322
.320:
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2402   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index,device/2);
.322:
.31F:
! Debug: div int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
shr	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2403   write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec,device%2);
! Debug: mod int = const 2 to unsigned char device = [S+$81E-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2404   boot_segment=buffer[0x23]*0x100+buffer[0x22];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7ED] (used reg = )
mov	al,-$7EB[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EE] to unsigned int = ax+0 (used reg = )
add	al,-$7EC[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	-$814[bp],ax
!BCC_EOS
! 2405   if(boot_segment==0x0000)boot_segment=0x07C0;
! Debug: logeq int = const 0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,-$814[bp]
test	ax,ax
jne 	.323
.324:
! Debug: eq int = const $7C0 to unsigned short boot_segment = [S+$81E-$816] (used reg = )
mov	ax,#$7C0
mov	-$814[bp],ax
!BCC_EOS
! 2406   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment,boot_segment);
.323:
! Debug: list unsigned short boot_segment = [S+$81E-$816] (used reg = )
push	-$814[bp]
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2407   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment,0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2408   nbsectors=buffer[0x27]*0x100+buffer[0x26];
! Debug: mul int = const $100 to unsigned char buffer = [S+$81E-$7E9] (used reg = )
mov	al,-$7E7[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add unsigned char buffer = [S+$81E-$7EA] to unsigned int = ax+0 (used reg = )
add	al,-$7E8[bp]
adc	ah,*0
! Debug: eq unsigned int = ax+0 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	-$816[bp],ax
!BCC_EOS
! 2409   write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count,nbsectors);
! Debug: list unsigned short nbsectors = [S+$81E-$818] (used reg = )
push	-$816[bp]
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2410   lba=buffer[0x2B]*0x1000000+buffer[0x2A]*0x10000+buffer[0x29]*0x100+buffer[0x28];
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$81E-$7E8] (used reg = )
mov	al,-$7E6[bp]
xor	ah,ah
xor	bx,bx
push	bx
push	ax
! Debug: mul int = const $100 to unsigned char buffer = [S+$822-$7E7] (used reg = )
mov	al,-$7E5[bp]
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: cast unsigned long = const 0 to unsigned int = ax+0 (used reg = )
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$826-$7E6] (used reg = )
mov	al,-$7E4[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $10000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,*1
push	bx
push	ax
mov	ax,-$828[bp]
mov	bx,-$826[bp]
lea	di,-$82C[bp]
call	lmulul
add	sp,*8
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned char buffer = [S+$82A-$7E5] (used reg = )
mov	al,-$7E3[bp]
xor	ah,ah
xor	bx,bx
! Debug: mul long = const $1000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$82C[bp]
mov	bx,-$82A[bp]
lea	di,-$830[bp]
call	lmulul
add	sp,*8
! Debug: add unsigned long (temp) = [S+$82A-$82A] to unsigned long = bx+0 (used reg = )
lea	di,-$828[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$826-$826] to unsigned long = bx+0 (used reg = )
lea	di,-$824[bp]
call	laddul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$822-$822] to unsigned long = bx+0 (used reg = )
lea	di,-$820[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$81E-$814] (used reg = )
mov	-$812[bp],ax
mov	-$810[bp],bx
!BCC_EOS
! 2411   write_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba,lba);
! Debug: list unsigned long lba = [S+$81E-$814] (used reg = )
push	-$810[bp]
push	-$812[bp]
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$824-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 2412   memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$822-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 2413   atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$81E-$10] (used reg = )
mov	al,*$28
mov	-$E[bp],al
!BCC_EOS
! 2414   atacmd[7]=((1+(nbsectors-1)/4) & 0xff00) >> 8;
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and unsigned int = const $FF00 to unsigned int = ax+1 (used reg = )
inc	ax
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$81E-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2415   atacmd[8]=((1+(nbsectors-1)/4) & 0x00ff);
! Debug: sub int = const 1 to unsigned short nbsectors = [S+$81E-$818] (used reg = )
mov	ax,-$816[bp]
! Debug: div int = const 4 to unsigned int = ax-1 (used reg = )
dec	ax
shr	ax,*1
shr	ax,*1
! Debug: add unsigned int = ax+0 to int = const 1 (used reg = )
! Debug: expression subtree swapping
! Debug: and int = const $FF to unsigned int = ax+1 (used reg = )
inc	ax
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$81E-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 2416   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 2417   atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$812[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2418   atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 2419   atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$81E-$814] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$812[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$81E-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2420   if((error = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, nbsectors*512L, 0x01, boot_segment,0)) != 0)
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$824-$818] (used reg = )
mov	ax,-$816[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-$826[bp]
mov	bx,-$824[bp]
lea	di,-$82A[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$82A-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$830-$81D] (used reg = )
mov	al,-$81B[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned short error = [S+$81E-$81C] (used reg = )
mov	-$81A[bp],ax
! Debug: ne int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
je  	.325
.326:
! 2421     
! 2421 return 12;
mov	ax,*$C
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2422   switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
.325:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
br 	.329
! 2423     case 0x01:
! 2424       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,15);
.32A:
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2425       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2426       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2427       break;
br 	.327
!BCC_EOS
! 2428     case 0x02:
! 2429       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,18);
.32B:
! Debug: list int = const $12 (used reg = )
mov	ax,*$12
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2430       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2431       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2432       break;
br 	.327
!BCC_EOS
! 2433     case 0x03:
! 2434       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,36);
.32C:
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2435       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,80);
! Debug: list int = const $50 (used reg = )
mov	ax,*$50
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2436       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2437       break;
br 	.327
!BCC_EOS
! 2438     case 0x04:
! 2439       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt,read_byte(boot_segment,446+6)&0x3f);
.32D:
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2440       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders,
! 2441               (read_byte(boot_segment,446+6)<<2) + read_byte(boot_segment,446+7) + 1);
! Debug: list int = const $1C5 (used reg = )
mov	ax,#$1C5
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: list int = const $1C4 (used reg = )
mov	ax,#$1C4
push	ax
! Debug: list unsigned short boot_segment = [S+$822-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: add unsigned char (temp) = [S+$820-$820] to unsigned int = ax+0 (used reg = )
add	al,0+..FFF9[bp]
adc	ah,*0
inc	sp
inc	sp
! Debug: add int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2442       write_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads,read_byte(boot_segment,446+5) + 1);
! Debug: list int = const $1C3 (used reg = )
mov	ax,#$1C3
push	ax
! Debug: list unsigned short boot_segment = [S+$820-$816] (used reg = )
push	-$814[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2443       break;
jmp .327
!BCC_EOS
! 2444    }
! 2445   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0) {
jmp .327
.329:
sub	al,*1
beq 	.32A
sub	al,*1
beq 	.32B
sub	al,*1
beq 	.32C
sub	al,*1
beq 	.32D
.327:
..FFF9	=	-$81E
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.32E
.32F:
! 2446     if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)==0x00)
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.330
.331:
! 2447       write_byte(0x40,0x10,read_byte(0x40,0x10)|0x41);
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $41 to unsigned char = al+0 (used reg = )
or	al,*$41
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2448     else
! 2449       write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount, read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount) + 1);
jmp .332
.330:
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: add int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2450    }
.332:
! 2451   if(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)!=0)
.32E:
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.333
.334:
! 2452     write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active,0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$822-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2453   return (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive)*0x100)+0;
.333:
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$820-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cx,#$100
imul	cx
! Debug: add int = const 0 to unsigned int = ax+0 (used reg = )
! Debug: cast unsigned short = const 0 to unsigned int = ax+0 (used reg = )
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2454 }
! 2455   void
! Register BX used in function cdrom_boot
! 2456 int14_function(regs, ds, iret_addr)
! 2457   pusha_regs_t regs;
export	_int14_function
_int14_function:
!BCC_EOS
! 2458   Bit16u ds;
!BCC_EOS
! 2459   iret_addr_t iret_addr;
!BCC_EOS
! 2460 {
! 2461   Bit16u addr,timer,val16;
!BCC_EOS
! 2462   Bit8u timeout;
!BCC_EOS
! 2463 #asm
push	bp
mov	bp,sp
add	sp,*-8
!BCC_EOS
!BCC_ASM
_int14_function.ds	set	$1C
.int14_function.ds	set	$14
_int14_function.timer	set	4
.int14_function.timer	set	-4
_int14_function.timeout	set	1
.int14_function.timeout	set	-7
_int14_function.iret_addr	set	$1E
.int14_function.iret_addr	set	$16
_int14_function.addr	set	6
.int14_function.addr	set	-2
_int14_function.val16	set	2
.int14_function.val16	set	-6
_int14_function.regs	set	$C
.int14_function.regs	set	4
  sti
! 2465 endasm
!BCC_ENDASM
!BCC_EOS
! 2466   addr = read_word(0x0040, (regs.u.r16.dx << 1));
! Debug: sl int = const 1 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+$A-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2467   timeout = read_byte(0x0040, 0x007C + regs.u.r16.dx);
! Debug: add unsigned short regs = [S+$A+$C] to int = const $7C (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$7C (used reg = )
add	ax,*$7C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char timeout = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2468   if ((
! 2468 regs.u.r16.dx < 4) && (addr > 0)) {
! Debug: lt int = const 4 to unsigned short regs = [S+$A+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*4
bhis	.335
.337:
! Debug: gt int = const 0 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.335
.336:
! 2469     switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.33A
! 2470       case 0:
! 2471         outb(addr+3, inb(addr+3) | 0x80);
.33B:
! Debug: add int = const 3 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2472         if (regs.u.r8.al & 0xE0 == 0) {
! Debug: and int = const 0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	al,al
test	al,al
je  	.33C
.33D:
! 2473           outb(addr, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2474           outb(addr+1, 0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2475         } else {
jmp .33E
.33C:
! 2476           val16 = 0x600 >> ((regs.u.r8.al & 0xE0) >> 5);
! Debug: and int = const $E0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,#$E0
! Debug: sr int = const 5 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*5
shr	ax,cl
! Debug: sr unsigned int = ax+0 to int = const $600 (used reg = )
mov	bx,ax
mov	ax,#$600
mov	cx,bx
sar	ax,cl
! Debug: eq int = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2477           outb(addr, val16 & 0xFF);
! Debug: and int = const $FF to unsigned short val16 = [S+$A-8] (used reg = )
mov	al,-6[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2478           outb(addr+1, val16 >> 8);
! Debug: sr int = const 8 to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: add int = const 1 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2479         }
! 2480         outb(addr+3, regs.u.r8.al & 0x1F);
.33E:
! Debug: and int = const $1F to unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
and	al,*$1F
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short addr = [S+$C-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2481         regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2482         regs.u.r8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2483         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2484         break;
br 	.338
!BCC_EOS
! 2485       case 1:
! 2486         timer = read_word(0x0040, 0x006C);
.33F:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2487         while (((inb(addr+5) & 0x60) != 0x60) && (timeout)) {
jmp .341
.342:
! 2488           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2489           if (val16 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.343
.344:
! 2490             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2491             timeout--;
! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2492             }
! 2493           }
.343:
! 2494         if (timeout) outb(addr, regs.u.r8.al);
.341:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: ne int = const $60 to unsigned char = al+0 (used reg = )
cmp	al,*$60
je  	.345
.346:
mov	al,-7[bp]
test	al,al
jne	.342
.345:
.340:
mov	al,-7[bp]
test	al,al
beq 	.347
.348:
! Debug: list unsigned char regs = [S+$A+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2495         regs.u.r8.ah = inb(addr+5);
.347:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2496         if (!timeout) regs.u.r8.ah |= 0x80;
mov	al,-7[bp]
test	al,al
jne 	.349
.34A:
! Debug: orab int = const $80 to unsigned char regs = [S+$A+$11] (used reg = )
mov	al,$13[bp]
or	al,#$80
mov	$13[bp],al
!BCC_EOS
! 2497         iret_addr.flags.u.r8.flagsl &= 0xfe;
.349:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2498         break;
br 	.338
!BCC_EOS
! 2499       case 2:
! 2500         timer = read_word(0x0040, 0x006C);
.34B:
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short timer = [S+$A-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2501         while (((inb(addr+5) & 0x01) == 0) && (timeout)) {
jmp .34D
.34E:
! 2502           val16 = read_word(0x0040, 0x006C);
! Debug: list int = const $6C (used reg = )
mov	ax,*$6C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short val16 = [S+$A-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2503           if (val16 != timer) {
! Debug: ne unsigned short timer = [S+$A-6] to unsigned short val16 = [S+$A-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
je  	.34F
.350:
! 2504             timer = val16;
! Debug: eq unsigned short val16 = [S+$A-8] to unsigned short timer = [S+$A-6] (used reg = )
mov	ax,-6[bp]
mov	-4[bp],ax
!BCC_EOS
! 2505             timeout--;
! Debug: postdec unsigned char timeout = [S+$A-9] (used reg = )
mov	al,-7[bp]
dec	ax
mov	-7[bp],al
!BCC_EOS
! 2506             }
! 2507           }
.34F:
! 2508         if (timeout) {
.34D:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.351
.352:
mov	al,-7[bp]
test	al,al
jne	.34E
.351:
.34C:
mov	al,-7[bp]
test	al,al
je  	.353
.354:
! 2509           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$A+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2510           regs.u.r8.al = inb(addr);
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2511         } else {
jmp .355
.353:
! 2512           regs.u.r8.ah = inb(addr+5);
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2513           }
! 2514         iret_addr.flags.u.r8.flagsl &= 0xfe;
.355:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2515         break;
br 	.338
!BCC_EOS
! 2516       case 3:
! 2517         regs.u.r8.ah = inb(addr+5);
.356:
! Debug: add int = const 5 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+5 (used reg = )
add	ax,*5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2518         regs.u.r8.al = inb(addr+6);
! Debug: add int = const 6 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$A+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2519         iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 2520         break;
jmp .338
!BCC_EOS
! 2521       default:
! 2522         iret_addr.flags.u.r8.flagsl |= 0x01;
.357:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2523       }
! 2524   } else {
jmp .338
.33A:
sub	al,*0
beq 	.33B
sub	al,*1
beq 	.33F
sub	al,*1
beq 	.34B
sub	al,*1
je 	.356
jmp	.357
.338:
..FFF8	=	-$A
jmp .358
.335:
! 2525     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+$A+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 2526     }
! 2527 }
.358:
mov	sp,bp
pop	bp
ret
! 2528   void
! Register BX used in function int14_function
! 2529 int15_function(regs, ES, DS, FLAGS)
! 2530   pusha_regs_t regs;
export	_int15_function
_int15_function:
!BCC_EOS
! 2531   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2532 {
! 2533   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2534   bx_bool prev_a20_enable;
!BCC_EOS
! 2535   Bit16u base15_00;
!BCC_EOS
! 2536   Bit8u base23_16;
!BCC_EOS
! 2537   Bit16u ss;
!BCC_EOS
! 2538   Bit16u CX,DX;
!BCC_EOS
! 2539   Bit16u bRegister;
!BCC_EOS
! 2540   Bit8u irqDisable;
!BCC_EOS
! 2541 ;
add	sp,*-$10
!BCC_EOS
! 2542   switch (re
! 2542 gs.u.r8.ah) {
mov	al,$13[bp]
br 	.35B
! 2543     case 0x24:
! 2544       switch (regs.u.r8.al) {
.35C:
mov	al,$12[bp]
jmp .35F
! 2545         case 0x00:
! 2546           set_enable_a20(0);
.360:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2547           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2548           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2549           break;
jmp .35D
!BCC_EOS
! 2550         case 0x01:
! 2551           set_enable_a20(1);
.361:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2552           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2553           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2554           break;
jmp .35D
!BCC_EOS
! 2555         case 0x02:
! 2556           regs.u.r8.al = (inb(0x92) >> 1) & 0x01;
.362:
! Debug: list int = const $92 (used reg = )
mov	ax,#$92
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sr int = const 1 to unsigned char = al+0 (used reg = )
xor	ah,ah
shr	ax,*1
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2557           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2558           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2559           break;
jmp .35D
!BCC_EOS
! 2560         case 0x03:
! 2561           FLAGS &= 0xfffe;
.363:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2562           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2563           regs.u.r16.bx = 3;
! Debug: eq int = const 3 to unsigned short regs = [S+$14+$A] (used reg = )
mov	ax,*3
mov	$C[bp],ax
!BCC_EOS
! 2564           break;
jmp .35D
!BCC_EOS
! 2565         default:
! 2566           ;
.364:
!BCC_EOS
! 2567           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2568           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2569       }
! 2570       break;
jmp .35D
.35F:
sub	al,*0
je 	.360
sub	al,*1
je 	.361
sub	al,*1
je 	.362
sub	al,*1
je 	.363
jmp	.364
.35D:
br 	.359
!BCC_EOS
! 2571     case 0x41:
! 2572       FLAGS |= 0x0001;
.365:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2573       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2574       break;
br 	.359
!BCC_EOS
! 2575     case 0x4f:
! 2576       FLAGS |= 0x0001;
.366:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2577       break;
br 	.359
!BCC_EOS
! 2578     case 0x52:
! 2579       FLAGS &= 0xfffe;
.367:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2580       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2581       break;
br 	.359
!BCC_EOS
! 2582     case 0x83: {
.368:
! 2583       if( regs.u.r8.al == 0 ) {
! Debug: logeq int = const 0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
test	al,al
bne 	.369
.36A:
! 2584         if( ( read_byte( 0x40, 0xA0 ) & 1 ) == 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
bne 	.36B
.36C:
! 2585           write_byte( 0x40, 0xA0, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2586           write_word( 0x40, 0x98, ES );
! Debug: list unsigned short ES = [S+$14+$12] (used reg = )
push	$14[bp]
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2587           write_word( 0x40, 0x9A, regs.u.r16.bx );
! Debug: list unsigned short regs = [S+$14+$A] (used reg = )
push	$C[bp]
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2588           write_word( 0x40, 0x9C, regs.u.r16.dx );
! Debug: list unsigned short regs = [S+$14+$C] (used reg = )
push	$E[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2589           write_word( 0x40, 0x9E, regs.u.r16.cx );
! Debug: list unsigned short regs = [S+$14+$E] (used reg = )
push	$10[bp]
! Debug: list int = const $9E (used reg = )
mov	ax,#$9E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2590           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2591           irqDisable = inb( 0xA1 );
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char irqDisable = [S+$14-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 2592           outb( 0xA1, irqDisable & 0xFE );
! Debug: and int = const $FE to unsigned char irqDisable = [S+$14-$13] (used reg = )
mov	al,-$11[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 2593           bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 2594           outb_cmos( 0xB, bRegister | 0x40 );
! Debug: or int = const $40 to unsigned short bRegister = [S+$14-$12] (used reg = )
mov	ax,-$10[bp]
or	al,*$40
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2595         } else {
jmp .36D
.36B:
! 2596           ;
!BCC_EOS
! 2597           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2598           regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2599         }
! 2600       } else if( regs.u.r8.al == 1 ) {
.36D:
jmp .36E
.369:
! Debug: logeq int = const 1 to unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*1
jne 	.36F
.370:
! 2601         write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2602         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2603         bRegister = inb_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bRegister = [S+$14-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 2604         outb_cmos( 0xB, bRegister & ~0x40 );
! Debug: and int = const -$41 to unsigned short bRegister = [S+$14-$12] (used reg = )
mov	ax,-$10[bp]
and	al,#$BF
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 2605       } else {
jmp .371
.36F:
! 2606         ;
!BCC_EOS
! 2607         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2608         regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2609         regs.u.r8.al--;
! Debug: postdec unsigned char regs = [S+$14+$10] (used reg = )
mov	al,$12[bp]
dec	ax
mov	$12[bp],al
!BCC_EOS
! 2610       }
! 2611       break;
.371:
.36E:
br 	.359
!BCC_EOS
! 2612     }
! 2613     case 0x87:
! 2614 #asm
.372:
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
  cli
! 2616 endasm
!BCC_ENDASM
!BCC_EOS
! 2617       prev_a20_enable = set_enable_a20(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
! Debug: eq unsigned short = ax+0 to unsigned short prev_a20_enable = [S+$14-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 2618       base15_00 = (ES << 4) + regs.u.r16.si;
! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: add unsigned short regs = [S+$14+4] to unsigned int = ax+0 (used reg = )
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2619       base23_16 = ES >> 12;
! Debug: sr int = const $C to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2620       if (base15_00 < (ES<<4))
! Debug: sl int = const 4 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,$14[bp]
mov	cl,*4
shl	ax,cl
! Debug: lt unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
cmp	ax,-6[bp]
jbe 	.373
.374:
! 2621         base23_16++;
! Debug: postinc unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
inc	ax
mov	-7[bp],al
!BCC_EOS
! 2622       write_word(ES, regs.u.r16.si+0x08
.373:
! 2622 +0, 47);
! Debug: list int = const $2F (used reg = )
mov	ax,*$2F
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2623       write_word(ES, regs.u.r16.si+0x08+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
push	-6[bp]
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2624       write_byte(ES, regs.u.r16.si+0x08+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2625       write_byte(ES, regs.u.r16.si+0x08+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$D (used reg = )
add	ax,*$D
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2626       write_word(ES, regs.u.r16.si+0x08+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 8 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+8 (used reg = )
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2627       write_word(ES, regs.u.r16.si+0x20+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2628       write_word(ES, regs.u.r16.si+0x20+2, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2629       write_byte(ES, regs.u.r16.si+0x20+4, 0x000f);
! Debug: list int = const $F (used reg = )
mov	ax,*$F
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2630       write_byte(ES, regs.u.r16.si+0x20+5, 0x9b);
! Debug: list int = const $9B (used reg = )
mov	ax,#$9B
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2631       write_word(ES, regs.u.r16.si+0x20+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $20 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$20 (used reg = )
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2632       ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$14-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 2633       base15_00 = ss << 4;
! Debug: sl int = const 4 to unsigned short ss = [S+$14-$C] (used reg = )
mov	ax,-$A[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base15_00 = [S+$14-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 2634       base23_16 = ss >> 12;
! Debug: sr int = const $C to unsigned short ss = [S+$14-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char base23_16 = [S+$14-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 2635       write_word(ES, regs.u.r16.si+0x28+0, 0xffff);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 0 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2636       write_word(ES, regs.u.r16.si+0x28+2, base15_00);
! Debug: list unsigned short base15_00 = [S+$14-8] (used reg = )
push	-6[bp]
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 2 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2637       write_byte(ES, regs.u.r16.si+0x28+4, base23_16);
! Debug: list unsigned char base23_16 = [S+$14-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 4 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2C (used reg = )
add	ax,*$2C
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2638       write_byte(ES, regs.u.r16.si+0x28+5, 0x93);
! Debug: list int = const $93 (used reg = )
mov	ax,#$93
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 5 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2D (used reg = )
add	ax,*$2D
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2639       write_word(ES, regs.u.r16.si+0x28+6, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $28 to unsigned short regs = [S+$16+4] (used reg = )
mov	ax,6[bp]
! Debug: add int = const 6 to unsigned int = ax+$28 (used reg = )
! Debug: list unsigned int = ax+$2E (used reg = )
add	ax,*$2E
push	ax
! Debug: list unsigned short ES = [S+$18+$12] (used reg = )
push	$14[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2640       CX = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+$14+$E] to unsigned short CX = [S+$14-$E] (used reg = )
mov	ax,$10[bp]
mov	-$C[bp],ax
!BCC_EOS
! 2641 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
      mov bx, sp
      SEG SS
        mov cx, _int15_function.CX [bx]
      push eax
      xor eax, eax
      mov ds, ax
      mov 0x0469, ss
      mov 0x0467, sp
      SEG ES
        lgdt [si + 0x08]
      SEG CS
        lidt [pmode_IDT_info]
      ;; perhaps do something with IDT here
      ;; set PE bit in CR0
      mov eax, cr0
      or al, #0x01
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to protected mode
      JMP_AP(0x0020, protected_mode)
protected_mode:
      ;; GDT points to valid descriptor table, now load SS, DS, ES
      mov ax, #0x28 ;; 101 000 = 5th descriptor in table, TI=GDT, RPL=00
      mov ss, ax
      mov ax, #0x10 ;; 010 000 = 2nd descriptor in table, TI=GDT, RPL=00
      mov ds, ax
      mov ax, #0x18 ;; 011 000 = 3rd descriptor in table, TI=GDT, RPL=00
      mov es, ax
      xor si, si
      xor di, di
      cld
      rep
        movsw ;; move CX words from DS:SI to ES:DI
      ;; make sure DS and ES limits are 64KB
      mov ax, #0x28
      mov ds, ax
      mov es, ax
      ;; reset PG bit in CR0 ???
      mov eax, cr0
      and al, #0xFE
      mov cr0, eax
      ;; far jump to flush CPU queue after transition to real mode
      JMP_AP(0xf000, real_mode)
real_mode:
      ;; restore IDT to normal real-mode defaults
      SEG CS
        lidt [rmode_IDT_info]
      xor ax, ax
      mov ds, ax
      mov ss, 0x0469
      mov sp, 0x0467
      pop eax
! 2693 endasm
!BCC_ENDASM
!BCC_EOS
! 2694       set_enable_a20(prev_a20_enable);
! Debug: list unsigned short prev_a20_enable = [S+$14-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned short = set_enable_a20+0 (used reg = )
call	_set_enable_a20
inc	sp
inc	sp
!BCC_EOS
! 2695 #asm
!BCC_EOS
!BCC_ASM
_int15_function.CX	set	6
.int15_function.CX	set	-$C
_int15_function.FLAGS	set	$2A
.int15_function.FLAGS	set	$18
_int15_function.irqDisable	set	1
.int15_function.irqDisable	set	-$11
_int15_function.DS	set	$28
.int15_function.DS	set	$16
_int15_function.DX	set	4
.int15_function.DX	set	-$E
_int15_function.base23_16	set	$B
.int15_function.base23_16	set	-7
_int15_function.bRegister	set	2
.int15_function.bRegister	set	-$10
_int15_function.ES	set	$26
.int15_function.ES	set	$14
_int15_function.ebda_seg	set	$10
.int15_function.ebda_seg	set	-2
_int15_function.base15_00	set	$C
.int15_function.base15_00	set	-6
_int15_function.ss	set	8
.int15_function.ss	set	-$A
_int15_function.regs	set	$16
.int15_function.regs	set	4
_int15_function.prev_a20_enable	set	$E
.int15_function.prev_a20_enable	set	-4
  sti
! 2697 endasm
!BCC_ENDASM
!BCC_EOS
! 2698       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2699       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2700       break;
br 	.359
!BCC_EOS
! 2701     case 0x88:
! 2702       regs.u.r8.al = inb_cmos(0x30);
.375:
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$10] (used reg = )
mov	$12[bp],al
!BCC_EOS
! 2703       regs.u.r8.ah = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$14+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 2704       if(regs.u.r16.ax > 0xffc0)
! Debug: gt unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
mov	ax,$12[bp]
cmp	ax,#$FFC0
jbe 	.376
.377:
! 2705         regs.u.r16.ax = 0xffc0;
! Debug: eq unsigned int = const $FFC0 to unsigned short regs = [S+$14+$10] (used reg = )
mov	ax,#$FFC0
mov	$12[bp],ax
!BCC_EOS
! 2706       FLAGS &= 0xfffe;
.376:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2707       break;
br 	.359
!BCC_EOS
! 2708     case 0x90:
! 2709       break;
.378:
br 	.359
!BCC_EOS
! 2710     case 0x91:
! 2711       break;
.379:
br 	.359
!BCC_EOS
! 2712     case 0xbf:
! 2713       ;
.37A:
!BCC_EOS
! 2714       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2715       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2716       break;
br 	.359
!BCC_EOS
! 2717     case 0xC0:
! 2718       FLAGS &= 0xfffe;
.37B:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2719       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$14+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2720       regs.u.r16.bx = 0xe6f5;
! Debug: eq unsigned int = const $E6F5 to unsigned short regs = [S+$14+$A] (used reg = )
mov	ax,#$E6F5
mov	$C[bp],ax
!BCC_EOS
! 2721       ES = 0xF000;
! Debug: eq unsigned int = const $F000 to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,#$F000
mov	$14[bp],ax
!BCC_EOS
! 2722       break;
br 	.359
!BCC_EOS
! 2723     case 0xc1:
! 2724       ES = ebda_seg;
.37C:
! Debug: eq unsigned short ebda_seg = [S+$14-4] to unsigned short ES = [S+$14+$12] (used reg = )
mov	ax,-2[bp]
mov	$14[bp],ax
!BCC_EOS
! 2725       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2726       break;
br 	.359
!BCC_EOS
! 2727     case 0xd8:
! 2728       bios_printf(8, "EISA BIOS not present\n");
.37D:
! Debug: list * char = .37E+0 (used reg = )
mov	bx,#.37E
push	bx
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 2729       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2730       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2731       break;
jmp .359
!BCC_EOS
! 2732     default:
! 2733       ;
.37F:
!BCC_EOS
! 2734       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$14+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2735       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$14+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2736       break;
jmp .359
!BCC_EOS
! 2737     }
! 2738 }
jmp .359
.35B:
sub	al,*$24
beq 	.35C
sub	al,*$1D
beq 	.365
sub	al,*$E
beq 	.366
sub	al,*3
beq 	.367
sub	al,*$31
beq 	.368
sub	al,*4
beq 	.372
sub	al,*1
beq 	.375
sub	al,*8
beq 	.378
sub	al,*1
beq 	.379
sub	al,*$2E
beq 	.37A
sub	al,*1
beq 	.37B
sub	al,*1
beq 	.37C
sub	al,*$17
beq 	.37D
jmp	.37F
.359:
..FFF7	=	-$14
mov	sp,bp
pop	bp
ret
! 2739   void
! Register BX used in function int15_function
! 2740 int15_function_mouse(regs, ES, DS, FLAGS)
! 2741   pusha_regs_t regs;
export	_int15_function_mouse
_int15_function_mouse:
!BCC_EOS
! 2742   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 2743 {
! 2744   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 2745   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 2746   Bit16u mouse_driver_seg;
!BCC_EOS
! 2747   Bit16u mouse_driver_offset;
!BCC_EOS
! 2748   Bit8u comm_byte, prev_command_byte;
!BCC_EOS
! 2749   Bit8u ret, mouse_data1, mouse_data2, mouse_data3;
!BCC_EOS
! 2750 ;
add	sp,*-$C
!BCC_EOS
! 2751   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.382
! 2752     case 0xC2:
! 2753       switch (regs.u.r8.al) {
.383:
mov	al,$12[bp]
br 	.386
! 2754         case 0:
! 2755 ;
.387:
!BCC_EOS
! 2756           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.38A
! 2757             case 0:
! 2758 ;
.38B:
!BCC_EOS
! 2759               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2760               ret = send_to_mouse_ctrl(0xF5);
! Debug: list int = const $F5 (used reg = )
mov	ax,#$F5
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2761               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.38C
.38D:
! 2762                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2763                 if ( (ret == 0) || (mouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
je  	.38F
.390:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.38E
.38F:
! 2764                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2765                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2766                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2767                   }
! 2768                 }
.38E:
! 2769               FLAGS |= 0x0001;
.38C:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2770               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2771               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2772               break;
br 	.388
!BCC_EOS
! 2773  
! 2773            case 1:
! 2774 ;
.391:
!BCC_EOS
! 2775               mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2776               if ( (mouse_flags_2 & 0x80) == 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.392
.393:
! 2777                 ;
!BCC_EOS
! 2778                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2779                 regs.u.r8.ah = 5;
! Debug: eq int = const 5 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*5
mov	$13[bp],al
!BCC_EOS
! 2780                 return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2781                 }
! 2782               inhibit_mouse_int_and_events();
.392:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2783               ret = send_to_mouse_ctrl(0xF4);
! Debug: list int = const $F4 (used reg = )
mov	ax,#$F4
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2784               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.394
.395:
! 2785                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2786                 if ( (ret == 0) && (mouse_data1 == 0xFA) ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.396
.398:
! Debug: logeq int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
jne 	.396
.397:
! 2787                   enable_mouse_int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2788                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2789                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2790                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2791                   }
! 2792                 }
.396:
! 2793               FLAGS |= 0x0001;
.394:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2794               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2795               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2796             default:
! 2797               ;
.399:
!BCC_EOS
! 2798               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2799               regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 2800               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2801             }
! 2802           break;
jmp .388
.38A:
sub	al,*0
beq 	.38B
sub	al,*1
beq 	.391
jmp	.399
.388:
br 	.384
!BCC_EOS
! 2803         case 1:
! 2804         case 5:
.39A:
! 2805 ;
.39B:
!BCC_EOS
! 2806           if (regs.u.r8.al == 5) {
! Debug: logeq int = const 5 to unsigned char regs = [S+$10+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*5
jne 	.39C
.39D:
! 2807             if (regs.u.r8.bh != 3) {
! Debug: ne int = const 3 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*3
je  	.39E
.39F:
! 2808               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2809               regs.u.r8.ah = 0x02;
! Debug: eq int = const 2 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*2
mov	$13[bp],al
!BCC_EOS
! 2810               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2811             }
! 2812             mouse_flags_2 = read_byte(ebda_seg, 0x0027);
.39E:
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2813             mouse_flags_2 = (mouse_flags_2 & 0x00) | regs.u.r8.bh;
! Debug: and int = const 0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	al,al
! Debug: or unsigned char regs = [S+$10+$B] to unsigned char = al+0 (used reg = )
or	al,$D[bp]
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2814             mouse_flags_1 = 0x00;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
xor	al,al
mov	-3[bp],al
!BCC_EOS
! 2815             write_byte(ebda_seg, 0x0026, mouse_flags_1);
! Debug: list unsigned char mouse_flags_1 = [S+$10-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2816             write_byte(ebda_seg, 0x0027, mouse_flags_2);
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2817           }
! 2818           inhibit_mouse_int_and_events();
.39C:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2819           ret = send_to_mouse_ctrl(0xFF);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2820           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3A0
.3A1:
! 2821             ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2822             if (mouse_data3 == 0xfe) {
! Debug: logeq int = const $FE to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FE
jne 	.3A2
.3A3:
! 2823               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2824               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2825             }
! 2826             if (mouse_data3 != 0xfa)
.3A2:
! Debug: ne int = const $FA to unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
cmp	al,#$FA
je  	.3A4
.3A5:
! 2827               bios_printf((2 | 4 | 1), "Mouse reset returned %02x (should be ack)\n", (unsigned)mouse_data3);
! Debug: list unsigned char mouse_data3 = [S+$10-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3A6+0 (used reg = )
mov	bx,#.3A6
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2828             if ( ret == 0 ) {
.3A4:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3A7
.3A8:
! 2829               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2830               if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3A9
.3AA:
! 2831                 ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2832                 if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3AB
.3AC:
! 2833                   enable_mouse
! 2833 _int_and_events();
! Debug: func () void = enable_mouse_int_and_events+0 (used reg = )
call	_enable_mouse_int_and_events
!BCC_EOS
! 2834                   FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2835                   regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2836                   regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2837                   regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2838                   return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2839                   }
! 2840                 }
.3AB:
! 2841               }
.3A9:
! 2842             }
.3A7:
! 2843           FLAGS |= 0x0001;
.3A0:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2844           regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2845           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2846         case 2:
! 2847 ;
.3AD:
!BCC_EOS
! 2848           switch (regs.u.r8.bh) {
mov	al,$D[bp]
jmp .3B0
! 2849             case 0: mouse_data1 = 10; break;
.3B1:
! Debug: eq int = const $A to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$A
mov	-$C[bp],al
!BCC_EOS
jmp .3AE
!BCC_EOS
! 2850             case 1: mouse_data1 = 20; break;
.3B2:
! Debug: eq int = const $14 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$14
mov	-$C[bp],al
!BCC_EOS
jmp .3AE
!BCC_EOS
! 2851             case 2: mouse_data1 = 40; break;
.3B3:
! Debug: eq int = const $28 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$28
mov	-$C[bp],al
!BCC_EOS
jmp .3AE
!BCC_EOS
! 2852             case 3: mouse_data1 = 60; break;
.3B4:
! Debug: eq int = const $3C to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$3C
mov	-$C[bp],al
!BCC_EOS
jmp .3AE
!BCC_EOS
! 2853             case 4: mouse_data1 = 80; break;
.3B5:
! Debug: eq int = const $50 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$50
mov	-$C[bp],al
!BCC_EOS
jmp .3AE
!BCC_EOS
! 2854             case 5: mouse_data1 = 100; break;
.3B6:
! Debug: eq int = const $64 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,*$64
mov	-$C[bp],al
!BCC_EOS
jmp .3AE
!BCC_EOS
! 2855             case 6: mouse_data1 = 200; break;
.3B7:
! Debug: eq int = const $C8 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,#$C8
mov	-$C[bp],al
!BCC_EOS
jmp .3AE
!BCC_EOS
! 2856             default: mouse_data1 = 0;
.3B8:
! Debug: eq int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
xor	al,al
mov	-$C[bp],al
!BCC_EOS
! 2857           }
! 2858           if (mouse_data1 > 0) {
jmp .3AE
.3B0:
sub	al,*0
jb 	.3B8
cmp	al,*6
ja  	.3B9
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.3BA[bx]
.3BA:
.word	.3B1
.word	.3B2
.word	.3B3
.word	.3B4
.word	.3B5
.word	.3B6
.word	.3B7
.3B9:
jmp	.3B8
.3AE:
! Debug: gt int = const 0 to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
test	al,al
je  	.3BB
.3BC:
! 2859             ret = send_to_mouse_ctrl(0xF3);
! Debug: list int = const $F3 (used reg = )
mov	ax,#$F3
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2860             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3BD
.3BE:
! 2861               ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2862               ret = send_to_mouse_ctrl(mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2863               ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2864               FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2865               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2866             } else {
jmp .3BF
.3BD:
! 2867               FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2868               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2869             }
! 2870           } else {
.3BF:
jmp .3C0
.3BB:
! 2871             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2872             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2873           }
! 2874           break;
.3C0:
br 	.384
!BCC_EOS
! 2875         case 3:
! 2876 ;
.3C1:
!BCC_EOS
! 2877           comm_byte = inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2878           if (regs.u.r8.bh < 4) {
! Debug: lt int = const 4 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*4
bhis	.3C2
.3C3:
! 2879             ret = send_to_mouse_ctrl(0xE8);
! Debug: list int = const $E8 (used reg = )
mov	ax,#$E8
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2880             if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3C4
.3C5:
! 2881               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2882               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3C6
.3C7:
! 2883                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3C8+0 (used reg = )
mov	bx,#.3C8
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2884               ret = send_to_mouse_ctrl(regs.u.r8.bh);
.3C6:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2885               ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2886               if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3C9
.3CA:
! 2887                 bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3CB+0 (used reg = )
mov	bx,#.3CB
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2888               FLAGS &= 0xfffe;
.3C9:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2889               regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2890             } else {
jmp .3CC
.3C4:
! 2891               FLAGS |= 0x0
! 2891 001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2892               regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2893             }
! 2894           } else {
.3CC:
jmp .3CD
.3C2:
! 2895             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2896             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2897           }
! 2898           set_kbd_command_byte(comm_byte);
.3CD:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2899           break;
br 	.384
!BCC_EOS
! 2900         case 4:
! 2901 ;
.3CE:
!BCC_EOS
! 2902           inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2903           ret = send_to_mouse_ctrl(0xF2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2904           if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3CF
.3D0:
! 2905             ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2906             ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2907             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2908             regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2909             regs.u.r8.bh = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,-$D[bp]
mov	$D[bp],al
!BCC_EOS
! 2910           } else {
jmp .3D1
.3CF:
! 2911             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2912             regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2913           }
! 2914           break;
.3D1:
br 	.384
!BCC_EOS
! 2915         case 6:
! 2916 ;
.3D2:
!BCC_EOS
! 2917           switch (regs.u.r8.bh) {
mov	al,$D[bp]
br 	.3D5
! 2918             case 0:
! 2919               comm_byte = inhibit_mouse_int_and_events();
.3D6:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2920               ret = send_to_mouse_ctrl(0xE9);
! Debug: list int = const $E9 (used reg = )
mov	ax,#$E9
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2921               if (ret == 0) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3D7
.3D8:
! 2922                 ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2923                 if (mouse_data1 != 0xfa)
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je  	.3D9
.3DA:
! 2924                   bios_printf((2 | 4 | 1), "Mouse status returned %02x (should be ack)\n", (unsigned)mouse_data1);
! Debug: list unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3DB+0 (used reg = )
mov	bx,#.3DB
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2925                 if (ret == 0) {
.3D9:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3DC
.3DD:
! 2926                   ret = get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2927                   if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
bne 	.3DE
.3DF:
! 2928                     ret = get_mouse_data(&mouse_data2);
! Debug: list * unsigned char mouse_data2 = S+$10-$F (used reg = )
lea	bx,-$D[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2929                     if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3E0
.3E1:
! 2930                       ret = get_mouse_data(&mouse_data3);
! Debug: list * unsigned char mouse_data3 = S+$10-$10 (used reg = )
lea	bx,-$E[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2931                       if ( ret == 0 ) {
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3E2
.3E3:
! 2932                         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2933                         regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2934                         regs.u.r8.bl = mouse_data1;
! Debug: eq unsigned char mouse_data1 = [S+$10-$E] to unsigned char regs = [S+$10+$A] (used reg = )
mov	al,-$C[bp]
mov	$C[bp],al
!BCC_EOS
! 2935                         regs.u.r8.cl = mouse_data2;
! Debug: eq unsigned char mouse_data2 = [S+$10-$F] to unsigned char regs = [S+$10+$E] (used reg = )
mov	al,-$D[bp]
mov	$10[bp],al
!BCC_EOS
! 2936                         regs.u.r8.dl = mouse_data3;
! Debug: eq unsigned char mouse_data3 = [S+$10-$10] to unsigned char regs = [S+$10+$C] (used reg = )
mov	al,-$E[bp]
mov	$E[bp],al
!BCC_EOS
! 2937                         set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2938                         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2939                         }
! 2940                       }
.3E2:
! 2941                     }
.3E0:
! 2942                   }
.3DE:
! 2943                 }
.3DC:
! 2944               FLAGS |= 0x0001;
.3D7:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2945               regs.u.r8.ah = ret;
! Debug: eq unsigned char ret = [S+$10-$D] to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,-$B[bp]
mov	$13[bp],al
!BCC_EOS
! 2946               set_kbd_command_byte(comm_byte);
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2947               return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 2948             case 1:
! 2949             case 2:
.3E4:
! 2950               comm_byte = inhibit_mouse_int_and_events();
.3E5:
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
! Debug: eq unsigned char = al+0 to unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 2951           
! 2951     if (regs.u.r8.bh == 1) {
! Debug: logeq int = const 1 to unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
cmp	al,*1
jne 	.3E6
.3E7:
! 2952                 ret = send_to_mouse_ctrl(0xE6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2953               } else {
jmp .3E8
.3E6:
! 2954                 ret = send_to_mouse_ctrl(0xE7);
! Debug: list int = const $E7 (used reg = )
mov	ax,#$E7
push	ax
! Debug: func () unsigned char = send_to_mouse_ctrl+0 (used reg = )
call	_send_to_mouse_ctrl
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2955               }
! 2956               if (ret == 0) {
.3E8:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3E9
.3EA:
! 2957                 get_mouse_data(&mouse_data1);
! Debug: list * unsigned char mouse_data1 = S+$10-$E (used reg = )
lea	bx,-$C[bp]
push	bx
! Debug: func () unsigned char = get_mouse_data+0 (used reg = )
call	_get_mouse_data
inc	sp
inc	sp
!BCC_EOS
! 2958                 ret = (mouse_data1 != 0xFA);
! Debug: ne int = const $FA to unsigned char mouse_data1 = [S+$10-$E] (used reg = )
mov	al,-$C[bp]
cmp	al,#$FA
je 	.3EB
mov	al,*1
jmp	.3EC
.3EB:
xor	al,al
.3EC:
! Debug: eq char = al+0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 2959               }
! 2960               if (ret == 0) {
.3E9:
! Debug: logeq int = const 0 to unsigned char ret = [S+$10-$D] (used reg = )
mov	al,-$B[bp]
test	al,al
jne 	.3ED
.3EE:
! 2961                 FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2962                 regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2963               } else {
jmp .3EF
.3ED:
! 2964                 FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2965                 regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 2966               }
! 2967               set_kbd_command_byte(comm_byte);
.3EF:
! Debug: list unsigned char comm_byte = [S+$10-$B] (used reg = )
mov	al,-9[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_kbd_command_byte+0 (used reg = )
call	_set_kbd_command_byte
inc	sp
inc	sp
!BCC_EOS
! 2968               break;
jmp .3D3
!BCC_EOS
! 2969             default:
! 2970               bios_printf((2 | 4 | 1), "INT 15h C2 AL=6, BH=%02x\n", (unsigned) regs.u.r8.bh);
.3F0:
! Debug: list unsigned char regs = [S+$10+$B] (used reg = )
mov	al,$D[bp]
xor	ah,ah
push	ax
! Debug: list * char = .3F1+0 (used reg = )
mov	bx,#.3F1
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 2971             }
! 2972           break;
jmp .3D3
.3D5:
sub	al,*0
beq 	.3D6
sub	al,*1
beq 	.3E4
sub	al,*1
beq 	.3E5
jmp	.3F0
.3D3:
br 	.384
!BCC_EOS
! 2973         case 7:
! 2974 ;
.3F2:
!BCC_EOS
! 2975           mouse_driver_seg = ES;
! Debug: eq unsigned short ES = [S+$10+$12] to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,$14[bp]
mov	-6[bp],ax
!BCC_EOS
! 2976           mouse_driver_offset = regs.u.r16.bx;
! Debug: eq unsigned short regs = [S+$10+$A] to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,$C[bp]
mov	-8[bp],ax
!BCC_EOS
! 2977           write_word(ebda_seg, 0x0022, mouse_driver_offset);
! Debug: list unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $22 (used reg = )
mov	ax,*$22
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2978           write_word(ebda_seg, 0x0024, mouse_driver_seg);
! Debug: list unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
push	-6[bp]
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 2979           mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$12-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 2980           if (mouse_driver_offset == 0 && mouse_driver_seg == 0) {
! Debug: logeq int = const 0 to unsigned short mouse_driver_offset = [S+$10-$A] (used reg = )
mov	ax,-8[bp]
test	ax,ax
jne 	.3F3
.3F5:
! Debug: logeq int = const 0 to unsigned short mouse_driver_seg = [S+$10-8] (used reg = )
mov	ax,-6[bp]
test	ax,ax
jne 	.3F3
.3F4:
! 2981             if ( (mouse_flags_2 & 0x80) != 0 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,#$80
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.3F6
.3F7:
! 2982               mouse_flags_2 &= ~0x80;
! Debug: andab int = const -$81 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
and	al,*$7F
mov	-4[bp],al
!BCC_EOS
! 2983               inhibit_mouse_int_and_events();
! Debug: func () unsigned char = inhibit_mouse_int_and_events+0 (used reg = )
call	_inhibit_mouse_int_and_events
!BCC_EOS
! 2984               }
! 2985             }
.3F6:
! 2986           else {
jmp .3F8
.3F3:
! 2987             mouse_flags_2 |= 0x80;
! Debug: orab int = const $80 to unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
or	al,#$80
mov	-4[bp],al
!BCC_EOS
! 2988             }
! 2989           write_byte(ebda_seg, 0x0027, mouse_flags_2);
.3F8:
! Debug: list unsigned char mouse_flags_2 = [S+$10-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$14-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 2990           FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
and	al,#$FE
mov	$18[bp],ax
!BCC_EOS
! 2991           regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+$10+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 2992           break;
jmp .384
!BCC_EOS
! 2993         default:
! 2994 ;
.3F9:
!BCC_EOS
! 2995           regs.u.r8.ah = 1;
! Debug: eq int = const 1 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,*1
mov	$13[bp],al
!BCC_EOS
! 2996           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 2997         }
! 2998       break;
jmp .384
.386:
sub	al,*0
jb 	.3F9
cmp	al,*7
ja  	.3FA
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.3FB[bx]
.3FB:
.word	.387
.word	.39A
.word	.3AD
.word	.3C1
.word	.3CE
.word	.39B
.word	.3D2
.word	.3F2
.3FA:
jmp	.3F9
.384:
jmp .380
!BCC_EOS
! 2999     default:
! 3000       ;
.3FC:
!BCC_EOS
! 3001       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$10+$16] (used reg = )
mov	ax,$18[bp]
or	al,*1
mov	$18[bp],ax
!BCC_EOS
! 3002       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$10+$11] (used reg = )
mov	al,#$86
mov	$13[bp],al
!BCC_EOS
! 3003       break;
jmp .380
!BCC_EOS
! 3004     }
! 3005 }
jmp .380
.382:
sub	al,#$C2
beq 	.383
jmp	.3FC
.380:
..FFF6	=	-$10
mov	sp,bp
pop	bp
ret
! 3006 void set_e820_range(ES, DI, start, end, type)
! Register BX used in function int15_function_mouse
! 3007      Bit16u ES;
export	_set_e820_range
_set_e820_range:
!BCC_EOS
! 3008      Bit16u DI;
!BCC_EOS
! 3009      Bit32u start;
!BCC_EOS
! 3010      Bit32u end;
!BCC_EOS
! 3011      Bit16u type;
!BCC_EOS
! 3012 {
! 3013     write_word(ES, DI, start);
push	bp
mov	bp,sp
! Debug: list unsigned long start = [S+2+6] (used reg = )
push	$A[bp]
push	8[bp]
! Debug: list unsigned short DI = [S+6+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3014     write_word(ES, DI+2, start >> 16);
! Debug: sr int = const $10 to unsigned long start = [S+2+6] (used reg = )
mov	ax,8[bp]
mov	bx,$A[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 2 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3015     write_word(ES, DI+4, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 4 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3016     write_word(ES, DI+6, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const 6 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3017     end -= start;
! Debug: subab unsigned long start = [S+2+6] to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
lea	di,8[bp]
call	lsubul
mov	$C[bp],ax
mov	$E[bp],bx
!BCC_EOS
! 3018     write_word(ES, DI+8, end);
! Debug: list unsigned long end = [S+2+$A] (used reg = )
push	$E[bp]
push	$C[bp]
! Debug: add int = const 8 to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3019     write_word(ES, DI+10, end >> 16);
! Debug: sr int = const $10 to unsigned long end = [S+2+$A] (used reg = )
mov	ax,$C[bp]
mov	bx,$E[bp]
xchg	bx,ax
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const $A to unsigned short DI = [S+6+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short ES = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3020     write_word(ES, DI+12, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $C to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3021     write_word(ES, DI+14, 0x0000);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $E to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3022     write_word(ES
! 3022 , DI+16, type);
! Debug: list unsigned short type = [S+2+$E] (used reg = )
push	$10[bp]
! Debug: add int = const $10 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3023     write_word(ES, DI+18, 0x0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add int = const $12 to unsigned short DI = [S+4+4] (used reg = )
mov	ax,6[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short ES = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
mov	sp,bp
!BCC_EOS
! 3024 }
pop	bp
ret
! 3025   void
! Register BX used in function set_e820_range
! 3026 int15_function32(regs, ES, DS, FLAGS)
! 3027   pushad_regs_t regs;
export	_int15_function32
_int15_function32:
!BCC_EOS
! 3028   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 3029 {
! 3030   Bit32u extended_memory_size=0;
push	bp
mov	bp,sp
add	sp,*-4
! Debug: eq int = const 0 to unsigned long extended_memory_size = [S+6-6] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3031   Bit16u CX,DX;
!BCC_EOS
! 3032   Bit16u off, e820_table_size;
!BCC_EOS
! 3033   Bit32u base, type, size;
!BCC_EOS
! 3034 ;
add	sp,*-$14
!BCC_EOS
! 3035   switch (regs.u.r8.ah) {
mov	al,$21[bp]
br 	.3FF
! 3036     case 0x86:
! 3037       CX = regs.u.r16.cx;
.400:
! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short CX = [S+$1A-8] (used reg = )
mov	ax,$1C[bp]
mov	-6[bp],ax
!BCC_EOS
! 3038       DX = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short DX = [S+$1A-$A] (used reg = )
mov	ax,$18[bp]
mov	-8[bp],ax
!BCC_EOS
! 3039 #asm
!BCC_EOS
!BCC_ASM
_int15_function32.CX	set	$12
.int15_function32.CX	set	-6
_int15_function32.extended_memory_size	set	$14
.int15_function32.extended_memory_size	set	-4
_int15_function32.FLAGS	set	$40
.int15_function32.FLAGS	set	$28
_int15_function32.type	set	4
.int15_function32.type	set	-$14
_int15_function32.DS	set	$3E
.int15_function32.DS	set	$26
_int15_function32.DX	set	$10
.int15_function32.DX	set	-8
_int15_function32.size	set	0
.int15_function32.size	set	-$18
_int15_function32.ES	set	$3C
.int15_function32.ES	set	$24
_int15_function32.e820_table_size	set	$C
.int15_function32.e820_table_size	set	-$C
_int15_function32.base	set	8
.int15_function32.base	set	-$10
_int15_function32.regs	set	$1C
.int15_function32.regs	set	4
_int15_function32.off	set	$E
.int15_function32.off	set	-$A
      sti
      ;; Get the count in eax
      mov bx, sp
SEG SS
      mov ax, _int15_function32.CX [bx]
      shl eax, #16
SEG SS
      mov ax, _int15_function32.DX [bx]
      ;; convert to numbers of 15usec ticks
      mov ebx, #15
      xor edx, edx
      div eax, ebx
      mov ecx, eax
      ;; wait for ecx number of refresh requests
      in al, #0x61
      and al,#0x10
      mov ah, al
      or ecx, ecx
      je int1586_tick_end
int1586_tick:
      in al, #0x61
      and al,#0x10
      cmp al, ah
      je int1586_tick
      mov ah, al
      dec ecx
      jnz int1586_tick
int1586_tick_end:
! 3068 endasm
!BCC_ENDASM
!BCC_EOS
! 3069       break;
br 	.3FD
!BCC_EOS
! 3070     case 0xe8:
! 3071         switch(regs.u.r8.al)
.401:
mov	al,$20[bp]
! 3072         {
br 	.404
! 3073        case 0x20: {
.405:
! 3074             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3075             if (regs.u.r32.edx != 0x534D4150)
! Debug: ne long = const $534D4150 to unsigned long regs = [S+$1A+$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$4150
mov	bx,#$534D
push	bx
push	ax
mov	ax,$18[bp]
mov	bx,$1A[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
je  	.406
.407:
! 3076                 goto int15_unimplemented;
add	sp,#..FFF4-..FFF5
br 	.FFF4
!BCC_EOS
! 3077             if ((regs.u.r16.bx / 0x14) * 0x14 == regs.u.r16.bx) {
.406:
! Debug: div int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
mov	bx,*$14
call	idiv_u
! Debug: mul int = const $14 to unsigned int = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: logeq unsigned short regs = [S+$1A+$12] to unsigned int = ax+0 (used reg = )
cmp	ax,$14[bp]
bne 	.408
.409:
! 3078                 if (regs.u.r16.bx + 0x14 <= e820_table_size)
! Debug: add int = const $14 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
! Debug: le unsigned short e820_table_size = [S+$1A-$E] to unsigned int = ax+$14 (used reg = )
add	ax,*$14
cmp	ax,-$C[bp]
ja  	.40A
.40B:
! 3079                     memcpyb(ES, regs.u.r16.di,
! 3080                             (Bit16u)(0x000EA100 >> 4), 0x8 + regs.u.r16.bx, 0x14);
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: add unsigned short regs = [S+$1C+$12] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,$14[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: list unsigned short regs = [S+$20+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
push	$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 3081                 regs.u.r32.ebx += 0x14;
.40A:
! Debug: addab unsigned long = const $14 to unsigned long regs = [S+$1A+$12] (used reg = )
mov	ax,*$14
xor	bx,bx
push	bx
push	ax
mov	ax,$14[bp]
mov	bx,$16[bp]
lea	di,-2+..FFF5[bp]
call	laddul
mov	$14[bp],ax
mov	$16[bp],bx
add	sp,*4
!BCC_EOS
! 3082                 if ((regs.u.r32.ebx + 0x14 - 1) > e820_table_size)
! Debug: cast unsigned long = const 0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned long = const $14 to unsigned long regs = [S+$1E+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,*$14
xor	bx,bx
lea	di,$14[bp]
call	laddul
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-6+..FFF5[bp]
mov	bx,-4+..FFF5[bp]
lea	di,-$A+..FFF5[bp]
call	lsubul
add	sp,*8
! Debug: gt unsigned long (temp) = [S+$1E-$1E] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jbe 	.40C
.40D:
! 3083                     regs.u.r32.ebx = 0;
! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3084             } else if (regs.u.r16.bx == 1) {
.40C:
br 	.40E
.408:
! Debug: logeq int = const 1 to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$14[bp]
cmp	ax,*1
bne 	.40F
.410:
! 3085                 for (off = 0; off < e820_table_size; off += 0x14) {
! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
xor	ax,ax
mov	-$A[bp],ax
!BCC_EOS
!BCC_EOS
jmp .413
.414:
! 3086                     base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 3087                     type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
mov	-$14[bp],ax
mov	-$12[bp],bx
!BCC_EOS
! 3088                     if ((base >= 0x100000) && (type == 1))
! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
xor	ax,ax
mov	bx,*$10
lea	di,-$10[bp]
call	lcmpul
ja  	.415
.417:
! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-$14[bp]
mov	bx,-$12[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jne 	.415
.416:
! 3089                         break;
jmp .411
!BCC_EOS
! 3090                 }
.415:
! 3091                 if (off == e820_table_size) {
.412:
! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
add	ax,*$14
mov	-$A[bp],ax
.413:
! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jb 	.414
.418:
.411:
! Debug: logeq unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jne 	.419
.41A:
! 3092   
! 3092                   FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 3093                     break;
br 	.402
!BCC_EOS
! 3094                 }
! 3095                 memcpyb(ES, regs.u.r16.di, (Bit16u)(0x000EA100 >> 4), 0x8 + off, 0x14);
.419:
! Debug: list int = const $14 (used reg = )
mov	ax,*$14
push	ax
! Debug: add unsigned short off = [S+$1C-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: list unsigned short regs = [S+$20+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ES = [S+$22+$22] (used reg = )
push	$24[bp]
! Debug: func () void = memcpyb+0 (used reg = )
call	_memcpyb
add	sp,*$A
!BCC_EOS
! 3096                 regs.u.r32.ebx = 0;
! Debug: eq int = const 0 to unsigned long regs = [S+$1A+$12] (used reg = )
xor	ax,ax
xor	bx,bx
mov	$14[bp],ax
mov	$16[bp],bx
!BCC_EOS
! 3097             } else {
jmp .41B
.40F:
! 3098                 goto int15_unimplemented;
add	sp,#..FFF4-..FFF5
br 	.FFF4
!BCC_EOS
! 3099             }
! 3100             regs.u.r32.eax = 0x534D4150;
.41B:
.40E:
! Debug: eq long = const $534D4150 to unsigned long regs = [S+$1A+$1E] (used reg = )
mov	ax,#$4150
mov	bx,#$534D
mov	$20[bp],ax
mov	$22[bp],bx
!BCC_EOS
! 3101             regs.u.r32.ecx = 0x14;
! Debug: eq int = const $14 to unsigned long regs = [S+$1A+$1A] (used reg = )
mov	ax,*$14
xor	bx,bx
mov	$1C[bp],ax
mov	$1E[bp],bx
!BCC_EOS
! 3102             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3103             break;
br 	.402
!BCC_EOS
! 3104         }
! 3105         case 0x01: {
.41C:
! 3106             e820_table_size = read_word((Bit16u)(0x000EA100 >> 4), 0x0) * 0x14;
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: mul int = const $14 to unsigned short = ax+0 (used reg = )
mov	cx,*$14
imul	cx
! Debug: eq unsigned int = ax+0 to unsigned short e820_table_size = [S+$1A-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3107             FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
and	al,#$FE
mov	$28[bp],ax
!BCC_EOS
! 3108             regs.u.r8.cl = inb_cmos(0x30);
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1A] (used reg = )
mov	$1C[bp],al
!BCC_EOS
! 3109             regs.u.r8.ch = inb_cmos(0x31);
! Debug: list int = const $31 (used reg = )
mov	ax,*$31
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+$1A+$1B] (used reg = )
mov	$1D[bp],al
!BCC_EOS
! 3110             if (regs.u.r16.cx > (15*1024))
! Debug: gt int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
mov	ax,$1C[bp]
cmp	ax,#$3C00
jbe 	.41D
.41E:
! 3111                 regs.u.r16.cx = 15*1024;
! Debug: eq int = const $3C00 to unsigned short regs = [S+$1A+$1A] (used reg = )
mov	ax,#$3C00
mov	$1C[bp],ax
!BCC_EOS
! 3112             for (off = 0; off < e820_table_size; off += 0x14) {
.41D:
! Debug: eq int = const 0 to unsigned short off = [S+$1A-$C] (used reg = )
xor	ax,ax
mov	-$A[bp],ax
!BCC_EOS
!BCC_EOS
jmp .421
.422:
! 3113                 base = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const 8 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
mov	-$10[bp],ax
mov	-$E[bp],bx
!BCC_EOS
! 3114                 type = read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x10 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $18 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long type = [S+$1A-$16] (used reg = )
mov	-$14[bp],ax
mov	-$12[bp],bx
!BCC_EOS
! 3115                 if ((base >= 0x100000) && (type == 1))
! Debug: ge long = const $100000 to unsigned long base = [S+$1A-$12] (used reg = )
xor	ax,ax
mov	bx,*$10
lea	di,-$10[bp]
call	lcmpul
ja  	.423
.425:
! Debug: logeq unsigned long = const 1 to unsigned long type = [S+$1A-$16] (used reg = )
! Debug: expression subtree swapping
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-$14[bp]
mov	bx,-$12[bp]
lea	di,-2+..FFF5[bp]
call	lcmpul
lea	sp,2+..FFF5[bp]
jne 	.423
.424:
! 3116                     break;
jmp .41F
!BCC_EOS
! 3117             }
.423:
! 3118             regs.u.r16.dx = 0;
.420:
! Debug: addab int = const $14 to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
add	ax,*$14
mov	-$A[bp],ax
.421:
! Debug: lt unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
jb 	.422
.426:
.41F:
! Debug: eq int = const 0 to unsigned short regs = [S+$1A+$16] (used reg = )
xor	ax,ax
mov	$18[bp],ax
!BCC_EOS
! 3119             if (off != e820_table_size) {
! Debug: ne unsigned short e820_table_size = [S+$1A-$E] to unsigned short off = [S+$1A-$C] (used reg = )
mov	ax,-$A[bp]
cmp	ax,-$C[bp]
je  	.427
.428:
! 3120                 size = base + read_dword((Bit16u)(0x000EA100 >> 4), 0x8 + 0x8 + off);
! Debug: add unsigned short off = [S+$1A-$C] to int = const $10 (used reg = )
! Debug: expression subtree swapping
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short = const $EA10 (used reg = )
mov	ax,#$EA10
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: add unsigned long = bx+0 to unsigned long base = [S+$1A-$12] (used reg = )
! Debug: expression subtree swapping
lea	di,-$10[bp]
call	laddul
! Debug: eq unsigned long = bx+0 to unsigned long size = [S+$1A-$1A] (used reg = )
mov	-$18[bp],ax
mov	-$16[bp],bx
!BCC_EOS
! 3121                 if (size > 0x1000000) {
! Debug: gt long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
xor	ax,ax
mov	bx,#$100
lea	di,-$18[bp]
call	lcmpul
jae 	.429
.42A:
! 3122                     size -= 0x1000000;
! Debug: subab long = const $1000000 to unsigned long size = [S+$1A-$1A] (used reg = )
xor	ax,ax
mov	bx,#$100
push	bx
push	ax
mov	ax,-$18[bp]
mov	bx,-$16[bp]
lea	di,-2+..FFF5[bp]
call	lsubul
mov	-$18[bp],ax
mov	-$16[bp],bx
add	sp,*4
!BCC_EOS
! 3123                     regs.u.r16.dx = (Bit16u)(size >> 16);
! Debug: sr int = const $10 to unsigned long size = [S+$1A-$1A] (used reg = )
mov	ax,-$18[bp]
mov	bx,-$16[bp]
xchg	bx,ax
xor	bx,bx
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short regs = [S+$1A+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3124                 }
! 3125             }
.429:
! 3126             regs.u.r16.ax = regs.u.r16.cx;
.427:
! Debug: eq unsigned short regs = [S+$1A+$1A] to unsigned short regs = [S+$1A+$1E] (used reg = )
mov	ax,$1C[bp]
mov	$20[bp],ax
!BCC_EOS
! 3127             regs.u.r16.bx = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+$1A+$16] to unsigned short regs = [S+$1A+$12] (used reg = )
mov	ax,$18[bp]
mov	$14[bp],ax
!BCC_EOS
! 3128             break;
jmp .402
!BCC_EOS
! 3129         }
! 3130         default:
! 3131             goto int15_unimplemented;
.42B:
add	sp,#..FFF4-..FFF5
jmp .FFF4
!BCC_EOS
! 3132         }
! 3133         break;
jmp .402
.404:
sub	al,*1
beq 	.41C
sub	al,*$1F
beq 	.405
jmp	.42B
.402:
jmp .3FD
!BCC_EOS
! 3134     int15_unimplemented:
.FFF4:
! 3135     default:
! 3136       ;
.42C:
!BCC_EOS
! 3137       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$1A+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 3138       regs.u.r8.ah = 0x86;
! Debug: eq int = const $86 to unsigned char regs = [S+$1A+$1F] (used reg = )
mov	al,#$86
mov	$21[bp],al
!BCC_EOS
! 3139       break;
jmp .3FD
!BCC_EOS
! 3140     }
! 3141 }
jmp .3FD
.3FF:
sub	al,#$86
beq 	.400
sub	al,*$62
beq 	.401
jmp	.42C
.3FD:
..FFF5	=	-$1A
..FFF4	=	-$1A
mov	sp,bp
pop	bp
ret
! 3142   void
! Register BX used in function int15_function32
! 3143 int16_function(DI, SI, BP, SP, BX, DX, CX, AX, FLAGS)
! 3144   Bit16u DI, SI, BP, SP, BX, DX, CX, AX, FLAGS;
export	_int16_function
_int16_function:
!BCC_EOS
! 3145 {
! 3146   Bit8u scan_code, ascii_code, shift_flags, led_flags, count;
!BCC_EOS
! 3147   Bit16u kbd_code, max;
!BCC_EOS
! 3148   ;
push	bp
mov	bp,sp
add	sp,*-$A
!BCC_EOS
! 3149   shift_flags = read_byte(0x0040, 0x17);
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3150   led_flags = read_byte(0x0040, 0x97);
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3151   if ((((shift_flags >> 4) & 0x07) ^ (led_flags & 0x07)) != 0) {
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
push	ax
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: eor unsigned char (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	al,-$C[bp]
inc	sp
inc	sp
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.42D
.42E:
! 3152 #asm
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    cli
! 3154 endasm
!BCC_ENDASM
!BCC_EOS
! 3155     outb(0x60
! 3155 , 0xed);
! Debug: list int = const $ED (used reg = )
mov	ax,#$ED
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3156     while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .430
.431:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3157     if ((inb(0x60) == 0xfa)) {
.430:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.431
.432:
.42F:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.433
.434:
! 3158       led_flags &= 0xf8;
! Debug: andab int = const $F8 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,#$F8
mov	-4[bp],al
!BCC_EOS
! 3159       led_flags |= ((shift_flags >> 4) & 0x07);
! Debug: sr int = const 4 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 7 to unsigned int = ax+0 (used reg = )
and	al,*7
! Debug: orab unsigned char = al+0 to unsigned char led_flags = [S+$C-6] (used reg = )
or	al,-4[bp]
mov	-4[bp],al
!BCC_EOS
! 3160       outb(0x60, led_flags & 0x07);
! Debug: and int = const 7 to unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
and	al,*7
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3161       while ((inb(0x64) & 0x01) == 0) outb(0x80, 0x21);
jmp .436
.437:
! Debug: list int = const $21 (used reg = )
mov	ax,*$21
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3162       inb(0x60);
.436:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.437
.438:
.435:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
!BCC_EOS
! 3163       write_byte(0x0040, 0x97, led_flags);
! Debug: list unsigned char led_flags = [S+$C-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $97 (used reg = )
mov	ax,#$97
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3164     }
! 3165 #asm
.433:
!BCC_EOS
!BCC_ASM
_int16_function.BP	set	$12
.int16_function.BP	set	8
_int16_function.count	set	5
.int16_function.count	set	-5
_int16_function.CX	set	$1A
.int16_function.CX	set	$10
_int16_function.ascii_code	set	8
.int16_function.ascii_code	set	-2
_int16_function.DI	set	$E
.int16_function.DI	set	4
_int16_function.FLAGS	set	$1E
.int16_function.FLAGS	set	$14
_int16_function.kbd_code	set	2
.int16_function.kbd_code	set	-8
_int16_function.scan_code	set	9
.int16_function.scan_code	set	-1
_int16_function.DX	set	$18
.int16_function.DX	set	$E
_int16_function.led_flags	set	6
.int16_function.led_flags	set	-4
_int16_function.SI	set	$10
.int16_function.SI	set	6
_int16_function.AX	set	$1C
.int16_function.AX	set	$12
_int16_function.SP	set	$14
.int16_function.SP	set	$A
_int16_function.BX	set	$16
.int16_function.BX	set	$C
_int16_function.shift_flags	set	7
.int16_function.shift_flags	set	-3
_int16_function.max	set	0
.int16_function.max	set	-$A
    sti
! 3167 endasm
!BCC_ENDASM
!BCC_EOS
! 3168   }
! 3169   switch (( AX >> 8 )) {
.42D:
! Debug: sr int = const 8 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
br 	.43B
! 3170     case 0x00:
! 3171       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.43C:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.43D
.43E:
! 3172         bios_printf((2 | 4 | 1), "KBD: int16h: out of keyboard input\n");
! Debug: list * char = .43F+0 (used reg = )
mov	bx,#.43F
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3173         }
! 3174       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.43D:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.440
.442:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.440
.441:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3175       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .443
.440:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.444
.445:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3176       AX = (scan_code << 8) | ascii_code;
.444:
.443:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3177       break;
br 	.439
!BCC_EOS
! 3178     case 0x01:
! 3179       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.446:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.447
.448:
! 3180         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3181         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3182         }
! 3183       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.447:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.449
.44B:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.449
.44A:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3184       else if (ascii_code == 0xE0) ascii_code = 0;
jmp .44C
.449:
! Debug: logeq int = const $E0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$E0
jne 	.44D
.44E:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3185       AX = (scan_code << 8) | ascii_code;
.44D:
.44C:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3186       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3187       break;
br 	.439
!BCC_EOS
! 3188     case 0x02:
! 3189       shift_flags = read_byte(0x0040, 0x17);
.44F:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3190       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3191       break;
br 	.439
!BCC_EOS
! 3192     case 0x05:
! 3193       if ( !enqueue_key(( CX >> 8 ), ( CX & 0x00ff )) ) {
.450:
! Debug: and int = const $FF to unsigned short CX = [S+$C+$E] (used reg = )
mov	al,$10[bp]
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: sr int = const 8 to unsigned short CX = [S+$E+$E] (used reg = )
mov	ax,$10[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
test	ax,ax
jne 	.451
.452:
! 3194         AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3195         }
! 3196       else {
jmp .453
.451:
! 3197         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3198         }
! 3199       break;
.453:
br 	.439
!BCC_EOS
! 3200     case 0x09:
! 3201       AX = ((AX & 0xff00) | (0x30));
.454:
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const $30 to unsigned int = ax+0 (used reg = )
or	al,*$30
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3202       break;
br 	.439
!BCC_EOS
! 3203     case 0x0A:
! 3204       count = 2;
.455:
! Debug: eq int = const 2 to unsigned char count = [S+$C-7] (used reg = )
mov	al,*2
mov	-5[bp],al
!BCC_EOS
! 3205       kbd_code = 0x0;
! Debug: eq int = const 0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
xor	ax,ax
mov	-8[bp],ax
!BCC_EOS
! 3206       outb(0x60, 0xf2);
! Debug: list int = const $F2 (used reg = )
mov	ax,#$F2
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3207       max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3208       while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .457
.458:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3209       if (max>0x0) {
.457:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.459
.45A:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.458
.459:
.456:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
je  	.45B
.45C:
! 3210         if ((inb(0x60) == 0xfa)) {
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: logeq int = const $FA to unsigned char = al+0 (used reg = )
cmp	al,#$FA
jne 	.45D
.45E:
! 3211           do {
.461:
! 3212             max=0xffff;
! Debug: eq unsigned int = const $FFFF to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,#$FFFF
mov	-$A[bp],ax
!BCC_EOS
! 3213             while ( ((inb(0x64) & 0x01) == 0) && (--max>0) ) outb(0x80, 0x00);
jmp .463
.464:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3214             if (max>0x0) {
.463:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.465
.466:
! Debug: predec unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
dec	ax
mov	-$A[bp],ax
! Debug: gt int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne	.464
.465:
.462:
! Debug: gt int = const 0 to unsigned short max = [S+$C-$C] (used reg = )
mov	ax,-$A[bp]
test	ax,ax
je  	.467
.468:
! 3215               kbd_code >>= 8;
! Debug: srab int = const 8 to unsigned short kbd_code = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
mov	-8[bp],ax
!BCC_EOS
! 3216               kbd_code |= (inb(0x60) << 8);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: orab unsigned int = ax+0 to unsigned short kbd_code = [S+$C-$A] (used reg = )
or	ax,-8[bp]
mov	-8[bp],ax
!BCC_EOS
! 3217             }
! 3218           } while (--count>0);
.467:
.460:
! Debug: predec unsigned char count = [S+$C-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne	.461
.469:
!BCC_EOS
! 3219         }
.45F:
! 3220       }
.45D:
! 3221       BX=kbd_code;
.45B:
! Debug: eq unsigned short kbd_code = [S+$C-$A] to unsigned short BX = [S+$C+$A] (used reg = )
mov	ax,-8[bp]
mov	$C[bp],ax
!BCC_EOS
! 3222       break;
br 	.439
!BCC_EOS
! 3223     case 0x10:
! 3224       if ( !dequeue_key(&scan_code, &ascii_code, 1) ) {
.46A:
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.46B
.46C:
! 3225         bios_printf((2 | 4 | 1), "KBD: int16h: out o
! 3225 f keyboard input\n");
! Debug: list * char = .46D+0 (used reg = )
mov	bx,#.46D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 3226         }
! 3227       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.46B:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.46E
.470:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.46E
.46F:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3228       AX = (scan_code << 8) | ascii_code;
.46E:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3229       break;
br 	.439
!BCC_EOS
! 3230     case 0x11:
! 3231       if ( !dequeue_key(&scan_code, &ascii_code, 0) ) {
.471:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char ascii_code = S+$E-4 (used reg = )
lea	bx,-2[bp]
push	bx
! Debug: list * unsigned char scan_code = S+$10-3 (used reg = )
lea	bx,-1[bp]
push	bx
! Debug: func () unsigned int = dequeue_key+0 (used reg = )
call	_dequeue_key
add	sp,*6
test	ax,ax
jne 	.472
.473:
! 3232         FLAGS |= 0x0040;
! Debug: orab int = const $40 to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
or	al,*$40
mov	$14[bp],ax
!BCC_EOS
! 3233         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3234         }
! 3235       if (scan_code !=0 && ascii_code == 0xF0) ascii_code = 0;
.472:
! Debug: ne int = const 0 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
test	al,al
je  	.474
.476:
! Debug: logeq int = const $F0 to unsigned char ascii_code = [S+$C-4] (used reg = )
mov	al,-2[bp]
cmp	al,#$F0
jne 	.474
.475:
! Debug: eq int = const 0 to unsigned char ascii_code = [S+$C-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3236       AX = (scan_code << 8) | ascii_code;
.474:
! Debug: sl int = const 8 to unsigned char scan_code = [S+$C-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: or unsigned char ascii_code = [S+$C-4] to unsigned int = ax+0 (used reg = )
or	al,-2[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3237       FLAGS &= 0xffbf;
! Debug: andab unsigned int = const $FFBF to unsigned short FLAGS = [S+$C+$12] (used reg = )
mov	ax,$14[bp]
and	al,#$BF
mov	$14[bp],ax
!BCC_EOS
! 3238       break;
br 	.439
!BCC_EOS
! 3239     case 0x12:
! 3240       shift_flags = read_byte(0x0040, 0x17);
.477:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3241       AX = ((AX & 0xff00) | (shift_flags));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$C+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char shift_flags = [S+$C-5] to unsigned int = ax+0 (used reg = )
or	al,-3[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3242       shift_flags = read_byte(0x0040, 0x18) & 0x73;
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $73 to unsigned char = al+0 (used reg = )
and	al,*$73
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3243       shift_flags |= read_byte(0x0040, 0x96) & 0x0c;
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $C to unsigned char = al+0 (used reg = )
and	al,*$C
! Debug: orab unsigned char = al+0 to unsigned char shift_flags = [S+$C-5] (used reg = )
or	al,-3[bp]
mov	-3[bp],al
!BCC_EOS
! 3244       AX = ((AX & 0x00ff) | ((shift_flags) << 8));
! Debug: sl int = const 8 to unsigned char shift_flags = [S+$C-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$E+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$E-$E] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF3[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3245       ;
!BCC_EOS
! 3246       break;
jmp .439
!BCC_EOS
! 3247     case 0x92:
! 3248       AX = ((AX & 0x00ff) | ((0x80) << 8));
.478:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3249       break;
jmp .439
!BCC_EOS
! 3250     case 0xA2:
! 3251       break;
.479:
jmp .439
!BCC_EOS
! 3252     case 0x6F:
! 3253       if (( AX & 0x00ff ) == 0x08)
.47A:
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: logeq int = const 8 to unsigned char = al+0 (used reg = )
cmp	al,*8
jne 	.47B
.47C:
! 3254         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$C+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$C+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 3255     default:
.47B:
! 3256       ;
.47D:
!BCC_EOS
! 3257     }
! 3258 }
jmp .439
.43B:
sub	ax,*0
jl 	.47D
cmp	ax,*$12
ja  	.47E
shl	ax,*1
mov	bx,ax
seg	cs
br	.47F[bx]
.47F:
.word	.43C
.word	.446
.word	.44F
.word	.47D
.word	.47D
.word	.450
.word	.47D
.word	.47D
.word	.47D
.word	.454
.word	.455
.word	.47D
.word	.47D
.word	.47D
.word	.47D
.word	.47D
.word	.46A
.word	.471
.word	.477
.47E:
sub	ax,*$6F
je 	.47A
sub	ax,*$23
je 	.478
sub	ax,*$10
je 	.479
jmp	.47D
.439:
..FFF3	=	-$C
mov	sp,bp
pop	bp
ret
! 3259   unsigned int
! Register BX used in function int16_function
! 3260 dequeue_key(scan_code, ascii_code, incr)
! 3261   Bit8u *scan_code;
export	_dequeue_key
_dequeue_key:
!BCC_EOS
! 3262   Bit8u *ascii_code;
!BCC_EOS
! 3263   unsigned int incr;
!BCC_EOS
! 3264 {
! 3265   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail;
!BCC_EOS
! 3266   Bit16u ss;
!BCC_EOS
! 3267   Bit8u acode, scode;
!BCC_EOS
! 3268   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$C
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$E-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3269   buffer_end = read_word(0x0040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$E-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3270   buffer_head = read_word(0x0040, 0x001a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3271   buffer_tail = read_word(0x0040, 0x001c);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$E-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3272   if (buffer_head != buffer_tail) {
! Debug: ne unsigned short buffer_tail = [S+$E-$A] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-8[bp]
beq 	.480
.481:
! 3273     ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+$E-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3274     acode = read_byte(0x0040, buffer_head);
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char acode = [S+$E-$D] (used reg = )
mov	-$B[bp],al
!BCC_EOS
! 3275     scode = read_byte(0x0040, buffer_head+1);
! Debug: add int = const 1 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char scode = [S+$E-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 3276     write_byte(ss, ascii_code, acode);
! Debug: list unsigned char acode = [S+$E-$D] (used reg = )
mov	al,-$B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char ascii_code = [S+$10+4] (used reg = )
push	6[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3277     write_byte(ss, scan_code, scode);
! Debug: list unsigned char scode = [S+$E-$E] (used reg = )
mov	al,-$C[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char scan_code = [S+$10+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$12-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3278     if (incr) {
mov	ax,8[bp]
test	ax,ax
je  	.482
.483:
! 3279       buffer_head += 2;
! Debug: addab int = const 2 to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
inc	ax
inc	ax
mov	-6[bp],ax
!BCC_EOS
! 3280       if (buffer_head >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$E-6] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-6[bp]
cmp	ax,-4[bp]
jb  	.484
.485:
! 3281         buffer_head = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$E-4] to unsigned short buffer_head = [S+$E-8] (used reg = )
mov	ax,-2[bp]
mov	-6[bp],ax
!BCC_EOS
! 3282       write_word(0x0040, 0x001a, buffer_head);
.484:
! Debug: list unsigned short buffer_head = [S+$E-8] (used reg = )
push	-6[bp]
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3283       }
! 3284     return(1);
.482:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3285     }
! 3286   else {
jmp .486
.480:
! 3287     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3288     }
! 3289 }
.486:
mov	sp,bp
pop	bp
ret
! 3290 static char panic_msg_keyb_buffer_full[] = "%s: keyboard input buffer full\n";
.data
_panic_msg_keyb_buffer_full:
.487:
.ascii	"%s: keyboard input buffer full"
.byte	$A
.byte	0
!BCC_EOS
! 3291   Bit8u
! 3292 inhibit_mouse_int_and_events()
! 3293 {
.text
export	_inhibit_mouse_int_and_events
_inhibit_mouse_int_and_events:
! 3294   Bit8u command_byte, prev_command_byte;
!BCC_EOS
! 3295   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.488
.489:
! 3296     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .48A+0 (used reg = )
mov	bx,#.48A
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3297   outb(0x64, 0x20);
.488:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3298   while ( (inb(0x64)
! 3298  & 0x01) != 0x01 );
jmp .48C
.48D:
!BCC_EOS
! 3299   prev_command_byte = inb(0x60);
.48C:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.48D
.48E:
.48B:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char prev_command_byte = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 3300   command_byte = prev_command_byte;
! Debug: eq unsigned char prev_command_byte = [S+4-4] to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-2[bp]
mov	-1[bp],al
!BCC_EOS
! 3301   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.48F
.490:
! 3302     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"inhibmouse");
! Debug: list * char = .491+0 (used reg = )
mov	bx,#.491
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3303   command_byte &= 0xfd;
.48F:
! Debug: andab int = const $FD to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FD
mov	-1[bp],al
!BCC_EOS
! 3304   command_byte |= 0x20;
! Debug: orab int = const $20 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*$20
mov	-1[bp],al
!BCC_EOS
! 3305   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3306   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3307   return(prev_command_byte);
mov	al,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3308 }
! 3309   void
! Register BX used in function inhibit_mouse_int_and_events
! 3310 enable_mouse_int_and_events()
! 3311 {
export	_enable_mouse_int_and_events
_enable_mouse_int_and_events:
! 3312   Bit8u command_byte;
!BCC_EOS
! 3313   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.492
.493:
! 3314     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! Debug: list * char = .494+0 (used reg = )
mov	bx,#.494
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3315   outb(0x64, 0x20);
.492:
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3316   while ( (inb(0x64) & 0x01) != 0x01 );
jmp .496
.497:
!BCC_EOS
! 3317   command_byte = inb(0x60);
.496:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: ne int = const 1 to unsigned char = al+0 (used reg = )
cmp	al,*1
jne	.497
.498:
.495:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char command_byte = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3318   if ( inb(0x64) & 0x02 )
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.499
.49A:
! 3319     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"enabmouse");
! Debug: list * char = .49B+0 (used reg = )
mov	bx,#.49B
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3320   command_byte |= 0x02;
.499:
! Debug: orab int = const 2 to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 3321   command_byte &= 0xdf;
! Debug: andab int = const $DF to unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$DF
mov	-1[bp],al
!BCC_EOS
! 3322   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3323   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3324 }
mov	sp,bp
pop	bp
ret
! 3325   Bit8u
! Register BX used in function enable_mouse_int_and_events
! 3326 send_to_mouse_ctrl(sendbyte)
! 3327   Bit8u sendbyte;
export	_send_to_mouse_ctrl
_send_to_mouse_ctrl:
!BCC_EOS
! 3328 {
! 3329   Bit8u response;
!BCC_EOS
! 3330   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.49C
.49D:
! 3331     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"sendmouse");
! Debug: list * char = .49E+0 (used reg = )
mov	bx,#.49E
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3332   outb(0x64, 0xD4);
.49C:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3333   outb(0x60, sendbyte);
! Debug: list unsigned char sendbyte = [S+4+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 3334   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3335 }
! 3336   Bit8u
! Register BX used in function send_to_mouse_ctrl
! 3337 get_mouse_data(data)
! 3338   Bit8u *data;
export	_get_mouse_data
_get_mouse_data:
!BCC_EOS
! 3339 {
! 3340   Bit8u response;
!BCC_EOS
! 3341   Bit16u ss;
!BCC_EOS
! 3342   while ( (inb(0x64) & 0x21) != 0x21 ) {
push	bp
mov	bp,sp
add	sp,*-4
jmp .4A0
.4A1:
! 3343     }
! 3344   response = inb(0x60);
.4A0:
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $21 to unsigned char = al+0 (used reg = )
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
jne	.4A1
.4A2:
.49F:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char response = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3345   ss = get_SS();
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: eq unsigned short = ax+0 to unsigned short ss = [S+6-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3346   write_byte(ss, data, response);
! Debug: list unsigned char response = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char data = [S+8+2] (used reg = )
push	4[bp]
! Debug: list unsigned short ss = [S+$A-6] (used reg = )
push	-4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3347   return(0);
xor	al,al
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3348 }
! 3349   void
! 3350 set_kbd_command_byte(command_byte)
! 3351   Bit8u command_byte;
export	_set_kbd_command_byte
_set_kbd_command_byte:
!BCC_EOS
! 3352 {
! 3353   if ( inb(0x64) & 0x02 )
push	bp
mov	bp,sp
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
mov	sp,bp
! Debug: and int = const 2 to unsigned char = al+0 (used reg = )
and	al,*2
test	al,al
je  	.4A3
.4A4:
! 3354     bios_printf((2 | 4 | 1), panic_msg_keyb_buffer_full,"setkbdcomm");
! Debug: list * char = .4A5+0 (used reg = )
mov	bx,#.4A5
push	bx
! Debug: list * char = panic_msg_keyb_buffer_full+0 (used reg = )
mov	bx,#_panic_msg_keyb_buffer_full
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 3355   outb(0x64, 0xD4);
.4A3:
! Debug: list int = const $D4 (used reg = )
mov	ax,#$D4
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3356   outb(0x64, 0x60);
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3357   outb(0x60, command_byte);
! Debug: list unsigned char command_byte = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
mov	sp,bp
!BCC_EOS
! 3358 }
pop	bp
ret
! 3359   void
! Register BX used in function set_kbd_command_byte
! 3360 int09_function(DI, SI, BP, SP, BX, DX, CX, AX)
! 3361   Bit16u DI, SI, BP, SP, BX, DX, CX, AX;
export	_int09_function
_int09_function:
!BCC_EOS
! 3362 {
! 3363   Bit8u scancode, asciicode, shift_flags;
!BCC_EOS
! 3364   Bit8u mf2_flags, mf2_state;
!BCC_EOS
! 3365   scancode = ( AX & 0x00ff );
push	bp
mov	bp,sp
add	sp,*-6
! Debug: and int = const $FF to unsigned short AX = [S+8+$10] (used reg = )
mov	al,$12[bp]
! Debug: eq unsigned char = al+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3366   if (scancode == 0) {
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.4A6
.4A7:
! 3367     ;
!BCC_EOS
! 3368     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3369     }
! 3370   shift_flags = read_byte(0x0040, 0x17);
.4A6:
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3371   mf2_flags = read_byte(0x0040, 0x18);
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3372   mf2_state = read_byte(0x0040, 0x96);
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3373   asciicode = 0;
! Debug: eq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 3374   switch (scancode) {
mov	al,-1[bp]
br 	.4AA
! 3375     case 0x3a:
! 3376       shift_flags ^= 0x40;
.4AB:
! Debug: eorab int = const $40 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$40
mov	-3[bp],al
!BCC_EOS
! 3377       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3378       mf2_flags |= 0x40;
! Debug: orab int = const $40 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$40
mov	-4[bp],al
!BCC_EOS
! 3379       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3380       break;
br 	.4A8
!BCC_EOS
! 3381     case 0xba:
! 3382       mf2_flags &= ~0x40;
.4AC:
! Debug: andab int = const -$41 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$BF
mov	-4[bp],al
!BCC_EOS
! 3383       
! 3383 write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3384       break;
br 	.4A8
!BCC_EOS
! 3385     case 0x2a:
! 3386       shift_flags |= 0x02;
.4AD:
! Debug: orab int = const 2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*2
mov	-3[bp],al
!BCC_EOS
! 3387       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3388       break;
br 	.4A8
!BCC_EOS
! 3389     case 0xaa:
! 3390       shift_flags &= ~0x02;
.4AE:
! Debug: andab int = const -3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FD
mov	-3[bp],al
!BCC_EOS
! 3391       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3392       break;
br 	.4A8
!BCC_EOS
! 3393     case 0x36:
! 3394       shift_flags |= 0x01;
.4AF:
! Debug: orab int = const 1 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*1
mov	-3[bp],al
!BCC_EOS
! 3395       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3396       break;
br 	.4A8
!BCC_EOS
! 3397     case 0xb6:
! 3398       shift_flags &= ~0x01;
.4B0:
! Debug: andab int = const -2 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FE
mov	-3[bp],al
!BCC_EOS
! 3399       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3400       break;
br 	.4A8
!BCC_EOS
! 3401     case 0x1d:
! 3402       if ((mf2_state & 0x01) == 0) {
.4B1:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4B2
.4B3:
! 3403         shift_flags |= 0x04;
! Debug: orab int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*4
mov	-3[bp],al
!BCC_EOS
! 3404         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3405         if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4B4
.4B5:
! 3406           mf2_state |= 0x04;
! Debug: orab int = const 4 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
mov	-5[bp],al
!BCC_EOS
! 3407           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3408         } else {
jmp .4B6
.4B4:
! 3409           mf2_flags |= 0x01;
! Debug: orab int = const 1 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*1
mov	-4[bp],al
!BCC_EOS
! 3410           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3411         }
! 3412       }
.4B6:
! 3413       break;
.4B2:
br 	.4A8
!BCC_EOS
! 3414     case 0x9d:
! 3415       if ((mf2_state & 0x01) == 0) {
.4B7:
! Debug: and int = const 1 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*1
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4B8
.4B9:
! 3416         shift_flags &= ~0x04;
! Debug: andab int = const -5 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$FB
mov	-3[bp],al
!BCC_EOS
! 3417         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3418         if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4BA
.4BB:
! 3419           mf2_state &= ~0x04;
! Debug: andab int = const -5 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
mov	-5[bp],al
!BCC_EOS
! 3420           write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3421         } else {
jmp .4BC
.4BA:
! 3422           mf2_flags &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FE
mov	-4[bp],al
!BCC_EOS
! 3423           write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3424         }
! 3425       }
.4BC:
! 3426       break;
.4B8:
br 	.4A8
!BCC_EOS
! 3427     case 0x38:
! 3428       shift_flags |= 0x08;
.4BD:
! Debug: orab int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
or	al,*8
mov	-3[bp],al
!BCC_EOS
! 3429       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3430       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4BE
.4BF:
! 3431         mf2_state |= 0x08;
! Debug: orab int = const 8 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*8
mov	-5[bp],al
!BCC_EOS
! 3432         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3433       } else {
jmp .4C0
.4BE:
! 3434         mf2_flags |= 0x02;
! Debug: orab int = const 2 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*2
mov	-4[bp],al
!BCC_EOS
! 3435         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3436       }
! 3437       break;
.4C0:
br 	.4A8
!BCC_EOS
! 3438     case 0xb8:
! 3439       shift_flags &= ~0x08;
.4C1:
! Debug: andab int = const -9 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,#$F7
mov	-3[bp],al
!BCC_EOS
! 3440       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3441       if (mf2_state & 0x02) {
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
test	al,al
je  	.4C2
.4C3:
! 3442         mf2_state &= ~0x08;
! Debug: andab int = const -9 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$F7
mov	-5[bp],al
!BCC_EOS
! 3443         write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3444       } else {
jmp .4C4
.4C2:
! 3445         mf2_flags &= ~0x02;
! Debug: andab int = const -3 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$FD
mov	-4[bp],al
!BCC_EOS
! 3446         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3447       }
! 3448       break;
.4C4:
br 	.4A8
!BCC_EOS
! 3449     case 0x45:
! 3450       if ((mf2_state & 0x03) == 0) {
.4C5:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4C6
.4C7:
! 3451         mf2_flags |= 0x20;
! Debug: orab int = const $20 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$20
mov	-4[bp],al
!BCC_EOS
! 3452         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3453         shift_flags ^= 0x20;
! Debug: eorab int = const $20 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$20
mov	-3[bp],al
!BCC_EOS
! 3454         write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3455       }
! 3456       break;
.4C6:
br 	.4A8
!BCC_EOS
! 3457     case 0xc5:
! 3458       if ((mf2_state & 0x03) == 0) {
.4C8:
! Debug: and int = const 3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*3
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.4C9
.4CA:
! 3459    
! 3459      mf2_flags &= ~0x20;
! Debug: andab int = const -$21 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$DF
mov	-4[bp],al
!BCC_EOS
! 3460         write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3461       }
! 3462       break;
.4C9:
br 	.4A8
!BCC_EOS
! 3463     case 0x46:
! 3464       mf2_flags |= 0x10;
.4CB:
! Debug: orab int = const $10 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
or	al,*$10
mov	-4[bp],al
!BCC_EOS
! 3465       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3466       shift_flags ^= 0x10;
! Debug: eorab int = const $10 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	al,*$10
mov	-3[bp],al
!BCC_EOS
! 3467       write_byte(0x0040, 0x17, shift_flags);
! Debug: list unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $17 (used reg = )
mov	ax,*$17
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3468       break;
br 	.4A8
!BCC_EOS
! 3469     case 0xc6:
! 3470       mf2_flags &= ~0x10;
.4CC:
! Debug: andab int = const -$11 to unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
and	al,#$EF
mov	-4[bp],al
!BCC_EOS
! 3471       write_byte(0x0040, 0x18, mf2_flags);
! Debug: list unsigned char mf2_flags = [S+8-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $18 (used reg = )
mov	ax,*$18
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3472       break;
br 	.4A8
!BCC_EOS
! 3473     case 0x53:
! 3474         if ((shift_flags & 0x0c) == 0x0c)
.4CD:
! Debug: and int = const $C to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*$C
! Debug: logeq int = const $C to unsigned char = al+0 (used reg = )
cmp	al,*$C
jne 	.4CE
.4CF:
! 3475             machine_reset();
! Debug: func () void = machine_reset+0 (used reg = )
call	_machine_reset
!BCC_EOS
! 3476     default:
.4CE:
! 3477       if (scancode & 0x80) {
.4D0:
! Debug: and int = const $80 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
test	al,al
je  	.4D1
.4D2:
! 3478         break;
br 	.4A8
!BCC_EOS
! 3479       }
! 3480       if (scancode > 0x58) {
.4D1:
! Debug: gt int = const $58 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$58
jbe 	.4D3
.4D4:
! 3481         ;
!BCC_EOS
! 3482         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3483       }
! 3484       if (shift_flags & 0x08) {
.4D3:
! Debug: and int = const 8 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*8
test	al,al
je  	.4D5
.4D6:
! 3485         asciicode = scan_to_scanascii[scancode].alt;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+6] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,6[bx]
mov	-2[bp],al
!BCC_EOS
! 3486         scancode = scan_to_scanascii[scancode].alt >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+6] (used reg = )
mov	ax,6[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3487       } else if (shift_flags & 0x04) {
br 	.4D7
.4D5:
! Debug: and int = const 4 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*4
test	al,al
je  	.4D8
.4D9:
! 3488         asciicode = scan_to_scanascii[scancode].control;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+4] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,4[bx]
mov	-2[bp],al
!BCC_EOS
! 3489         scancode = scan_to_scanascii[scancode].control >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+4] (used reg = )
mov	ax,4[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3490       } else if (((mf2_state & 0x02) > 0) && ((scancode >= 0x47) && (scancode <= 0x53))) {
br 	.4DA
.4D8:
! Debug: and int = const 2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,*2
! Debug: gt int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.4DB
.4DD:
! Debug: ge int = const $47 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$47
jb  	.4DB
.4DE:
! Debug: le int = const $53 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
cmp	al,*$53
ja  	.4DB
.4DC:
! 3491         asciicode = 0xe0;
! Debug: eq int = const $E0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,#$E0
mov	-2[bp],al
!BCC_EOS
! 3492         scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3493       } else if (shift_flags & 0x03) {
br 	.4DF
.4DB:
! Debug: and int = const 3 to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,*3
test	al,al
beq 	.4E0
.4E1:
! 3494         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4E2
.4E3:
! 3495           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3496           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3497         } else {
jmp .4E4
.4E2:
! 3498           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3499           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3500         }
! 3501       } else {
.4E4:
br 	.4E5
.4E0:
! 3502         if (shift_flags & scan_to_scanascii[scancode].lock_flags) {
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: and unsigned char = [bx+8] to unsigned char shift_flags = [S+8-5] (used reg = )
mov	al,-3[bp]
and	al,8[bx]
test	al,al
je  	.4E6
.4E7:
! 3503           asciicode = scan_to_scanascii[scancode].shift;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: eq unsigned short = [bx+2] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,2[bx]
mov	-2[bp],al
!BCC_EOS
! 3504           scancode = scan_to_scanascii[scancode].shift >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
add	bx,#_scan_to_scanascii
! Debug: sr int = const 8 to unsigned short = [bx+2] (used reg = )
mov	ax,2[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3505         } else {
jmp .4E8
.4E6:
! 3506           asciicode = scan_to_scanascii[scancode].normal;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: eq unsigned short = [bx+_scan_to_scanascii+0] to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,_scan_to_scanascii[bx]
mov	-2[bp],al
!BCC_EOS
! 3507           scancode = scan_to_scanascii[scancode].normal >> 8;
! Debug: ptradd unsigned char scancode = [S+8-3] to [$59] struct  = scan_to_scanascii+0 (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	dx,ax
shl	ax,*1
shl	ax,*1
add	ax,dx
shl	ax,*1
mov	bx,ax
! Debug: sr int = const 8 to unsigned short = [bx+_scan_to_scanascii+0] (used reg = )
mov	ax,_scan_to_scanascii[bx]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char scancode = [S+8-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 3508         }
! 3509       }
.4E8:
! 3510       if (scancode==0 && asciicode==0) {
.4E5:
.4DF:
.4DA:
.4D7:
! Debug: logeq int = const 0 to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.4E9
.4EB:
! Debug: logeq int = const 0 to unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
test	al,al
jne 	.4E9
.4EA:
! 3511         ;
!BCC_EOS
! 3512       }
! 3513       enqueue_key(scancode, asciicode);
.4E9:
! Debug: list unsigned char asciicode = [S+8-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char scancode = [S+$A-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned int = enqueue_key+0 (used reg = )
call	_enqueue_key
add	sp,*4
!BCC_EOS
! 3514       break;
jmp .4A8
!BCC_EOS
! 3515   }
! 3516   if ((scancode & 0x7f) != 0x1d) {
jmp .4A8
.4AA:
sub	al,*$1D
beq 	.4B1
sub	al,*$D
beq 	.4AD
sub	al,*$C
beq 	.4AF
sub	al,*2
beq 	.4BD
sub	al,*2
beq 	.4AB
sub	al,*$B
beq 	.4C5
sub	al,*1
beq 	.4CB
sub	al,*$D
beq 	.4CD
sub	al,*$4A
beq 	.4B7
sub	al,*$D
beq 	.4AE
sub	al,*$C
beq 	.4B0
sub	al,*2
beq 	.4C1
sub	al,*2
beq 	.4AC
sub	al,*$B
beq 	.4C8
sub	al,*1
beq 	.4CC
br 	.4D0
.4A8:
..FFF2	=	-8
! Debug: and int = const $7F to unsigned char scancode = [S+8-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: ne int = const $1D to unsigned char = al+0 (used reg = )
cmp	al,*$1D
je  	.4EC
.4ED:
! 3517     mf2_state &= ~0x01;
! Debug: andab int = const -2 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
mov	-5[bp],al
!BCC_EOS
! 3518   }
! 3519   mf2_state &= ~0x02;
.4EC:
! Debug: andab int = const -3 to unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FD
mov	-5[bp],al
!BCC_EOS
! 3520   write_byte(0x0040, 0x96, mf2_state);
! Debug: list unsigned char mf2_state = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $96 (used reg = )
mov	ax,#$96
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3521 }
mov	sp,bp
pop	bp
ret
! 3522   unsigned int
! Register BX used in function int09_function
! 3523 enqueue_key(scan_
! 3523 code, ascii_code)
! 3524   Bit8u scan_code, ascii_code;
export	_enqueue_key
_enqueue_key:
!BCC_EOS
! 3525 {
! 3526   Bit16u buffer_start, buffer_end, buffer_head, buffer_tail, temp_tail;
!BCC_EOS
! 3527   buffer_start = read_word(0x0040, 0x0080);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_start = [S+$C-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3528   buffer_end = read_word(0x0040, 0x0082);
! Debug: list int = const $82 (used reg = )
mov	ax,#$82
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_end = [S+$C-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 3529   buffer_head = read_word(0x0040, 0x001A);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_head = [S+$C-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 3530   buffer_tail = read_word(0x0040, 0x001C);
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 3531   temp_tail = buffer_tail;
! Debug: eq unsigned short buffer_tail = [S+$C-$A] to unsigned short temp_tail = [S+$C-$C] (used reg = )
mov	ax,-8[bp]
mov	-$A[bp],ax
!BCC_EOS
! 3532   buffer_tail += 2;
! Debug: addab int = const 2 to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
inc	ax
inc	ax
mov	-8[bp],ax
!BCC_EOS
! 3533   if (buffer_tail >= buffer_end)
! Debug: ge unsigned short buffer_end = [S+$C-6] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-4[bp]
jb  	.4EE
.4EF:
! 3534     buffer_tail = buffer_start;
! Debug: eq unsigned short buffer_start = [S+$C-4] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-2[bp]
mov	-8[bp],ax
!BCC_EOS
! 3535   if (buffer_tail == buffer_head) {
.4EE:
! Debug: logeq unsigned short buffer_head = [S+$C-8] to unsigned short buffer_tail = [S+$C-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-6[bp]
jne 	.4F0
.4F1:
! 3536     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3537     }
! 3538    write_byte(0x0040, temp_tail, ascii_code);
.4F0:
! Debug: list unsigned char ascii_code = [S+$C+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short temp_tail = [S+$E-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3539    write_byte(0x0040, temp_tail+1, scan_code);
! Debug: list unsigned char scan_code = [S+$C+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short temp_tail = [S+$E-$C] (used reg = )
mov	ax,-$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3540    write_word(0x0040, 0x001C, buffer_tail);
! Debug: list unsigned short buffer_tail = [S+$C-$A] (used reg = )
push	-8[bp]
! Debug: list int = const $1C (used reg = )
mov	ax,*$1C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3541    return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3542 }
! 3543   void
! 3544 int74_function(make_farcall, Z, Y, X, status)
! 3545   Bit16u make_farcall, Z, Y, X, status;
export	_int74_function
_int74_function:
!BCC_EOS
! 3546 {
! 3547   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3548   Bit8u in_byte, index, package_count;
!BCC_EOS
! 3549   Bit8u mouse_flags_1, mouse_flags_2;
!BCC_EOS
! 3550 ;
add	sp,*-6
!BCC_EOS
! 3551   make_farcall = 0;
! Debug: eq int = const 0 to unsigned short make_farcall = [S+$A+2] (used reg = )
xor	ax,ax
mov	4[bp],ax
!BCC_EOS
! 3552   in_byte = inb(0x64);
! Debug: list int = const $64 (used reg = )
mov	ax,*$64
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3553   if ( (in_byte & 0x21) != 0x21 ) {
! Debug: and int = const $21 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
and	al,*$21
! Debug: ne int = const $21 to unsigned char = al+0 (used reg = )
cmp	al,*$21
je  	.4F2
.4F3:
! 3554     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3555     }
! 3556   in_byte = inb(0x60);
.4F2:
! Debug: list int = const $60 (used reg = )
mov	ax,*$60
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char in_byte = [S+$A-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3557 ;
!BCC_EOS
! 3558   mouse_flags_1 = read_byte(ebda_seg, 0x0026);
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	-6[bp],al
!BCC_EOS
! 3559   mouse_flags_2 = read_byte(ebda_seg, 0x0027);
! Debug: list int = const $27 (used reg = )
mov	ax,*$27
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	-7[bp],al
!BCC_EOS
! 3560   if ( (mouse_flags_2 & 0x80) != 0x80 ) {
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
je  	.4F4
.4F5:
! 3561       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3562   }
! 3563   package_count = mouse_flags_2 & 0x07;
.4F4:
! Debug: and int = const 7 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char package_count = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3564   index = mouse_flags_1 & 0x07;
! Debug: and int = const 7 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
and	al,*7
! Debug: eq unsigned char = al+0 to unsigned char index = [S+$A-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3565   write_byte(ebda_seg, 0x28 + index, in_byte);
! Debug: list unsigned char in_byte = [S+$A-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char index = [S+$C-6] to int = const $28 (used reg = )
! Debug: expression subtree swapping
mov	al,-4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3566   if ( (index+1) >= package_count ) {
! Debug: add int = const 1 to unsigned char index = [S+$A-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
! Debug: ge unsigned char package_count = [S+$A-7] to unsigned int = ax+1 (used reg = )
inc	ax
push	ax
mov	al,-5[bp]
xor	ah,ah
cmp	ax,-$A[bp]
lea	sp,-8[bp]
ja  	.4F6
.4F7:
! 3567 ;
!BCC_EOS
! 3568     status = read_byte(ebda_seg, 0x0028 + 0);
! Debug: list int = const $28 (used reg = )
mov	ax,*$28
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short status = [S+$A+$A] (used reg = )
xor	ah,ah
mov	$C[bp],ax
!BCC_EOS
! 3569     X = read_byte(ebda_seg, 0x0028 + 1);
! Debug: list int = const $29 (used reg = )
mov	ax,*$29
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short X = [S+$A+8] (used reg = )
xor	ah,ah
mov	$A[bp],ax
!BCC_EOS
! 3570     Y = read_byte(ebda_seg, 0x0028 + 2);
! Debug: list int = const $2A (used reg = )
mov	ax,*$2A
push	ax
! Debug: list unsigned short ebda_seg = [S+$C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short Y = [S+$A+6] (used reg = )
xor	ah,ah
mov	8[bp],ax
!BCC_EOS
! 3571     Z = 0;
! Debug: eq int = const 0 to unsigned short Z = [S+$A+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 3572     mouse_flags_1 = 0;
! Debug: eq int = const 0 to unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 3573     if (mouse_flags_2 & 0x80)
! Debug: and int = const $80 to unsigned char mouse_flags_2 = [S+$A-9] (used reg = )
mov	al,-7[bp]
and	al,#$80
test	al,al
je  	.4F8
.4F9:
! 3574       make_farcall = 1;
! Debug: eq int = const 1 to unsigned short make_farcall = [S+$A+2] (used reg = )
mov	ax,*1
mov	4[bp],ax
!BCC_EOS
! 3575     }
.4F8:
! 3576   else {
jmp .4FA
.4F6:
! 3577     mouse_flags_1++;
! Debug: postinc unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
inc	ax
mov	-6[bp],al
!BCC_EOS
! 3578     }
! 3579   write_byte(ebda_seg, 0x0026, mouse_flags_1);
.4FA:
! Debug: list unsigned char mouse_flags_1 = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $26 (used reg = )
mov	ax,*$26
push	ax
! Debug: list unsigned short ebda_seg = [S+$E-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3580 }
mov	sp,bp
pop	bp
ret
! 3581   void
! 3582 int13_harddisk(EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3583   Bit16u EHAX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_harddisk
_int13_harddisk:
!BCC_EOS
! 3584 {
! 3585   Bit32u lba_low, lba_high;
!BCC_EOS
! 3586   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
add	sp,*-$A
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+$C-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 3587   Bit16u cylinder, head, sector;
!BCC_EOS
! 3588   Bit16u segment, offset;
!BCC_EOS
! 3589   Bit16u npc, nph, npspt, nlc, nlh, nlspt;
!BCC_EOS
! 3590   Bit16u size, count;
!BCC_EOS
! 3591   Bit8u device, status;
!BCC_EOS
! 3592   ;
add	sp,*-$1C
!BCC_EOS
! 3593   write_byte(0x0040, 0x008e, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $8E (used reg = )
mov	ax,#$8E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3594   if ( (( ELDX & 0x00ff ) < 0x80) || (( ELDX & 0x00ff )
! 3594  >= 0x80 + (4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jb  	.4FC
.4FD:
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $88 to unsigned char = al+0 (used reg = )
cmp	al,#$88
jb  	.4FB
.4FC:
! 3595     ;
!BCC_EOS
! 3596     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3597     }
! 3598   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.hdidmap[( ELDX & 0x00ff )-0x80]);
.4FB:
! Debug: and int = const $FF to unsigned short ELDX = [S+$28+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $80 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$80 to [8] unsigned char = const $233 (used reg = )
add	ax,*-$80
mov	bx,ax
! Debug: address unsigned char = [bx+$233] (used reg = )
! Debug: list * unsigned char = bx+$233 (used reg = )
add	bx,#$233
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$28-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 3599   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
cmp	al,*8
jb  	.4FE
.4FF:
! 3600     ;
!BCC_EOS
! 3601     goto int13_fail;
add	sp,#..FFF1+$28
br 	.FFF1
!BCC_EOS
! 3602     }
! 3603   switch (( AX >> 8 )) {
.4FE:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.502
! 3604     case 0x00:
! 3605       ata_reset (device);
.503:
! Debug: list unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () void = ata_reset+0 (used reg = )
call	_ata_reset
inc	sp
inc	sp
!BCC_EOS
! 3606       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3607       break;
br 	.500
!BCC_EOS
! 3608     case 0x01:
! 3609       status = read_byte(0x0040, 0x0074);
.504:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3610       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$2A+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3611       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3612       if (status) goto int13_fail_nostatus;
mov	al,-$26[bp]
test	al,al
je  	.505
.506:
add	sp,#..FFEE-..FFF0
br 	.FFEE
!BCC_EOS
! 3613       else goto int13_success_noah;
jmp .507
.505:
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3614       break;
.507:
br 	.500
!BCC_EOS
! 3615     case 0x02:
! 3616     case 0x03:
.508:
! 3617     case 0x04:
.509:
! 3618       count = ( AX & 0x00ff );
.50A:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3619       cylinder = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 3620       cylinder |= ( ((Bit16u) ( CX & 0x00ff )) << 2) & 0x300;
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: cast unsigned short = const 0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: sl int = const 2 to unsigned short = ax+0 (used reg = )
shl	ax,*1
shl	ax,*1
! Debug: and int = const $300 to unsigned int = ax+0 (used reg = )
and	ax,#$300
! Debug: orab unsigned int = ax+0 to unsigned short cylinder = [S+$28-$E] (used reg = )
or	ax,-$C[bp]
mov	-$C[bp],ax
!BCC_EOS
! 3621       sector = (( CX & 0x00ff ) & 0x3f);
! Debug: and int = const $FF to unsigned short CX = [S+$28+$14] (used reg = )
mov	al,$16[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ah,ah
mov	-$10[bp],ax
!BCC_EOS
! 3622       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$28-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 3623       segment = ES;
! Debug: eq unsigned short ES = [S+$28+6] to unsigned short segment = [S+$28-$14] (used reg = )
mov	ax,8[bp]
mov	-$12[bp],ax
!BCC_EOS
! 3624       offset = BX;
! Debug: eq unsigned short BX = [S+$28+$10] to unsigned short offset = [S+$28-$16] (used reg = )
mov	ax,$12[bp]
mov	-$14[bp],ax
!BCC_EOS
! 3625       if ((count > 128) || (count == 0) || (sector == 0)) {
! Debug: gt int = const $80 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
cmp	ax,#$80
ja  	.50C
.50E:
! Debug: logeq int = const 0 to unsigned short count = [S+$28-$26] (used reg = )
mov	ax,-$24[bp]
test	ax,ax
je  	.50C
.50D:
! Debug: logeq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
test	ax,ax
jne 	.50B
.50C:
! 3626         ;
!BCC_EOS
! 3627         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3628       }
! 3629       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.50B:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3630       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3631       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3632       if( (cylinder >= nlc) || (head >= nlh) || (sector > nlspt )) {
! Debug: ge unsigned short nlc = [S+$28-$1E] to unsigned short cylinder = [S+$28-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-$1C[bp]
jae 	.510
.512:
! Debug: ge unsigned short nlh = [S+$28-$20] to unsigned short head = [S+$28-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-$1E[bp]
jae 	.510
.511:
! Debug: gt unsigned short nlspt = [S+$28-$22] to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$20[bp]
jbe 	.50F
.510:
! 3633         ;
!BCC_EOS
! 3634         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3635         }
! 3636       if ( ( AX >> 8 ) == 0x04 ) goto int13_success;
.50F:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.513
.514:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3637       nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
.513:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$28-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3638       npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3639       if ( (nph != nlh) || (npspt != nlspt)) {
! Debug: ne unsigned short nlh = [S+$28-$20] to unsigned short nph = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
cmp	ax,-$1E[bp]
jne 	.516
.517:
! Debug: ne unsigned short nlspt = [S+$28-$22] to unsigned short npspt = [S+$28-$1C] (used reg = )
mov	ax,-$1A[bp]
cmp	ax,-$20[bp]
je  	.515
.516:
! 3640         lba_low = ((((Bit32u)cylinder * (Bit32u)nlh) + (Bit32u)head) * (Bit32u)nlspt) + (Bit32u)sector - 1;
! Debug: cast unsigned long = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$2C-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$30-$10] (used reg = )
mov	ax,-$E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$34-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$38-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$38-$38] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$34-$34] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	laddul
add	sp,*4
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lsubul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3641         lba_high = 0;
! Debug: eq int = const 0 to unsigned long lba_high = [S+$28-$A] (used reg = )
xor	ax,ax
xor	bx,bx
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3642         sector = 0;
! Debug: eq int = const 0 to unsigned short sector = [S+$28-$12] (used reg = )
xor	ax,ax
mov	-$10[bp],ax
!BCC_EOS
! 3643         }
! 3644       if ( ( AX >> 8 ) == 0x02 )
.515:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 2 to unsigned int = ax+0 (used reg = )
cmp	ax,*2
jne 	.518
.519:
! 3645         status=ata_cmd_data_in(device, 0x20, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3646       else
! 3647         status=ata_cmd_data_out(device, 0x30, count, cylinder, head, sector, lba_low, lba_high, segment, offset);
jmp .51A
.518:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list unsigned short sector = [S+$34-$12] (used reg = )
push	-$10[bp]
! Debug: list unsigned short head = [S+$36-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short cylinder = [S+$38-$E] (used reg = )
push	-$C[bp]
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3648       AX = ((AX & 0xff00) | (read_word(ebda_seg,
.51A:
! 3648  &((ebda_data_t *) 0)->ata.trsfsectors)));
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$2A+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or unsigned short (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3649       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.51B
.51C:
! 3650         ;
!BCC_EOS
! 3651         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3652         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3653         }
! 3654       goto int13_success;
.51B:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3655       break;
br 	.500
!BCC_EOS
! 3656     case 0x05:
! 3657       ;
.51D:
!BCC_EOS
! 3658       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3659       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3660       break;
br 	.500
!BCC_EOS
! 3661     case 0x08:
! 3662       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.51E:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3663       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3664       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3665       count = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.hdcount);
! Debug: list * unsigned char = const $232 (used reg = )
mov	ax,#$232
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned short count = [S+$28-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 3666       nlc = nlc - 2;
! Debug: sub int = const 2 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: eq unsigned int = ax-2 to unsigned short nlc = [S+$28-$1E] (used reg = )
dec	ax
dec	ax
mov	-$1C[bp],ax
!BCC_EOS
! 3667       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3668       CX = ((CX & 0x00ff) | ((nlc & 0xff) << 8));
! Debug: and int = const $FF to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	al,-$1C[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$2A+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3669       CX = ((CX & 0xff00) | (((nlc >> 2) & 0xc0) | (nlspt & 0x3f)));
! Debug: and int = const $3F to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	al,-$20[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short nlc = [S+$2A-$1E] (used reg = )
mov	ax,-$1C[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$2A+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$2A-$2A] to unsigned int = ax+0 (used reg = )
or	al,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3670       DX = ((DX & 0x00ff) | ((nlh - 1) << 8));
! Debug: sub int = const 1 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	ax,-$1E[bp]
! Debug: sl int = const 8 to unsigned int = ax-1 (used reg = )
dec	ax
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$2A+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$2A-$2A] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFF0[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3671       DX = ((DX & 0xff00) | (count));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$28+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned short count = [S+$28-$26] to unsigned int = ax+0 (used reg = )
or	ax,-$24[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3672       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3673       break;
br 	.500
!BCC_EOS
! 3674     case 0x10:
! 3675       status = inb(read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[device/2].iobase1) + 7);
.51F:
! Debug: div int = const 2 to unsigned char device = [S+$28-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: ptradd unsigned int = ax+0 to [4] struct  = const $122 (used reg = )
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: add int = const 7 to unsigned short = ax+0 (used reg = )
! Debug: list unsigned int = ax+7 (used reg = )
add	ax,*7
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3676       if ( (status & ( 0x80 | 0x40 )) == 0x40 ) {
! Debug: and int = const $C0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
and	al,#$C0
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.520
.521:
! 3677         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3678         }
! 3679       else {
jmp .522
.520:
! 3680         AX = ((AX & 0x00ff) | ((0xAA) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3681         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3682         }
! 3683       break;
.522:
br 	.500
!BCC_EOS
! 3684     case 0x15:
! 3685       nlc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.cylinders);
.523:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14E] (used reg = )
! Debug: list * unsigned short = bx+$14E (used reg = )
add	bx,#$14E
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlc = [S+$28-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3686       nlh = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.heads);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$14C] (used reg = )
! Debug: list * unsigned short = bx+$14C (used reg = )
add	bx,#$14C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlh = [S+$28-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 3687       nlspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lchs.spt);
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$150] (used reg = )
! Debug: list * unsigned short = bx+$150 (used reg = )
add	bx,#$150
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 3688       lba_low = (Bit32u)(nlc - 1) * (Bit32u)nlh * (Bit32u)nlspt;
! Debug: cast unsigned long = const 0 to unsigned short nlspt = [S+$28-$22] (used reg = )
mov	ax,-$20[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nlh = [S+$2C-$20] (used reg = )
mov	ax,-$1E[bp]
xor	bx,bx
push	bx
push	ax
! Debug: sub int = const 1 to unsigned short nlc = [S+$30-$1E] (used reg = )
mov	ax,-$1C[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$30-$30] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$2C-$2C] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	lmulul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3689       CX = lba_low >> 16;
! Debug: sr int = const $10 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	ax,-4[bp]
mov	bx,-2[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short CX = [S+$28+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 3690       DX = lba_low & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long lba_low = [S+$28-6] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-4[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short DX = [S+$28+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 3691       AX = ((AX & 0x00ff) | ((3) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3692       goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3693       break;
br 	.500
!BCC_EOS
! 3694     case 0x41:
! 3695       BX=0xaa55;
.524:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$28+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3696       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3697       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$28+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3698       goto int13_success_noah;
add	sp,#..FFED-..FFF0
br 	.FFED
!BCC_EOS
! 3699       break;
br 	.500
!BCC_EOS
! 3700     case 0x42:
! 3701     case 0x43:
.525:
! 3702     case 0x44:
.526:
! 3703     case 0x47:
.527:
! 3704       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.528:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3705       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)-
! 3705 >segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$28-$14] (used reg = )
mov	-$12[bp],ax
!BCC_EOS
! 3706       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$28-$16] (used reg = )
mov	-$14[bp],ax
!BCC_EOS
! 3707       lba_high=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3708       if (lba_high > read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: gt unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
lea	di,-8[bp]
call	lcmpul
jae 	.529
.52A:
! 3709         ;
!BCC_EOS
! 3710         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3711         }
! 3712       lba_low=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.529:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3713       if (lba_high == read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high)
! 3714           && lba_low >= read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low) ) {
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: logeq unsigned long = bx+0 to unsigned long lba_high = [S+$28-$A] (used reg = )
! Debug: expression subtree swapping
lea	di,-8[bp]
call	lcmpul
jne 	.52B
.52D:
! Debug: ptradd unsigned char device = [S+$28-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: ge unsigned long = bx+0 to unsigned long lba_low = [S+$28-6] (used reg = )
lea	di,-4[bp]
call	lcmpul
ja  	.52B
.52C:
! 3715         ;
!BCC_EOS
! 3716         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3717         }
! 3718       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
.52B:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.52F
.530:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.52E
.52F:
! 3719         goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3720       if ( ( AX >> 8 ) == 0x42 )
.52E:
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $42 to unsigned int = ax+0 (used reg = )
cmp	ax,*$42
jne 	.531
.532:
! 3721         status=ata_cmd_data_in(device, 0x20, count, 0, 0, 0, lba_low, lba_high, segment, offset);
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_in+0 (used reg = )
call	_ata_cmd_data_in
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3722       else
! 3723         status=ata_cmd_data_out(device, 0x30, count, 0, 0, 0, lba_low, lba_high, segment, offset);
jmp .533
.531:
! Debug: list unsigned short offset = [S+$28-$16] (used reg = )
push	-$14[bp]
! Debug: list unsigned short segment = [S+$2A-$14] (used reg = )
push	-$12[bp]
! Debug: list unsigned long lba_high = [S+$2C-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: list unsigned long lba_low = [S+$30-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short count = [S+$3A-$26] (used reg = )
push	-$24[bp]
! Debug: list int = const $30 (used reg = )
mov	ax,*$30
push	ax
! Debug: list unsigned char device = [S+$3E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_data_out+0 (used reg = )
call	_ata_cmd_data_out
add	sp,*$18
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$28-$28] (used reg = )
mov	-$26[bp],al
!BCC_EOS
! 3724       count=read_word(ebda_seg, &((ebda_data_t *) 0)->ata.trsfsectors);
.533:
! Debug: list * unsigned short = const $254 (used reg = )
mov	ax,#$254
push	ax
! Debug: list unsigned short ebda_seg = [S+$2A-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$28-$26] (used reg = )
mov	-$24[bp],ax
!BCC_EOS
! 3725       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$28-$26] (used reg = )
push	-$24[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3726       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$28-$28] (used reg = )
mov	al,-$26[bp]
test	al,al
je  	.534
.535:
! 3727         ;
!BCC_EOS
! 3728         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3729         goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3730         }
! 3731       goto int13_success;
.534:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3732       break;
br 	.500
!BCC_EOS
! 3733     case 0x45:
! 3734     case 0x49:
.536:
! 3735       goto int13_success;
.537:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3736       break;
br 	.500
!BCC_EOS
! 3737     case 0x46:
! 3738       AX = ((AX & 0x00ff) | ((0xb2) << 8));
.538:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4E00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4E00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3739       goto int13_fail_noah;
add	sp,#..FFEC-..FFF0
br 	.FFEC
!BCC_EOS
! 3740       break;
br 	.500
!BCC_EOS
! 3741     case 0x48:
! 3742       size=read_word(DS,SI+(Bit16u)&((dpt_t *) 0)->size);
.539:
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$28-$24] (used reg = )
mov	-$22[bp],ax
!BCC_EOS
! 3743       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
jae 	.53A
.53B:
! 3744         goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3745       if(size >= 0x1a) {
.53A:
! Debug: ge int = const $1A to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1A
blo 	.53C
.53D:
! 3746         Bit16u blksize;
!BCC_EOS
! 3747         npc = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.cylinders);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$154] (used reg = )
! Debug: list * unsigned short = bx+$154 (used reg = )
add	bx,#$154
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	-$16[bp],ax
!BCC_EOS
! 3748         nph = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.heads);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$152] (used reg = )
! Debug: list * unsigned short = bx+$152 (used reg = )
add	bx,#$152
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3749         npspt = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].pchs.spt);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$156] (used reg = )
! Debug: list * unsigned short = bx+$156 (used reg = )
add	bx,#$156
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3750         lba_low = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_low);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$158] (used reg = )
! Debug: list * unsigned long = bx+$158 (used reg = )
add	bx,#$158
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_low = [S+$2A-6] (used reg = )
mov	-4[bp],ax
mov	-2[bp],bx
!BCC_EOS
! 3751         lba_high = read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].sectors_high);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned long = [bx+$15C] (used reg = )
! Debug: list * unsigned long = bx+$15C (used reg = )
add	bx,#$15C
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba_high = [S+$2A-$A] (used reg = )
mov	-8[bp],ax
mov	-6[bp],bx
!BCC_EOS
! 3752      
! 3752    blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 3753         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3754         if (lba_high || (lba_low/npspt)/nph > 0x3fff)
mov	ax,-8[bp]
mov	bx,-6[bp]
call	ltstl
jne 	.53F
.540:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2E-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: div unsigned long = bx+0 to unsigned long lba_low = [S+$2E-6] (used reg = )
push	bx
push	ax
mov	ax,-4[bp]
mov	bx,-2[bp]
lea	di,-6+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: div unsigned long (temp) = [S+$2E-$2E] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFF0[bp]
call	ldivul
add	sp,*4
! Debug: gt unsigned long = const $3FFF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$3FFF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFF0[bp]
mov	bx,0+..FFF0[bp]
lea	di,-6+..FFF0[bp]
call	lcmpul
jbe	.541
mov	al,*1
jmp	.542
.541:
xor	al,al
.542:
add	sp,*8
! Debug: cast unsigned long = const 0 to char = al+0 (used reg = )
xor	ah,ah
cwd
mov	bx,dx
call	ltstl
je  	.53E
.53F:
! 3755         {
! 3756           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3757           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0x3fff);
! Debug: list int = const $3FFF (used reg = )
mov	ax,#$3FFF
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*6
!BCC_EOS
! 3758         }
! 3759         else
! 3760         {
jmp .544
.53E:
! 3761           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3762           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, (Bit32u)npc);
! Debug: cast unsigned long = const 0 to unsigned short npc = [S+$2A-$18] (used reg = )
mov	ax,-$16[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3763         }
! 3764         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, (Bit32u)nph);
.544:
! Debug: cast unsigned long = const 0 to unsigned short nph = [S+$2A-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3765         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, (Bit32u)npspt);
! Debug: cast unsigned long = const 0 to unsigned short npspt = [S+$2A-$1C] (used reg = )
mov	ax,-$1A[bp]
xor	bx,bx
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3766         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, lba_low);
! Debug: list unsigned long lba_low = [S+$2A-6] (used reg = )
push	-2[bp]
push	-4[bp]
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3767         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, lba_high);
! Debug: list unsigned long lba_high = [S+$2A-$A] (used reg = )
push	-6[bp]
push	-8[bp]
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3768         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3769         }
! 3770       if(size >= 0x1e) {
.53C:
! Debug: ge int = const $1E to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$1E
blo 	.545
.546:
! 3771         Bit8u channel, dev, irq, mode, checksum, i, translation;
!BCC_EOS
! 3772         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 3773         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3774         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$36-$C] (used reg = )
push	-$A[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3775         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$38+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$3A+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3776         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$36-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3777         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$36-$32] (used reg = )
mov	-$30[bp],ax
!BCC_EOS
! 3778         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	-$32[bp],ax
!BCC_EOS
! 3779         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$36-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$36-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3780         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	-$2A[bp],al
!BCC_EOS
! 3781         translation = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].translation);
! Debug: ptradd unsigned char device = [S+$36-$27] to [8] struct  = const $142 (used reg = )
mov	al,-$25[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$14A] (used reg = )
! Debug: list * unsigned char = bx+$14A (used reg = )
add	bx,#$14A
push	bx
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 3782         options = (translation==0?0:1)<<3;
! Debug: logeq int = const 0 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
test	al,al
jne 	.547
.548:
xor	al,al
jmp .549
.547:
mov	al,*1
.549:
! Debug: sl int = const 3 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*3
shl	ax,cl
! Debug: eq int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
mov	-$34[bp],ax
!BCC_EOS
! 3783         options |= (1<<4);
! Debug: orab int = const $10 to unsigned short options = [S+$36-$36] (used reg = )
mov	ax,-$34[bp]
or	al,*$10
mov	-$34[bp],ax
!BCC_EOS
! 3784         options |= (mode==0x01?1:0)<<7;
! Debug: logeq int = const 1 to unsigned char mode = [S+$36-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*1
jne 	.54A
.54B:
mov	al,*1
jmp .54C
.54A:
xor	al,al
.54C:
! Debug: sl int = const 7 to char = al+0 (used reg = )
xor	ah,ah
mov	cl,*7
shl	ax,cl
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3785         options |= (translation==1?1:0)<<9;
! Debug: logeq int = const 1 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*1
jne 	.54D
.54E:
mov	al,*1
jmp .54F
.54D:
xor	al,al
.54F:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3786         options |= (translation==3?3:0)<<9;
! Debug: logeq int = const 3 to unsigned char translation = [S+$36-$2F] (used reg = )
mov	al,-$2D[bp]
cmp	al,*3
jne 	.550
.551:
mov	al,*3
jmp .552
.550:
xor	al,al
.552:
! Debug: sl int = const 9 to char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
shl	ax,*1
! Debug: orab int = ax+0 to unsigned short options = [S+$36-$36] (used reg = )
or	ax,-$34[bp]
mov	-$34[bp],ax
!BCC_EOS
! 3787         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$36-$32] (used reg = )
push	-$30[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3788         wri
! 3788 te_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$36-$34] (used reg = )
mov	ax,-$32[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3789         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.prefix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$36-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3790         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3791         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$36-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3792         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3793         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3794         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3795         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
! Debug: list unsigned short options = [S+$36-$36] (used reg = )
push	-$34[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3796         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3797         if (size >=0x42)
! Debug: ge int = const $42 to unsigned short size = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
jb  	.553
.554:
! 3798           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3799         else
! 3800           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x10);
jmp .555
.553:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3801         checksum=0;
.555:
! Debug: eq int = const 0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	al,al
mov	-$2B[bp],al
!BCC_EOS
! 3802         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$36-$2E] (used reg = )
xor	al,al
mov	-$2C[bp],al
!BCC_EOS
!BCC_EOS
jmp .558
.559:
! Debug: ptradd unsigned char i = [S+$36-$2E] to * unsigned char = const $244 (used reg = )
mov	al,-$2C[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
xor	ah,ah
add	al,-$2B[bp]
adc	ah,*0
mov	-$2B[bp],al
!BCC_EOS
! 3803         checksum = ~checksum;
.557:
! Debug: postinc unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
inc	ax
mov	-$2C[bp],al
.558:
! Debug: lt int = const $F to unsigned char i = [S+$36-$2E] (used reg = )
mov	al,-$2C[bp]
cmp	al,*$F
jb 	.559
.55A:
.556:
! Debug: not unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$36-$2D] (used reg = )
mov	-$2B[bp],al
!BCC_EOS
! 3804         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$36-$2D] (used reg = )
mov	al,-$2B[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$3A-$C] (used reg = )
push	-$A[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3805         }
! 3806       if(size >= 0x42) {
.545:
! Debug: ge int = const $42 to unsigned short size = [S+$28-$24] (used reg = )
mov	ax,-$22[bp]
cmp	ax,*$42
blo 	.55B
.55C:
! 3807         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 3808         Bit16u iobase1;
!BCC_EOS
! 3809         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$29] (used reg = )
mov	-$27[bp],al
!BCC_EOS
! 3810         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	-$28[bp],al
!BCC_EOS
! 3811         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$29] to [4] struct  = const $122 (used reg = )
mov	al,-$27[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-$C] (used reg = )
push	-$A[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2E] (used reg = )
mov	-$2C[bp],ax
!BCC_EOS
! 3812         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3813         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3814         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3815         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3816         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3817         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.55D
.55E:
! 3818           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3819           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3820           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3821           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->
! 3821 host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3822           }
! 3823         else {
jmp .55F
.55D:
! 3824           }
! 3825         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.55F:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3826         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3827         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3828         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3829         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$2E-$2A] (used reg = )
mov	al,-$28[bp]
test	al,al
jne 	.560
.561:
! 3830           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3831           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3832           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3833           }
! 3834         else {
jmp .562
.560:
! 3835           }
! 3836         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.562:
! Debug: mod int = const 2 to unsigned char device = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3837         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3838         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3839         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$32+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$34+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 3840         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	al,al
mov	-$29[bp],al
!BCC_EOS
! 3841         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,*$1E
mov	-$2A[bp],al
!BCC_EOS
!BCC_EOS
jmp .565
.566:
! Debug: add unsigned char i = [S+$2E-$2C] to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$2A[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
xor	ah,ah
add	al,-$29[bp]
adc	ah,*0
mov	-$29[bp],al
!BCC_EOS
! 3842         checksum = ~checksum;
.564:
! Debug: postinc unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
inc	ax
mov	-$2A[bp],al
.565:
! Debug: lt int = const $40 to unsigned char i = [S+$2E-$2C] (used reg = )
mov	al,-$2A[bp]
cmp	al,*$40
jb 	.566
.567:
.563:
! Debug: not unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	-$29[bp],al
!BCC_EOS
! 3843         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$2B] (used reg = )
mov	al,-$29[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3844         }
! 3845       goto int13_success;
.55B:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3846       break;
br 	.500
!BCC_EOS
! 3847     case 0x4e:
! 3848       switch (( AX & 0x00ff )) {
.568:
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
jmp .56B
! 3849         case 0x01:
! 3850         case 0x03:
.56C:
! 3851         case 0x04:
.56D:
! 3852         case 0x06:
.56E:
! 3853           goto int13_success;
.56F:
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3854           break;
jmp .569
!BCC_EOS
! 3855         default :
! 3856           goto int13_fail;
.570:
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3857         }
! 3858       break;
jmp .569
.56B:
sub	al,*1
je 	.56C
sub	al,*2
je 	.56D
sub	al,*1
je 	.56E
sub	al,*2
je 	.56F
jmp	.570
.569:
br 	.500
!BCC_EOS
! 3859     case 0x09:
! 3860     case 0x0c:
.571:
! 3861     case 0x0d:
.572:
! 3862     case 0x11:
.573:
! 3863     case 0x14:
.574:
! 3864       ;
.575:
!BCC_EOS
! 3865       goto int13_success;
add	sp,#..FFEF-..FFF0
br 	.FFEF
!BCC_EOS
! 3866       break;
br 	.500
!BCC_EOS
! 3867     case 0x0a:
! 3868     case 0x0b:
.576:
! 3869     case 0x18:
.577:
! 3870     case 0x50:
.578:
! 3871     default:
.579:
! 3872       ;
.57A:
!BCC_EOS
! 3873       goto int13_fail;
add	sp,#..FFF1-..FFF0
br 	.FFF1
!BCC_EOS
! 3874       break;
br 	.500
!BCC_EOS
! 3875     }
! 3876 int13_fail:
jmp .500
.502:
add	sp,*-$E
sub	ax,*0
jl 	.57A
cmp	ax,*$18
ja  	.57B
shl	ax,*1
mov	bx,ax
seg	cs
br	.57C[bx]
.57C:
.word	.503
.word	.504
.word	.508
.word	.509
.word	.50A
.word	.51D
.word	.57A
.word	.57A
.word	.51E
.word	.571
.word	.576
.word	.577
.word	.572
.word	.573
.word	.57A
.word	.57A
.word	.51F
.word	.574
.word	.57A
.word	.57A
.word	.575
.word	.523
.word	.57A
.word	.57A
.word	.578
.57B:
sub	ax,*$41
jb 	.57A
cmp	ax,*$F
ja  	.57D
shl	ax,*1
mov	bx,ax
seg	cs
br	.57E[bx]
.57E:
.word	.524
.word	.525
.word	.526
.word	.527
.word	.536
.word	.538
.word	.528
.word	.539
.word	.537
.word	.57A
.word	.57A
.word	.57A
.word	.57A
.word	.568
.word	.57A
.word	.579
.57D:
br 	.57A
.500:
..FFF0	=	-$36
add	sp,*$E
.FFF1:
..FFF1	=	-$28
! 3877     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$28+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3878 int13_fail_noah:
.FFEC:
..FFEC	=	-$28
! 3879     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$28+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3880 int13_fail_nostatus:
.FFEE:
..FFEE	=	-$28
! 3881     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 3882     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3883 int13_success:
.FFEF:
..FFEF	=	-$28
! 3884     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$28+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$28+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 3885 int13_success_noah:
.FFED:
..FFED	=	-$28
! 3886     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3887     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$28+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 3888     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 3889 }
! 3890   void
! Register BX used in function int13_harddisk
! 3891 int13_cdrom(EHBX, DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 3892   Bit16u EHBX, 
export	_int13_cdrom
_int13_cdrom:
! 3892 DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
!BCC_EOS
! 3893 {
! 3894   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 3895   Bit8u device, status, locks;
!BCC_EOS
! 3896   Bit8u atacmd[12];
!BCC_EOS
! 3897   Bit32u lba;
!BCC_EOS
! 3898   Bit16u count, segment, offset, i, size;
!BCC_EOS
! 3899   ;
add	sp,*-$1E
!BCC_EOS
! 3900   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3901   if( (( ELDX & 0x00ff ) < 0xE0) || (( ELDX & 0x00ff ) >= 0xE0+(4*2)) ) {
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: lt int = const $E0 to unsigned char = al+0 (used reg = )
cmp	al,#$E0
jb  	.580
.581:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: ge int = const $E8 to unsigned char = al+0 (used reg = )
cmp	al,#$E8
jb  	.57F
.580:
! 3902     ;
!BCC_EOS
! 3903     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3904     }
! 3905   device=read_byte(ebda_seg,&((ebda_data_t *) 0)->ata.cdidmap[( ELDX & 0x00ff )-0xE0]);
.57F:
! Debug: and int = const $FF to unsigned short ELDX = [S+$22+$E] (used reg = )
mov	al,$10[bp]
! Debug: sub int = const $E0 to unsigned char = al+0 (used reg = )
xor	ah,ah
! Debug: ptradd unsigned int = ax-$E0 to [8] unsigned char = const $23C (used reg = )
add	ax,#-$E0
mov	bx,ax
! Debug: address unsigned char = [bx+$23C] (used reg = )
! Debug: list * unsigned char = bx+$23C (used reg = )
add	bx,#$23C
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char device = [S+$22-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 3906   if (device >= (4*2)) {
! Debug: ge int = const 8 to unsigned char device = [S+$22-5] (used reg = )
mov	al,-3[bp]
cmp	al,*8
jb  	.582
.583:
! 3907     ;
!BCC_EOS
! 3908     goto int13_fail;
add	sp,#..FFEB+$22
br 	.FFEB
!BCC_EOS
! 3909     }
! 3910   switch (( AX >> 8 )) {
.582:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
br 	.586
! 3911     case 0x00:
! 3912     case 0x09:
.587:
! 3913     case 0x0c:
.588:
! 3914     case 0x0d:
.589:
! 3915     case 0x10:
.58A:
! 3916     case 0x11:
.58B:
! 3917     case 0x14:
.58C:
! 3918     case 0x16:
.58D:
! 3919       goto int13_success;
.58E:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3920       break;
br 	.584
!BCC_EOS
! 3921     case 0x03:
! 3922     case 0x05:
.58F:
! 3923     case 0x43:
.590:
! 3924       AX = ((AX & 0x00ff) | ((0x03) << 8));
.591:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3925       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3926       break;
br 	.584
!BCC_EOS
! 3927     case 0x01:
! 3928       status = read_byte(0x0040, 0x0074);
.592:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3929       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$24+$16] (used reg = )
mov	al,$18[bp]
! Debug: or unsigned int (temp) = [S+$24-$24] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3930       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3931       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.593
.594:
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 3932       else goto int13_success_noah;
jmp .595
.593:
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3933       break;
.595:
br 	.584
!BCC_EOS
! 3934     case 0x15:
! 3935       AX = ((AX & 0x00ff) | ((0x02) << 8));
.596:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3936       goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3937       break;
br 	.584
!BCC_EOS
! 3938     case 0x41:
! 3939       BX=0xaa55;
.597:
! Debug: eq unsigned int = const $AA55 to unsigned short BX = [S+$22+$10] (used reg = )
mov	ax,#$AA55
mov	$12[bp],ax
!BCC_EOS
! 3940       AX = ((AX & 0x00ff) | ((0x30) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $3000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$3000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3941       CX=0x0007;
! Debug: eq int = const 7 to unsigned short CX = [S+$22+$14] (used reg = )
mov	ax,*7
mov	$16[bp],ax
!BCC_EOS
! 3942       goto int13_success_noah;
add	sp,#..FFE6-..FFEA
br 	.FFE6
!BCC_EOS
! 3943       break;
br 	.584
!BCC_EOS
! 3944     case 0x42:
! 3945     case 0x44:
.598:
! 3946     case 0x47:
.599:
! 3947       count=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count);
.59A:
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3948       segment=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->segment);
! Debug: add unsigned short = const 6 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$22-$1C] (used reg = )
mov	-$1A[bp],ax
!BCC_EOS
! 3949       offset=read_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->offset);
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$22-$1E] (used reg = )
mov	-$1C[bp],ax
!BCC_EOS
! 3950       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba2);
! Debug: add unsigned short = const $C to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 3951       if (lba != 0L) {
! Debug: ne long = const 0 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFEA[bp]
call	lcmpul
lea	sp,2+..FFEA[bp]
je  	.59B
.59C:
! 3952         bios_printf((2 | 4 | 1), "int13_cdrom: function %02x. Can't use 64bits lba\n",( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * char = .59D+0 (used reg = )
mov	bx,#.59D
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 3953         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 3954         }
! 3955       lba=read_dword(DS, SI+(Bit16u)&((int13ext_t *) 0)->lba1);
.59B:
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long lba = [S+$22-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 3956       if (( ( AX >> 8 ) == 0x44 ) || ( ( AX >> 8 ) == 0x47 ))
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $44 to unsigned int = ax+0 (used reg = )
cmp	ax,*$44
je  	.59F
.5A0:
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const $47 to unsigned int = ax+0 (used reg = )
cmp	ax,*$47
jne 	.59E
.59F:
! 3957         goto int13_success;
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3958       memsetb(get_SS(),atacmd,0,12);
.59E:
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$26-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 3959       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$22-$13] (used reg = )
mov	al,*$28
mov	-$11[bp],al
!BCC_EOS
! 3960       atacmd[7]=(count & 0xff00) >> 8;
! Debug: and unsigned int = const $FF00 to unsigned short count = [S+$22-$1A] (used reg = )
mov	ax,-$18[bp]
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$22-$C] (used reg = )
mov	-$A[bp],al
!BCC_EOS
! 3961       atacmd[8]=(count & 0x00ff);
! Debug: and int = const $FF to unsigned short count = [S+$22-$1A] (used reg = )
mov	al,-$18[bp]
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$22-$B] (used reg = )
mov	-9[bp],al
!BCC_EOS
! 3962     
! 3962   atacmd[2]=(lba & 0xff000000) >> 24;
! Debug: and unsigned long = const $FF000000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF00
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 3963       atacmd[3]=(lba & 0x00ff0000) >> 16;
! Debug: and long = const $FF0000 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
xor	ax,ax
mov	bx,#$FF
lea	di,-$16[bp]
call	landul
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$10] (used reg = )
mov	-$E[bp],al
!BCC_EOS
! 3964       atacmd[4]=(lba & 0x0000ff00) >> 8;
! Debug: and unsigned long = const $FF00 to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF00
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 3965       atacmd[5]=(lba & 0x000000ff);
! Debug: and unsigned long = const $FF to unsigned long lba = [S+$22-$18] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FF
xor	bx,bx
lea	di,-$16[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$22-$E] (used reg = )
mov	-$C[bp],al
!BCC_EOS
! 3966       status = ata_cmd_packet(device, 12, get_SS(), atacmd, 0, count*2048L, 0x01, segment,offset);
! Debug: list unsigned short offset = [S+$22-$1E] (used reg = )
push	-$1C[bp]
! Debug: list unsigned short segment = [S+$24-$1C] (used reg = )
push	-$1A[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short count = [S+$28-$1A] (used reg = )
mov	ax,-$18[bp]
xor	bx,bx
! Debug: mul long = const $800 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$800
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFEA[bp]
mov	bx,-6+..FFEA[bp]
lea	di,-$C+..FFEA[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$2E-$13 (used reg = )
lea	bx,-$11[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$34-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$22-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 3967       count = (Bit16u)(read_dword(ebda_seg, &((ebda_data_t *) 0)->ata.trsfbytes) >> 11);
! Debug: list * unsigned long = const $256 (used reg = )
mov	ax,#$256
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: sr int = const $B to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
mov	di,*3
call	lsrul
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: eq unsigned short = ax+0 to unsigned short count = [S+$22-$1A] (used reg = )
mov	-$18[bp],ax
!BCC_EOS
! 3968       write_word(DS, SI+(Bit16u)&((int13ext_t *) 0)->count, count);
! Debug: list unsigned short count = [S+$22-$1A] (used reg = )
push	-$18[bp]
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$24+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$26+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 3969       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.5A1
.5A2:
! 3970         ;
!BCC_EOS
! 3971         AX = ((AX & 0x00ff) | ((0x0c) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3972         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3973         }
! 3974       goto int13_success;
.5A1:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 3975       break;
br 	.584
!BCC_EOS
! 3976     case 0x45:
! 3977       if (( AX & 0x00ff ) > 2) goto int13_fail;
.5A3:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: gt int = const 2 to unsigned char = al+0 (used reg = )
cmp	al,*2
jbe 	.5A4
.5A5:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 3978       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.5A4:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 3979       switch (( AX & 0x00ff )) {
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
br 	.5A8
! 3980         case 0 :
! 3981           if (locks == 0xff) {
.5A9:
! Debug: logeq int = const $FF to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
cmp	al,#$FF
jne 	.5AA
.5AB:
! 3982             AX = ((AX & 0x00ff) | ((0xb4) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3983             AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3984             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3985             }
! 3986           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, ++locks);
.5AA:
! Debug: preinc unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
inc	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3987           AX = ((AX & 0xff00) | (1));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 1 to unsigned int = ax+0 (used reg = )
or	al,*1
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3988           break;
br 	.5A6
!BCC_EOS
! 3989         case 1 :
! 3990           if (locks == 0x00) {
.5AC:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5AD
.5AE:
! 3991             AX = ((AX & 0x00ff) | ((0xb0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$5000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$5000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3992             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3993             goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 3994             }
! 3995           write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock, --locks);
.5AD:
! Debug: predec unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
dec	ax
mov	-5[bp],al
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: ptradd unsigned char device = [S+$24-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$26-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 3996           AX = ((AX & 0xff00) | (locks==0?0:1));
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5AF
.5B0:
xor	al,al
jmp .5B1
.5AF:
mov	al,*1
.5B1:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 3997           break;
jmp .5A6
!BCC_EOS
! 3998         case 2 :
! 3999           AX = ((AX & 0xff00) | (locks==0?0:1));
.5B2:
! Debug: logeq int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
jne 	.5B3
.5B4:
xor	al,al
jmp .5B5
.5B3:
mov	al,*1
.5B5:
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$24+$16] (used reg = )
mov	ax,$18[bp]
xor	al,al
! Debug: or char (temp) = [S+$24-$24] to unsigned int = ax+0 (used reg = )
or	al,0+..FFEA[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4000           break;
jmp .5A6
!BCC_EOS
! 4001         }
! 4002       goto int13_success;
jmp .5A6
.5A8:
sub	al,*0
beq 	.5A9
sub	al,*1
beq 	.5AC
sub	al,*1
je 	.5B2
.5A6:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4003       break;
br 	.584
!BCC_EOS
! 4004     case 0x46:
! 4005       locks = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].lock);
.5B6:
! Debug: ptradd unsigned char device = [S+$22-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$145] (used reg = )
! Debug: list * unsigned char = bx+$145 (used reg = )
add	bx,#$145
push	bx
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char locks = [S+$22-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4006       if (locks != 0) {
! Debug: ne int = const 0 to unsigned char locks = [S+$22-7] (used reg = )
mov	al,-5[bp]
test	al,al
je  	.5B7
.5B8:
! 4007         AX = ((AX & 0x00ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4008         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4009         }
! 4010 #asm
.5B7:
!BCC_EOS
!BCC_ASM
_int13_cdrom.BP	set	$2E
.int13_cdrom.BP	set	$E
_int13_cdrom.EHBX	set	$24
.int13_cdrom.EHBX	set	4
_int13_cdrom.CS	set	$3C
.int13_cdrom.CS	set	$1C
_int13_cdrom.count	set	8
.int13_cdrom.count	set	-$18
_int13_cdrom.CX	set	$36
.int13_cdrom.CX	set	$16
_int13_cdrom.segment	set	6
.int13_cdrom.segment	set	-$1A
_int13_cdrom.DI	set	$2A
.int13_cdrom.DI	set	$A
_int13_cdrom.FLAGS	set	$3E
.int13_cdrom.FLAGS	set	$1E
_int13_cdrom.DS	set	$26
.int13_cdrom.DS	set	6
_int13_cdrom.ELDX	set	$30
.int13_cdrom.ELDX	set	$10
_int13_cdrom.DX	set	$34
.int13_cdrom.DX	set	$14
_int13_cdrom.size	set	0
.int13_cdrom.size	set	-$20
_int13_cdrom.i	set	2
.int13_cdrom.i	set	-$1E
_int13_cdrom.device	set	$1D
.int13_cdrom.device	set	-3
_int13_cdrom.ES	set	$28
.int13_cdrom.ES	set	8
_int13_cdrom.ebda_seg	set	$1E
.int13_cdrom.ebda_seg	set	-2
_int13_cdrom.SI	set	$2C
.int13_cdrom.SI	set	$C
_int13_cdrom.IP	set	$3A
.int13_cdrom.IP	set	$1A
_int13_cdrom.lba	set	$A
.int13_cdrom.lba	set	-$16
_int13_cdrom.status	set	$1C
.int13_cdrom.status	set	-4
_int13_cdrom.atacmd	set	$F
.int13_cdrom.atacmd	set	-$11
_int13_cdrom.AX	set	$38
.int13_cdrom.AX	set	$18
_int13_cdrom.offset	set	4
.int13_cdrom.offset	set	-$1C
_int13_cdrom.BX	set	$32
.int13_cdrom.BX	set	$12
_int13_cdrom.locks	set	$1B
.int13_cdrom.locks	set	-5
        push bp
        mov bp, sp
        mov ah, #0x52
        int #0x15
        mov _int13_cdrom.status + 2[bp], ah
        jnc int13_cdrom_rme_end
        mov _int13_cdrom.status, #1
int13_cdrom_rme_end:
        pop bp
! 4020 endasm
!BCC_ENDASM
!BCC_EOS
! 4021       if (status != 0) {
! Debug: ne int = const 0 to unsigned char status = [S+$22-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.5B9
.5BA:
! 4022         AX = ((AX & 0x00
! 4022 ff) | ((0xb1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const -$4F00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$4F00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4023         goto int13_fail_noah;
add	sp,#..FFE8-..FFEA
br 	.FFE8
!BCC_EOS
! 4024       }
! 4025       goto int13_success;
.5B9:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4026       break;
br 	.584
!BCC_EOS
! 4027     case 0x48:
! 4028       size = read_word(DS,SI+(Bit16u)&((int13ext_t *) 0)->size);
.5BB:
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$22+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$24+4] (used reg = )
push	6[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short size = [S+$22-$22] (used reg = )
mov	-$20[bp],ax
!BCC_EOS
! 4029       if(size < 0x1a)
! Debug: lt int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
jae 	.5BC
.5BD:
! 4030         goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4031       if(size >= 0x1a) {
.5BC:
! Debug: ge int = const $1A to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1A
blo 	.5BE
.5BF:
! 4032         Bit16u cylinders, heads, spt, blksize;
!BCC_EOS
! 4033         blksize = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].blksize);
! Debug: ptradd unsigned char device = [S+$2A-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned short = [bx+$148] (used reg = )
! Debug: list * unsigned short = bx+$148 (used reg = )
add	bx,#$148
push	bx
! Debug: list unsigned short ebda_seg = [S+$2C-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short blksize = [S+$2A-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4034         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1a);
! Debug: list int = const $1A (used reg = )
mov	ax,*$1A
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4035         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->infos, 0x74);
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: add unsigned short = const 2 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4036         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->cylinders, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 4 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4037         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->heads, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const 8 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4038         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->spt, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $C to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4039         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count1, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $10 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4040         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->sector_count2, 0xffffffff);
! Debug: list unsigned long = const $FFFFFFFF (used reg = )
mov	ax,#$FFFF
mov	bx,#$FFFF
push	bx
push	ax
! Debug: add unsigned short = const $14 to unsigned short SI = [S+$2E+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$14 (used reg = )
add	ax,*$14
push	ax
! Debug: list unsigned short DS = [S+$30+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4041         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->blksize, blksize);
! Debug: list unsigned short blksize = [S+$2A-$2A] (used reg = )
push	-$28[bp]
! Debug: add unsigned short = const $18 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$18 (used reg = )
add	ax,*$18
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4042         }
! 4043       if(size >= 0x1e) {
.5BE:
! Debug: ge int = const $1E to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$1E
blo 	.5C0
.5C1:
! 4044         Bit8u channel, dev, irq, mode, checksum, i;
!BCC_EOS
! 4045         Bit16u iobase1, iobase2, options;
!BCC_EOS
! 4046         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x1e);
! Debug: list int = const $1E (used reg = )
mov	ax,*$1E
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4047         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_segment, ebda_seg);
! Debug: list unsigned short ebda_seg = [S+$2E-4] (used reg = )
push	-2[bp]
! Debug: add unsigned short = const $1C to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1C (used reg = )
add	ax,*$1C
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4048         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->dpte_offset, &((ebda_data_t *) 0)->ata.dpte);
! Debug: list * struct  = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: add unsigned short = const $1A to unsigned short SI = [S+$30+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1A (used reg = )
add	ax,*$1A
push	ax
! Debug: list unsigned short DS = [S+$32+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4049         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$2E-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4050         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$2E-$2A] (used reg = )
mov	-$28[bp],ax
!BCC_EOS
! 4051         iobase2 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase2);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$126] (used reg = )
! Debug: list * unsigned short = bx+$126 (used reg = )
add	bx,#$126
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	-$2A[bp],ax
!BCC_EOS
! 4052         irq = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].irq);
! Debug: ptradd unsigned char channel = [S+$2E-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$128] (used reg = )
! Debug: list * unsigned char = bx+$128 (used reg = )
add	bx,#$128
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char irq = [S+$2E-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4053         mode = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.devices[device].mode);
! Debug: ptradd unsigned char device = [S+$2E-5] to [8] struct  = const $142 (used reg = )
mov	al,-3[bp]
xor	ah,ah
mov	cx,*$1E
imul	cx
mov	bx,ax
! Debug: address unsigned char = [bx+$146] (used reg = )
! Debug: list * unsigned char = bx+$146 (used reg = )
add	bx,#$146
push	bx
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	-$24[bp],al
!BCC_EOS
! 4054         options = (1<<4);
! Debug: eq int = const $10 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,*$10
mov	-$2C[bp],ax
!BCC_EOS
! 4055         options |= (1<<5);
! Debug: orab int = const $20 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$20
mov	-$2C[bp],ax
!BCC_EOS
! 4056         options |= (1<<6);
! Debug: orab int = const $40 to unsigned short options = [S+$2E-$2E] (used reg = )
mov	ax,-$2C[bp]
or	al,*$40
mov	-$2C[bp],ax
!BCC_EOS
! 4057         options |= (mode==0x01?1:0<<7);
! Debug: logeq int = const 1 to unsigned char mode = [S+$2E-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*1
jne 	.5C2
.5C3:
mov	al,*1
jmp .5C4
.5C2:
xor	al,al
.5C4:
! Debug: orab char = al+0 to unsigned short options = [S+$2E-$2E] (used reg = )
xor	ah,ah
or	ax,-$2C[bp]
mov	-$2C[bp],ax
!BCC_EOS
! 4058         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase1, iobase1);
! Debug: list unsigned short iobase1 = [S+$2E-$2A] (used reg = )
push	-$28[bp]
! Debug: list * unsigned short = const $244 (used reg = )
mov	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4059         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.iobase2, iobase2 + 6);
! Debug: add int = const 6 to unsigned short iobase2 = [S+$2E-$2C] (used reg = )
mov	ax,-$2A[bp]
! Debug: list unsigned int = ax+6 (used reg = )
add	ax,*6
push	ax
! Debug: list * unsigned short = const $246 (used reg = )
mov	ax,#$246
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4060         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pref
! 4060 ix, (0xe | (device % 2))<<4 );
! Debug: mod int = const 2 to unsigned char device = [S+$2E-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: or unsigned char = al+0 to int = const $E (used reg = )
! Debug: expression subtree swapping
or	al,*$E
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char = const $248 (used reg = )
mov	ax,#$248
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4061         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.unused, 0xcb );
! Debug: list int = const $CB (used reg = )
mov	ax,#$CB
push	ax
! Debug: list * unsigned char = const $249 (used reg = )
mov	ax,#$249
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4062         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.irq, irq );
! Debug: list unsigned char irq = [S+$2E-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $24A (used reg = )
mov	ax,#$24A
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4063         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.blkcount, 1 );
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list * unsigned char = const $24B (used reg = )
mov	ax,#$24B
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4064         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.dma, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24C (used reg = )
mov	ax,#$24C
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4065         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.pio, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $24D (used reg = )
mov	ax,#$24D
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4066         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.options, options);
! Debug: list unsigned short options = [S+$2E-$2E] (used reg = )
push	-$2C[bp]
! Debug: list * unsigned short = const $24E (used reg = )
mov	ax,#$24E
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4067         write_word(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.reserved, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned short = const $250 (used reg = )
mov	ax,#$250
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4068         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.revision, 0x11);
! Debug: list int = const $11 (used reg = )
mov	ax,*$11
push	ax
! Debug: list * unsigned char = const $252 (used reg = )
mov	ax,#$252
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4069         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	al,al
mov	-$25[bp],al
!BCC_EOS
! 4070         for (i=0; i<15; i++) checksum+=read_byte(ebda_seg, ((Bit8u*)(&((ebda_data_t *) 0)->ata.dpte)) + i);
! Debug: eq int = const 0 to unsigned char i = [S+$2E-$28] (used reg = )
xor	al,al
mov	-$26[bp],al
!BCC_EOS
!BCC_EOS
jmp .5C7
.5C8:
! Debug: ptradd unsigned char i = [S+$2E-$28] to * unsigned char = const $244 (used reg = )
mov	al,-$26[bp]
xor	ah,ah
! Debug: list * unsigned char = ax+$244 (used reg = )
add	ax,#$244
push	ax
! Debug: list unsigned short ebda_seg = [S+$30-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
xor	ah,ah
add	al,-$25[bp]
adc	ah,*0
mov	-$25[bp],al
!BCC_EOS
! 4071         checksum = ~checksum;
.5C6:
! Debug: postinc unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
inc	ax
mov	-$26[bp],al
.5C7:
! Debug: lt int = const $F to unsigned char i = [S+$2E-$28] (used reg = )
mov	al,-$26[bp]
cmp	al,*$F
jb 	.5C8
.5C9:
.5C5:
! Debug: not unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$2E-$27] (used reg = )
mov	-$25[bp],al
!BCC_EOS
! 4072         write_byte(ebda_seg, &((ebda_data_t *) 0)->ata.dpte.checksum, checksum);
! Debug: list unsigned char checksum = [S+$2E-$27] (used reg = )
mov	al,-$25[bp]
xor	ah,ah
push	ax
! Debug: list * unsigned char = const $253 (used reg = )
mov	ax,#$253
push	ax
! Debug: list unsigned short ebda_seg = [S+$32-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4073         }
! 4074       if(size >= 0x42) {
.5C0:
! Debug: ge int = const $42 to unsigned short size = [S+$22-$22] (used reg = )
mov	ax,-$20[bp]
cmp	ax,*$42
blo 	.5CA
.5CB:
! 4075         Bit8u channel, iface, checksum, i;
!BCC_EOS
! 4076         Bit16u iobase1;
!BCC_EOS
! 4077         channel = device / 2;
! Debug: div int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
shr	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char channel = [S+$28-$23] (used reg = )
mov	-$21[bp],al
!BCC_EOS
! 4078         iface = read_byte(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iface);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned char = [bx+$122] (used reg = )
! Debug: list * unsigned char = bx+$122 (used reg = )
add	bx,#$122
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	-$22[bp],al
!BCC_EOS
! 4079         iobase1 = read_word(ebda_seg, &((ebda_data_t *) 0)->ata.channels[channel].iobase1);
! Debug: ptradd unsigned char channel = [S+$28-$23] to [4] struct  = const $122 (used reg = )
mov	al,-$21[bp]
xor	ah,ah
mov	cl,*3
shl	ax,cl
mov	bx,ax
! Debug: address unsigned short = [bx+$124] (used reg = )
! Debug: list * unsigned short = bx+$124 (used reg = )
add	bx,#$124
push	bx
! Debug: list unsigned short ebda_seg = [S+$2A-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short iobase1 = [S+$28-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4080         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->size, 0x42);
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: add unsigned short = const 0 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4081         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->key, 0xbedd);
! Debug: list unsigned int = const $BEDD (used reg = )
mov	ax,#$BEDD
push	ax
! Debug: add unsigned short = const $1E to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$1E (used reg = )
add	ax,*$1E
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4082         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->dpi_length, 0x24);
! Debug: list int = const $24 (used reg = )
mov	ax,*$24
push	ax
! Debug: add unsigned short = const $20 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$20 (used reg = )
add	ax,*$20
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4083         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved1, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $21 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$21 (used reg = )
add	ax,*$21
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4084         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->reserved2, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $22 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$22 (used reg = )
add	ax,*$22
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4085         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5CC
.5CD:
! 4086           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[0], 'I');
! Debug: list int = const $49 (used reg = )
mov	ax,*$49
push	ax
! Debug: add unsigned short = const $24 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$24 (used reg = )
add	ax,*$24
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4087           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[1], 'S');
! Debug: list int = const $53 (used reg = )
mov	ax,*$53
push	ax
! Debug: add unsigned short = const $25 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$25 (used reg = )
add	ax,*$25
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4088           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $26 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$26 (used reg = )
add	ax,*$26
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4089           write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->host_bus[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $27 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$27 (used reg = )
add	ax,*$27
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4090           }
! 4091         else {
jmp .5CE
.5CC:
! 4092           }
! 4093         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[0], 'A');
.5CE:
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $28 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$28 (used reg = )
add	ax,*$28
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4094         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[1], 'T');
! Debug: list int = const $54 (used reg = )
mov	ax,*$54
push	ax
! Debug: add unsigned short = const $29 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$29 (used reg = )
add	ax,*$29
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4095         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_t
! 4095 ype[2], 'A');
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: add unsigned short = const $2A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2A (used reg = )
add	ax,*$2A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4096         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_type[3], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $2B to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$2B (used reg = )
add	ax,*$2B
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4097         if (iface==0x00) {
! Debug: logeq int = const 0 to unsigned char iface = [S+$28-$24] (used reg = )
mov	al,-$22[bp]
test	al,al
jne 	.5CF
.5D0:
! 4098           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[0], iobase1);
! Debug: list unsigned short iobase1 = [S+$28-$28] (used reg = )
push	-$26[bp]
! Debug: add unsigned short = const $30 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$30 (used reg = )
add	ax,*$30
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4099           write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $32 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$32 (used reg = )
add	ax,*$32
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4100           write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->iface_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $34 to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$34 (used reg = )
add	ax,*$34
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4101           }
! 4102         else {
jmp .5D1
.5CF:
! 4103           }
! 4104         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[0], device%2);
.5D1:
! Debug: mod int = const 2 to unsigned char device = [S+$28-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
and	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add unsigned short = const $38 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$38 (used reg = )
add	ax,*$38
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4105         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[1], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $39 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$39 (used reg = )
add	ax,*$39
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4106         write_word(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[2], 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: add unsigned short = const $3A to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3A (used reg = )
add	ax,*$3A
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4107         write_dword(DS, SI+(Bit16u)&((dpt_t *) 0)->device_path[4], 0L);
! Debug: list long = const 0 (used reg = )
xor	ax,ax
xor	bx,bx
push	bx
push	ax
! Debug: add unsigned short = const $3C to unsigned short SI = [S+$2C+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$3C (used reg = )
add	ax,*$3C
push	ax
! Debug: list unsigned short DS = [S+$2E+4] (used reg = )
push	6[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4108         checksum=0;
! Debug: eq int = const 0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	al,al
mov	-$23[bp],al
!BCC_EOS
! 4109         for (i=30; i<64; i++) checksum+=read_byte(DS, SI + i);
! Debug: eq int = const $1E to unsigned char i = [S+$28-$26] (used reg = )
mov	al,*$1E
mov	-$24[bp],al
!BCC_EOS
!BCC_EOS
jmp .5D4
.5D5:
! Debug: add unsigned char i = [S+$28-$26] to unsigned short SI = [S+$28+$A] (used reg = )
mov	ax,$C[bp]
add	al,-$24[bp]
adc	ah,*0
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+$2A+4] (used reg = )
push	6[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char checksum = [S+$28-$25] (used reg = )
xor	ah,ah
add	al,-$23[bp]
adc	ah,*0
mov	-$23[bp],al
!BCC_EOS
! 4110         checksum = ~checksum;
.5D3:
! Debug: postinc unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
inc	ax
mov	-$24[bp],al
.5D4:
! Debug: lt int = const $40 to unsigned char i = [S+$28-$26] (used reg = )
mov	al,-$24[bp]
cmp	al,*$40
jb 	.5D5
.5D6:
.5D2:
! Debug: not unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
not	ax
! Debug: eq unsigned int = ax+0 to unsigned char checksum = [S+$28-$25] (used reg = )
mov	-$23[bp],al
!BCC_EOS
! 4111         write_byte(DS, SI+(Bit16u)&((dpt_t *) 0)->checksum, checksum);
! Debug: list unsigned char checksum = [S+$28-$25] (used reg = )
mov	al,-$23[bp]
xor	ah,ah
push	ax
! Debug: add unsigned short = const $41 to unsigned short SI = [S+$2A+$A] (used reg = )
mov	ax,$C[bp]
! Debug: list unsigned int = ax+$41 (used reg = )
add	ax,*$41
push	ax
! Debug: list unsigned short DS = [S+$2C+4] (used reg = )
push	6[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4112         }
! 4113       goto int13_success;
.5CA:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4114       break;
br 	.584
!BCC_EOS
! 4115     case 0x49:
! 4116       AX = ((AX & 0x00ff) | ((06) << 8));
.5D7:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4117       goto int13_fail_nostatus;
add	sp,#..FFE7-..FFEA
br 	.FFE7
!BCC_EOS
! 4118       break;
br 	.584
!BCC_EOS
! 4119     case 0x4e:
! 4120       switch (( AX & 0x00ff )) {
.5D8:
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
jmp .5DB
! 4121         case 0x01:
! 4122         case 0x03:
.5DC:
! 4123         case 0x04:
.5DD:
! 4124         case 0x06:
.5DE:
! 4125           goto int13_success;
.5DF:
add	sp,#..FFE9-..FFEA
br 	.FFE9
!BCC_EOS
! 4126           break;
jmp .5D9
!BCC_EOS
! 4127         default :
! 4128           goto int13_fail;
.5E0:
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4129         }
! 4130       break;
jmp .5D9
.5DB:
sub	al,*1
je 	.5DC
sub	al,*2
je 	.5DD
sub	al,*1
je 	.5DE
sub	al,*2
je 	.5DF
jmp	.5E0
.5D9:
br 	.584
!BCC_EOS
! 4131     case 0x02:
! 4132     case 0x04:
.5E1:
! 4133     case 0x08:
.5E2:
! 4134     case 0x0a:
.5E3:
! 4135     case 0x0b:
.5E4:
! 4136     case 0x18:
.5E5:
! 4137     case 0x50:
.5E6:
! 4138     default:
.5E7:
! 4139       ;
.5E8:
!BCC_EOS
! 4140       goto int13_fail;
add	sp,#..FFEB-..FFEA
br 	.FFEB
!BCC_EOS
! 4141       break;
br 	.584
!BCC_EOS
! 4142     }
! 4143 int13_fail:
jmp .584
.586:
add	sp,*-$C
sub	ax,*0
jl 	.5E8
cmp	ax,*$18
ja  	.5E9
shl	ax,*1
mov	bx,ax
seg	cs
br	.5EA[bx]
.5EA:
.word	.587
.word	.592
.word	.5E1
.word	.58F
.word	.5E2
.word	.590
.word	.5E8
.word	.5E8
.word	.5E3
.word	.588
.word	.5E4
.word	.5E5
.word	.589
.word	.58A
.word	.5E8
.word	.5E8
.word	.58B
.word	.58C
.word	.5E8
.word	.5E8
.word	.58D
.word	.596
.word	.58E
.word	.5E8
.word	.5E6
.5E9:
sub	ax,*$41
jb 	.5E8
cmp	ax,*$F
ja  	.5EB
shl	ax,*1
mov	bx,ax
seg	cs
br	.5EC[bx]
.5EC:
.word	.597
.word	.598
.word	.591
.word	.599
.word	.5A3
.word	.5B6
.word	.59A
.word	.5BB
.word	.5D7
.word	.5E8
.word	.5E8
.word	.5E8
.word	.5E8
.word	.5D8
.word	.5E8
.word	.5E7
.5EB:
br 	.5E8
.584:
..FFEA	=	-$2E
add	sp,*$C
.FFEB:
..FFEB	=	-$22
! 4144     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$22+$16] (used reg = )
mov	$18[bp],ax
!BCC_EOS
! 4145 int13_fail_noah:
.FFE8:
..FFE8	=	-$22
! 4146     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$22+$16] (used reg = )
mov	ax,$18[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4147 int13_fail_nostatus:
.FFE7:
..FFE7	=	-$22
! 4148     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
or	al,*1
mov	$1E[bp],ax
!BCC_EOS
! 4149     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4150 int13_success:
.FFE9:
..FFE9	=	-$22
! 4151     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$22+$16] (used reg = )
mov	al,$18[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$22+$16] (used reg = )
xor	ah,ah
mov	$18[bp],ax
!BCC_EOS
! 4152 int13_success_noah:
.FFE6:
..FFE6	=	-$22
! 4153     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4154     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$22+$1C] (used reg = )
mov	ax,$1E[bp]
and	al,#$FE
mov	$1E[bp],ax
!BCC_EOS
! 4155     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4156 }
! 4157   void
! Register BX used in function int13_cdrom
! 4158 int13_eltorito(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4159   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_eltorito
_int13_eltorito:
!BCC_EOS
! 4160 {
! 4161   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4162   ;
!BCC_EOS
! 4163   switch (( AX >> 8 )) {
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.5EF
! 4164     case 0x4a:
! 4165     case 0x4c:
.5F0:
! 4166     case 0x4d:
.5F1:
! 4167       bios_printf((2 | 4 | 1), "Int13 eltorito call with AX=%04x. 
.5F2:
! 4167 Please report\n",AX);
! Debug: list unsigned short AX = [S+4+$14] (used reg = )
push	$16[bp]
! Debug: list * char = .5F3+0 (used reg = )
mov	bx,#.5F3
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*6
!BCC_EOS
! 4168       goto int13_fail;
add	sp,#..FFE4-..FFE5
br 	.FFE4
!BCC_EOS
! 4169       break;
br 	.5ED
!BCC_EOS
! 4170     case 0x4b:
! 4171       write_byte(DS,SI+0x00,0x13);
.5F4:
! Debug: list int = const $13 (used reg = )
mov	ax,*$13
push	ax
! Debug: add int = const 0 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4172       write_byte(DS,SI+0x01,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media));
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 1 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4173       write_byte(DS,SI+0x02,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive));
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4174       write_byte(DS,SI+0x03,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index));
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 3 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+3 (used reg = )
add	ax,*3
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4175       write_dword(DS,SI+0x04,read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba));
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: add int = const 4 to unsigned short SI = [S+8+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+4 (used reg = )
add	ax,*4
push	ax
! Debug: list unsigned short DS = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 4176       write_word(DS,SI+0x08,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec));
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const 8 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4177       write_word(DS,SI+0x0a,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.buffer_segment));
! Debug: list * unsigned short = const $264 (used reg = )
mov	ax,#$264
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $A to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$A (used reg = )
add	ax,*$A
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4178       write_word(DS,SI+0x0c,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment));
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $C to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$C (used reg = )
add	ax,*$C
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4179       write_word(DS,SI+0x0e,read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.sector_count));
! Debug: list * unsigned short = const $268 (used reg = )
mov	ax,#$268
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: add int = const $E to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$E (used reg = )
add	ax,*$E
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 4180       write_byte(DS,SI+0x10,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders));
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $10 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$10 (used reg = )
add	ax,*$10
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4181       write_byte(DS,SI+0x11,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt));
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $11 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$11 (used reg = )
add	ax,*$11
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4182       write_byte(DS,SI+0x12,read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads));
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+6-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const $12 to unsigned short SI = [S+6+8] (used reg = )
mov	ax,$A[bp]
! Debug: list unsigned int = ax+$12 (used reg = )
add	ax,*$12
push	ax
! Debug: list unsigned short DS = [S+8+2] (used reg = )
push	4[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4183       if(( AX & 0x00ff ) == 0x00) {
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.5F5
.5F6:
! 4184         write_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+8-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4185         }
! 4186       goto int13_success;
.5F5:
add	sp,#..FFE3-..FFE5
jmp .FFE3
!BCC_EOS
! 4187       break;
jmp .5ED
!BCC_EOS
! 4188     default:
! 4189       ;
.5F7:
!BCC_EOS
! 4190       goto int13_fail;
add	sp,#..FFE4-..FFE5
jmp .FFE4
!BCC_EOS
! 4191       break;
jmp .5ED
!BCC_EOS
! 4192     }
! 4193 int13_fail:
jmp .5ED
.5EF:
sub	ax,*$4A
beq 	.5F0
sub	ax,*1
beq 	.5F4
sub	ax,*1
beq 	.5F1
sub	ax,*1
beq 	.5F2
jmp	.5F7
.5ED:
..FFE5	=	-4
.FFE4:
..FFE4	=	-4
! 4194     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+4+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4195     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+4+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4196     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4197     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4198 int13_success:
.FFE3:
..FFE3	=	-4
! 4199     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+4+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+4+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4200     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4201     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+4+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4202     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4203 }
! 4204   void
! Register BX used in function int13_eltorito
! 4205 int13_cdemu(DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS)
! 4206   Bit16u DS, ES, DI, SI, BP, SP, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_cdemu
_int13_cdemu:
!BCC_EOS
! 4207 {
! 4208   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 4209   Bit8u device, status;
!BCC_EOS
! 4210   Bit16u vheads, vspt, vcylinders;
!BCC_EOS
! 4211   Bit16u head, sector, cylinder, nbsectors;
!BCC_EOS
! 4212   Bit32u vlba, ilba, slba, elba;
!BCC_EOS
! 4213   Bit16u before, segment, offset;
!BCC_EOS
! 4214   Bit8u atacmd[12];
!BCC_EOS
! 4215   ;
add	sp,*-$32
!BCC_EOS
! 4216   device = read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.controller_index) * 2;
! Debug: list * unsigned char = const $25D (used reg = )
mov	ax,#$25D
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: mul int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
! Debug: eq unsigned int = ax+0 to unsigned char device = [S+$36-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4217 
! 4217   device += read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.device_spec);
! Debug: list * unsigned short = const $25E (used reg = )
mov	ax,#$25E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: addab unsigned char = al+0 to unsigned char device = [S+$36-5] (used reg = )
xor	ah,ah
add	al,-3[bp]
adc	ah,*0
mov	-3[bp],al
!BCC_EOS
! 4218   write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4219   if( (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.active) ==0 )
! 4220    || (read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.emulated_drive ) != ( DX & 0x00ff ))) {
! Debug: list * unsigned char = const $25A (used reg = )
mov	ax,#$25A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.5F9
.5FA:
! Debug: expression subtree swapping
! Debug: list * unsigned char = const $25C (used reg = )
mov	ax,#$25C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: ne unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
cmp	al,-$36[bp]
lea	sp,-$34[bp]
je  	.5F8
.5F9:
! 4221     ;
!BCC_EOS
! 4222     goto int13_fail;
add	sp,#..FFE2+$36
br 	.FFE2
!BCC_EOS
! 4223     }
! 4224   switch (( AX >> 8 )) {
.5F8:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
br 	.5FD
! 4225     case 0x00:
! 4226     case 0x09:
.5FE:
! 4227     case 0x0c:
.5FF:
! 4228     case 0x0d:
.600:
! 4229     case 0x10:
.601:
! 4230     case 0x11:
.602:
! 4231     case 0x14:
.603:
! 4232     case 0x16:
.604:
! 4233       goto int13_success;
.605:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4234       break;
br 	.5FB
!BCC_EOS
! 4235     case 0x03:
! 4236     case 0x05:
.606:
! 4237       AX = ((AX & 0x00ff) | ((0x03) << 8));
.607:
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4238       goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4239       break;
br 	.5FB
!BCC_EOS
! 4240     case 0x01:
! 4241       status=read_byte(0x0040, 0x0074);
.608:
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4242       AX = ((AX & 0x00ff) | ((status) << 8));
! Debug: sl int = const 8 to unsigned char status = [S+$36-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$38+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4243       write_byte(0x0040, 0x0074, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4244       if (status) goto int13_fail_nostatus;
mov	al,-4[bp]
test	al,al
je  	.609
.60A:
add	sp,#..FFDE-..FFE1
br 	.FFDE
!BCC_EOS
! 4245       else goto int13_success_noah;
jmp .60B
.609:
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4246       break;
.60B:
br 	.5FB
!BCC_EOS
! 4247     case 0x02:
! 4248     case 0x04:
.60C:
! 4249       vspt = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.60D:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4250       vcylinders = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders);
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 4251       vheads = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads);
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vheads = [S+$36-8] (used reg = )
mov	-6[bp],ax
!BCC_EOS
! 4252       ilba = read_dword(ebda_seg,&((ebda_data_t *) 0)->cdemu.ilba);
! Debug: list * unsigned long = const $260 (used reg = )
mov	ax,#$260
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	-$1A[bp],ax
mov	-$18[bp],bx
!BCC_EOS
! 4253       sector = ( CX & 0x00ff ) & 0x003f;
! Debug: and int = const $FF to unsigned short CX = [S+$36+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $3F to unsigned char = al+0 (used reg = )
and	al,*$3F
! Debug: eq unsigned char = al+0 to unsigned short sector = [S+$36-$10] (used reg = )
xor	ah,ah
mov	-$E[bp],ax
!BCC_EOS
! 4254       cylinder = (( CX & 0x00ff ) & 0x00c0) << 2 | ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$36+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: and int = const $C0 to unsigned char = al+0 (used reg = )
and	al,#$C0
! Debug: sl int = const 2 to unsigned char = al+0 (used reg = )
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	-$10[bp],ax
!BCC_EOS
! 4255       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned short head = [S+$36-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4256       nbsectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
xor	ah,ah
mov	-$12[bp],ax
!BCC_EOS
! 4257       segment = ES;
! Debug: eq unsigned short ES = [S+$36+4] to unsigned short segment = [S+$36-$28] (used reg = )
mov	ax,6[bp]
mov	-$26[bp],ax
!BCC_EOS
! 4258       offset = BX;
! Debug: eq unsigned short BX = [S+$36+$E] to unsigned short offset = [S+$36-$2A] (used reg = )
mov	ax,$10[bp]
mov	-$28[bp],ax
!BCC_EOS
! 4259       if(nbsectors==0) goto int13_success;
! Debug: logeq int = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
test	ax,ax
jne 	.60E
.60F:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4260       if ((sector > vspt)
.60E:
! 4261        || (cylinder >= vcylinders)
! 4262        || (head >= vheads)) {
! Debug: gt unsigned short vspt = [S+$36-$A] to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,-8[bp]
ja  	.611
.613:
! Debug: ge unsigned short vcylinders = [S+$36-$C] to unsigned short cylinder = [S+$36-$12] (used reg = )
mov	ax,-$10[bp]
cmp	ax,-$A[bp]
jae 	.611
.612:
! Debug: ge unsigned short vheads = [S+$36-8] to unsigned short head = [S+$36-$E] (used reg = )
mov	ax,-$C[bp]
cmp	ax,-6[bp]
jb  	.610
.611:
! 4263         goto int13_fail;
add	sp,#..FFE2-..FFE1
br 	.FFE2
!BCC_EOS
! 4264         }
! 4265       if (( AX >> 8 ) == 0x04) goto int13_success;
.610:
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: logeq int = const 4 to unsigned int = ax+0 (used reg = )
cmp	ax,*4
jne 	.614
.615:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4266       segment = ES+(BX / 16);
.614:
! Debug: div int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
mov	cl,*4
shr	ax,cl
! Debug: add unsigned int = ax+0 to unsigned short ES = [S+$36+4] (used reg = )
! Debug: expression subtree swapping
add	ax,6[bp]
! Debug: eq unsigned int = ax+0 to unsigned short segment = [S+$36-$28] (used reg = )
mov	-$26[bp],ax
!BCC_EOS
! 4267       offset = BX % 16;
! Debug: mod int = const $10 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
and	al,*$F
! Debug: eq unsigned char = al+0 to unsigned short offset = [S+$36-$2A] (used reg = )
xor	ah,ah
mov	-$28[bp],ax
!BCC_EOS
! 4268       vlba=((((Bit32u)cylinder*(Bit32u)vheads)+(Bit32u)head)*(Bit32u)vspt)+((Bit32u)(sector-1));
! Debug: sub int = const 1 to unsigned short sector = [S+$36-$10] (used reg = )
mov	ax,-$E[bp]
! Debug: cast unsigned long = const 0 to unsigned int = ax-1 (used reg = )
dec	ax
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vspt = [S+$3A-$A] (used reg = )
mov	ax,-8[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short head = [S+$3E-$E] (used reg = )
mov	ax,-$C[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short vheads = [S+$42-8] (used reg = )
mov	ax,-6[bp]
xor	bx,bx
push	bx
push	ax
! Debug: cast unsigned long = const 0 to unsigned short cylinder = [S+$46-$12] (used reg = )
mov	ax,-$10[bp]
xor	bx,bx
! Debug: mul unsigned long (temp) = [S+$46-$46] to unsigned long = bx+0 (used reg = )
lea	di,-$E+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$42-$42] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: mul unsigned long (temp) = [S+$3E-$3E] to unsigned long = bx+0 (used reg = )
lea	di,-6+..FFE1[bp]
call	lmulul
add	sp,*4
! Debug: add unsigned long (temp) = [S+$3A-$3A] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFE1[bp]
call	laddul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	-$16[bp],ax
mov	-$14[bp],bx
!BCC_EOS
! 4269       AX = ((AX & 0xff00) | (nbsectors));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or unsigned short nbsectors = [S+$36-$14] to unsigned int = ax+0 (used reg = )
or	ax,-$12[bp]
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4270       slba = (Bit32u)vlba/4;
! Debug: div unsigned long = const 4 to unsigned long vlba = [S+$36-$18] (used reg = )
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-$16[bp]
mov	bx,-$14[bp]
lea	di,-2+..FFE1[bp]
call	ldivul
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long slba = [S+$36-$20] (used reg = )
mov	-$1E[bp],ax
mov	-$1C[bp],bx
!BCC_EOS
! 4271       before= (Bit16u)vlba%4;
! Debug: mod int = const 4 to unsigned short vlba = [S+$36-$18] (used reg = )
mov	ax,-$16[bp]
and	al,*3
! Debug: eq unsigned char = al+0 to unsigned short before = [S+$36-$26] (used reg = )
xor	ah,ah
mov	-$24[bp],ax
!BCC_EOS
! 4272       elba = (Bit32u)(vlba+nbsectors-1)/4;
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$36-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: add unsigned long = bx+0 to unsigned long vlba = [S+$36-$18] (used reg = )
! Debug: expression subtree swapping
lea	di,-$16[bp]
call	laddul
! Debug: sub unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	lsubul
add	sp,*8
! Debug: cast unsigned long = const 0 to unsigned long = bx+0 (used reg = )
! Debug: div unsigned long = const 4 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*4
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	ldivul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned long elba = [S+$36-$24] (used reg = )
mov	-$22[bp],ax
mov	-$20[bp],bx
!BCC_EOS
! 4273       memsetb(get_SS(),atacmd,0,12);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list * unsigned char atacmd = S+$3A-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: func () void = memsetb+0 (used reg = )
call	_memsetb
add	sp,*8
!BCC_EOS
! 4274       atacmd[0]=0x28;
! Debug: eq int = const $28 to unsigned char atacmd = [S+$36-$36] (used reg = )
mov	al,*$28
mov	-$34[bp],al
!BCC_EOS
! 4275       atacmd[7]=((Bit16u)(elba-slba+1) & 0xff00) >> 8;
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and unsigned int = const $FF00 to unsigned short = ax+0 (used reg = )
xor	al,al
! Debug: sr int = const 8 to unsigned int = ax+0 (used reg = )
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char atacmd = [S+$36-$2F] (used reg = )
mov	-$2D[bp],al
!BCC_EOS
! 4276       atacmd[8]=((Bit16u)(elba-slba+1) & 0x0
! 4276 0ff);
! Debug: sub unsigned long slba = [S+$36-$20] to unsigned long elba = [S+$36-$24] (used reg = )
mov	ax,-$22[bp]
mov	bx,-$20[bp]
lea	di,-$1E[bp]
call	lsubul
! Debug: add unsigned long = const 1 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,*1
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	laddul
add	sp,*8
! Debug: cast unsigned short = const 0 to unsigned long = bx+0 (used reg = )
! Debug: and int = const $FF to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char atacmd = [S+$36-$2E] (used reg = )
mov	-$2C[bp],al
!BCC_EOS
! 4277       atacmd[2]=(ilba+slba & 0xff000000) >> 24;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF000000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF00
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $18 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
mov	al,ah
xor	ah,ah
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$34] (used reg = )
mov	-$32[bp],al
!BCC_EOS
! 4278       atacmd[3]=(ilba+slba & 0x00ff0000) >> 16;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and long = const $FF0000 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
xor	ax,ax
mov	bx,#$FF
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const $10 to unsigned long = bx+0 (used reg = )
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$33] (used reg = )
mov	-$31[bp],al
!BCC_EOS
! 4279       atacmd[4]=(ilba+slba & 0x0000ff00) >> 8;
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF00 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF00
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: sr int = const 8 to unsigned long = bx+0 (used reg = )
mov	al,ah
mov	ah,bl
mov	bl,bh
sub	bh,bh
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$32] (used reg = )
mov	-$30[bp],al
!BCC_EOS
! 4280       atacmd[5]=(ilba+slba & 0x000000ff);
! Debug: add unsigned long slba = [S+$36-$20] to unsigned long ilba = [S+$36-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
lea	di,-$1E[bp]
call	laddul
! Debug: and unsigned long = const $FF to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$FF
xor	bx,bx
push	bx
push	ax
mov	ax,-2+..FFE1[bp]
mov	bx,0+..FFE1[bp]
lea	di,-6+..FFE1[bp]
call	landul
add	sp,*8
! Debug: eq unsigned long = bx+0 to unsigned char atacmd = [S+$36-$31] (used reg = )
mov	-$2F[bp],al
!BCC_EOS
! 4281       if((status = ata_cmd_packet(device, 12, get_SS(), atacmd, before*512, nbsectors*512L, 0x01, segment,offset)) != 0) {
! Debug: list unsigned short offset = [S+$36-$2A] (used reg = )
push	-$28[bp]
! Debug: list unsigned short segment = [S+$38-$28] (used reg = )
push	-$26[bp]
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: cast unsigned long = const 0 to unsigned short nbsectors = [S+$3C-$14] (used reg = )
mov	ax,-$12[bp]
xor	bx,bx
! Debug: mul long = const $200 to unsigned long = bx+0 (used reg = )
push	bx
push	ax
mov	ax,#$200
xor	bx,bx
push	bx
push	ax
mov	ax,-8+..FFE1[bp]
mov	bx,-6+..FFE1[bp]
lea	di,-$C+..FFE1[bp]
call	lmulul
add	sp,*8
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: mul int = const $200 to unsigned short before = [S+$40-$26] (used reg = )
mov	ax,-$24[bp]
mov	cx,#$200
imul	cx
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list * unsigned char atacmd = S+$42-$36 (used reg = )
lea	bx,-$34[bp]
push	bx
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: list unsigned short = ax+0 (used reg = )
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: list unsigned char device = [S+$48-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = ata_cmd_packet+0 (used reg = )
call	_ata_cmd_packet
add	sp,*$14
! Debug: eq unsigned short = ax+0 to unsigned char status = [S+$36-6] (used reg = )
mov	-4[bp],al
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.616
.617:
! 4282         ;
!BCC_EOS
! 4283         AX = ((AX & 0x00ff) | ((0x02) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $200 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$200
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4284         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4285         goto int13_fail_noah;
add	sp,#..FFDF-..FFE1
br 	.FFDF
!BCC_EOS
! 4286         }
! 4287       goto int13_success;
.616:
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4288       break;
br 	.5FB
!BCC_EOS
! 4289     case 0x08:
! 4290       vspt=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.spt);
.618:
! Debug: list * unsigned short = const $26E (used reg = )
mov	ax,#$26E
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short vspt = [S+$36-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4291       vcylinders=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.cylinders) - 1;
! Debug: list * unsigned short = const $26C (used reg = )
mov	ax,#$26C
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vcylinders = [S+$36-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4292       vheads=read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.vdevice.heads) - 1;
! Debug: list * unsigned short = const $26A (used reg = )
mov	ax,#$26A
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: sub int = const 1 to unsigned short = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short vheads = [S+$36-8] (used reg = )
dec	ax
mov	-6[bp],ax
!BCC_EOS
! 4293       AX = ((AX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4294       BX = ((BX & 0xff00) | (0x00));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4295       CX = ((CX & 0x00ff) | ((vcylinders & 0xff) << 8));
! Debug: and int = const $FF to unsigned short vcylinders = [S+$36-$C] (used reg = )
mov	al,-$A[bp]
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short CX = [S+$38+$12] (used reg = )
mov	al,$14[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4296       CX = ((CX & 0xff00) | ((( vcylinders >> 2) & 0xc0) | ( vspt & 0x3f )));
! Debug: and int = const $3F to unsigned short vspt = [S+$36-$A] (used reg = )
mov	al,-8[bp]
and	al,*$3F
push	ax
! Debug: sr int = const 2 to unsigned short vcylinders = [S+$38-$C] (used reg = )
mov	ax,-$A[bp]
shr	ax,*1
shr	ax,*1
! Debug: and int = const $C0 to unsigned int = ax+0 (used reg = )
and	al,#$C0
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
push	ax
! Debug: and unsigned int = const $FF00 to unsigned short CX = [S+$38+$12] (used reg = )
mov	ax,$14[bp]
xor	al,al
! Debug: or unsigned char (temp) = [S+$38-$38] to unsigned int = ax+0 (used reg = )
or	al,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short CX = [S+$36+$12] (used reg = )
mov	$14[bp],ax
!BCC_EOS
! 4297       DX = ((DX & 0x00ff) | ((vheads) << 8));
! Debug: sl int = const 8 to unsigned short vheads = [S+$36-8] (used reg = )
mov	ax,-6[bp]
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short DX = [S+$38+$10] (used reg = )
mov	al,$12[bp]
! Debug: or unsigned int (temp) = [S+$38-$38] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFE1[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4298       DX = ((DX & 0xff00) | (0x02));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$36+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$36+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4299       switch(read_byte(ebda_seg,&((ebda_data_t *) 0)->cdemu.media)) {
! Debug: list * unsigned char = const $25B (used reg = )
mov	ax,#$25B
push	ax
! Debug: list unsigned short ebda_seg = [S+$38-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
jmp .61B
! 4300         case 0x01: BX = ((BX & 0xff00) | (0x02)); break;
.61C:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 2 to unsigned int = ax+0 (used reg = )
or	al,*2
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .619
!BCC_EOS
! 4301         case 0x02: BX = ((BX & 0xff00) | (0x04)); break;
.61D:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 4 to unsigned int = ax+0 (used reg = )
or	al,*4
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .619
!BCC_EOS
! 4302         case 0x03: BX = ((BX & 0xff00) | (0x06)); break;
.61E:
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$36+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or int = const 6 to unsigned int = ax+0 (used reg = )
or	al,*6
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$36+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
jmp .619
!BCC_EOS
! 4303         }
! 4304 #asm
jmp .619
.61B:
sub	al,*1
je 	.61C
sub	al,*1
je 	.61D
sub	al,*1
je 	.61E
.619:
!BCC_EOS
!BCC_ASM
_int13_cdemu.BP	set	$40
.int13_cdemu.BP	set	$C
_int13_cdemu.CS	set	$4E
.int13_cdemu.CS	set	$1A
_int13_cdemu.nbsectors	set	$22
.int13_cdemu.nbsectors	set	-$12
_int13_cdemu.CX	set	$48
.int13_cdemu.CX	set	$14
_int13_cdemu.elba	set	$12
.int13_cdemu.elba	set	-$22
_int13_cdemu.segment	set	$E
.int13_cdemu.segment	set	-$26
_int13_cdemu.DI	set	$3C
.int13_cdemu.DI	set	8
_int13_cdemu.FLAGS	set	$50
.int13_cdemu.FLAGS	set	$1C
_int13_cdemu.vcylinders	set	$2A
.int13_cdemu.vcylinders	set	-$A
_int13_cdemu.sector	set	$26
.int13_cdemu.sector	set	-$E
_int13_cdemu.DS	set	$38
.int13_cdemu.DS	set	4
_int13_cdemu.head	set	$28
.int13_cdemu.head	set	-$C
_int13_cdemu.cylinder	set	$24
.int13_cdemu.cylinder	set	-$10
_int13_cdemu.DX	set	$46
.int13_cdemu.DX	set	$12
_int13_cdemu.device	set	$31
.int13_cdemu.device	set	-3
_int13_cdemu.ES	set	$3A
.int13_cdemu.ES	set	6
_int13_cdemu.vspt	set	$2C
.int13_cdemu.vspt	set	-8
_int13_cdemu.vlba	set	$1E
.int13_cdemu.vlba	set	-$16
_int13_cdemu.ebda_seg	set	$32
.int13_cdemu.ebda_seg	set	-2
_int13_cdemu.SI	set	$3E
.int13_cdemu.SI	set	$A
_int13_cdemu.IP	set	$4C
.int13_cdemu.IP	set	$18
_int13_cdemu.status	set	$30
.int13_cdemu.status	set	-4
_int13_cdemu.atacmd	set	0
.int13_cdemu.atacmd	set	-$34
_int13_cdemu.AX	set	$4A
.int13_cdemu.AX	set	$16
_int13_cdemu.ilba	set	$1A
.int13_cdemu.ilba	set	-$1A
_int13_cdemu.before	set	$10
.int13_cdemu.before	set	-$24
_int13_cdemu.offset	set	$C
.int13_cdemu.offset	set	-$28
_int13_cdemu.slba	set	$16
.int13_cdemu.slba	set	-$1E
_int13_cdemu.SP	set	$42
.int13_cdemu.SP	set	$E
_int13_cdemu.vheads	set	$2E
.int13_cdemu.vheads	set	-6
_int13_cdemu.BX	set	$44
.int13_cdemu.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_cdemu.DI+2[bp], ax
      mov _int13_cdemu.ES+2[bp], cs
      pop bp
! 4311 endasm
!BCC_ENDASM
!BCC_EOS
! 4312       goto int13_success;
add	sp,#..FFE0-..FFE1
br 	.FFE0
!BCC_EOS
! 4313       break;
br 	.5FB
!BCC_EOS
! 4314     case 0x15:
! 4315       AX = ((AX & 0x00ff) | ((0x03) << 8));
.61F:
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $300 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$300
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4316       goto int13_success_noah;
add	sp,#..FFDD-..FFE1
br 	.FFDD
!BCC_EOS
! 4317       break;
br 	.5FB
!BCC_EOS
! 4318     case 0x0a:
! 4319     case 0x0b:
.620:
! 4320     case 0x18:
.621:
! 4321     case 0x41:
.622:
! 4322     case 0x42:
.623:
! 4323     case 0x43:
.624:
! 4324     case 0x44:
.625:
! 4325     case 0x45:
.626:
! 4326     case 0x46:
.627:
! 4327     case 0x47:
.628:
! 4328     case 0x48:
.629:
! 4329     case 0x49:
.62A:
! 4330     case 0x4e:
.62B:
! 4331     case 0x50:
.62C:
! 4332     default:
.62D:
! 4333       ;
.62E:
!BCC_EOS
! 4334       goto int13_fail;
add	sp,#..FFE2-..FFE1
jmp .FFE2
!BCC_EOS
! 4335       break;
jmp .5FB
!BCC_EOS
! 4336     }
! 4337 int13_fail:
jmp .5FB
.5FD:
sub	ax,*0
jl 	.62E
cmp	ax,*$18
ja  	.62F
shl	ax,*1
mov	bx,ax
seg	cs
br	.630[bx]
.630:
.word	.5FE
.word	.608
.word	.60C
.word	.606
.word	.60D
.word	.607
.word	.62E
.word	.62E
.word	.618
.word	.5FF
.word	.620
.word	.621
.word	.600
.word	.601
.word	.62E
.word	.62E
.word	.602
.word	.603
.word	.62E
.word	.62E
.word	.604
.word	.61F
.word	.605
.word	.62E
.word	.622
.62F:
sub	ax,*$41
jb 	.62E
cmp	ax,*$F
ja  	.631
shl	ax,*1
mov	bx,ax
seg	cs
br	.632[bx]
.632:
.word	.623
.word	.624
.word	.625
.word	.626
.word	.627
.word	.628
.word	.629
.word	.62A
.word	.62B
.word	.62E
.word	.62E
.word	.62E
.word	.62E
.word	.62C
.word	.62E
.word	.62D
.631:
br 	.62E
.5FB:
..FFE1	=	-$36
.FFE2:
..FFE2	=	-$36
! 4338     AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$36+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4339 int13_fail_noah:
.FFDF:
..FFDF	=	-$36
! 4340     write_byte(0x0040, 0x0074, ( AX >> 8 ));
! Debug: sr int = const 8 to unsigned short AX = [S+$36+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4341 int13_fail_nostatus:
.FFDE:
..FFDE	=	-$36
! 4342     FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4343     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4344 int13_success:
.FFE0:
..FFE0	=	-$36
! 4344 
! 4345     AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$36+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$36+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4346 int13_success_noah:
.FFDD:
..FFDD	=	-$36
! 4347     write_byte(0x0040, 0x0074, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $74 (used reg = )
mov	ax,*$74
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4348     FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$36+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4349     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4350 }
! 4351 void floppy_reset_controller()
! Register BX used in function int13_cdemu
! 4352 {
export	_floppy_reset_controller
_floppy_reset_controller:
! 4353   Bit8u val8;
!BCC_EOS
! 4354   val8 = inb(0x03f2);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4355   outb(0x03f2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4356   outb(0x03f2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4357   do {
.635:
! 4358     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4359   } while ( (val8 & 0xc0) != 0x80 );
.634:
! Debug: and int = const $C0 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.635
.636:
!BCC_EOS
! 4360 }
.633:
mov	sp,bp
pop	bp
ret
! 4361 void floppy_prepare_controller(drive)
! 4362   Bit16u drive;
export	_floppy_prepare_controller
_floppy_prepare_controller:
!BCC_EOS
! 4363 {
! 4364   Bit8u val8, dor, prev_reset;
!BCC_EOS
! 4365   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4366   val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4367   write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4368   prev_reset = inb(0x03f2) & 0x04;
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const 4 to unsigned char = al+0 (used reg = )
and	al,*4
! Debug: eq unsigned char = al+0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4369   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.637
.638:
! 4370     dor = 0x20;
! Debug: eq int = const $20 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$20
mov	-2[bp],al
!BCC_EOS
! 4371   else
! 4372     dor = 0x10;
jmp .639
.637:
! Debug: eq int = const $10 to unsigned char dor = [S+6-4] (used reg = )
mov	al,*$10
mov	-2[bp],al
!BCC_EOS
! 4373   dor |= 0x0c;
.639:
! Debug: orab int = const $C to unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
or	al,*$C
mov	-2[bp],al
!BCC_EOS
! 4374   dor |= drive;
! Debug: orab unsigned short drive = [S+6+2] to unsigned char dor = [S+6-4] (used reg = )
mov	ax,4[bp]
or	al,-2[bp]
mov	-2[bp],al
!BCC_EOS
! 4375   outb(0x03f2, dor);
! Debug: list unsigned char dor = [S+6-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F2 (used reg = )
mov	ax,#$3F2
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4376   write_byte(0x40,0x40, 37);
! Debug: list int = const $25 (used reg = )
mov	ax,*$25
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4377   do {
.63C:
! 4378     val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4379   } while ( (val8 & 0xc0) != 0x80 );
.63B:
! Debug: and int = const $C0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$C0
! Debug: ne int = const $80 to unsigned char = al+0 (used reg = )
cmp	al,#$80
jne	.63C
.63D:
!BCC_EOS
! 4380   if (prev_reset == 0) {
.63A:
! Debug: logeq int = const 0 to unsigned char prev_reset = [S+6-5] (used reg = )
mov	al,-3[bp]
test	al,al
jne 	.63E
.63F:
! 4381 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    sti
! 4383 endasm
!BCC_ENDASM
!BCC_EOS
! 4384     do {
.642:
! 4385       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4386     } while ( (val8 & 0x80) == 0 );
.641:
! Debug: and int = const $80 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,#$80
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je 	.642
.643:
!BCC_EOS
! 4387     val8 &= 0x7f;
.640:
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4388 #asm
!BCC_EOS
!BCC_ASM
_floppy_prepare_controller.dor	set	2
.floppy_prepare_controller.dor	set	-2
_floppy_prepare_controller.prev_reset	set	1
.floppy_prepare_controller.prev_reset	set	-3
_floppy_prepare_controller.val8	set	3
.floppy_prepare_controller.val8	set	-1
_floppy_prepare_controller.drive	set	8
.floppy_prepare_controller.drive	set	4
    cli
! 4390 endasm
!BCC_ENDASM
!BCC_EOS
! 4391     write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4392   }
! 4393 }
.63E:
mov	sp,bp
pop	bp
ret
! 4394   bx_bool
! 4395 floppy_media_known(drive)
! 4396   Bit16u drive;
export	_floppy_media_known
_floppy_media_known:
!BCC_EOS
! 4397 {
! 4398   Bit8u val8;
!BCC_EOS
! 4399   Bit16u media_state_offset;
!BCC_EOS
! 4400   val8 = read_byte(0x0040, 0x003e);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4401   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.644
.645:
! 4402     val8 >>= 1;
! Debug: srab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
shr	ax,*1
mov	-1[bp],al
!BCC_EOS
! 4403   val8 &= 0x01;
.644:
! Debug: andab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*1
mov	-1[bp],al
!BCC_EOS
! 4404   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.646
.647:
! 4405     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4406   media_state_offset = 0x0090;
.646:
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4407   if (drive)
mov	ax,4[bp]
test	ax,ax
je  	.648
.649:
! 4408     media_state_offset += 1;
! Debug: addab int = const 1 to unsigned short media_state_offset = [S+6-6] (used reg = )
mov	ax,-4[bp]
inc	ax
mov	-4[bp],ax
!BCC_EOS
! 4409   val8 = read_byte(0x0040, media_state_offset);
.648:
! Debug: list unsigned short media_state_offset = [S+6-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4410   val8 = (val8 >> 4) & 0x01;
! Debug: sr int = const 4 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: and int = const 1 to unsigned int = ax+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4411   if (val8 == 0)
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.64A
.64B:
! 4412     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4413   return(1);
.64A:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4414 }
! 4415   bx_bool
! 4416 floppy_media_sense(drive)
! 4417   Bit16u drive;
export	_floppy_media_sense
_floppy_media_sense:
!BCC_EOS
! 4418 {
! 4419   bx_bool retval;
!BCC_EOS
! 4420   Bit16u media_state_offset;
!BCC_EOS
! 4421   Bit8u drive_type, config_data, media_state;
!BCC_EOS
! 4422   if (floppy_drive_recal(drive) == 0) {
push	bp
mov	bp,sp
add	sp,*-8
! Debug: list unsigned short drive = [S+$A+2] (used reg = )
push	4[bp]
! Debug: func () unsigned short = floppy_drive_recal+0 (used reg = )
call	_floppy_drive_recal
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.64C
.64D:
! 4423     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4424     }
! 4425   drive_type = inb_cmos(0x10);
.64C:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4426   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.64E
.64F:
! 4427     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-5[bp],al
!BCC_EOS
! 4428   else
! 4429     drive_type &= 0x0f;
jmp .650
.64E:
! Debug: andab int = const $F to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
and	al,*$F
mov	-5[bp],al
!BCC_EOS
! 4430   if ( drive_type == 1 ) {
.650:
! Debug: logeq int = const 1 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
jne 	.651
.652:
! 4431     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4432     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4433     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4434     }
! 4435   else if ( drive_type == 2 ) {
br 	.653
.651:
! Debug: logeq int = const 2 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*2
jne 	.654
.655:
! 4436     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4437     media_state = 0x25;
! Debug: eq int = const $25 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$25
mov	-7[bp],al
!BCC_EOS
! 4438     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4439     }
! 4440   else if ( drive_type == 3 ) {
br 	.656
.654:
! Debug: logeq int = const 3 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*3
jne 	.657
.658:
! 4441     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4442     media_state = 0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4443     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4444     }
! 4445   else if ( drive_type == 4 ) {
br 	.659
.657:
! Debug: logeq int = const 4 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*4
jne 	.65A
.65B:
! 4446     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4447     media_state =
! 4447  0x17;
! Debug: eq int = const $17 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$17
mov	-7[bp],al
!BCC_EOS
! 4448     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4449     }
! 4450   else if ( drive_type == 5 ) {
jmp .65C
.65A:
! Debug: logeq int = const 5 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*5
jne 	.65D
.65E:
! 4451     config_data = 0xCC;
! Debug: eq int = const $CC to unsigned char config_data = [S+$A-8] (used reg = )
mov	al,#$CC
mov	-6[bp],al
!BCC_EOS
! 4452     media_state = 0xD7;
! Debug: eq int = const $D7 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,#$D7
mov	-7[bp],al
!BCC_EOS
! 4453     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4454     }
! 4455   else if ( drive_type == 6 ) {
jmp .65F
.65D:
! Debug: logeq int = const 6 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*6
jne 	.660
.661:
! 4456     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4457     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4458     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4459     }
! 4460   else if ( drive_type == 7 ) {
jmp .662
.660:
! Debug: logeq int = const 7 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*7
jne 	.663
.664:
! 4461     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4462     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4463     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4464     }
! 4465   else if ( drive_type == 8 ) {
jmp .665
.663:
! Debug: logeq int = const 8 to unsigned char drive_type = [S+$A-7] (used reg = )
mov	al,-5[bp]
cmp	al,*8
bne 	.666
.667:
! 4466     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4467     media_state = 0x27;
! Debug: eq int = const $27 to unsigned char media_state = [S+$A-9] (used reg = )
mov	al,*$27
mov	-7[bp],al
!BCC_EOS
! 4468     retval = 1;
! Debug: eq int = const 1 to unsigned short retval = [S+$A-4] (used reg = )
mov	ax,*1
mov	-2[bp],ax
!BCC_EOS
! 4469     }
! 4470   else {
jmp .668
.666:
! 4471     config_data = 0x00;
! Debug: eq int = const 0 to unsigned char config_data = [S+$A-8] (used reg = )
xor	al,al
mov	-6[bp],al
!BCC_EOS
! 4472     media_state = 0x00;
! Debug: eq int = const 0 to unsigned char media_state = [S+$A-9] (used reg = )
xor	al,al
mov	-7[bp],al
!BCC_EOS
! 4473     retval = 0;
! Debug: eq int = const 0 to unsigned short retval = [S+$A-4] (used reg = )
xor	ax,ax
mov	-2[bp],ax
!BCC_EOS
! 4474     }
! 4475   if (drive == 0)
.668:
.665:
.662:
.65F:
.65C:
.659:
.656:
.653:
! Debug: logeq int = const 0 to unsigned short drive = [S+$A+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.669
.66A:
! 4476     media_state_offset = 0x90;
! Debug: eq int = const $90 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$90
mov	-4[bp],ax
!BCC_EOS
! 4477   else
! 4478     media_state_offset = 0x91;
jmp .66B
.669:
! Debug: eq int = const $91 to unsigned short media_state_offset = [S+$A-6] (used reg = )
mov	ax,#$91
mov	-4[bp],ax
!BCC_EOS
! 4479   write_byte(0x0040, 0x008B, config_data);
.66B:
! Debug: list unsigned char config_data = [S+$A-8] (used reg = )
mov	al,-6[bp]
xor	ah,ah
push	ax
! Debug: list int = const $8B (used reg = )
mov	ax,#$8B
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4480   write_byte(0x0040, media_state_offset, media_state);
! Debug: list unsigned char media_state = [S+$A-9] (used reg = )
mov	al,-7[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short media_state_offset = [S+$C-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4481   return(retval);
mov	ax,-2[bp]
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4482 }
! 4483   bx_bool
! 4484 floppy_drive_recal(drive)
! 4485   Bit16u drive;
export	_floppy_drive_recal
_floppy_drive_recal:
!BCC_EOS
! 4486 {
! 4487   Bit8u val8;
!BCC_EOS
! 4488   Bit16u curr_cyl_offset;
!BCC_EOS
! 4489   floppy_prepare_controller(drive);
push	bp
mov	bp,sp
add	sp,*-4
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4490   outb(0x03f5, 0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4491   outb(0x03f5, drive);
! Debug: list unsigned short drive = [S+6+2] (used reg = )
push	4[bp]
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4492 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  sti
! 4494 endasm
!BCC_ENDASM
!BCC_EOS
! 4495   do {
.66E:
! 4496     val8 = (read_byte(0x0040, 0x003e) & 0x80);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4497   } while ( val8 == 0 );
.66D:
! Debug: logeq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
test	al,al
je 	.66E
.66F:
!BCC_EOS
! 4498   val8 = 0;
.66C:
! Debug: eq int = const 0 to unsigned char val8 = [S+6-3] (used reg = )
xor	al,al
mov	-1[bp],al
!BCC_EOS
! 4499 #asm
!BCC_EOS
!BCC_ASM
_floppy_drive_recal.curr_cyl_offset	set	0
.floppy_drive_recal.curr_cyl_offset	set	-4
_floppy_drive_recal.val8	set	3
.floppy_drive_recal.val8	set	-1
_floppy_drive_recal.drive	set	8
.floppy_drive_recal.drive	set	4
  cli
! 4501 endasm
!BCC_ENDASM
!BCC_EOS
! 4502   val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+6-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4503   val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
mov	-1[bp],al
!BCC_EOS
! 4504   if (drive) {
mov	ax,4[bp]
test	ax,ax
je  	.670
.671:
! 4505     val8 |= 0x02;
! Debug: orab int = const 2 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*2
mov	-1[bp],al
!BCC_EOS
! 4506     curr_cyl_offset = 0x0095;
! Debug: eq int = const $95 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$95
mov	-4[bp],ax
!BCC_EOS
! 4507   } else {
jmp .672
.670:
! 4508     val8 |= 0x01;
! Debug: orab int = const 1 to unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
or	al,*1
mov	-1[bp],al
!BCC_EOS
! 4509     curr_cyl_offset = 0x0094;
! Debug: eq int = const $94 to unsigned short curr_cyl_offset = [S+6-6] (used reg = )
mov	ax,#$94
mov	-4[bp],ax
!BCC_EOS
! 4510   }
! 4511   write_byte(0x0040, 0x003e, val8);
.672:
! Debug: list unsigned char val8 = [S+6-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4512   write_byte(0x0040, curr_cyl_offset, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short curr_cyl_offset = [S+8-6] (used reg = )
push	-4[bp]
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4513   return(1);
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4514 }
! 4515   bx_bool
! 4516 floppy_drive_exists(drive)
! 4517   Bit16u drive;
export	_floppy_drive_exists
_floppy_drive_exists:
!BCC_EOS
! 4518 {
! 4519   Bit8u drive_type;
!BCC_EOS
! 4520   drive_type = inb_cmos(0x10);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4521   if (drive == 0)
! Debug: logeq int = const 0 to unsigned short drive = [S+4+2] (used reg = )
mov	ax,4[bp]
test	ax,ax
jne 	.673
.674:
! 4522     drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-1[bp],al
!BCC_EOS
! 4523   else
! 4524     drive_type &= 0x0f;
jmp .675
.673:
! Debug: andab int = const $F to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$F
mov	-1[bp],al
!BCC_EOS
! 4525   if ( drive_type == 0 )
.675:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+4-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.676
.677:
! 4526     return(0);
xor	ax,ax
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4527   else
! 4528     return(1);
jmp .678
.676:
mov	ax,*1
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4529 }
.678:
mov	sp,bp
pop	bp
ret
! 4530   void
! 4531 int13_diskette_function(DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS)
! 4532   Bit16u DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS;
export	_int13_diskette_function
_int13_diskette_function:
!BCC_EOS
! 4533 {
! 4534   Bit8u drive, num_sectors, track, sector, head, status;
!BCC_EOS
! 4535   Bit16u base_address, base_count, base_es;
!BCC_EOS
! 4536   Bit8u page, mode_register, val8, dor;
!BCC_EOS
! 4537   Bit8u return_status[7];
!BCC_EOS
! 4538   Bit8u drive_type, num_floppies, ah;
!BCC_EOS
! 4539   Bit16u es, last_addr;
!BCC_EOS
! 4540   ;
push	bp
mov	bp,sp
add	sp,*-$1E
!BCC_EOS
! 4541   ah = ( AX >> 8 );
! Debug: sr int = const 8 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	-$1A[bp],al
!BCC_EOS
! 4542   switch ( ah ) {
mov	al,-$1A[bp]
br 	.67B
! 4543     case 0x00:
! 4544 ;
.67C:
!BCC_EOS
! 4545       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4546       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.67D
.67E:
! 4547         AX 
! 4547 = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4548         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4549         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4550         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4551       }
! 4552       drive_type = inb_cmos(0x10);
.67D:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4553       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.67F
.680:
! 4554         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4555       else
! 4556         drive_type &= 0x0f;
jmp .681
.67F:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4557       if (drive_type == 0) {
.681:
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.682
.683:
! 4558         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4559         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4560         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4561         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4562       }
! 4563       AX = ((AX & 0x00ff) | ((0) << 8));
.682:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4564       set_diskette_ret_status(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4565       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4566       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4567       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4568     case 0x01:
! 4569       FLAGS &= 0xfffe;
.684:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4570       val8 = read_byte(0x0000, 0x0441);
! Debug: list int = const $441 (used reg = )
mov	ax,#$441
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4571       AX = ((AX & 0x00ff) | ((val8) << 8));
! Debug: sl int = const 8 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
mov	ah,al
xor	al,al
push	ax
! Debug: and int = const $FF to unsigned short AX = [S+$22+$14] (used reg = )
mov	al,$16[bp]
! Debug: or unsigned int (temp) = [S+$22-$22] to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,0+..FFDC[bp]
inc	sp
inc	sp
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4572       if (val8) {
mov	al,-$F[bp]
test	al,al
je  	.685
.686:
! 4573         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4574       }
! 4575       return;
.685:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4576     case 0x02:
! 4577     case 0x03:
.687:
! 4578     case 0x04:
.688:
! 4579       num_sectors = ( AX & 0x00ff );
.689:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4580       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4581       sector = ( CX & 0x00ff );
! Debug: and int = const $FF to unsigned short CX = [S+$20+$12] (used reg = )
mov	al,$14[bp]
! Debug: eq unsigned char = al+0 to unsigned char sector = [S+$20-6] (used reg = )
mov	-4[bp],al
!BCC_EOS
! 4582       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4583       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4584       if ((drive > 1) || (head > 1) || (sector == 0) ||
! 4585           (num_sectors == 0) || (num_sectors > 72)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.68B
.68F:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.68B
.68E:
! Debug: logeq int = const 0 to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
test	al,al
je  	.68B
.68D:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.68B
.68C:
! Debug: gt int = const $48 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$48
jbe 	.68A
.68B:
! 4586         ;
!BCC_EOS
! 4587         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4588         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4589         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4590         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4591         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4592       }
! 4593       if (floppy_drive_exists(drive) == 0) {
.68A:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.690
.691:
! 4594         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4595         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4596         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4597         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4598         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4599       }
! 4600       if (floppy_media_known(drive) == 0) {
.690:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.692
.693:
! 4601         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.694
.695:
! 4602           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4603           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4604           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4605           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4606           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4607         }
! 4608       }
.694:
! 4609       if (ah == 0x02) {
.692:
! Debug: logeq int = const 2 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*2
bne 	.696
.697:
! 4610         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4611         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4612         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4613         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.698
.699:
! 4614           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4615         }
! 4616         base_count = (num_sectors * 512) - 1;
.698:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4617         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4618         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.69A
.69B:
! 4619         
! 4619   AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4620           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4621           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4622           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4623           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4624         }
! 4625         ;
.69A:
!BCC_EOS
! 4626         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4627   ;
!BCC_EOS
! 4628         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4629         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4630         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4631   ;
!BCC_EOS
! 4632         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4633         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4634         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4635         mode_register = 0x46;
! Debug: eq int = const $46 to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$46
mov	-$E[bp],al
!BCC_EOS
! 4636   ;
!BCC_EOS
! 4637         outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4638   ;
!BCC_EOS
! 4639         outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4640   ;
!BCC_EOS
! 4641         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4642         ;
!BCC_EOS
! 4643         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4644         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4645         outb(0x03f5, 0xe6);
! Debug: list int = const $E6 (used reg = )
mov	ax,#$E6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4646         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4647         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4648         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4649         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4650         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4651         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4652         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4653         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4654 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4656 endasm
!BCC_ENDASM
!BCC_EOS
! 4657         do {
.69E:
! 4658           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4659           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.69F
.6A0:
! 4660             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4661             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4662             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4663             AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4664             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4665             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4666           }
! 4667           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.69F:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4668         } while ( val8 == 0 );
.69D:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.69E
.6A1:
!BCC_EOS
! 4669         val8 = 0;
.69C:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4670 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4672 endasm
!BCC_ENDASM
!BCC_EOS
! 4673         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4674         val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4675         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4676         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4677         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6A2
.6A3:
! 4678           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6A4+0 (used reg = )
mov	bx,#.6A4
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4679         return_status[0] = inb(0x3f5);
.6A2:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4680         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4681         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4682         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4683         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4684         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4685         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4686         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4687         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4688         write_byte(0x0040, 0x0044, 
! 4688 return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4689         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4690         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4691         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4692         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4693         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6A5
.6A6:
! 4694           AX = ((AX & 0x00ff) | ((0x20) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $2000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$2000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4695           set_diskette_ret_status(0x20);
! Debug: list int = const $20 (used reg = )
mov	ax,*$20
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4696           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4697           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4698           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4699         }
! 4700         set_diskette_current_cyl(drive, track);
.6A5:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4701         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4702         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4703         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4704       } else if (ah == 0x03) {
br 	.6A7
.696:
! Debug: logeq int = const 3 to unsigned char ah = [S+$20-$1C] (used reg = )
mov	al,-$1A[bp]
cmp	al,*3
bne 	.6A8
.6A9:
! 4705         page = (ES >> 12);
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4706         base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4707         base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4708         if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6AA
.6AB:
! 4709           page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4710         }
! 4711         base_count = (num_sectors * 512) - 1;
.6AA:
! Debug: mul int = const $200 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
mov	cx,#$200
imul	cx
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4712         last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4713         if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6AC
.6AD:
! 4714           AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4715           set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4716           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4717           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4718           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4719         }
! 4720         ;
.6AC:
!BCC_EOS
! 4721         outb(0x000a, 0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4722         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4723         outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4724         outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4725         outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4726         outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4727         outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4728         mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4729         outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4730         outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4731         ;
!BCC_EOS
! 4732         outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4733         floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4734         outb(0x03f5, 0xc5);
! Debug: list int = const $C5 (used reg = )
mov	ax,#$C5
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4735         outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4736         outb(0x03f5, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4737         outb(0x03f5, head);
! Debug: list unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4738         outb(0x03f5, sector);
! Debug: list unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4739         outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4740         outb(0x03f5, sector + num_sectors - 1);
! Debug: add unsigned char num_sectors = [S+$20-4] to unsigned char sector = [S+$20-6] (used reg = )
mov	al,-4[bp]
xor	ah,ah
add	al,-2[bp]
adc	ah,*0
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax-1 (used reg = )
dec	ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4741         outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4742         outb(0x03f5, 0xff);
! Debug: list int = const $FF (used reg = )
mov	ax,#$FF
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4743 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        sti
! 4745 endasm
!BCC_ENDASM
!BCC_EOS
! 4746         do {
.6B0:
! 4747           val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4748           if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6B1
.6B2:
! 4749             floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4750             AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4751             set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4752  
! 4752            AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4753             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4754             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4755           }
! 4756           val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6B1:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4757         } while ( val8 == 0 );
.6AF:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6B0
.6B3:
!BCC_EOS
! 4758         val8 = 0;
.6AE:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4759 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
        cli
! 4761 endasm
!BCC_ENDASM
!BCC_EOS
! 4762         val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4763         val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4764         write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4765         val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4766         if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6B4
.6B5:
! 4767           bios_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6B6+0 (used reg = )
mov	bx,#.6B6
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4768         return_status[0] = inb(0x3f5);
.6B4:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4769         return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4770         return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4771         return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4772         return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4773         return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4774         return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4775         write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4776         write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4777         write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4778         write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4779         write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4780         write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4781         write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4782         if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6B7
.6B8:
! 4783           if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6B9
.6BA:
! 4784             AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4785             FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4786             return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4787           } else {
jmp .6BB
.6B9:
! 4788             bios_printf((2 | 4 | 1), "int13_diskette_function: read error\n");
! Debug: list * char = .6BC+0 (used reg = )
mov	bx,#.6BC
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4789           }
! 4790         }
.6BB:
! 4791         set_diskette_current_cyl(drive, track);
.6B7:
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4792         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4793         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4794         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4795       } else {
jmp .6BD
.6A8:
! 4796         set_diskette_current_cyl(drive, track);
! Debug: list unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
xor	ah,ah
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4797         FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4798         AX = ((AX & 0x00ff) | ((0x00) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4799         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4800       }
! 4801       break;
.6BD:
.6A7:
br 	.679
!BCC_EOS
! 4802     case 0x05:
! 4803 ;
.6BE:
!BCC_EOS
! 4804       num_sectors = ( AX & 0x00ff );
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: eq unsigned char = al+0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 4805       track = ( CX >> 8 );
! Debug: sr int = const 8 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,$14[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char track = [S+$20-5] (used reg = )
mov	-3[bp],al
!BCC_EOS
! 4806       head = ( DX >> 8 );
! Debug: sr int = const 8 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
mov	al,ah
xor	ah,ah
! Debug: eq unsigned int = ax+0 to unsigned char head = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 4807       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4808       if ((drive > 1) || (head > 1) || (track > 79) ||
! 4809           (num_sectors == 0) || (num_sectors > 18)) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
ja  	.6C0
.6C4:
! Debug: gt int = const 1 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
cmp	al,*1
ja  	.6C0
.6C3:
! Debug: gt int = const $4F to unsigned char track = [S+$20-5] (used reg = )
mov	al,-3[bp]
cmp	al,*$4F
ja  	.6C0
.6C2:
! Debug: logeq int = const 0 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
test	al,al
je  	.6C0
.6C1:
! Debug: gt int = const $12 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
cmp	al,*$12
jbe 	.6BF
.6C0:
! 4810         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4811         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4812   
! 4812       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4813       }
! 4814       if (floppy_drive_exists(drive) == 0) {
.6BF:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_drive_exists+0 (used reg = )
call	_floppy_drive_exists
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6C5
.6C6:
! 4815         AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4816         set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4817         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4818         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4819       }
! 4820       if (floppy_media_known(drive) == 0) {
.6C5:
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_known+0 (used reg = )
call	_floppy_media_known
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6C7
.6C8:
! 4821         if (floppy_media_sense(drive) == 0) {
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () unsigned short = floppy_media_sense+0 (used reg = )
call	_floppy_media_sense
inc	sp
inc	sp
! Debug: logeq int = const 0 to unsigned short = ax+0 (used reg = )
test	ax,ax
jne 	.6C9
.6CA:
! 4822           AX = ((AX & 0x00ff) | ((0x0C) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $C00 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$C00
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4823           set_diskette_ret_status(0x0C);
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4824           AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4825           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4826           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4827         }
! 4828       }
.6C9:
! 4829       page = (ES >> 12);
.6C7:
! Debug: sr int = const $C to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	al,ah
xor	ah,ah
mov	cl,*4
shr	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned char page = [S+$20-$F] (used reg = )
mov	-$D[bp],al
!BCC_EOS
! 4830       base_es = (ES << 4);
! Debug: sl int = const 4 to unsigned short ES = [S+$20+4] (used reg = )
mov	ax,6[bp]
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short base_es = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 4831       base_address = base_es + BX;
! Debug: add unsigned short BX = [S+$20+$E] to unsigned short base_es = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
add	ax,$10[bp]
! Debug: eq unsigned int = ax+0 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 4832       if ( base_address < base_es ) {
! Debug: lt unsigned short base_es = [S+$20-$E] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
cmp	ax,-$C[bp]
jae 	.6CB
.6CC:
! 4833         page++;
! Debug: postinc unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
inc	ax
mov	-$D[bp],al
!BCC_EOS
! 4834       }
! 4835       base_count = (num_sectors * 4) - 1;
.6CB:
! Debug: mul int = const 4 to unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: sub int = const 1 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned int = ax-1 to unsigned short base_count = [S+$20-$C] (used reg = )
dec	ax
mov	-$A[bp],ax
!BCC_EOS
! 4836       last_addr = base_address + base_count;
! Debug: add unsigned short base_count = [S+$20-$C] to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
add	ax,-$A[bp]
! Debug: eq unsigned int = ax+0 to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	-$1E[bp],ax
!BCC_EOS
! 4837       if (last_addr < base_address) {
! Debug: lt unsigned short base_address = [S+$20-$A] to unsigned short last_addr = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,-8[bp]
jae 	.6CD
.6CE:
! 4838         AX = ((AX & 0x00ff) | ((0x09) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $900 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$900
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4839         set_diskette_ret_status(0x09);
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4840         AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4841         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4842         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4843       }
! 4844       outb(0x000a, 0x06);
.6CD:
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4845       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4846       outb(0x0004, base_address);
! Debug: list unsigned short base_address = [S+$20-$A] (used reg = )
push	-8[bp]
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4847       outb(0x0004, base_address>>8);
! Debug: sr int = const 8 to unsigned short base_address = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4848       outb(0x000c, 0x00);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4849       outb(0x0005, base_count);
! Debug: list unsigned short base_count = [S+$20-$C] (used reg = )
push	-$A[bp]
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4850       outb(0x0005, base_count>>8);
! Debug: sr int = const 8 to unsigned short base_count = [S+$20-$C] (used reg = )
mov	ax,-$A[bp]
mov	al,ah
xor	ah,ah
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4851       mode_register = 0x4a;
! Debug: eq int = const $4A to unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,*$4A
mov	-$E[bp],al
!BCC_EOS
! 4852       outb(0x000b, mode_register);
! Debug: list unsigned char mode_register = [S+$20-$10] (used reg = )
mov	al,-$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4853       outb(0x0081, page);
! Debug: list unsigned char page = [S+$20-$F] (used reg = )
mov	al,-$D[bp]
xor	ah,ah
push	ax
! Debug: list int = const $81 (used reg = )
mov	ax,#$81
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4854       outb(0x000a, 0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $A (used reg = )
mov	ax,*$A
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4855       floppy_prepare_controller(drive);
! Debug: list unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = floppy_prepare_controller+0 (used reg = )
call	_floppy_prepare_controller
inc	sp
inc	sp
!BCC_EOS
! 4856       outb(0x03f5, 0x4d);
! Debug: list int = const $4D (used reg = )
mov	ax,*$4D
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4857       outb(0x03f5, (head << 2) | drive);
! Debug: sl int = const 2 to unsigned char head = [S+$20-7] (used reg = )
mov	al,-5[bp]
xor	ah,ah
shl	ax,*1
shl	ax,*1
! Debug: or unsigned char drive = [S+$20-3] to unsigned int = ax+0 (used reg = )
or	al,-1[bp]
! Debug: list unsigned int = ax+0 (used reg = )
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4858       outb(0x03f5, 2);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4859       outb(0x03f5, num_sectors);
! Debug: list unsigned char num_sectors = [S+$20-4] (used reg = )
mov	al,-2[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4860       outb(0x03f5, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4861       outb(0x03f5, 0xf6);
! Debug: list int = const $F6 (used reg = )
mov	ax,#$F6
push	ax
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 4862 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      sti
! 4864 endasm
!BCC_ENDASM
!BCC_EOS
! 4865       do {
.6D1:
! 4866         val8 = read_byte(0x0040, 0x0040);
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4867         if (val8 == 0) {
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
jne 	.6D2
.6D3:
! 4868           floppy_reset_controller();
! Debug: func () void = floppy_reset_controller+0 (used reg = )
call	_floppy_reset_controller
!BCC_EOS
! 4869           AX = ((AX & 0x00ff) | ((0x80) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const -$8000 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#-$8000
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4870           set_diskette_ret_status(0x80);
! Debug: list int = const $80 (used reg = )
mov	ax,#$80
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4871           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4872           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4873         }
! 4874         val8 = (read_byte(0x0040, 0x003e) & 0x80);
.6D2:
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: and int = const $80 to unsigned char = al+0 (used reg = )
and	al,#$80
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4875       } while ( val8 == 0 );
.6D0:
! Debug: logeq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
test	al,al
je 	.6D1
.6D4:
!BCC_EOS
! 4876       val8 = 0;
.6CF:
! Debug: eq int = const 0 to unsigned char val8 = [S+$20-$11] (used reg = )
xor	al,al
mov	-$F[bp],al
!BCC_EOS
! 4877 #asm
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      cli
! 4879 endasm
!BCC_ENDASM
!BCC_EOS
! 4880       val8 = read_byte(0x0040, 0x003e);
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4881       val8 &= 0x7f;
! Debug: andab int = const $7F to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,*$7F
mov	-$F[bp],al
!BCC_EOS
! 4882       write_byte(0x0040, 0x003e, val8);
! Debug: list unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const $3E (used reg = )
mov	ax,*$3E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4883       val8 = inb(0x3f4);
! Debug: list int = const $3F4 (used reg = )
mov	ax,#$3F4
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	-$F[bp],al
!BCC_EOS
! 4884       if ( (val8 & 0xc0) != 0xc0 )
! Debug: and int = const $C0 to unsigned char val8 = [S+$20-$11] (used reg = )
mov	al,-$F[bp]
and	al,#$C0
! Debug: ne int = const $C0 to unsigned char = al+0 (used reg = )
cmp	al,#$C0
je  	.6D5
.6D6:
! 4885         bi
! 4885 os_printf((2 | 4 | 1), "int13_diskette: ctrl not ready\n");
! Debug: list * char = .6D7+0 (used reg = )
mov	bx,#.6D7
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4886       return_status[0] = inb(0x3f5);
.6D5:
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	-$17[bp],al
!BCC_EOS
! 4887       return_status[1] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	-$16[bp],al
!BCC_EOS
! 4888       return_status[2] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$17] (used reg = )
mov	-$15[bp],al
!BCC_EOS
! 4889       return_status[3] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$16] (used reg = )
mov	-$14[bp],al
!BCC_EOS
! 4890       return_status[4] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$15] (used reg = )
mov	-$13[bp],al
!BCC_EOS
! 4891       return_status[5] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$14] (used reg = )
mov	-$12[bp],al
!BCC_EOS
! 4892       return_status[6] = inb(0x3f5);
! Debug: list int = const $3F5 (used reg = )
mov	ax,#$3F5
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char return_status = [S+$20-$13] (used reg = )
mov	-$11[bp],al
!BCC_EOS
! 4893       write_byte(0x0040, 0x0042, return_status[0]);
! Debug: list unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
xor	ah,ah
push	ax
! Debug: list int = const $42 (used reg = )
mov	ax,*$42
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4894       write_byte(0x0040, 0x0043, return_status[1]);
! Debug: list unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
xor	ah,ah
push	ax
! Debug: list int = const $43 (used reg = )
mov	ax,*$43
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4895       write_byte(0x0040, 0x0044, return_status[2]);
! Debug: list unsigned char return_status = [S+$20-$17] (used reg = )
mov	al,-$15[bp]
xor	ah,ah
push	ax
! Debug: list int = const $44 (used reg = )
mov	ax,*$44
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4896       write_byte(0x0040, 0x0045, return_status[3]);
! Debug: list unsigned char return_status = [S+$20-$16] (used reg = )
mov	al,-$14[bp]
xor	ah,ah
push	ax
! Debug: list int = const $45 (used reg = )
mov	ax,*$45
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4897       write_byte(0x0040, 0x0046, return_status[4]);
! Debug: list unsigned char return_status = [S+$20-$15] (used reg = )
mov	al,-$13[bp]
xor	ah,ah
push	ax
! Debug: list int = const $46 (used reg = )
mov	ax,*$46
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4898       write_byte(0x0040, 0x0047, return_status[5]);
! Debug: list unsigned char return_status = [S+$20-$14] (used reg = )
mov	al,-$12[bp]
xor	ah,ah
push	ax
! Debug: list int = const $47 (used reg = )
mov	ax,*$47
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4899       write_byte(0x0040, 0x0048, return_status[6]);
! Debug: list unsigned char return_status = [S+$20-$13] (used reg = )
mov	al,-$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $48 (used reg = )
mov	ax,*$48
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 4900       if ( (return_status[0] & 0xc0) != 0 ) {
! Debug: and int = const $C0 to unsigned char return_status = [S+$20-$19] (used reg = )
mov	al,-$17[bp]
and	al,#$C0
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6D8
.6D9:
! 4901         if ( (return_status[1] & 0x02) != 0 ) {
! Debug: and int = const 2 to unsigned char return_status = [S+$20-$18] (used reg = )
mov	al,-$16[bp]
and	al,*2
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.6DA
.6DB:
! 4902           AX = 0x0300;
! Debug: eq int = const $300 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,#$300
mov	$16[bp],ax
!BCC_EOS
! 4903           FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4904           return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4905         } else {
jmp .6DC
.6DA:
! 4906           bios_printf((2 | 4 | 1), "int13_diskette_function: write error\n");
! Debug: list * char = .6DD+0 (used reg = )
mov	bx,#.6DD
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4907         }
! 4908       }
.6DC:
! 4909       AX = ((AX & 0x00ff) | ((0) << 8));
.6D8:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4910       set_diskette_ret_status(0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 4911       set_diskette_current_cyl(drive, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned char drive = [S+$22-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: func () void = set_diskette_current_cyl+0 (used reg = )
call	_set_diskette_current_cyl
add	sp,*4
!BCC_EOS
! 4912       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4913       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4914     case 0x08:
! 4915 ;
.6DE:
!BCC_EOS
! 4916       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4917       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.6DF
.6E0:
! 4918         AX = 0;
! Debug: eq int = const 0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ax,ax
mov	$16[bp],ax
!BCC_EOS
! 4919         BX = 0;
! Debug: eq int = const 0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ax,ax
mov	$10[bp],ax
!BCC_EOS
! 4920         CX = 0;
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4921         DX = 0;
! Debug: eq int = const 0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 4922         ES = 0;
! Debug: eq int = const 0 to unsigned short ES = [S+$20+4] (used reg = )
xor	ax,ax
mov	6[bp],ax
!BCC_EOS
! 4923         DI = 0;
! Debug: eq int = const 0 to unsigned short DI = [S+$20+6] (used reg = )
xor	ax,ax
mov	8[bp],ax
!BCC_EOS
! 4924         DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4925         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4926         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4927         }
! 4928       drive_type = inb_cmos(0x10);
.6DF:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 4929       num_floppies = 0;
! Debug: eq int = const 0 to unsigned char num_floppies = [S+$20-$1B] (used reg = )
xor	al,al
mov	-$19[bp],al
!BCC_EOS
! 4930       if (drive_type & 0xf0)
! Debug: and int = const $F0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,#$F0
test	al,al
je  	.6E1
.6E2:
! 4931         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4932       if (drive_type & 0x0f)
.6E1:
! Debug: and int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
test	al,al
je  	.6E3
.6E4:
! 4933         num_floppies++;
! Debug: postinc unsigned char num_floppies = [S+$20-$1B] (used reg = )
mov	al,-$19[bp]
inc	ax
mov	-$19[bp],al
!BCC_EOS
! 4934       if (drive == 0)
.6E3:
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
bne 	.6E5
.6E6:
! 4935         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 4936       else
! 4937         drive_type &= 0x0f;
jmp .6E7
.6E5:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 4938       BX = ((BX & 0x00ff) | ((0) << 8));
.6E7:
! Debug: and int = const $FF to unsigned short BX = [S+$20+$E] (used reg = )
mov	al,$10[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short BX = [S+$20+$E] (used reg = )
xor	ah,ah
mov	$10[bp],ax
!BCC_EOS
! 4939       BX = ((BX & 0xff00) | (drive_type));
! Debug: and unsigned int = const $FF00 to unsigned short BX = [S+$20+$E] (used reg = )
mov	ax,$10[bp]
xor	al,al
! Debug: or unsigned char drive_type = [S+$20-$1A] to unsigned int = ax+0 (used reg = )
or	al,-$18[bp]
! Debug: eq unsigned int = ax+0 to unsigned short BX = [S+$20+$E] (used reg = )
mov	$10[bp],ax
!BCC_EOS
! 4940       AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4941       AX = ((AX & 0xff00) | (0));
! Debug: and unsigned int = const $FF00 to unsigned short AX = [S+$20+$14] (used reg = )
mov	ax,$16[bp]
xor	al,al
! Debug: or int = const 0 to unsigned int = ax+0 (used reg = )
or	al,*0
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 4942       DX = ((DX & 0xff00) | (num_floppies));
! Debug: and unsigned int = const $FF00 to unsigned short DX = [S+$20+$10] (used reg = )
mov	ax,$12[bp]
xor	al,al
! Debug: or unsigned char num_floppies = [S+$20-$1B] to unsigned int = ax+0 (used reg = )
or	al,-$19[bp]
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4943       switch (drive_type) {
mov	al,-$18[bp]
br 	.6EA
! 4944         case 0:
! 4945           CX = 0;
.6EB:
! Debug: eq int = const 0 to unsigned short CX = [S+$20+$12] (used reg = )
xor	ax,ax
mov	$14[bp],ax
!BCC_EOS
! 4946           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4947           break;
br 	.6E8
!BCC_EOS
! 4948         case 1:
! 4949           CX = 0x2709;
.6EC:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 4950           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4951      
! 4951      break;
br 	.6E8
!BCC_EOS
! 4952         case 2:
! 4953           CX = 0x4f0f;
.6ED:
! Debug: eq int = const $4F0F to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F0F
mov	$14[bp],ax
!BCC_EOS
! 4954           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4955           break;
br 	.6E8
!BCC_EOS
! 4956         case 3:
! 4957           CX = 0x4f09;
.6EE:
! Debug: eq int = const $4F09 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F09
mov	$14[bp],ax
!BCC_EOS
! 4958           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4959           break;
br 	.6E8
!BCC_EOS
! 4960         case 4:
! 4961           CX = 0x4f12;
.6EF:
! Debug: eq int = const $4F12 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F12
mov	$14[bp],ax
!BCC_EOS
! 4962           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4963           break;
br 	.6E8
!BCC_EOS
! 4964         case 5:
! 4965           CX = 0x4f24;
.6F0:
! Debug: eq int = const $4F24 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$4F24
mov	$14[bp],ax
!BCC_EOS
! 4966           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4967           break;
jmp .6E8
!BCC_EOS
! 4968         case 6:
! 4969           CX = 0x2708;
.6F1:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 4970           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4971           break;
jmp .6E8
!BCC_EOS
! 4972         case 7:
! 4973           CX = 0x2709;
.6F2:
! Debug: eq int = const $2709 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2709
mov	$14[bp],ax
!BCC_EOS
! 4974           DX = ((DX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short DX = [S+$20+$10] (used reg = )
xor	ah,ah
mov	$12[bp],ax
!BCC_EOS
! 4975           break;
jmp .6E8
!BCC_EOS
! 4976         case 8:
! 4977           CX = 0x2708;
.6F3:
! Debug: eq int = const $2708 to unsigned short CX = [S+$20+$12] (used reg = )
mov	ax,#$2708
mov	$14[bp],ax
!BCC_EOS
! 4978           DX = ((DX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short DX = [S+$20+$10] (used reg = )
mov	al,$12[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short DX = [S+$20+$10] (used reg = )
mov	$12[bp],ax
!BCC_EOS
! 4979           break;
jmp .6E8
!BCC_EOS
! 4980         default:
! 4981           bios_printf((2 | 4 | 1), "floppy: int13: bad floppy type\n");
.6F4:
! Debug: list * char = .6F5+0 (used reg = )
mov	bx,#.6F5
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 4982         }
! 4983 #asm
jmp .6E8
.6EA:
sub	al,*0
jb 	.6F4
cmp	al,*8
ja  	.6F6
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.6F7[bx]
.6F7:
.word	.6EB
.word	.6EC
.word	.6ED
.word	.6EE
.word	.6EF
.word	.6F0
.word	.6F1
.word	.6F2
.word	.6F3
.6F6:
jmp	.6F4
.6E8:
!BCC_EOS
!BCC_ASM
_int13_diskette_function.BP	set	$2A
.int13_diskette_function.BP	set	$C
_int13_diskette_function.CS	set	$38
.int13_diskette_function.CS	set	$1A
_int13_diskette_function.CX	set	$32
.int13_diskette_function.CX	set	$14
_int13_diskette_function.base_address	set	$16
.int13_diskette_function.base_address	set	-8
_int13_diskette_function.DI	set	$26
.int13_diskette_function.DI	set	8
_int13_diskette_function.FLAGS	set	$3A
.int13_diskette_function.FLAGS	set	$1C
_int13_diskette_function.base_count	set	$14
.int13_diskette_function.base_count	set	-$A
_int13_diskette_function.sector	set	$1A
.int13_diskette_function.sector	set	-4
_int13_diskette_function.DS	set	$22
.int13_diskette_function.DS	set	4
_int13_diskette_function.head	set	$19
.int13_diskette_function.head	set	-5
_int13_diskette_function.ELDX	set	$2C
.int13_diskette_function.ELDX	set	$E
_int13_diskette_function.dor	set	$E
.int13_diskette_function.dor	set	-$10
_int13_diskette_function.DX	set	$30
.int13_diskette_function.DX	set	$12
_int13_diskette_function.return_status	set	7
.int13_diskette_function.return_status	set	-$17
_int13_diskette_function.es	set	2
.int13_diskette_function.es	set	-$1C
_int13_diskette_function.mode_register	set	$10
.int13_diskette_function.mode_register	set	-$E
_int13_diskette_function.ES	set	$24
.int13_diskette_function.ES	set	6
_int13_diskette_function.base_es	set	$12
.int13_diskette_function.base_es	set	-$C
_int13_diskette_function.track	set	$1B
.int13_diskette_function.track	set	-3
_int13_diskette_function.SI	set	$28
.int13_diskette_function.SI	set	$A
_int13_diskette_function.drive_type	set	6
.int13_diskette_function.drive_type	set	-$18
_int13_diskette_function.num_sectors	set	$1C
.int13_diskette_function.num_sectors	set	-2
_int13_diskette_function.IP	set	$36
.int13_diskette_function.IP	set	$18
_int13_diskette_function.status	set	$18
.int13_diskette_function.status	set	-6
_int13_diskette_function.AX	set	$34
.int13_diskette_function.AX	set	$16
_int13_diskette_function.val8	set	$F
.int13_diskette_function.val8	set	-$F
_int13_diskette_function.last_addr	set	0
.int13_diskette_function.last_addr	set	-$1E
_int13_diskette_function.page	set	$11
.int13_diskette_function.page	set	-$D
_int13_diskette_function.ah	set	4
.int13_diskette_function.ah	set	-$1A
_int13_diskette_function.drive	set	$1D
.int13_diskette_function.drive	set	-1
_int13_diskette_function.num_floppies	set	5
.int13_diskette_function.num_floppies	set	-$19
_int13_diskette_function.BX	set	$2E
.int13_diskette_function.BX	set	$10
      push bp
      mov bp, sp
      mov ax, #diskette_param_table2
      mov _int13_diskette_function.DI+2[bp], ax
      mov _int13_diskette_function.ES+2[bp], cs
      pop bp
! 4990 endasm
!BCC_ENDASM
!BCC_EOS
! 4991       FLAGS &= 0xfffe;
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 4992       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 4993     case 0x15:
! 4994 ;
.6F8:
!BCC_EOS
! 4995       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 4996       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.6F9
.6FA:
! 4997         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 4998         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 4999         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5000         }
! 5001       drive_type = inb_cmos(0x10);
.6F9:
! Debug: list int = const $10 (used reg = )
mov	ax,*$10
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	-$18[bp],al
!BCC_EOS
! 5002       if (drive == 0)
! Debug: logeq int = const 0 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
test	al,al
jne 	.6FB
.6FC:
! 5003         drive_type >>= 4;
! Debug: srab int = const 4 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
xor	ah,ah
mov	cl,*4
shr	ax,cl
mov	-$18[bp],al
!BCC_EOS
! 5004       else
! 5005         drive_type &= 0x0f;
jmp .6FD
.6FB:
! Debug: andab int = const $F to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
and	al,*$F
mov	-$18[bp],al
!BCC_EOS
! 5006       FLAGS &= 0xfffe;
.6FD:
! Debug: andab unsigned int = const $FFFE to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
and	al,#$FE
mov	$1C[bp],ax
!BCC_EOS
! 5007       if (drive_type==0) {
! Debug: logeq int = const 0 to unsigned char drive_type = [S+$20-$1A] (used reg = )
mov	al,-$18[bp]
test	al,al
jne 	.6FE
.6FF:
! 5008         AX = ((AX & 0x00ff) | ((0) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const 0 to unsigned char = al+0 (used reg = )
or	al,*0
! Debug: eq unsigned char = al+0 to unsigned short AX = [S+$20+$14] (used reg = )
xor	ah,ah
mov	$16[bp],ax
!BCC_EOS
! 5009         }
! 5010       else {
jmp .700
.6FE:
! 5011         AX = ((AX & 0x00ff) | ((1) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5012         }
! 5013       return;
.700:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5014     case 0x16:
! 5015 ;
.701:
!BCC_EOS
! 5016       drive = ( ELDX & 0x00ff );
! Debug: and int = const $FF to unsigned short ELDX = [S+$20+$C] (used reg = )
mov	al,$E[bp]
! Debug: eq unsigned char = al+0 to unsigned char drive = [S+$20-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5017       if (drive > 1) {
! Debug: gt int = const 1 to unsigned char drive = [S+$20-3] (used reg = )
mov	al,-1[bp]
cmp	al,*1
jbe 	.702
.703:
! 5018         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5019         set_diskette_ret_status(0x01);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5020         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5021         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5022         }
! 5023       AX = ((AX & 0x00ff) | ((0x06) << 8));
.702:
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $600 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$600
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5024       set_diskette_ret_status(0x06);
! Debug: list int = const 6 (used reg = )
mov	ax,*6
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5025       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5026       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5027     case 0x17:
! 5028 ;
.704:
!BCC_EOS
! 5029       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5030       set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5031       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5032       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5033     case 0x18:
! 5034 ;
.705:
!BCC_EOS
! 5035       AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5036       set_d
! 5036 iskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5037       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5038       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5039     default:
! 5040         ;
.706:
!BCC_EOS
! 5041         AX = ((AX & 0x00ff) | ((0x01) << 8));
! Debug: and int = const $FF to unsigned short AX = [S+$20+$14] (used reg = )
mov	al,$16[bp]
! Debug: or int = const $100 to unsigned char = al+0 (used reg = )
xor	ah,ah
or	ax,#$100
! Debug: eq unsigned int = ax+0 to unsigned short AX = [S+$20+$14] (used reg = )
mov	$16[bp],ax
!BCC_EOS
! 5042         set_diskette_ret_status(1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = set_diskette_ret_status+0 (used reg = )
call	_set_diskette_ret_status
inc	sp
inc	sp
!BCC_EOS
! 5043         FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+$20+$1A] (used reg = )
mov	ax,$1C[bp]
or	al,*1
mov	$1C[bp],ax
!BCC_EOS
! 5044         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5045     }
! 5046 }
jmp .679
.67B:
sub	al,*0
jb 	.706
cmp	al,*8
ja  	.707
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.708[bx]
.708:
.word	.67C
.word	.684
.word	.687
.word	.688
.word	.689
.word	.6BE
.word	.706
.word	.706
.word	.6DE
.707:
sub	al,*$15
beq 	.6F8
sub	al,*1
beq 	.701
sub	al,*1
beq 	.704
sub	al,*1
beq 	.705
jmp	.706
.679:
..FFDC	=	-$20
mov	sp,bp
pop	bp
ret
! 5047  void
! Register BX used in function int13_diskette_function
! 5048 set_diskette_ret_status(value)
! 5049   Bit8u value;
export	_set_diskette_ret_status
_set_diskette_ret_status:
!BCC_EOS
! 5050 {
! 5051   write_byte(0x0040, 0x0041, value);
push	bp
mov	bp,sp
! Debug: list unsigned char value = [S+2+2] (used reg = )
mov	al,4[bp]
xor	ah,ah
push	ax
! Debug: list int = const $41 (used reg = )
mov	ax,*$41
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5052 }
pop	bp
ret
! 5053   void
! 5054 set_diskette_current_cyl(drive, cyl)
! 5055   Bit8u drive;
export	_set_diskette_current_cyl
_set_diskette_current_cyl:
!BCC_EOS
! 5056   Bit8u cyl;
!BCC_EOS
! 5057 {
! 5058   if (drive > 1)
push	bp
mov	bp,sp
! Debug: gt int = const 1 to unsigned char drive = [S+2+2] (used reg = )
mov	al,4[bp]
cmp	al,*1
jbe 	.709
.70A:
! 5059     bios_printf((2 | 4 | 1), "set_diskette_current_cyl(): drive > 1\n");
! Debug: list * char = .70B+0 (used reg = )
mov	bx,#.70B
push	bx
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
mov	sp,bp
!BCC_EOS
! 5060   write_byte(0x0040, 0x0094+drive, cyl);
.709:
! Debug: list unsigned char cyl = [S+2+4] (used reg = )
mov	al,6[bp]
xor	ah,ah
push	ax
! Debug: add unsigned char drive = [S+4+2] to int = const $94 (used reg = )
! Debug: expression subtree swapping
mov	al,4[bp]
xor	ah,ah
! Debug: list unsigned int = ax+$94 (used reg = )
add	ax,#$94
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
mov	sp,bp
!BCC_EOS
! 5061 }
pop	bp
ret
! 5062   void
! Register BX used in function set_diskette_current_cyl
! 5063 determine_floppy_media(drive)
! 5064   Bit16u drive;
export	_determine_floppy_media
_determine_floppy_media:
!BCC_EOS
! 5065 {
! 5066 }
ret
! 5067   void
! 5068 int17_function(regs, ds, iret_addr)
! 5069   pusha_regs_t regs;
export	_int17_function
_int17_function:
!BCC_EOS
! 5070   Bit16u ds;
!BCC_EOS
! 5071   iret_addr_t iret_addr;
!BCC_EOS
! 5072 {
! 5073   Bit16u addr,timeout;
!BCC_EOS
! 5074   Bit8u val8;
!BCC_EOS
! 5075 #asm
push	bp
mov	bp,sp
add	sp,*-6
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
  sti
! 5077 endasm
!BCC_ENDASM
!BCC_EOS
! 5078   addr = read_word(0x0040, (regs.u.r16.dx << 1) + 8);
! Debug: sl int = const 1 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
shl	ax,*1
! Debug: add int = const 8 to unsigned int = ax+0 (used reg = )
! Debug: list unsigned int = ax+8 (used reg = )
add	ax,*8
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short addr = [S+8-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5079   if ((regs.u.r8.ah < 3) && (regs.u.r16.dx < 3) && (addr > 0)) {
! Debug: lt int = const 3 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*3
bhis	.70C
.70F:
! Debug: lt int = const 3 to unsigned short regs = [S+8+$C] (used reg = )
mov	ax,$E[bp]
cmp	ax,*3
bhis	.70C
.70E:
! Debug: gt int = const 0 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
test	ax,ax
beq 	.70C
.70D:
! 5080     timeout = read_byte(0x0040, 0x0078 + regs.u.r16.dx) << 8;
! Debug: add unsigned short regs = [S+8+$C] to int = const $78 (used reg = )
! Debug: expression subtree swapping
mov	ax,$E[bp]
! Debug: list unsigned int = ax+$78 (used reg = )
add	ax,*$78
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: sl int = const 8 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	ah,al
xor	al,al
! Debug: eq unsigned int = ax+0 to unsigned short timeout = [S+8-6] (used reg = )
mov	-4[bp],ax
!BCC_EOS
! 5081     if (regs.u.r8.ah == 0) {
! Debug: logeq int = const 0 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
test	al,al
jne 	.710
.711:
! 5082       outb(addr, regs.u.r8.al);
! Debug: list unsigned char regs = [S+8+$10] (used reg = )
mov	al,$12[bp]
xor	ah,ah
push	ax
! Debug: list unsigned short addr = [S+$A-4] (used reg = )
push	-2[bp]
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5083       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5084       outb(addr+2, val8 | 0x01);
! Debug: or int = const 1 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*1
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5085 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5087 endasm
!BCC_ENDASM
!BCC_EOS
! 5088       outb(addr+2, val8 & ~0x01);
! Debug: and int = const -2 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5089       while (((inb(addr+1) & 0x40) == 0x40) && (timeout)) {
jmp .713
.714:
! 5090         timeout--;
! Debug: postdec unsigned short timeout = [S+8-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5091       }
! 5092     }
.713:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $40 to unsigned char = al+0 (used reg = )
and	al,*$40
! Debug: logeq int = const $40 to unsigned char = al+0 (used reg = )
cmp	al,*$40
jne 	.715
.716:
mov	ax,-4[bp]
test	ax,ax
jne	.714
.715:
.712:
! 5093     if (regs.u.r8.ah == 1) {
.710:
! Debug: logeq int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
cmp	al,*1
jne 	.717
.718:
! 5094       val8 = inb(addr+2);
! Debug: add int = const 2 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5095       outb(addr+2, val8 & ~0x04);
! Debug: and int = const -5 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
and	al,#$FB
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5096 #asm
!BCC_EOS
!BCC_ASM
_int17_function.ds	set	$1A
.int17_function.ds	set	$14
_int17_function.timeout	set	2
.int17_function.timeout	set	-4
_int17_function.val8	set	1
.int17_function.val8	set	-5
_int17_function.iret_addr	set	$1C
.int17_function.iret_addr	set	$16
_int17_function.addr	set	4
.int17_function.addr	set	-2
_int17_function.regs	set	$A
.int17_function.regs	set	4
      nop
! 5098 endasm
!BCC_ENDASM
!BCC_EOS
! 5099       outb(addr+2, val8 | 0x04);
! Debug: or int = const 4 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
or	al,*4
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: add int = const 2 to unsigned short addr = [S+$A-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+2 (used reg = )
inc	ax
inc	ax
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5100     }
! 5101     val8 = inb(addr+1);
.717:
! Debug: add int = const 1 to unsigned short addr = [S+8-4] (used reg = )
mov	ax,-2[bp]
! Debug: list unsigned int = ax+1 (used reg = )
inc	ax
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+8-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5102     regs.u.r8.ah = (val8 ^ 0x48);
! Debug: eor int = const $48 to unsigned char val8 = [S+8-7] (used reg = )
mov	al,-5[bp]
xor	al,*$48
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+8+$11] (used reg = )
mov	$13[bp],al
!BCC_EOS
! 5103     if (!timeout) regs.u.r8.ah |= 0x01;
mov	ax,-4[bp]
test	ax,ax
jne 	.719
.71A:
! Debug: orab int = const 1 to unsigned char regs = [S+8+$11] (used reg = )
mov	al,$13[bp]
or	al,*1
mov	$13[bp],al
!BCC_EOS
! 5104     iret_addr.flags.u.r8.flagsl &= 0xfe;
.719:
! Debug: andab int = const $FE to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5105   } else {
jmp .71B
.70C:
! 5106     iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+8+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5107   }
! 5108 }
.71B:
mov	sp,bp
pop	bp
ret
! 5109 void
! 5110 int18_function(seq_nr)
! 5111 Bit16u seq_nr;
export	_int18_function
_int18_function:
!BCC_EOS
! 5112 {
! 5113   Bit16u ebda_seg=read_word(0x0040,0x000E);
push	bp
mov	bp,sp
dec	sp
dec	sp
! Debug: list int = const $E (used reg = )
mov	ax,*$E
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short ebda_seg = [S+4-4] (used reg = )
mov	-2[bp],ax
!BCC_EOS
! 5114   Bit16u bootdev;
!BCC_EOS
! 5115   Bit8u bootdrv;
!BCC_EOS
! 5116   Bit8u bootchk;
!BCC_EOS
! 5117   Bit16u bootseg;
!BCC_EOS
! 5118   Bit16u bootip;
!BCC_EOS
! 5119   Bit16u status;
!BCC_EOS
! 5120   Bit16u bootfirst;
!BCC_EOS
! 5121   ipl_entry_t e;
!BCC_EOS
! 5122   bootdev = inb_cmos(0x3d);
add	sp,*-$1C
! Debug: list int = const $3D (used reg = )
mov	ax,*$3D
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned short bootdev = [S+$20-6] (used reg = )
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5123   bootdev |= ((inb_cmos(0x38) & 0xf0) << 4);
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $F0 to unsigned char = al+0 (used reg = )
and	al,#$F0
! Debug: sl int = const 4 to unsigned char = al+0 (used reg = )
xor	ah,ah
mov	cl,*4
shl	ax,cl
! Debug: orab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
or	ax,-4[bp]
mov	-4[bp],ax
!BCC_EOS
! 5124   bootdev >>= 4 * seq_nr;
! Debug: mul unsigned short seq_nr = [S+$20+2] to int = const 4 (used reg = )
! Debug: expression subtree swapping
mov	ax,4[bp]
shl	ax,*1
shl	ax,*1
! Debug: srab unsigned int = ax+0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	bx,ax
mov	ax,-4[bp]
mov	cx,bx
shr	ax,cl
mov	-4[bp],ax
!BCC_EOS
! 5125   bootdev &= 0xf;
! Debug: andab int = const $F to unsigned short bootdev = [S+$20-6] (used reg = )
mov	al,-4[bp]
and	al,*$F
xor	ah,ah
mov	-4[bp],ax
!BCC_EOS
! 5126   bootfirst = read_word(ebda_seg, 0x0384);
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5127   if (bootfirst != 0xFFFF) {
! Debug: ne unsigned int = const $FFFF to unsigned short bootfirst = [S+$20-$10] (used reg = )
mov	ax,-$E[bp]
cmp	ax,#$FFFF
je  	.71C
.71D:
! 5128     bootdev = bootfirst;
! Debug: eq unsigned short bootfirst = [S+$20-$10] to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-$E[bp]
mov	-4[bp],ax
!BCC_EOS
! 5129     write_word(ebda_seg, 0x0384, 0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $384 (used reg = )
mov	ax,#$384
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5130     write_word(ebda_seg, 0x0382,
! 5130  0xFFFF);
! Debug: list unsigned int = const $FFFF (used reg = )
mov	ax,#$FFFF
push	ax
! Debug: list int = const $382 (used reg = )
mov	ax,#$382
push	ax
! Debug: list unsigned short ebda_seg = [S+$24-4] (used reg = )
push	-2[bp]
! Debug: func () void = write_word+0 (used reg = )
call	_write_word
add	sp,*6
!BCC_EOS
! 5131   } else if (bootdev == 0) {
jmp .71E
.71C:
! Debug: logeq int = const 0 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
test	ax,ax
jne 	.71F
.720:
! 5132     bios_printf(2, "\nNo bootable device.\n");
! Debug: list * char = .721+0 (used reg = )
mov	bx,#.721
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5133     bios_printf(2, "Powering off in 30 seconds.\n");
! Debug: list * char = .722+0 (used reg = )
mov	bx,#.722
push	bx
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5134 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    sti
    mov cx, #0x01c9
    mov dx, #0xc380
    mov ah, #0x86 ;; INT 15/86: wait CX:DX usec.
    int #0x15
! 5140 endasm
!BCC_ENDASM
!BCC_EOS
! 5141     bios_printf(1, "");
! Debug: list * char = .723+0 (used reg = )
mov	bx,#.723
push	bx
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = bios_printf+0 (used reg = )
call	_bios_printf
add	sp,*4
!BCC_EOS
! 5142   }
! 5143   bootdev -= 1;
.71F:
.71E:
! Debug: subab int = const 1 to unsigned short bootdev = [S+$20-6] (used reg = )
mov	ax,-4[bp]
dec	ax
mov	-4[bp],ax
!BCC_EOS
! 5144   if (get_boot_vector(bootdev, &e) == 0) {
! Debug: list * struct  e = S+$20-$20 (used reg = )
lea	bx,-$1E[bp]
push	bx
! Debug: list unsigned short bootdev = [S+$22-6] (used reg = )
push	-4[bp]
! Debug: func () unsigned char = get_boot_vector+0 (used reg = )
call	_get_boot_vector
add	sp,*4
! Debug: logeq int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
jne 	.724
.725:
! 5145     ;
!BCC_EOS
! 5146     return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5147   }
! 5148   print_boot_device(e.type, e.description);
.724:
! Debug: list unsigned long e = [S+$20-$18] (used reg = )
push	-$14[bp]
push	-$16[bp]
! Debug: list unsigned short e = [S+$24-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_device+0 (used reg = )
call	_print_boot_device
add	sp,*6
!BCC_EOS
! 5149   switch(e.type) {
mov	ax,-$1E[bp]
br 	.728
! 5150   case 0x01:
! 5151   case 0x02:
.729:
! 5152     bootdrv = (e.type == 0x02) ? 0x80 : 0x00;
.72A:
! Debug: logeq int = const 2 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*2
jne 	.72B
.72C:
mov	al,#$80
jmp .72D
.72B:
xor	al,al
.72D:
! Debug: eq char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5153     bootseg = 0x07c0;
! Debug: eq int = const $7C0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,#$7C0
mov	-8[bp],ax
!BCC_EOS
! 5154     status = 0;
! Debug: eq int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
xor	ax,ax
mov	-$C[bp],ax
!BCC_EOS
! 5155 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    push bp
    mov bp, sp
    push ax
    push bx
    push cx
    push dx
    mov dl, _int18_function.bootdrv + 2[bp]
    mov ax, _int18_function.bootseg + 2[bp]
    mov es, ax ;; segment
    xor bx, bx ;; offset
    mov ah, #0x02 ;; function 2, read diskette sector
    mov al, #0x01 ;; read 1 sector
    mov ch, #0x00 ;; track 0
    mov cl, #0x01 ;; sector 1
    mov dh, #0x00 ;; head 0
    int #0x13 ;; read sector
    jnc int19_load_done
    mov ax, #0x0001
    mov _int18_function.status + 2[bp], ax
int19_load_done:
    pop dx
    pop cx
    pop bx
    pop ax
    pop bp
! 5181 endasm
!BCC_ENDASM
!BCC_EOS
! 5182     if (status != 0) {
! Debug: ne int = const 0 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
test	ax,ax
je  	.72E
.72F:
! 5183       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5184       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5185     }
! 5186     if ((e.type != 0x01) || !((inb_cmos(0x38) & 0x01))) {
.72E:
! Debug: ne int = const 1 to unsigned short e = [S+$20-$20] (used reg = )
mov	ax,-$1E[bp]
cmp	ax,*1
jne 	.731
.732:
! Debug: list int = const $38 (used reg = )
mov	ax,*$38
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
test	al,al
jne 	.730
.731:
! 5187       if (read_word(bootseg,0x1fe) != 0xaa55) {
! Debug: list int = const $1FE (used reg = )
mov	ax,#$1FE
push	ax
! Debug: list unsigned short bootseg = [S+$22-$A] (used reg = )
push	-8[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: ne unsigned int = const $AA55 to unsigned short = ax+0 (used reg = )
cmp	ax,#$AA55
je  	.733
.734:
! 5188         print_boot_failure(e.type, 0);
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5189         return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5190       }
! 5191     }
.733:
! 5192     bootip = (bootseg & 0x0fff) << 4;
.730:
! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$FFF
! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5193     bootseg &= 0xf000;
! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$F000
mov	-8[bp],ax
!BCC_EOS
! 5194   break;
br 	.726
!BCC_EOS
! 5195   case 0x03:
! 5196     status = cdrom_boot();
.735:
! Debug: func () unsigned short = cdrom_boot+0 (used reg = )
call	_cdrom_boot
! Debug: eq unsigned short = ax+0 to unsigned short status = [S+$20-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5197     if ( (status & 0x00ff) !=0 ) {
! Debug: and int = const $FF to unsigned short status = [S+$20-$E] (used reg = )
mov	al,-$C[bp]
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.736
.737:
! 5198       print_cdromboot_failure(status);
! Debug: list unsigned short status = [S+$20-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = print_cdromboot_failure+0 (used reg = )
call	_print_cdromboot_failure
inc	sp
inc	sp
!BCC_EOS
! 5199       print_boot_failure(e.type, 1);
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: list unsigned short e = [S+$22-$20] (used reg = )
push	-$1E[bp]
! Debug: func () void = print_boot_failure+0 (used reg = )
call	_print_boot_failure
add	sp,*4
!BCC_EOS
! 5200       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5201     }
! 5202     bootdrv = (Bit8u)(status>>8);
.736:
! Debug: sr int = const 8 to unsigned short status = [S+$20-$E] (used reg = )
mov	ax,-$C[bp]
mov	al,ah
xor	ah,ah
! Debug: cast unsigned char = const 0 to unsigned int = ax+0 (used reg = )
! Debug: eq unsigned char = al+0 to unsigned char bootdrv = [S+$20-7] (used reg = )
mov	-5[bp],al
!BCC_EOS
! 5203     bootseg = read_word(ebda_seg,&((ebda_data_t *) 0)->cdemu.load_segment);
! Debug: list * unsigned short = const $266 (used reg = )
mov	ax,#$266
push	ax
! Debug: list unsigned short ebda_seg = [S+$22-4] (used reg = )
push	-2[bp]
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5204     bootip = (bootseg & 0x0fff) << 4;
! Debug: and int = const $FFF to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$FFF
! Debug: sl int = const 4 to unsigned int = ax+0 (used reg = )
mov	cl,*4
shl	ax,cl
! Debug: eq unsigned int = ax+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5205     bootseg &= 0xf000;
! Debug: andab unsigned int = const $F000 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	ax,-8[bp]
and	ax,#$F000
mov	-8[bp],ax
!BCC_EOS
! 5206     break;
jmp .726
!BCC_EOS
! 5207   case 0x80:
! 5208     bootseg = e.vector >> 16;
.738:
! Debug: sr int = const $10 to unsigned long e = [S+$20-$1C] (used reg = )
mov	ax,-$1A[bp]
mov	bx,-$18[bp]
xchg	bx,ax
xor	bx,bx
! Debug: eq unsigned long = bx+0 to unsigned short bootseg = [S+$20-$A] (used reg = )
mov	-8[bp],ax
!BCC_EOS
! 5209     bootip = e.vector & 0xffff;
! Debug: and unsigned long = const $FFFF to unsigned long e = [S+$20-$1C] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$FFFF
xor	bx,bx
lea	di,-$1A[bp]
call	landul
! Debug: eq unsigned long = bx+0 to unsigned short bootip = [S+$20-$C] (used reg = )
mov	-$A[bp],ax
!BCC_EOS
! 5210     break;
jmp .726
!BCC_EOS
! 5211   default: return;
.739:
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 5212   }
! 5213   ;
jmp .726
.728:
sub	ax,*1
beq 	.729
sub	ax,*1
beq 	.72A
sub	ax,*1
beq 	.735
sub	ax,*$7D
je 	.738
jmp	.739
.726:
..FFDB	=	-$20
!BCC_EOS
! 5214 #asm
!BCC_EOS
!BCC_ASM
_int18_function.bootip	set	$14
.int18_function.bootip	set	-$A
_int18_function.seq_nr	set	$22
.int18_function.seq_nr	set	4
_int18_function.bootchk	set	$18
.int18_function.bootchk	set	-6
_int18_function.bootseg	set	$16
.int18_function.bootseg	set	-8
_int18_function.ebda_seg	set	$1C
.int18_function.ebda_seg	set	-2
_int18_function.status	set	$12
.int18_function.status	set	-$C
_int18_function.bootfirst	set	$10
.int18_function.bootfirst	set	-$E
_int18_function.bootdrv	set	$19
.int18_function.bootdrv	set	-5
_int18_function.bootdev	set	$1A
.int18_function.bootdev	set	-4
_int18_function.e	set	0
.int18_function.e	set	-$1E
    mov bp, sp
    push cs
    push #int18_handler
    ;; Build an iret stack frame that will take us to the boot vector.
    ;; iret pops ip, then cs, then flags, so push them in the opposite order.
    pushf
    mov ax, _int18_function.bootseg + 0[bp]
    push ax
    mov ax, _int18_function.bootip + 0[bp]
    push ax
    ;; Set the magic number in ax and the boot drive in dl.
    mov ax, #0xaa55
    mov dl, _int18_function.bootdrv + 0[bp]
    ;; Zero some of the other registers.
    xor bx, bx
    mov ds, bx
    mov es, bx
    mov bp, bx
    ;; Go!
    iret
! 5235 endasm
!BCC_ENDASM
!BCC_EOS
! 5236 }
mov	sp,bp
pop	bp
ret
! 5237   void
! Register BX used in function int18_function
! 5238 int1a_function(regs, ds, iret_addr)
! 5239   pusha_regs_t regs;
export	_int1a_function
_int1a_function:
!BCC_EOS
! 5240   Bit16u ds;
!BCC_EOS
! 5241   iret_addr_t iret_addr;
!BCC_EOS
! 5242 {
! 5243   Bit8u val8;
!BCC_EOS
! 5244   ;
push	bp
mov	bp,sp
dec	sp
dec	sp
!BCC_EOS
! 5245 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
  sti
! 5247 endasm
!BCC_ENDASM
!BCC_EOS
! 5248   switch (regs.u.r8.ah) {
mov	al,$13[bp]
br 	.73C
! 5249     case 0:
! 5250 #asm
.73D:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5252 endasm
!BCC_ENDASM
!BCC_EOS
! 5253       regs.u.r16.cx = ((bios_data_t *) 0)->ticks_high;
! Debug: eq unsigned short = [+$46E] to unsigned short regs = [S+4+$E] (used reg = )
mov	ax,[$46E]
mov	$10[bp],ax
!BCC_EOS
! 5254       regs.u.r16.dx = ((bios_data_t *) 0)->ticks_low;
! Debug: eq unsigned short = [+$46C] to unsigned short regs = [S+4+$C] (used reg = )
mov	ax,[$46C]
mov	$E[bp],ax
!BCC_EOS
! 5255       regs.u.r8.al = ((bios_data_t *) 0)->midnight_flag;
! Debug: eq unsigned char = [+$470] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,[$470]
mov	$12[bp],al
!BCC_EOS
! 5256       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5257 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5259 endasm
!BCC_ENDASM
!BCC_EOS
! 5260       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5261       break;
br 	.73A
!BCC_EOS
! 5262     case 1:
! 5263 #asm
.73E:
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      cli
! 5265 endasm
!BCC_ENDASM
!BCC_EOS
! 5266       ((bios_data_t *) 0)->ticks_high = regs.u.r16.cx;
! Debug: eq unsigned short regs = [S+4+$E] to unsigned short = [+$46E] (used reg = )
mov	ax,$10[bp]
mov	[$46E],ax
!BCC_EOS
! 5267       ((bios_data_t *) 0)->ticks_low = regs.u.r16.dx;
! Debug: eq unsigned short regs = [S+4+$C] to unsigned short = [+$46C] (used reg = )
mov	ax,$E[bp]
mov	[$46C],ax
!BCC_EOS
! 5268       ((bios_data_t *) 0)->midnight_flag = 0;
! Debug: eq int = const 0 to unsigned char = [+$470] (used reg = )
xor	al,al
mov	[$470],al
!BCC_EOS
! 5269 #asm
!BCC_EOS
!BCC_ASM
_int1a_function.ds	set	$16
.int1a_function.ds	set	$14
_int1a_function.val8	set	1
.int1a_function.val8	set	-1
_int1a_function.iret_addr	set	$18
.int1a_function.iret_addr	set	$16
_int1a_function.regs	set	6
.int1a_function.regs	set	4
      sti
! 5271 endasm
!BCC_ENDASM
!BCC_EOS
! 5272       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5273       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5274       break;
br 	.73A
!BCC_EOS
! 5275     case 2:
! 5276       if (rtc_updating()) {
.73F:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.740
.741:
! 5277         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5278         break;
br 	.73A
!BCC_EOS
! 5279         }
! 5280       regs.u.r8.dh = inb_cmos(0x00);
.740:
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5281       regs.u.r8.cl = inb_cmos(0x02);
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5282       regs.u.r8.ch = inb_cmos(0x04);
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5283       regs.u.r8.dl = inb_cmos(0x0b) & 0x01;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const 1 to unsigned char = al+0 (used reg = )
and	al,*1
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5284       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5285       regs.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5286       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5287       break;
br 	.73A
!BCC_EOS
! 5288     case 3:
! 5289       if (rtc_updating()) {
.742:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.743
.744:
! 5290         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5291         }
! 5292       outb_cmos(0x00, regs.u.r8.dh);
.743:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5293       outb_cmos(0x02, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 2 (used reg = )
mov	ax,*2
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5294       outb_cmos(0x04, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 4 (used reg = )
mov	ax,*4
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5295       val8 = (inb_cmos(0x0b) & 0x60) | 0x02 | (regs.u.r8.dl & 0x01);
! Debug: expression subtree swapping
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $60 to unsigned char = al+0 (used reg = )
and	al,*$60
! Debug: or int = const 2 to unsigned char = al+0 (used reg = )
or	al,*2
push	ax
! Debug: and int = const 1 to unsigned char regs = [S+6+$C] (used reg = )
mov	al,$E[bp]
and	al,*1
! Debug: or unsigned char (temp) = [S+6-6] to unsigned char = al+0 (used reg = )
or	al,0+..FFDA[bp]
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5296       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5297       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5298       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5299       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5300       break;
br 	.73A
!BCC_EOS
! 5301     case 4:
! 5302       regs.u.r8.ah = 0;
.745:
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5303 
! 5303       if (rtc_updating()) {
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.746
.747:
! 5304         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5305         break;
br 	.73A
!BCC_EOS
! 5306         }
! 5307       regs.u.r8.cl = inb_cmos(0x09);
.746:
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$E] (used reg = )
mov	$10[bp],al
!BCC_EOS
! 5308       regs.u.r8.dh = inb_cmos(0x08);
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$D] (used reg = )
mov	$F[bp],al
!BCC_EOS
! 5309       regs.u.r8.dl = inb_cmos(0x07);
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$C] (used reg = )
mov	$E[bp],al
!BCC_EOS
! 5310       regs.u.r8.ch = inb_cmos(0x32);
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char regs = [S+4+$F] (used reg = )
mov	$11[bp],al
!BCC_EOS
! 5311       regs.u.r8.al = regs.u.r8.ch;
! Debug: eq unsigned char regs = [S+4+$F] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$11[bp]
mov	$12[bp],al
!BCC_EOS
! 5312       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5313       break;
br 	.73A
!BCC_EOS
! 5314     case 5:
! 5315       if (rtc_updating()) {
.748:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.749
.74A:
! 5316         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5317         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5318         break;
br 	.73A
!BCC_EOS
! 5319         }
! 5320       outb_cmos(0x09, regs.u.r8.cl);
.749:
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 9 (used reg = )
mov	ax,*9
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5321       outb_cmos(0x08, regs.u.r8.dh);
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 8 (used reg = )
mov	ax,*8
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5322       outb_cmos(0x07, regs.u.r8.dl);
! Debug: list unsigned char regs = [S+4+$C] (used reg = )
mov	al,$E[bp]
xor	ah,ah
push	ax
! Debug: list int = const 7 (used reg = )
mov	ax,*7
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5323       outb_cmos(0x32, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const $32 (used reg = )
mov	ax,*$32
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5324       val8 = inb_cmos(0x0b) & 0x7f;
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: and int = const $7F to unsigned char = al+0 (used reg = )
and	al,*$7F
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5325       outb_cmos(0x0b, val8);
! Debug: list unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5326       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5327       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5328       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5329       break;
br 	.73A
!BCC_EOS
! 5330     case 6:
! 5331       val8 = inb_cmos(0x0b);
.74B:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5332       regs.u.r16.ax = 0;
! Debug: eq int = const 0 to unsigned short regs = [S+4+$10] (used reg = )
xor	ax,ax
mov	$12[bp],ax
!BCC_EOS
! 5333       if (val8 & 0x20) {
! Debug: and int = const $20 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$20
test	al,al
je  	.74C
.74D:
! 5334         iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5335         break;
br 	.73A
!BCC_EOS
! 5336         }
! 5337       if (rtc_updating()) {
.74C:
! Debug: func () unsigned short = rtc_updating+0 (used reg = )
call	_rtc_updating
test	ax,ax
je  	.74E
.74F:
! 5338         init_rtc();
! Debug: func () void = init_rtc+0 (used reg = )
call	_init_rtc
!BCC_EOS
! 5339         }
! 5340       outb_cmos(0x01, regs.u.r8.dh);
.74E:
! Debug: list unsigned char regs = [S+4+$D] (used reg = )
mov	al,$F[bp]
xor	ah,ah
push	ax
! Debug: list int = const 1 (used reg = )
mov	ax,*1
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5341       outb_cmos(0x03, regs.u.r8.cl);
! Debug: list unsigned char regs = [S+4+$E] (used reg = )
mov	al,$10[bp]
xor	ah,ah
push	ax
! Debug: list int = const 3 (used reg = )
mov	ax,*3
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5342       outb_cmos(0x05, regs.u.r8.ch);
! Debug: list unsigned char regs = [S+4+$F] (used reg = )
mov	al,$11[bp]
xor	ah,ah
push	ax
! Debug: list int = const 5 (used reg = )
mov	ax,*5
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5343       outb(0xa1, inb(0xa1) & 0xfe);
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () unsigned char = inb+0 (used reg = )
call	_inb
inc	sp
inc	sp
! Debug: and int = const $FE to unsigned char = al+0 (used reg = )
and	al,#$FE
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $A1 (used reg = )
mov	ax,#$A1
push	ax
! Debug: func () void = outb+0 (used reg = )
call	_outb
add	sp,*4
!BCC_EOS
! 5344       outb_cmos(0x0b, (val8 & 0x7f) | 0x20);
! Debug: and int = const $7F to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$7F
! Debug: or int = const $20 to unsigned char = al+0 (used reg = )
or	al,*$20
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5345       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5346       break;
br 	.73A
!BCC_EOS
! 5347     case 7:
! 5348       val8 = inb_cmos(0x0b);
.750:
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char val8 = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5349       outb_cmos(0x0b, val8 & 0x57);
! Debug: and int = const $57 to unsigned char val8 = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$57
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5350       regs.u.r8.ah = 0;
! Debug: eq int = const 0 to unsigned char regs = [S+4+$11] (used reg = )
xor	al,al
mov	$13[bp],al
!BCC_EOS
! 5351       regs.u.r8.al = val8;
! Debug: eq unsigned char val8 = [S+4-3] to unsigned char regs = [S+4+$10] (used reg = )
mov	al,-1[bp]
mov	$12[bp],al
!BCC_EOS
! 5352       iret_addr.flags.u.r8.flagsl &= 0xfe;
! Debug: andab int = const $FE to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
and	al,#$FE
mov	$1A[bp],al
!BCC_EOS
! 5353       break;
jmp .73A
!BCC_EOS
! 5354     case 0xb1:
! 5355       if (regs.u.r8.bl == 0xff) {
.751:
! Debug: logeq int = const $FF to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$FF
jne 	.752
.753:
! 5356         ;
!BCC_EOS
! 5357       } else if (regs.u.r8.bl == 0x81) {
jmp .754
.752:
! Debug: logeq int = const $81 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$81
jne 	.755
.756:
! 5358         ;
!BCC_EOS
! 5359       } else if (regs.u.r8.bl == 0x83) {
jmp .757
.755:
! Debug: logeq int = const $83 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$83
jne 	.758
.759:
! 5360         ;
!BCC_EOS
! 5361       } else if (regs.u.r8.bl == 0x86) {
jmp .75A
.758:
! Debug: logeq int = const $86 to unsigned char regs = [S+4+$A] (used reg = )
mov	al,$C[bp]
cmp	al,#$86
jne 	.75B
.75C:
! 5362         if (regs.u.r8.al == 0x02) {
! Debug: logeq int = const 2 to unsigned char regs = [S+4+$10] (used reg = )
mov	al,$12[bp]
cmp	al,*2
jne 	.75D
.75E:
! 5363           ;
!BCC_EOS
! 5364         } else {
jmp .75F
.75D:
! 5365           ;
!BCC_EOS
! 5366         }
! 5367       }
.75F:
! 5368       regs.u.r8.ah = regs.u.r8.bl;
.75B:
.75A:
.757:
.754:
! Debug: eq unsigned char regs = [S+4+$A] to unsigned char regs = [S+4+$11] (used reg = )
mov	al,$C[bp]
mov	$13[bp],al
!BCC_EOS
! 5369       iret_addr.flags.u.r8.flagsl |= 0x01;
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5370       break;
jmp .73A
!BCC_EOS
! 5371     default:
! 5372       iret_addr.flags.u.r8.flagsl |= 0x01;
.760:
! Debug: orab int = const 1 to unsigned char iret_addr = [S+4+$18] (used reg = )
mov	al,$1A[bp]
or	al,*1
mov	$1A[bp],al
!BCC_EOS
! 5373     }
! 5374 }
jmp .73A
.73C:
sub	al,*0
jb 	.760
cmp	al,*7
ja  	.761
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.762[bx]
.762:
.word	.73D
.word	.73E
.word	.73F
.word	.742
.word	.745
.word	.748
.word	.74B
.word	.750
.761:
sub	al,#$B1
je 	.751
jmp	.760
.73A:
..FFDA	=	-4
mov	sp,bp
pop	bp
ret
! 5375   void
! 5376 int70_function(regs, ds, iret_addr)
! 5377   pusha_regs_t regs;
export	_int70_function
_int70_function:
!BCC_EOS
! 5378   Bit16u ds;
!BCC_EOS
! 5379   iret_addr_t iret_addr;
!BCC_EOS
! 5380 {
! 5381   Bit8u registerB = 0, registerC = 0;
push	bp
mov	bp,sp
dec	sp
! Debug: eq int = const 0 to unsigned char registerB = [S+3-3] (used reg = )
xor	al,al
mov	-1[bp],al
dec	sp
! Debug: eq int = const 0 to unsigned char registerC = [S+4-4] (used reg = )
xor	al,al
mov	-2[bp],al
!BCC_EOS
! 5382   registerB = in
! 5382 b_cmos( 0xB );
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerB = [S+4-3] (used reg = )
mov	-1[bp],al
!BCC_EOS
! 5383   registerC = inb_cmos( 0xC );
! Debug: list int = const $C (used reg = )
mov	ax,*$C
push	ax
! Debug: func () unsigned char = inb_cmos+0 (used reg = )
call	_inb_cmos
inc	sp
inc	sp
! Debug: eq unsigned char = al+0 to unsigned char registerC = [S+4-4] (used reg = )
mov	-2[bp],al
!BCC_EOS
! 5384   if( ( registerB & 0x60 ) != 0 ) {
! Debug: and int = const $60 to unsigned char registerB = [S+4-3] (used reg = )
mov	al,-1[bp]
and	al,*$60
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.763
.764:
! 5385     if( ( registerC & 0x20 ) != 0 ) {
! Debug: and int = const $20 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$20
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
je  	.765
.766:
! 5386 #asm
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
      sti
      int #0x4a
      cli
! 5390 endasm
!BCC_ENDASM
!BCC_EOS
! 5391     }
! 5392     if( ( registerC & 0x40 ) != 0 ) {
.765:
! Debug: and int = const $40 to unsigned char registerC = [S+4-4] (used reg = )
mov	al,-2[bp]
and	al,*$40
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.767
.768:
! 5393       if( read_byte( 0x40, 0xA0 ) != 0 ) {
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: ne int = const 0 to unsigned char = al+0 (used reg = )
test	al,al
beq 	.769
.76A:
! 5394         Bit32u time, toggle;
!BCC_EOS
! 5395         time = read_dword( 0x40, 0x9C );
add	sp,*-8
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned long = read_dword+0 (used reg = )
call	_read_dword
mov	bx,dx
add	sp,*4
! Debug: eq unsigned long = bx+0 to unsigned long time = [S+$C-8] (used reg = )
mov	-6[bp],ax
mov	-4[bp],bx
!BCC_EOS
! 5396         if( time < 0x3D1 ) {
! Debug: lt unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
lea	di,-6[bp]
call	lcmpul
jbe 	.76B
.76C:
! 5397           Bit16u segment, offset;
!BCC_EOS
! 5398           segment = read_word( 0x40, 0x98 );
add	sp,*-4
! Debug: list int = const $98 (used reg = )
mov	ax,#$98
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short segment = [S+$10-$E] (used reg = )
mov	-$C[bp],ax
!BCC_EOS
! 5399           offset = read_word( 0x40, 0x9A );
! Debug: list int = const $9A (used reg = )
mov	ax,#$9A
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () unsigned short = read_word+0 (used reg = )
call	_read_word
add	sp,*4
! Debug: eq unsigned short = ax+0 to unsigned short offset = [S+$10-$10] (used reg = )
mov	-$E[bp],ax
!BCC_EOS
! 5400           write_byte( 0x40, 0xA0, 0 );
! Debug: list int = const 0 (used reg = )
xor	ax,ax
push	ax
! Debug: list int = const $A0 (used reg = )
mov	ax,#$A0
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5401           outb_cmos( 0xB, registerB & 0x37 );
! Debug: and int = const $37 to unsigned char registerB = [S+$10-3] (used reg = )
mov	al,-1[bp]
and	al,*$37
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list int = const $B (used reg = )
mov	ax,*$B
push	ax
! Debug: func () void = outb_cmos+0 (used reg = )
call	_outb_cmos
add	sp,*4
!BCC_EOS
! 5402           write_byte(segment, offset, read_byte(segment, offset) | 0x80 );
! Debug: list unsigned short offset = [S+$10-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$12-$E] (used reg = )
push	-$C[bp]
! Debug: func () unsigned char = read_byte+0 (used reg = )
call	_read_byte
add	sp,*4
! Debug: or int = const $80 to unsigned char = al+0 (used reg = )
or	al,#$80
! Debug: list unsigned char = al+0 (used reg = )
xor	ah,ah
push	ax
! Debug: list unsigned short offset = [S+$12-$10] (used reg = )
push	-$E[bp]
! Debug: list unsigned short segment = [S+$14-$E] (used reg = )
push	-$C[bp]
! Debug: func () void = write_byte+0 (used reg = )
call	_write_byte
add	sp,*6
!BCC_EOS
! 5403         } else {
add	sp,*4
jmp .76D
.76B:
! 5404           time -= 0x3D1;
! Debug: subab unsigned long = const $3D1 to unsigned long time = [S+$C-8] (used reg = )
mov	ax,#$3D1
xor	bx,bx
push	bx
push	ax
mov	ax,-6[bp]
mov	bx,-4[bp]
lea	di,-$E[bp]
call	lsubul
mov	-6[bp],ax
mov	-4[bp],bx
add	sp,*4
!BCC_EOS
! 5405           write_dword( 0x40, 0x9C, time );
! Debug: list unsigned long time = [S+$C-8] (used reg = )
push	-4[bp]
push	-6[bp]
! Debug: list int = const $9C (used reg = )
mov	ax,#$9C
push	ax
! Debug: list int = const $40 (used reg = )
mov	ax,*$40
push	ax
! Debug: func () void = write_dword+0 (used reg = )
call	_write_dword
add	sp,*8
!BCC_EOS
! 5406         }
! 5407       }
.76D:
add	sp,*8
! 5408     }
.769:
! 5409   }
.767:
! 5410 #asm
.763:
!BCC_EOS
!BCC_ASM
_int70_function.registerC	set	0
.int70_function.registerC	set	-2
_int70_function.ds	set	$16
.int70_function.ds	set	$14
_int70_function.registerB	set	1
.int70_function.registerB	set	-1
_int70_function.iret_addr	set	$18
.int70_function.iret_addr	set	$16
_int70_function.regs	set	6
.int70_function.regs	set	4
  call eoi_both_pics
! 5412 endasm
!BCC_ENDASM
!BCC_EOS
! 5413 }
mov	sp,bp
pop	bp
ret
! 5414 #asm
!BCC_ASM
_int70_function.ds	set	$12
_int70_function.iret_addr	set	$14
_int70_function.regs	set	2
;------------------------------------------
;- INT74h : PS/2 mouse hardware interrupt -
;------------------------------------------
int74_handler:
  sti
  pusha
  push ds ;; save DS
  push #0x00 ;; placeholder for status
  push #0x00 ;; placeholder for X
  push #0x00 ;; placeholder for Y
  push #0x00 ;; placeholder for Z
  push #0x00 ;; placeholder for make_far_call boolean
  call _int74_function
  pop cx ;; remove make_far_call from stack
  jcxz int74_done
  ;; make far call to EBDA:0022
  push #0x00
  pop ds
  push 0x040E ;; push 0000:040E (opcodes 0xff, 0x36, 0x0E, 0x04)
  pop ds
  call far ptr[0x22]
int74_done:
  cli
  call eoi_both_pics
  add sp, #8 ;; pop status, x, y, z
  pop ds ;; restore DS
  popa
  iret
;; This will perform an IRET, but will retain value of current CF
;; by altering flags on stack. Better than RETF #02.
iret_modify_cf:
  jc carry_set
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xfe
  pop bp
  iret
carry_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x01
  pop bp
  iret
;----------------------
;- INT13h (relocated) -
;----------------------
;
; int13_relocated is a little bit messed up since I played with it
; I have to rewrite it:
; - call a function that detect which function to call
; - make all called C function get the same parameters list
;
int13_relocated:
  ;; check for an eltorito function
  cmp ah,#0x4a
  jb int13_not_eltorito
  cmp ah,#0x4d
  ja int13_not_eltorito
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_eltorito ;; ELDX not used
int13_not_eltorito:
  push ax
  push bx
  push cx
  push dx
  ;; check if emulation active
  call _cdemu_isactive
  cmp al,#0x00
  je int13_cdemu_inactive
  ;; check if access to the emulated drive
  call _cdemu_emulated_drive
  pop dx
  push dx
  cmp al,dl ;; int13 on emulated drive
  jne int13_nocdemu
  pop dx
  pop cx
  pop bx
  pop ax
  pusha
  push es
  push ds
  push ss
  pop ds
  push #int13_out
  jmp _int13_cdemu ;; ELDX not used
int13_nocdemu:
  and dl,#0xE0 ;; mask to get device class, including cdroms
  cmp al,dl ;; al is 0x00 or 0x80
  jne int13_cdemu_inactive ;; inactive for device class
  pop dx
  pop cx
  pop bx
  pop ax
  push ax
  push cx
  push dx
  push bx
  dec dl ;; real drive is dl - 1
  jmp int13_legacy
int13_cdemu_inactive:
  pop dx
  pop cx
  pop bx
  pop ax
int13_noeltorito:
  push ax
  push cx
  push dx
  push bx
int13_legacy:
  push dx ;; push eltorito value of dx instead of sp
  push bp
  push si
  push di
  push es
  push ds
  push ss
  pop ds
  ;; now the 16-bit registers can be restored with:
  ;; pop ds; pop es; popa; iret
  ;; arguments passed to functions should be
  ;; DS, ES, DI, SI, BP, ELDX, BX, DX, CX, AX, IP, CS, FLAGS
  test dl, #0x80
  jnz int13_notfloppy
  push #int13_out
  jmp _int13_diskette_function
int13_notfloppy:
  cmp dl, #0xE0
  jb int13_notcdrom
  shr ebx, #16
  push bx
  call _int13_cdrom
  pop bx
  shl ebx, #16
  jmp int13_out
int13_notcdrom:
int13_disk:
  ;; int13_harddisk modifies high word of EAX
  shr eax, #16
  push ax
  call _int13_harddisk
  pop ax
  shl eax, #16
int13_out:
  pop ds
  pop es
  popa
  iret
;----------
;- INT18h -
;----------
int18_handler: ;; Boot Failure recovery: try the next device.
  ;; Reset SP and SS
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  ;; The first time we do this it will have been set to -1 so
  ;; we will start from device 0.
  xor ax, ax
  mov ds, ax
  mov bx, word ptr [0x40E] ;; EBDA segment
  mov ds, bx ;; Set segment
  mov bx, 0x0382 ;; BX is now the sequence number
  inc bx ;; ++
  mov 0x0382, bx ;; Write it back
  mov ds, ax ;; and reset the segment to zero.
  ;; Call the C code for the next boot device
  push bx
  call _int18_function
  ;; Boot failed: invoke the boot recovery function...
  int #0x18
;----------
;- INT19h -
;----------
int19_relocated: ;; Boot function, relocated
  ;;
  ;; *** Warning: INT 19h resets the whole machine ***
  ;;
  ;; Because PV drivers in HVM guests detach some of the emulated devices,
  ;; it is not safe to do a soft reboot by just dropping to real mode and
  ;; invoking INT 19h -- the boot drives might have disappeared!
  ;; If the user asks for a soft reboot, the only thing we can do is
  ;; reset the whole machine. When it comes back up, the normal BIOS
  ;; boot sequence will start, which is more or less the required behaviour.
  ;;
  ;; Reset SP and SS
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  call _machine_reset
;----------
;- INT1Ch -
;----------
int1c_handler: ;; User Timer Tick
  iret
;----------------------
;- POST: Floppy Drive -
;----------------------
floppy_drive_post:
  xor ax, ax
  mov ds, ax
  mov al, #0x00
  mov 0x043e, al ;; drive 0 & 1 uncalibrated, no interrupt has occurred
  mov 0x043f, al ;; diskette motor status: read op, drive0, motors off
  mov 0x0440, al ;; diskette motor timeout counter: not active
  mov 0x0441, al ;; diskette controller status return code
  mov 0x0442, al ;; disk & diskette controller status register 0
  mov 0x0443, al ;; diskette controller status register 1
  mov 0x0444, al ;; diskette controller status register 2
  mov 0x0445, al ;; diskette controller cylinder number
  mov 0x0446, al ;; diskette controller head number
  mov 0x0447, al ;; diskette controller sector number
  mov 0x0448, al ;; diskette controller bytes written
  mov 0x048b, al ;; diskette configuration data
  ;; -----------------------------------------------------------------
  ;; (048F) diskette controller information
  ;;
  mov al, #0x10 ;; get CMOS diskette drive type
  out 0x70, AL
  in AL, 0x71
  mov ah, al ;; save byte to AH
look_drive0:
  shr al, #4 ;; look at top 4 bits for drive 0
  jz f0_missing ;; jump if no drive0
  mov bl, #0x07 ;; drive0 determined, multi-rate, has changed line
  jmp look_drive1
f0_missing:
  mov bl, #0x00 ;; no drive0
look_drive1:
  mov al, ah ;; restore from AH
  and al, #0x0f ;; look at bottom 4 bits for drive 1
  jz f1_missing ;; jump if no drive1
  or bl, #0x70 ;; drive1 determined, multi-rate, has changed line
f1_missing:
                   ;; leave high bits in BL zerod
  mov 0x048f, bl ;; put new val in BDA (diskette controller information)
  ;; -----------------------------------------------------------------
  mov al, #0x00
  mov 0x0490, al ;; diskette 0 media state
  mov 0x0491, al ;; diskette 1 media state
                   ;; diskette 0,1 operational starting state
                   ;; drive type has not been determined,
                   ;; has no changed detection line
  mov 0x0492, al
  mov 0x0493, al
  mov 0x0494, al ;; diskette 0 current cylinder
  mov 0x0495, al ;; diskette 1 current cylinder
  mov al, #0x02
  out #0x0a, al ;; clear DMA-1 channel 2 mask bit
  SET_INT_VECTOR(0x1E, #0xF000, #diskette_param_table2)
  SET_INT_VECTOR(0x40, #0xF000, #int13_diskette)
  SET_INT_VECTOR(0x0E, #0xF000, #int0e_handler) ;; IRQ 6
  ret
;--------------------
;- POST: HARD DRIVE -
;--------------------
; relocated here because the primary POST area isnt big enough.
hard_drive_post:
  mov al, #0x0a ; 0000 1010 = reserved, disable IRQ 14
  mov dx, #0x03f6
  out dx, al
  xor ax, ax
  mov ds, ax
  mov 0x0474, al
  mov 0x0477, al
  mov 0x048c, al
  mov 0x048d, al
  mov 0x048e, al
  mov al, #0x01
  mov 0x0475, al
  mov al, #0xc0
  mov 0x0476, al
  SET_INT_VECTOR(0x13, #0xF000, #int13_handler)
  SET_INT_VECTOR(0x76, #0xF000, #int76_handler)
  ;; INT 41h: hard disk 0 configuration pointer
  ;; INT 46h: hard disk 1 configuration pointer
  SET_INT_VECTOR(0x41, word ptr [0x40E], #0x003D)
  SET_INT_VECTOR(0x46, word ptr [0x40E], #0x004D)
  ;; move disk geometry data from CMOS to EBDA disk parameter table(s)
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0xf0
  cmp al, #0xf0
  je post_d0_extended
  jmp check_for_hd1
post_d0_extended:
  mov al, #0x19
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d0_type47
  HALT(9030)
post_d0_type47:
  ;; CMOS purpose param table offset
  ;; 1b cylinders low 0
  ;; 1c cylinders high 1
  ;; 1d heads 2
  ;; 1e write pre-comp low 5
  ;; 1f write pre-comp high 6
  ;; 20 retries/bad map/heads>8 8
  ;; 21 landing zone low C
  ;; 22 landing zone high D
  ;; 23 sectors/track E
  xor ax, ax
  mov ds, ax
  mov ax, word ptr [0x40E] ;; EBDA segment
  mov ds, ax
  ;;; Filling EBDA table for hard disk 0.
  mov al, #0x1f
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x1e
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x05), ax ;; write precomp word
  mov al, #0x20
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x08), al ;; drive control byte
  mov al, #0x22
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x21
  out #0x70, al
  in al, #0x71
  mov (0x003d + 0x0C), ax ;; landing zone word
  mov al, #0x1c ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x1b
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x1d
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x23
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd0_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd0_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  mov (0x003d + 0x0E), dl ;; number of physical sectors
  jmp check_for_hd1
hd0_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x003d + 0x09), bx ;; number of physical cylinders
  mov (0x003d + 0x0b), cl ;; number of physical heads
  mov (0x003d + 0x04), dl ;; number of physical sectors
  mov (0x003d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x003d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd0_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd0_post_store_logical
hd0_post_above_2048:
  cmp bx, #4096
  jnbe hd0_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd0_post_store_logical
hd0_post_above_4096:
  cmp bx, #8192
  jnbe hd0_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd0_post_store_logical
hd0_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd0_post_store_logical:
  mov (0x003d + 0x00), bx ;; number of physical cylinders
  mov (0x003d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x003d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd0_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd0_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 0.
check_for_hd1:
  ;; is there really a second hard disk? if not, return now
  mov al, #0x12
  out #0x70, al
  in al, #0x71
  and al, #0x0f
  jnz post_d1_exists
  ret
post_d1_exists:
  ;; check that the hd type is really 0x0f.
  cmp al, #0x0f
  jz post_d1_extended
  HALT(9169)
post_d1_extended:
  ;; check that the extended type is 47 - user definable
  mov al, #0x1a
  out #0x70, al
  in al, #0x71
  cmp al, #47 ;; decimal 47 - user definable
  je post_d1_type47
  HALT(9177)
post_d1_type47:
  ;; Table for disk1.
  ;; CMOS purpose param table offset
  ;; 0x24 cylinders low 0
  ;; 0x25 cylinders high 1
  ;; 0x26 heads 2
  ;; 0x27 write pre-comp low 5
  ;; 0x28 write pre-comp high 6
  ;; 0x29 heads>8 8
  ;; 0x2a landing zone low C
  ;; 0x2b landing zone high D
  ;; 0x2c sectors/track E
;;; Fill EBDA table for hard disk 1.
  xor ax, ax
  mov ds, ax
  mov ax, word ptr [0x40E] ;; EBDA segment
  mov ds, ax
  mov al, #0x28
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x27
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x05), ax ;; write precomp word
  mov al, #0x29
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x08), al ;; drive control byte
  mov al, #0x2b
  out #0x70, al
  in al, #0x71
  mov ah, al
  mov al, #0x2a
  out #0x70, al
  in al, #0x71
  mov (0x004d + 0x0C), ax ;; landing zone word
  mov al, #0x25 ;; get cylinders word in AX
  out #0x70, al
  in al, #0x71 ;; high byte
  mov ah, al
  mov al, #0x24
  out #0x70, al
  in al, #0x71 ;; low byte
  mov bx, ax ;; BX = cylinders
  mov al, #0x26
  out #0x70, al
  in al, #0x71
  mov cl, al ;; CL = heads
  mov al, #0x2c
  out #0x70, al
  in al, #0x71
  mov dl, al ;; DL = sectors
  cmp bx, #1024
  jnbe hd1_post_logical_chs ;; if cylinders > 1024, use translated style CHS
hd1_post_physical_chs:
  ;; no logical CHS mapping used, just physical CHS
  ;; use Standard Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  mov (0x004d + 0x0E), dl ;; number of physical sectors
  ret
hd1_post_logical_chs:
  ;; complies with Phoenix style Translated Fixed Disk Parameter Table (FDPT)
  mov (0x004d + 0x09), bx ;; number of physical cylinders
  mov (0x004d + 0x0b), cl ;; number of physical heads
  mov (0x004d + 0x04), dl ;; number of physical sectors
  mov (0x004d + 0x0e), dl ;; number of logical sectors (same)
  mov al, #0xa0
  mov (0x004d + 0x03), al ;; A0h signature, indicates translated table
  cmp bx, #2048
  jnbe hd1_post_above_2048
  ;; 1024 < c <= 2048 cylinders
  shr bx, #0x01
  shl cl, #0x01
  jmp hd1_post_store_logical
hd1_post_above_2048:
  cmp bx, #4096
  jnbe hd1_post_above_4096
  ;; 2048 < c <= 4096 cylinders
  shr bx, #0x02
  shl cl, #0x02
  jmp hd1_post_store_logical
hd1_post_above_4096:
  cmp bx, #8192
  jnbe hd1_post_above_8192
  ;; 4096 < c <= 8192 cylinders
  shr bx, #0x03
  shl cl, #0x03
  jmp hd1_post_store_logical
hd1_post_above_8192:
  ;; 8192 < c <= 16384 cylinders
  shr bx, #0x04
  shl cl, #0x04
hd1_post_store_logical:
  mov (0x004d + 0x00), bx ;; number of physical cylinders
  mov (0x004d + 0x02), cl ;; number of physical heads
  ;; checksum
  mov cl, #0x0f ;; repeat count
  mov si, #0x004d ;; offset to disk0 FDPT
  mov al, #0x00 ;; sum
hd1_post_checksum_loop:
  add al, [si]
  inc si
  dec cl
  jnz hd1_post_checksum_loop
  not al ;; now take 2s complement
  inc al
  mov [si], al
;;; Done filling EBDA table for hard disk 1.
  ret
;--------------------
;- POST: EBDA segment
;--------------------
; relocated here because the primary POST area isnt big enough.
ebda_post:
  mov ax, #0x9FC0
  mov ds, ax
  mov byte ptr [0x0], #1
  xor ax, ax ; mov EBDA seg into 40E
  mov ds, ax
  mov word ptr [0x40E], #0x9FC0
  ret;;
;--------------------
;- POST: EOI + jmp via [0x40:67)
;--------------------
; relocated here because the primary POST area isnt big enough.
eoi_jmp_post:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
jmp_post_0x467:
  xor ax, ax
  mov ds, ax
  jmp far ptr [0x467]
iret_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  iret
retf_post_0x467:
  xor ax, ax
  mov ds, ax
  mov sp, [0x467]
  mov ss, [0x469]
  retf
s3_post:
  call _s3_resume
  mov bl, #0x00
  and ax, ax
  jz normal_post
  call _s3_resume_panic
;--------------------
eoi_both_pics:
  mov al, #0x20
  out #0xA0, al ;; slave PIC EOI
eoi_master_pic:
  mov al, #0x20
  out #0x20, al ;; master PIC EOI
  ret
;--------------------
BcdToBin:
  ;; in: AL in BCD format
  ;; out: AL in binary format, AH will always be 0
  ;; trashes BX
  mov bl, al
  and bl, #0x0f ;; bl has low digit
  shr al, #4 ;; al has high digit
  mov bh, #10
  mul al, bh ;; multiply high digit by 10 (result in AX)
  add al, bl ;; then add low digit
  ret
;--------------------
timer_tick_post:
  ;; Setup the Timer Ticks Count (0x46C:dword) and
  ;; Timer Ticks Roller Flag (0x470:byte)
  ;; The Timer Ticks Count needs to be set according to
  ;; the current CMOS time, as if ticks have been occurring
  ;; at 18.2hz since midnight up to this point. Calculating
  ;; this is a little complicated. Here are the factors I gather
  ;; regarding this. 14,318,180 hz was the original clock speed,
  ;; chosen so it could be divided by either 3 to drive the 5Mhz CPU
  ;; at the time, or 4 to drive the CGA video adapter. The div3
  ;; source was divided again by 4 to feed a 1.193Mhz signal to
  ;; the timer. With a maximum 16bit timer count, this is again
  ;; divided down by 65536 to 18.2hz.
  ;;
  ;; 14,318,180 Hz clock
  ;; /3 = 4,772,726 Hz fed to orginal 5Mhz CPU
  ;; /4 = 1,193,181 Hz fed to timer
  ;; /65536 (maximum timer count) = 18.20650736 ticks/second
  ;; 1 second = 18.20650736 ticks
  ;; 1 minute = 1092.390442 ticks
  ;; 1 hour = 65543.42651 ticks
  ;;
  ;; Given the values in the CMOS clock, one could calculate
  ;; the number of ticks by the following:
  ;; ticks = (BcdToBin(seconds) * 18.206507) +
  ;; (BcdToBin(minutes) * 1092.3904)
  ;; (BcdToBin(hours) * 65543.427)
  ;; To get a little more accuracy, since Im using integer
  ;; arithmatic, I use:
  ;; ticks = (BcdToBin(seconds) * 18206507) / 1000000 +
  ;; (BcdToBin(minutes) * 10923904) / 10000 +
  ;; (BcdToBin(hours) * 65543427) / 1000
  ;; assuming DS=0000
  ;; get CMOS seconds
  xor eax, eax ;; clear EAX
  mov al, #0x00
  out #0x70, al
  in al, #0x71 ;; AL has CMOS seconds in BCD
  call BcdToBin ;; EAX now has seconds in binary
  mov edx, #18206507
  mul eax, edx
  mov ebx, #1000000
  xor edx, edx
  div eax, ebx
  mov ecx, eax ;; ECX will accumulate total ticks
  ;; get CMOS minutes
  xor eax, eax ;; clear EAX
  mov al, #0x02
  out #0x70, al
  in al, #0x71 ;; AL has CMOS minutes in BCD
  call BcdToBin ;; EAX now has minutes in binary
  mov edx, #10923904
  mul eax, edx
  mov ebx, #10000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  ;; get CMOS hours
  xor eax, eax ;; clear EAX
  mov al, #0x04
  out #0x70, al
  in al, #0x71 ;; AL has CMOS hours in BCD
  call BcdToBin ;; EAX now has hours in binary
  mov edx, #65543427
  mul eax, edx
  mov ebx, #1000
  xor edx, edx
  div eax, ebx
  add ecx, eax ;; add to total ticks
  mov 0x46C, ecx ;; Timer Ticks Count
  xor al, al
  mov 0x470, al ;; Timer Ticks Rollover Flag
  ret
;--------------------
int76_handler:
  ;; record completion in BIOS task complete flag
  push ax
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov 0x008E, #0xff
  call eoi_both_pics
  pop ds
  pop ax
  iret
;--------------------
use32 386
apm32_out_str:
  push eax
  push ebx
  mov ebx, eax
apm32_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm32_out_str2
  outb dx, al
  inc ebx
  jmp apm32_out_str1
apm32_out_str2:
  pop ebx
  pop eax
  ret
apm32_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm32_07_suspend_str:
  .ascii "Suspend"
  db 0
apm32_07_standby_str:
  .ascii "Standby"
  db 0
_apm32_entry:
  pushf
;-----------------
; APM interface disconnect
apm32_04:
  cmp al, #0x04
  jne apm32_05
  jmp apm32_ok
;-----------------
; APM cpu idle
apm32_05:
  cmp al, #0x05
  jne apm32_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apm32_ok
;-----------------
; APM Set Power State
apm32_07:
  cmp al, #0x07
  jne apm32_08
  cmp bx, #1
  jne apm32_ok
  cmp cx, #3
  je apm32_07_poweroff
  cmp cx, #2
  je apm32_07_suspend
  cmp cx, #1
  je apm32_07_standby
  jne apm32_ok
apm32_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm32_07_poweroff_str
  call apm32_out_str
apm32_07_1:
  hlt
  jmp apm32_07_1
apm32_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_suspend_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
apm32_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm32_07_standby_str
  call apm32_out_str
  pop edx
  jmp apm32_ok
;-----------------
; APM Enable / Disable
apm32_08:
  cmp al, #0x08
  jne apm32_0a
  jmp apm32_ok
;-----------------
; Get Power Status
apm32_0a:
  cmp al, #0x0a
  jne apm32_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm32_ok
;-----------------
; Get PM Event
apm32_0b:
  cmp al, #0x0b
  jne apm32_0e
  mov ah, #0x80
  jmp apm32_error
;-----------------
; APM Driver Version
apm32_0e:
  cmp al, #0x0e
  jne apm32_0f
  mov ah, #1
  mov al, #2
  jmp apm32_ok
;-----------------
; APM Engage / Disengage
apm32_0f:
  cmp al, #0x0f
  jne apm32_10
  jmp apm32_ok
;-----------------
; APM Get Capabilities
apm32_10:
  cmp al, #0x10
  jne apm32_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm32_ok
;-----------------
apm32_ok:
  popf
  clc
  retf
apm32_unimplemented:
apm32_error:
  popf
  stc
  retf
use16 386
apm16_out_str:
  push eax
  push ebx
  mov ebx, eax
apm16_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apm16_out_str2
  outb dx, al
  inc ebx
  jmp apm16_out_str1
apm16_out_str2:
  pop ebx
  pop eax
  ret
apm16_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apm16_07_suspend_str:
  .ascii "Suspend"
  db 0
apm16_07_standby_str:
  .ascii "Standby"
  db 0
_apm16_entry:
  pushf
;-----------------
; APM interface disconnect
apm16_04:
  cmp al, #0x04
  jne apm16_05
  jmp apm16_ok
;-----------------
; APM cpu idle
apm16_05:
  cmp al, #0x05
  jne apm16_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apm16_ok
;-----------------
; APM Set Power State
apm16_07:
  cmp al, #0x07
  jne apm16_08
  cmp bx, #1
  jne apm16_ok
  cmp cx, #3
  je apm16_07_poweroff
  cmp cx, #2
  je apm16_07_suspend
  cmp cx, #1
  je apm16_07_standby
  jne apm16_ok
apm16_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apm16_07_poweroff_str
  call apm16_out_str
apm16_07_1:
  hlt
  jmp apm16_07_1
apm16_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_suspend_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
apm16_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apm16_07_standby_str
  call apm16_out_str
  pop edx
  jmp apm16_ok
;-----------------
; APM Enable / Disable
apm16_08:
  cmp al, #0x08
  jne apm16_0a
  jmp apm16_ok
;-----------------
; Get Power Status
apm16_0a:
  cmp al, #0x0a
  jne apm16_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apm16_ok
;-----------------
; Get PM Event
apm16_0b:
  cmp al, #0x0b
  jne apm16_0e
  mov ah, #0x80
  jmp apm16_error
;-----------------
; APM Driver Version
apm16_0e:
  cmp al, #0x0e
  jne apm16_0f
  mov ah, #1
  mov al, #2
  jmp apm16_ok
;-----------------
; APM Engage / Disengage
apm16_0f:
  cmp al, #0x0f
  jne apm16_10
  jmp apm16_ok
;-----------------
; APM Get Capabilities
apm16_10:
  cmp al, #0x10
  jne apm16_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apm16_ok
;-----------------
apm16_ok:
  popf
  clc
  retf
apm16_unimplemented:
apm16_error:
  popf
  stc
  retf
apmreal_out_str:
  push eax
  push ebx
  mov ebx, eax
apmreal_out_str1:
  SEG CS
  mov al, byte ptr [bx]
  cmp al, #0
  je apmreal_out_str2
  outb dx, al
  inc ebx
  jmp apmreal_out_str1
apmreal_out_str2:
  pop ebx
  pop eax
  ret
apmreal_07_poweroff_str:
  .ascii "Shutdown"
  db 0
apmreal_07_suspend_str:
  .ascii "Suspend"
  db 0
apmreal_07_standby_str:
  .ascii "Standby"
  db 0
  pushf
_apmreal_entry:
;-----------------
; APM installation check
apmreal_00:
  cmp al, #0x00
  jne apmreal_01
  mov ah, #1
  mov al, #2
  mov bh, #0x50
  mov bl, #0x4d
  mov cx, #0x3
  jmp apmreal_ok
;-----------------
; APM real mode interface connect
apmreal_01:
  cmp al, #0x01
  jne apmreal_02
  jmp apmreal_ok
;-----------------
; APM 16 bit protected mode interface connect
apmreal_02:
  cmp al, #0x02
  jne apmreal_03
  mov bx, #_apm16_entry
  mov ax, #0xf000
  mov si, #0xfff0
  mov cx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM 32 bit protected mode interface connect
apmreal_03:
  cmp al, #0x03
  jne apmreal_04
  mov ax, #0xf000
  mov ebx, #_apm32_entry
  mov cx, #0xf000
  mov esi, #0xfff0fff0
  mov dx, #0xf000
  mov di, #0xfff0
  jmp apmreal_ok
;-----------------
; APM interface disconnect
apmreal_04:
  cmp al, #0x04
  jne apmreal_05
  jmp apmreal_ok
;-----------------
; APM cpu idle
apmreal_05:
  cmp al, #0x05
  jne apmreal_07
  pushf ; XEN
  sti ; XEN: OS calls us with ints disabled -- better re-enable here!
  hlt
  popf ; XEN
  jmp apmreal_ok
;-----------------
; APM Set Power State
apmreal_07:
  cmp al, #0x07
  jne apmreal_08
  cmp bx, #1
  jne apmreal_ok
  cmp cx, #3
  je apmreal_07_poweroff
  cmp cx, #2
  je apmreal_07_suspend
  cmp cx, #1
  je apmreal_07_standby
  jne apmreal_ok
apmreal_07_poweroff:
  cli
  mov dx, #0x8900
  mov ax, #apmreal_07_poweroff_str
  call apmreal_out_str
apmreal_07_1:
  hlt
  jmp apmreal_07_1
apmreal_07_suspend:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_suspend_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
apmreal_07_standby:
  push edx
  mov dx, #0x8900
  mov ax, #apmreal_07_standby_str
  call apmreal_out_str
  pop edx
  jmp apmreal_ok
;-----------------
; APM Enable / Disable
apmreal_08:
  cmp al, #0x08
  jne apmreal_0a
  jmp apmreal_ok
;-----------------
; Get Power Status
apmreal_0a:
  cmp al, #0x0a
  jne apmreal_0b
  mov bh, #0x01
  mov bl, #0xff
  mov ch, #0x80
  mov cl, #0xff
  mov dx, #0xffff
  mov si, #0
  jmp apmreal_ok
;-----------------
; Get PM Event
apmreal_0b:
  cmp al, #0x0b
  jne apmreal_0e
  mov ah, #0x80
  jmp apmreal_error
;-----------------
; APM Driver Version
apmreal_0e:
  cmp al, #0x0e
  jne apmreal_0f
  mov ah, #1
  mov al, #2
  jmp apmreal_ok
;-----------------
; APM Engage / Disengage
apmreal_0f:
  cmp al, #0x0f
  jne apmreal_10
  jmp apmreal_ok
;-----------------
; APM Get Capabilities
apmreal_10:
  cmp al, #0x10
  jne apmreal_unimplemented
  mov bl, #0
  mov cx, #0
  jmp apmreal_ok
;-----------------
apmreal_ok:
  popf
  clc
  jmp iret_modify_cf
apmreal_unimplemented:
apmreal_error:
  popf
  stc
  jmp iret_modify_cf
    .align 16
gdt_base:
    .word 0,0
    .byte 0,0,0,0
gdt_entry_pm_32bit_cs:
    .word 0xffff, 0x0000
    .byte 0x00, 0x9b, 0xcf, 0x00
gdt_entry_pm_16bit_cs:
    .word 0xffff, 0x0000
    .byte 0xf0000 >> 16, 0x9b, 0x8f, 0x0
gdt_entry_pm_32bit_ds:
    .word 0xffff, 0x0000
    .byte 0x0, 0x93, 0xcf, 0x0
gdt_entry_pm_16bit_ds:
    .word 0xffff, 0x0000
    .byte 0x0, 0x93, 0x8f, 0x0
gdt_entry_end:
protmode_gdtdesc:
    .word (gdt_entry_end - gdt_base) - 1
    .long gdt_base | 0xf0000
realmode_gdtdesc:
    .word 0xffff
    .long 0x0
Upcall:
    ; Do an upcall into 32 bit space
    ;
    ; Input:
    ; bx: index of function to call
    ; Ouput:
    ; dx, ax: 32 bit result of call (even if 'void' is expected)
    ; Save caller state, stack frame offsets listed below
    pushf
    cli
    push ds
    push es
    push ss
    push esp
    ; Calculate protected-mode esp from ss:sp
    and esp, #0xffff
    xor eax, eax
    mov ax, ss
    shl eax, #4
    add esp, eax
    ; Switch to protected mode
    seg cs
    lgdt protmode_gdtdesc
    mov eax, cr0
    or al, #0x1 ; protected mode on
    mov cr0, eax
    jmpf DWORD (0xf0000|upcall1), #(gdt_entry_pm_32bit_cs - gdt_base)
upcall1:
    USE32
    mov ax, #(gdt_entry_pm_32bit_ds - gdt_base)
    mov ds, ax
    mov es, ax
    mov ss, ax
    ; Marshal arguments and call 32-bit function
    mov ecx, #32/4
upcall2:
    push 32 -4+14[esp]
    loop upcall2
    mov eax, [0x000EA000 + 0]
    call eax
    add esp, #32
    mov ecx, eax ; Result in ecx
    ; Restore real-mode stack pointer
    xor eax, eax
    mov ax, 4[esp]
    mov bx, ax ; Real-mode ss in bx
    shl eax, 4
    sub esp, eax
    ; Return to real mode
    jmpf upcall3, #(gdt_entry_pm_16bit_cs - gdt_base)
upcall3:
    USE16
    mov ax, #(gdt_entry_pm_16bit_ds - gdt_base)
    mov ds, ax
    mov es, ax
    mov ss, ax
    mov eax, cr0
    and al, #0xfe ; protected mode off
    mov cr0, eax
    jmpf upcall4, #0xf0000>>4
upcall4:
    seg cs
    lgdt realmode_gdtdesc
    ; Restore real-mode ss
    mov ss, bx
    ; Convert result into dx:ax format
    mov eax, ecx
    ror eax, #16
    mov dx, ax
    ror eax, #16
    ; Restore caller state and return
    pop esp
    pop bx ; skip ss
    pop es
    pop ds
    popf
    ret
MACRO DoUpcall
    mov bx, #?1
    jmp Upcall
MEND
_TCGInterruptHandler: DoUpcall(0)
_tcpa_acpi_init: DoUpcall(1)
_tcpa_extend_acpi_log: DoUpcall(2)
_tcpa_calling_int19h: DoUpcall(3)
_tcpa_returned_int19h: DoUpcall(4)
_tcpa_add_event_separators: DoUpcall(5)
_tcpa_wake_event: DoUpcall(6)
_tcpa_add_bootdevice: DoUpcall(7)
_tcpa_start_option_rom_scan: DoUpcall(8)
_tcpa_option_rom: DoUpcall(9)
_tcpa_ipl: DoUpcall(10)
_tcpa_measure_post: DoUpcall(11)
_tcpa_initialize_tpm: DoUpcall(12)
_get_s3_waking_vector: DoUpcall(13)
_pmm: DoUpcall(14)
! 6676 endasm
!BCC_ENDASM
! 6677 #asm
!BCC_ASM
_int70_function.ds	set	$12
_int70_function.iret_addr	set	$14
_int70_function.regs	set	2
MACRO POST_MEASURE
 push word #0x000f
 push #?2
 push word #0x000f
 push #?1
 call _tcpa_measure_post
 add sp, #8
MEND
! 6686 endasm
!BCC_ENDASM
! 6687 void
! Register BX used in function int70_function
! 6688 tcpa_do_measure_POSTs()
! 6689 {
export	_tcpa_do_measure_POSTs
_tcpa_do_measure_POSTs:
! 6690 #asm
!BCC_ASM
 POST_MEASURE(post, nmi)
 POST_MEASURE(floppy_drive_post, hard_drive_post)
 POST_MEASURE(hard_drive_post, ebda_post)
 POST_MEASURE(ebda_post, eoi_jmp_post)
 POST_MEASURE(eoi_jmp_post, timer_tick_post)
 POST_MEASURE(timer_tick_post, int76_handler)
 ret
! 6698 endasm
!BCC_ENDASM
! 6699 }
ret
! 6700   void
! 6701 int1a_function32(regs, ES, DS, FLAGS)
! 6702   pushad_regs_t regs;
export	_int1a_function32
_int1a_function32:
!BCC_EOS
! 6703   Bit16u ES, DS, FLAGS;
!BCC_EOS
! 6704 {
! 6705  Bit16u rc;
!BCC_EOS
! 6706  ;
push	bp
mov	bp,sp
dec	sp
dec	sp
!BCC_EOS
! 6707  switch (regs.u.r8.ah) {
mov	al,$21[bp]
br 	.770
! 6708  case 0xbb:
! 6709   if (regs.u.r8.al != 0 &&
.771:
! 6710       regs.u.r32.ebx != 0x41504354L) {
! Debug: ne int = const 0 to unsigned char regs = [S+4+$1E] (used reg = )
mov	al,$20[bp]
test	al,al
je  	.772
.774:
! Debug: ne long = const $41504354 to unsigned long regs = [S+4+$12] (used reg = )
! Debug: expression subtree swapping
mov	ax,#$4354
mov	bx,#$4150
push	bx
push	ax
mov	ax,$14[bp]
mov	bx,$16[bp]
lea	di,-2+..FFD9[bp]
call	lcmpul
lea	sp,2+..FFD9[bp]
je  	.772
.773:
! 6711       FLAGS |= 0x0001;
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6712       return;
mov	sp,bp
pop	bp
ret
!BCC_EOS
! 6713   }
! 6714   switch(regs.u.r8.al) {
.772:
mov	al,$20[bp]
jmp .777
! 6715   case 0x00:
! 6716   case 0x01:
.778:
! 6717   case 0x02:
.779:
! 6718   case 0x03:
.77A:
! 6719   case 0x04:
.77B:
! 6720   case 0x05:
.77C:
! 6721   case 0x06:
.77D:
! 6722   case 0x07:
.77E:
! 6723    TCGInterruptHandler(((Bit32u)get_SS() << 4) + (Bit32u)&regs,
.77F:
! 6724                        ES, DS,
! 6725                        ((Bit32u)get_SS() << 4) + (Bit32u)&FLAGS);
! Debug: expression subtree swapping
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
xor	bx,bx
! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
mov	di,*4
call	lslul
push	bx
push	ax
! Debug: cast unsigned long = const 0 to * unsigned short FLAGS = S+8+$26 (used reg = )
mov	ax,bp
add	ax,*$28
xor	bx,bx
! Debug: add unsigned long (temp) = [S+8-8] to unsigned long = bx+0 (used reg = )
lea	di,-2+..FFD9[bp]
call	laddul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: list unsigned short DS = [S+8+$24] (used reg = )
push	$26[bp]
! Debug: list unsigned short ES = [S+$A+$22] (used reg = )
push	$24[bp]
! Debug: expression subtree swapping
! Debug: func () unsigned short = get_SS+0 (used reg = )
call	_get_SS
! Debug: cast unsigned long = const 0 to unsigned short = ax+0 (used reg = )
xor	bx,bx
! Debug: sl int = const 4 to unsigned long = bx+0 (used reg = )
mov	di,*4
call	lslul
push	bx
push	ax
! Debug: cast unsigned long = const 0 to * struct  regs = S+$10+2 (used reg = )
mov	ax,bp
add	ax,*4
xor	bx,bx
! Debug: add unsigned long (temp) = [S+$10-$10] to unsigned long = bx+0 (used reg = )
lea	di,-$A+..FFD9[bp]
call	laddul
add	sp,*4
! Debug: list unsigned long = bx+0 (used reg = )
push	bx
push	ax
! Debug: func () unsigned long = TCGInterruptHandler+0 (used reg = )
call	_TCGInterruptHandler
mov	bx,dx
add	sp,*$C
!BCC_EOS
! 6726    break;
jmp .775
!BCC_EOS
! 6727   default:
! 6728    FLAGS |= 0x0001;
.780:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6729   }
! 6730   break;
jmp .775
.777:
sub	al,*0
jb 	.780
cmp	al,*7
ja  	.781
xor	ah,ah
shl	ax,*1
mov	bx,ax
seg	cs
br	.782[bx]
.782:
.word	.778
.word	.779
.word	.77A
.word	.77B
.word	.77C
.word	.77D
.word	.77E
.word	.77F
.781:
jmp	.780
.775:
jmp .76E
!BCC_EOS
! 6731  default:
! 6732   FLAGS |= 0x0001;
.783:
! Debug: orab int = const 1 to unsigned short FLAGS = [S+4+$26] (used reg = )
mov	ax,$28[bp]
or	al,*1
mov	$28[bp],ax
!BCC_EOS
! 6733   break;
jmp .76E
!BCC_EOS
! 6734  }
! 6735  ;
jmp .76E
.770:
sub	al,#$BB
beq 	.771
jmp	.783
.76E:
..FFD9	=	-4
!BCC_EOS
! 6736 }
mov	sp,bp
pop	bp
ret
! 6737 #asm
!BCC_ASM
_int1a_function32.FLAGS	set	$26
_int1a_function32.DS	set	$24
_int1a_function32.ES	set	$22
_int1a_function32.regs	set	2
;--------------------
use32 386
.align 16
bios32_structure:
  db 0x5f, 0x33, 0x32, 0x5f ;; "_32_" signature
  dw bios32_entry_point, 0xf ;; 32 bit physical address
  db 0 ;; revision level
  ;; length in paragraphs and checksum stored in a word to prevent errors
  dw (~(((bios32_entry_point >> 8) + (bios32_entry_point & 0xff) + 0x32) & 0xff) << 8) + 0x01
  db 0,0,0,0,0 ;; reserved
.align 16
bios32_entry_point:
  pushfd
  cmp eax, #0x49435024 ;; "$PCI"
  jne unknown_service
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, #0x12378086 ;; i440FX PCI bridge
  jne unknown_service
  mov ebx, #0x000f0000
  mov ecx, #0
  mov edx, #pcibios_protected
  xor al, al
  jmp bios32_end
unknown_service:
  mov al, #0x80
bios32_end:
  popfd
  retf
.align 16
pcibios_protected:
  pushfd
  cli
  push esi
  push edi
  cmp al, #0x01 ;; installation check
  jne pci_pro_f02
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov al, #0x01
  jmp pci_pro_ok
pci_pro_f02: ;; find pci device
  cmp al, #0x02
  jne pci_pro_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_pro_devloop:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_pro_nextdev
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f03: ;; find class code
  cmp al, #0x03
  jne pci_pro_f08
  xor bx, bx
  mov di, #0x08
pci_pro_devloop2:
  call pci_pro_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_pro_nextdev2
  cmp si, #0
  je pci_pro_ok
  dec si
pci_pro_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_pro_devloop2
  mov ah, #0x86
  jmp pci_pro_fail
pci_pro_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_pro_f09
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop edx
  mov cl, al
  jmp pci_pro_ok
pci_pro_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_pro_f0a
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop edx
  mov cx, ax
  jmp pci_pro_ok
pci_pro_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_pro_f0b
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  in eax, dx
  pop edx
  mov ecx, eax
  jmp pci_pro_ok
pci_pro_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_pro_f0c
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop edx
  jmp pci_pro_ok
pci_pro_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_pro_f0d
  call pci_pro_select_reg
  push edx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop edx
  jmp pci_pro_ok
pci_pro_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_pro_unknown
  call pci_pro_select_reg
  push edx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop edx
  jmp pci_pro_ok
pci_pro_unknown:
  mov ah, #0x81
pci_pro_fail:
  pop edi
  pop esi
  popfd
  stc
  retf
pci_pro_ok:
  xor ah, ah
  pop edi
  pop esi
  popfd
  clc
  retf
pci_pro_select_reg:
  push edx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop edx
  ret
use16 386
pcibios_real:
  push eax
  push dx
  mov eax, #0x80000000
  mov dx, #0x0cf8
  out dx, eax
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, #0x12378086 ;; i440FX PCI bridge
  je pci_present
  pop dx
  pop eax
  mov ah, #0xff
  stc
  ret
pci_present:
  pop dx
  pop eax
  cmp al, #0x01 ;; installation check
  jne pci_real_f02
  mov ax, #0x0001
  mov bx, #0x0210
  mov cx, #0
  mov edx, #0x20494350 ;; "PCI "
  mov edi, #0xf0000
  mov di, #pcibios_protected
  clc
  ret
pci_real_f02: ;; find pci device
  push esi
  push edi
  cmp al, #0x02
  jne pci_real_f03
  shl ecx, #16
  mov cx, dx
  xor bx, bx
  mov di, #0x00
pci_real_devloop:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  cmp eax, ecx
  jne pci_real_nextdev
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8602
  jmp pci_real_fail
pci_real_f03: ;; find class code
  cmp al, #0x03
  jne pci_real_f08
  xor bx, bx
  mov di, #0x08
pci_real_devloop2:
  call pci_real_select_reg
  mov dx, #0x0cfc
  in eax, dx
  shr eax, #8
  cmp eax, ecx
  jne pci_real_nextdev2
  cmp si, #0
  je pci_real_ok
  dec si
pci_real_nextdev2:
  inc bx
  cmp bx, #0x0100
  jne pci_real_devloop2
  mov dx, cx
  shr ecx, #16
  mov ax, #0x8603
  jmp pci_real_fail
pci_real_f08: ;; read configuration byte
  cmp al, #0x08
  jne pci_real_f09
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  in al, dx
  pop dx
  mov cl, al
  jmp pci_real_ok
pci_real_f09: ;; read configuration word
  cmp al, #0x09
  jne pci_real_f0a
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  in ax, dx
  pop dx
  mov cx, ax
  jmp pci_real_ok
pci_real_f0a: ;; read configuration dword
  cmp al, #0x0a
  jne pci_real_f0b
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  in eax, dx
  pop dx
  mov ecx, eax
  jmp pci_real_ok
pci_real_f0b: ;; write configuration byte
  cmp al, #0x0b
  jne pci_real_f0c
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x03
  add dx, #0x0cfc
  mov al, cl
  out dx, al
  pop dx
  jmp pci_real_ok
pci_real_f0c: ;; write configuration word
  cmp al, #0x0c
  jne pci_real_f0d
  call pci_real_select_reg
  push dx
  mov dx, di
  and dx, #0x02
  add dx, #0x0cfc
  mov ax, cx
  out dx, ax
  pop dx
  jmp pci_real_ok
pci_real_f0d: ;; write configuration dword
  cmp al, #0x0d
  jne pci_real_f0e
  call pci_real_select_reg
  push dx
  mov dx, #0x0cfc
  mov eax, ecx
  out dx, eax
  pop dx
  jmp pci_real_ok
pci_real_f0e: ;; get irq routing options
  cmp al, #0x0e
  jne pci_real_unknown
  SEG ES
  cmp word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  jb pci_real_too_small
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  pushf
  push ds
  push es
  push cx
  push si
  push di
  cld
  mov si, #pci_routing_table_structure_start
  push cs
  pop ds
  SEG ES
  mov cx, [di+2]
  SEG ES
  mov es, [di+4]
  mov di, cx
  mov cx, #pci_routing_table_structure_end - pci_routing_table_structure_start
  rep
      movsb
  pop di
  pop si
  pop cx
  pop es
  pop ds
  popf
  mov bx, #(1 << 9) | (1 << 11) ;; irq 9 and 11 are used
  jmp pci_real_ok
pci_real_too_small:
  SEG ES
  mov word ptr [di], #pci_routing_table_structure_end - pci_routing_table_structure_start
  mov ah, #0x89
  jmp pci_real_fail
pci_real_unknown:
  mov ah, #0x81
pci_real_fail:
  pop edi
  pop esi
  stc
  ret
pci_real_ok:
  xor ah, ah
  pop edi
  pop esi
  clc
  ret
pci_real_select_reg:
  push dx
  mov eax, #0x800000
  mov ax, bx
  shl eax, #8
  and di, #0xff
  or ax, di
  and al, #0xfc
  mov dx, #0x0cf8
  out dx, eax
  pop dx
  ret
.align 16
pci_routing_table_structure:
  db 0x24, 0x50, 0x49, 0x52 ;; "$PIR" signature
  db 0, 1 ;; version
  dw 32 + (6 * 16) ;; table size
  db 0 ;; PCI interrupt router bus
  db 0x08 ;; PCI interrupt router DevFunc
  dw 0x0000 ;; PCI exclusive IRQs
  dw 0x8086 ;; compatible PCI interrupt router vendor ID
  dw 0x122e ;; compatible PCI interrupt router device ID
  dw 0,0 ;; Miniport data
  db 0,0,0,0,0,0,0,0,0,0,0 ;; reserved
  db 0x37 ;; checksum
pci_routing_table_structure_start:
  ;; first slot entry PCI-to-ISA (embedded)
  db 0 ;; pci bus number
  db 0x08 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#: pointer into PCI2ISA config space
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 0 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; second slot entry: 1st PCI slot
  db 0 ;; pci bus number
  db 0x10 ;; pci device number (bit 7-3)
  db 0x62 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x63 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x60 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x61 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 1 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; third slot entry: 2nd PCI slot
  db 0 ;; pci bus number
  db 0x18 ;; pci device number (bit 7-3)
  db 0x63 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x60 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x61 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x62 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 2 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 4th slot entry: 3rd PCI slot
  db 0 ;; pci bus number
  db 0x20 ;; pci device number (bit 7-3)
  db 0x60 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x61 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x62 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x63 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 3 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 5th slot entry: 4rd PCI slot
  db 0 ;; pci bus number
  db 0x28 ;; pci device number (bit 7-3)
  db 0x61 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x62 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x63 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x60 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 4 ;; physical slot (0 = embedded)
  db 0 ;; reserved
  ;; 6th slot entry: 5rd PCI slot
  db 0 ;; pci bus number
  db 0x30 ;; pci device number (bit 7-3)
  db 0x62 ;; link value INTA#
  dw 0x0c20 ;; IRQ bitmap INTA#
  db 0x63 ;; link value INTB#
  dw 0x0c20 ;; IRQ bitmap INTB#
  db 0x60 ;; link value INTC#
  dw 0x0c20 ;; IRQ bitmap INTC#
  db 0x61 ;; link value INTD#
  dw 0x0c20 ;; IRQ bitmap INTD#
  db 5 ;; physical slot (0 = embedded)
  db 0 ;; reserved
pci_routing_table_structure_end:
; according to POST Memory Manager Specification Version 1.01
.align 16
pmm_structure:
  db 0x24,0x50,0x4d,0x4d ;; "$PMM" signature
  db 0x01 ;; revision
  db 16 ;; length
  db (-((pmm_entry_point>>8)+pmm_entry_point+0x20f))&0xff;; checksum
  dw pmm_entry_point,0xf000 ;; far call entrypoint
  db 0,0,0,0,0 ;; reserved
pmm_entry_point:
  pushf
  pushad
; Calculate protected-mode address of PMM function args
  xor eax, eax
  mov ax, sp
  xor ebx, ebx
  mov bx, ss
  shl ebx, 4
  lea ebx, [eax+ebx+38] ;; ebx=(ss<<4)+sp+4(far call)+2(pushf)+32(pushad)
  push ebx
;
; Stack layout at this point:
;
; : +0x0 +0x2 +0x4 +0x6 +0x8 +0xa +0xc +0xe
; -----------------------------------------------------------------------
; sp : [&arg1 ][edi ][esi ][ebp ]
; sp+0x10: [esp ][ebx ][edx ][ecx ]
; sp+0x20: [eax ][flags ][ip ][cs ][arg1 ][arg2, ...
;
  call _pmm
  mov bx, sp
SEG SS
  mov [bx+0x20], ax
SEG SS
  mov [bx+0x18], dx
  pop ebx
  popad
  popf
  retf
; parallel port detection: base address in DX, index in BX, timeout in CL
detect_parport:
  push dx
  add dx, #2
  in al, dx
  and al, #0xdf ; clear input mode
  out dx, al
  pop dx
  mov al, #0xaa
  out dx, al
  in al, dx
  cmp al, #0xaa
  jne no_parport
  push bx
  shl bx, #1
  mov [bx+0x408], dx ; Parallel I/O address
  pop bx
  mov [bx+0x478], cl ; Parallel printer timeout
  inc bx
no_parport:
  ret
; serial port detection: base address in DX, index in BX, timeout in CL
detect_serial:
  push dx
  inc dx
  mov al, #0x02
  out dx, al
  in al, dx
  cmp al, #0x02
  jne no_serial
  inc dx
  in al, dx
  cmp al, #0x02
  jne no_serial
  dec dx
  xor al, al
  out dx, al
  pop dx
  push bx
  shl bx, #1
  mov [bx+0x400], dx ; Serial I/O address
  pop bx
  mov [bx+0x47c], cl ; Serial timeout
  inc bx
  ret
no_serial:
  pop dx
  ret
rom_checksum:
  pusha
  push ds
  xor ax, ax
  xor bx, bx
  xor cx, cx
  xor dx, dx
  mov ch, [2]
  shl cx, #1
  jnc checksum_loop
  jz checksum_loop
  xchg dx, cx
  dec cx
checksum_loop:
  add al, [bx]
  inc bx
  loop checksum_loop
  test dx, dx
  je checksum_out
  add al, [bx]
  mov cx, dx
  mov dx, ds
  add dh, #0x10
  mov ds, dx
  xor dx, dx
  xor bx, bx
  jmp checksum_loop
checksum_out:
  and al, #0xff
  pop ds
  popa
  ret
;; We need a copy of this string, but we are not actually a PnP BIOS,
;; so make sure it is *not* aligned, so OSes will not see it if they scan.
.align 16
  db 0
pnp_string:
  .ascii "$PnP"
rom_scan:
  ;; Scan for existence of valid expansion ROMS.
  ;; Video ROM: from 0xC0000..0xC7FFF in 2k increments
  ;; General ROM: from 0xC8000..0xE9FFF in 2k increments
  ;; System ROM: only 0xF0000
  ;;
  ;; Header:
  ;; Offset Value
  ;; 0 0x55
  ;; 1 0xAA
  ;; 2 ROM length in 512-byte blocks
  ;; 3 ROM initialization entry point (FAR CALL)
rom_scan_loop:
  push ax ;; Save AX
  mov ds, cx
  mov ax, #0x0004 ;; start with increment of 4 (512-byte) blocks = 2k
  cmp [0], #0xAA55 ;; look for signature
  jne rom_scan_increment
  call rom_checksum
  jnz rom_scan_increment
  mov al, [2] ;; change increment to ROM length in 512-byte blocks
  ;; We want our increment in 512-byte quantities, rounded to
  ;; the nearest 2k quantity, since we only scan at 2k intervals.
  test al, #0x03
  jz block_count_rounded
  and al, #0xfc ;; needs rounding up
  add al, #0x04
block_count_rounded:
  push ax ;; Save AX
  push di ;; Save DI
  ;; Push addr of ROM entry point
  push cx ;; Push seg
  push #0x0003 ;; Push offset
  ;; Get the BDF into ax before invoking the option ROM
  mov bl, [2]
  mov al, bl
  shr al, #7
  cmp al, #1
  jne fetch_bdf
  mov ax, ds ;; Increment the DS since rom size larger than an segment
  add ax, #0x1000
  mov ds, ax
fetch_bdf:
  shl bx, #9
  xor ax, ax
  mov al, [bx]
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  ;; That should stop it grabbing INT 19h; we will use its BEV instead.
  mov bx, #0xf000
  mov es, bx
  lea di, pnp_string
  xor bx, bx ;; Restore DS back to 0000:
  mov ds, bx
  mov bp, sp ;; Call ROM init routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  ;; Look at the ROM's PnP Expansion header.  Properly, we're supposed
  ;; to init all the ROMs and then go back and build an IPL table of
  ;; all the bootable devices, but we can get away with one pass.
  mov ds, cx ;; ROM base
  mov bx, 0x001a ;; 0x1A is the offset into ROM header that contains...
  mov ax, [bx] ;; the offset of PnP expansion header, where...
  cmp ax, #0x5024 ;; we look for signature "$PnP"
  jne no_bev
  mov ax, 2[bx]
  cmp ax, #0x506e
  jne no_bev
  mov ax, 0x16[bx] ;; 0x16 is the offset of Boot Connection Vector
  cmp ax, #0x0000
  je no_bcv
  ;; Option ROM has BCV. Run it now.
  push cx ;; Push seg
  push ax ;; Push offset
  ;; Point ES:DI at "$PnP", which tells the ROM that we are a PnP BIOS.
  mov bx, #0xf000
  mov es, bx
  lea di, pnp_string
  mov bp, sp ;; Call ROM BCV routine using seg:off on stack
  db 0xff ;; call_far ss:[bp+0]
  db 0x5e
  db 0
  cli ;; In case expansion ROM BIOS turns IF on
  add sp, #2 ;; Pop offset value
  pop cx ;; Pop seg value (restore CX)
  jmp no_bev
no_bcv:
  mov ax, 0x1a[bx] ;; 0x1A is also the offset into the expansion header of...
  cmp ax, #0x0000 ;; the Bootstrap Entry Vector, or zero if there is 0 .
  je no_bev
  ;; Found a device that thinks it can boot the system. Record its BEV and product name string.
  mov di, 0x10[bx] ;; Pointer to the product name string or zero if 0
  xor bx, bx
  mov ds, bx
  mov bx, word ptr [0x40E] ;; EBDA segment
  mov ds, bx ;; Go to the segment where the IPL table lives
  mov bx, 0x0380 ;; Read the number of entries so far
  cmp bx, #8
  je no_bev ;; Get out if the table is full
  shl bx, #0x4 ;; Turn count into offset (entries are 16 bytes)
  mov 0x0300 +0[bx], #0x80 ;; This entry is a BEV device
  mov 0x0300 +6[bx], cx ;; Build a far pointer from the segment...
  mov 0x0300 +4[bx], ax ;; and the offset
  cmp di, #0x0000
  je no_prod_str
  mov 0xA[bx], cx ;; Build a far pointer from the segment...
  mov 8[bx], di ;; and the offset
no_prod_str:
  shr bx, #0x4 ;; Turn the offset back into a count
  inc bx ;; We have one more entry now
  mov 0x0380, bx ;; Remember that.
no_bev:
  pop di ;; Restore DI
  pop ax ;; Restore AX
rom_scan_increment:
  shl ax, #5 ;; convert 512-bytes blocks to 16-byte increments
                ;; because the segment selector is shifted left 4 bits.
  add cx, ax
  pop ax ;; Restore AX
  cmp cx, ax
  jbe rom_scan_loop
  xor ax, ax ;; Restore DS back to 0000:
  mov ds, ax
  ret
; Copy the SMBIOS entry point from where hvmloader left it.
; The entry point must be somewhere in 0xf0000-0xfffff on a 16-byte boundary,
; but the tables themselves can be elsewhere.
smbios_init:
  push ax
  push cx
  push es
  push ds
  push di
  push si
  mov cx, #0x001f ; 0x1f bytes to copy
  mov ax, #0xf000
  mov es, ax ; destination segment is 0xf0000
  mov di, #smbios_entry_point ; destination offset
  mov ax, #(0x000EB000>>4)
  mov ds, ax
  mov si, #(0x000EB000&15)
  cld
  rep
    movsb
  pop si
  pop di
  pop ds
  pop es
  pop cx
  pop ax
  ret
post_init_pic:
  mov al, #0x11 ; send initialisation commands
  out 0x20, al
  out 0xa0, al
  mov al, #0x08
  out 0x21, al
  mov al, #0x70
  out 0xa1, al
  mov al, #0x04
  out 0x21, al
  mov al, #0x02
  out 0xa1, al
  mov al, #0x01
  out 0x21, al
  out 0xa1, al
  mov al, #0xb8
  out 0x21, AL ;master pic: unmask IRQ 0, 1, 2, 6
  mov al, #0x8f
  out 0xa1, AL ;slave pic: unmask IRQ 12, 13, 14
  ret
  .align 16
smbios_entry_point:
  db 0,0,0,0,0,0,0,0 ; 8 bytes
  db 0,0,0,0,0,0,0,0 ; 16 bytes
  db 0,0,0,0,0,0,0,0 ; 24 bytes
  db 0,0,0,0,0,0,0 ; 31 bytes
;; the following area can be used to write dynamically generated tables
  .align 16
bios_table_area_start:
  db 0x5F, 0x5F, 0x5F, 0x48, 0x56, 0x4D, 0x4D, 0x50 ;; ___HVMMP
  dd bios_table_area_end - bios_table_area_start
;--------
;- POST -
;--------
.org 0xe05b ; POST Entry Point
post:
  xor ax, ax
  ;; first reset the DMA controllers
  out 0x0d,al
  out 0xda,al
  ;; then initialize the DMA controllers
  mov al, #0xC0
  out 0xD6, al ; cascade mode of channel 4 enabled
  mov al, #0x00
  out 0xD4, al ; unmask channel 4
  ;; Examine CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL
  in AL, 0x71
  ;; backup status
  mov bl, al
  ;; Reset CMOS shutdown status.
  mov AL, #0x0f
  out 0x70, AL ; select CMOS register Fh
  mov AL, #0x00
  out 0x71, AL ; set shutdown action to normal
  ;; Examine CMOS shutdown status.
  mov al, bl
  ;; 0x00, 0x09, 0x0D+ = normal startup
  cmp AL, #0x00
  jz normal_post
  cmp AL, #0x0d
  jae normal_post
  cmp AL, #0x09
  je normal_post
  ;; 0x05 = eoi + jmp via [0x40:0x67] jump
  cmp al, #0x05
  je eoi_jmp_post
  ;; 0x0A = jmp via [0x40:0x67] jump
  cmp al, #0x0a
  je jmp_post_0x467
  ;; 0x0B = iret via [0x40:0x67]
  cmp al, #0x0b
  je iret_post_0x467
  ;; 0x0C = retf via [0x40:0x67]
  cmp al, #0x0c
  je retf_post_0x467
  ;; Examine CMOS shutdown status.
  ;; 0x01,0x02,0x03,0x04,0x06,0x07,0x08 = Unimplemented shutdown status.
  push bx
  call _shutdown_status_panic
normal_post:
  ; case 0: normal startup
  cli
  mov ax, #0x0ffe
  mov sp, ax
  mov ax, #0x9e00
  mov ss, ax
  ;; Save shutdown status
  mov 0x04b0, bl
  cmp bl, #0xfe
  jz s3_post
  ;; zero out BIOS data area (40:00..40:ff)
  mov es, ax
  mov cx, #0x0080 ;; 128 words
  mov di, #0x0400
  cld
  rep
    stosw
  call _log_bios_start
  ;; set all interrupts to default handler
  xor bx, bx ;; offset index
  mov cx, #0x0100 ;; counter (256 interrupts)
  mov ax, #dummy_iret_handler
  mov dx, #0xF000
post_default_ints:
  mov [bx], ax
  add bx, #2
  mov [bx], dx
  add bx, #2
  loop post_default_ints
  ;; set vector 0x79 to zero
  ;; this is used by 'gardian angel' protection system
  SET_INT_VECTOR(0x79, #0, #0)
  ;; base memory in K 40:13 (word)
  mov ax, #(640 - 1)
  mov 0x0413, ax
  ;; Manufacturing Test 40:12
  ;; zerod out above
  ;; Warm Boot Flag 0040:0072
  ;; value of 1234h = skip memory checks
  ;; zerod out above
  ;; Printer Services vector
  SET_INT_VECTOR(0x17, #0xF000, #int17_handler)
  ;; Bootstrap failure vector
  SET_INT_VECTOR(0x18, #0xF000, #int18_handler)
  ;; Bootstrap Loader vector
  SET_INT_VECTOR(0x19, #0xF000, #int19_handler)
  ;; User Timer Tick vector
  SET_INT_VECTOR(0x1c, #0xF000, #int1c_handler)
  ;; Memory Size Check vector
  SET_INT_VECTOR(0x12, #0xF000, #int12_handler)
  ;; Equipment Configuration Check vector
  SET_INT_VECTOR(0x11, #0xF000, #int11_handler)
  ;; System Services
  SET_INT_VECTOR(0x15, #0xF000, #int15_handler)
  ;; EBDA setup
  call ebda_post
  ;; PIT setup
  SET_INT_VECTOR(0x08, #0xF000, #int08_handler)
  ;; int 1C already points at dummy_iret_handler (above)
  mov al, #0x34 ; timer0: binary count, 16bit count, mode 2
  out 0x43, al
  mov al, #0x0b ; #0xe90b = 20 Hz (temporary, until we fix xen/vmx support)
  out 0x40, al ; lsb
  mov al, #0xe9
  out 0x40, al ; msb
  ;; Keyboard
  SET_INT_VECTOR(0x09, #0xF000, #int09_handler)
  SET_INT_VECTOR(0x16, #0xF000, #int16_handler)
  xor ax, ax
  mov ds, ax
  mov 0x0417, al
  mov 0x0418, al
  mov 0x0419, al
  mov 0x0471, al
  mov 0x0497, al
  mov al, #0x10
  mov 0x0496, al
  mov bx, #0x001E
  mov 0x041A, bx
  mov 0x041C, bx
  mov bx, #0x001E
  mov 0x0480, bx
  mov bx, #0x003E
  mov 0x0482, bx
  call _keyboard_init
  ;; mov CMOS Equipment Byte to BDA Equipment Word
  mov ax, 0x0410
  mov al, #0x14
  out 0x70, al
  in al, 0x71
  mov 0x0410, ax
  ;; Parallel setup
  SET_INT_VECTOR(0x0F, #0xF000, #dummy_iret_handler)
  xor ax, ax
  mov ds, ax
  xor bx, bx
  mov cl, #0x14 ; timeout value
  mov dx, #0x378 ; Parallel I/O address, port 1
  call detect_parport
  mov dx, #0x278 ; Parallel I/O address, port 2
  call detect_parport
  shl bx, #0x0e
  mov ax, 0x410 ; Equipment word bits 14..15 determing # parallel ports
  and ax, #0x3fff
  or ax, bx ; set number of parallel ports
  mov 0x410, ax
  ;; Serial setup
  SET_INT_VECTOR(0x0C, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x14, #0xF000, #int14_handler)
  xor bx, bx
  mov cl, #0x0a ; timeout value
  mov dx, #0x03f8 ; Serial I/O address, port 1
  call detect_serial
  mov dx, #0x02f8 ; Serial I/O address, port 2
  call detect_serial
  mov dx, #0x03e8 ; Serial I/O address, port 3
  call detect_serial
  mov dx, #0x02e8 ; Serial I/O address, port 4
  call detect_serial
  shl bx, #0x09
  mov ax, 0x410 ; Equipment word bits 9..11 determing # serial ports
  and ax, #0xf1ff
  or ax, bx ; set number of serial port
  mov 0x410, ax
  ;; CMOS RTC
  SET_INT_VECTOR(0x1A, #0xF000, #int1a_handler)
  SET_INT_VECTOR(0x4A, #0xF000, #dummy_iret_handler)
  SET_INT_VECTOR(0x70, #0xF000, #int70_handler)
  ;; BIOS DATA AREA 0x4CE ???
  call timer_tick_post
  ;; PS/2 mouse setup
  SET_INT_VECTOR(0x74, #0xF000, #int74_handler)
  ;; IRQ13 (FPU exception) setup
  SET_INT_VECTOR(0x75, #0xF000, #int75_handler)
  ;; Video setup
  SET_INT_VECTOR(0x10, #0xF000, #int10_handler)
  ;; PIC
  call post_init_pic
  mov cx, #0xc000 ;; init vga bios
  mov ax, #0xc780
  call rom_scan
  call _print_bios_banner
  ;;
  ;; Floppy setup
  ;;
  call floppy_drive_post
  ;;
  ;; Hard Drive setup
  ;;
  call hard_drive_post
  ;;
  ;; ATA/ATAPI driver setup
  ;;
  call _ata_init
  call _ata_detect
  ;;
  ;;
  ;; eltorito floppy/harddisk emulation from cd
  ;;
  call _cdemu_init
  ;;
  call _enable_rom_write_access
  call _clobber_entry_point
  call _fixup_base_mem_in_k
  call smbios_init
  call _init_boot_vectors
  mov cx, #(0x000C8000 >> 4) ;; init option roms
  mov ax, #(0x000EA000 >> 4)
  call rom_scan
  call _disable_rom_write_access
  call _interactive_bootkey
  sti ;; enable interrupts
  ;; Start the boot sequence. See the comments in int19_relocated
  ;; for why we use INT 18h instead of INT 19h here.
  int #0x18
.org 0xe2c3 ; NMI Handler Entry Point
nmi:
  ;; FIXME the NMI handler should not panic
  ;; but iret when called from int75 (fpu exception)
  call _nmi_handler_msg
  iret
int75_handler:
  out 0xf0, al
  call eoi_both_pics
  int 2
  iret
;-------------------------------------------
;- INT 13h Fixed Disk Services Entry Point -
;-------------------------------------------
.org 0xe3fe ; INT 13h Fixed Disk Services Entry Point
int13_handler:
  jmp int13_relocated
.org 0xe401 ; Fixed Disk Parameter Table
;----------
;- INT19h -
;----------
.org 0xe6f2 ; INT 19h Boot Load Service Entry Point
int19_handler:
  jmp int19_relocated
;-------------------------------------------
;- System BIOS Configuration Data Table
;-------------------------------------------
.org 0xe6f5
db 0x08 ; Table size (bytes) -Lo
db 0x00 ; Table size (bytes) -Hi
db 0xFC
db 0x00
db 1
; Feature byte 1
; b7: 1=DMA channel 3 used by hard disk
; b6: 1=2 interrupt controllers present
; b5: 1=RTC present
; b4: 1=BIOS calls int 15h/4Fh every key
; b3: 1=wait for extern event supported (Int 15h/41h)
; b2: 1=extended BIOS data area used
; b1: 0=AT or ESDI bus, 1=MicroChannel
; b0: 1=Dual bus (MicroChannel + ISA)
db (0 << 7) | (1 << 6) | (1 << 5) | (1 << 4) | (0 << 3) | (1 << 2) | (0 << 1) | (0 << 0)
; Feature byte 2
; b7: 1=32-bit DMA supported
; b6: 1=int16h, function 9 supported
; b5: 1=int15h/C6h (get POS data) supported
; b4: 1=int15h/C7h (get mem map info) supported
; b3: 1=int15h/C8h (en/dis CPU) supported
; b2: 1=non-8042 kb controller
; b1: 1=data streaming supported
; b0: reserved
db (0 << 7) | (1 << 6) | (0 << 5) | (0 << 4) | (0 << 3) | (0 << 2) | (0 << 1) | (0 << 0)
; Feature byte 3
; b7: not used
; b6: reserved
; b5: reserved
; b4: POST supports ROM-to-RAM enable/disable
; b3: SCSI on system board
; b2: info panel installed
; b1: Initial Machine Load (IML) system - BIOS on disk
; b0: SCSI supported in IML
db 0x00
; Feature byte 4
; b7: IBM private
; b6: EEPROM present
; b5-3: ABIOS presence (011 = not supported)
; b2: private
; b1: memory split above 16Mb supported
; b0: POSTEXT directly supported by POST
db 0x00
; Feature byte 5 (IBM)
; b1: enhanced mouse
; b0: flash EPROM
db 0x00
.org 0xe729 ; Baud Rate Generator Table
;----------
;- INT14h -
;----------
.org 0xe739 ; INT 14h Serial Communications Service Entry Point
int14_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int14_function
  popa
  pop ds
  iret
;----------------------------------------
;- INT 16h Keyboard Service Entry Point -
;----------------------------------------
.org 0xe82e
int16_handler:
  sti
  push ds
  pushf
  pusha
  cmp ah, #0x00
  je int16_F00
  cmp ah, #0x10
  je int16_F00
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  jz int16_zero_set
int16_zero_clear:
  push bp
  mov bp, sp
  and BYTE [bp + 0x06], #0xbf
  pop bp
  iret
int16_zero_set:
  push bp
  mov bp, sp
  or BYTE [bp + 0x06], #0x40
  pop bp
  iret
int16_F00:
  mov bx, #0x0040
  mov ds, bx
int16_wait_for_key:
  cli
  mov bx, 0x001a
  cmp bx, 0x001c
  jne int16_key_found
  sti
  hlt
  jmp int16_wait_for_key
int16_key_found:
  mov bx, #0xf000
  mov ds, bx
  call _int16_function
  popa
  popf
  pop ds
  iret
;-------------------------------------------------
;- INT09h : Keyboard Hardware Service Entry Point -
;-------------------------------------------------
.org 0xe987
int09_handler:
  cli
  push ax
  mov al, #0xAD ;;disable keyboard
  out #0x64, al
  mov al, #0x0B
  out #0x20, al
  in al, #0x20
  and al, #0x02
  jz int09_finish
  in al, #0x60 ;;read key from keyboard controller
  sti
  push ds
  pusha
  mov ah, #0x4f ;; allow for keyboard intercept
  stc
  int #0x15
  jnc int09_done
  ;; check for extended key
  cmp al, #0xe0
  jne int09_check_pause
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x02
  or al, #0x02
  mov BYTE [0x496], al
  jmp int09_done
int09_check_pause: ;; check for pause key
  cmp al, #0xe1
  jne int09_process_key
  xor ax, ax
  mov ds, ax
  mov al, BYTE [0x496] ;; mf2_state |= 0x01
  or al, #0x01
  mov BYTE [0x496], al
  jmp int09_done
int09_process_key:
  mov bx, #0xf000
  mov ds, bx
  call _int09_function
int09_done:
  popa
  pop ds
  cli
  call eoi_master_pic
int09_finish:
  mov al, #0xAE ;;enable keyboard
  out #0x64, al
  pop ax
  iret
;----------------------------------------
;- INT 13h Diskette Service Entry Point -
;----------------------------------------
.org 0xec59
int13_diskette:
  jmp int13_noeltorito
;---------------------------------------------
;- INT 0Eh Diskette Hardware ISR Entry Point -
;---------------------------------------------
.org 0xef57 ; INT 0Eh Diskette Hardware ISR Entry Point
int0e_handler:
  push ax
  push dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_normal
  mov dx, #0x03f5
  mov al, #0x08 ; sense interrupt status
  out dx, al
int0e_loop1:
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  jne int0e_loop1
int0e_loop2:
  mov dx, #0x03f5
  in al, dx
  mov dx, #0x03f4
  in al, dx
  and al, #0xc0
  cmp al, #0xc0
  je int0e_loop2
int0e_normal:
  push ds
  xor ax, ax ;; segment 0000
  mov ds, ax
  call eoi_master_pic
  mov al, 0x043e
  or al, #0x80 ;; diskette interrupt has occurred
  mov 0x043e, al
  pop ds
  pop dx
  pop ax
  iret
.org 0xefc7 ; Diskette Controller Parameter Table
diskette_param_table:
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
;----------------------------------------
;- INT17h : Printer Service Entry Point -
;----------------------------------------
.org 0xefd2
int17_handler:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
  call _int17_function
  popa
  pop ds
  iret
diskette_param_table2:
;; New diskette parameter table adding 3 parameters from IBM
;; Since no provisions are made for multiple drive types, most
;; values in this table are ignored. I set parameters for 1.44M
;; floppy here
db 0xAF
db 0x02 ;; head load time 0000001, DMA used
db 0x25
db 0x02
db 18
db 0x1B
db 0xFF
db 0x6C
db 0xF6
db 0x0F
db 0x08
db 79 ;; maximum track
db 0 ;; data transfer rate
db 4 ;; drive type in cmos
.org 0xf045 ; INT 10 Functions 0-Fh Entry Point
  HALT(11460)
  iret
;----------
;- INT10h -
;----------
.org 0xf065 ; INT 10h Video Support Service Entry Point
int10_handler:
  ;; dont do anything, since the VGA BIOS handles int10h requests
  iret
.org 0xf0a4 ; MDA/CGA Video Parameter Table (INT 1Dh)
;----------
;- INT12h -
;----------
.org 0xf841 ; INT 12h Memory Size Service Entry Point
; ??? different for Pentium (machine check)?
int12_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0013
  pop ds
  iret
;----------
;- INT11h -
;----------
.org 0xf84d ; INT 11h Equipment List Service Entry Point
int11_handler:
  push ds
  mov ax, #0x0040
  mov ds, ax
  mov ax, 0x0010
  pop ds
  iret
;----------
;- INT15h -
;----------
.org 0xf859 ; INT 15h System Services Entry Point
int15_handler:
  pushf
  cmp ah, #0x53
  je apm_call
  push ds
  push es
  cmp ah, #0x86
  je int15_handler32
  cmp ah, #0xE8
  je int15_handler32
  pusha
  cmp ah, #0xC2
  je int15_handler_mouse
  call _int15_function
int15_handler_mouse_ret:
  popa
int15_handler32_ret:
  pop es
  pop ds
  popf
  jmp iret_modify_cf
apm_call:
  jmp _apmreal_entry
int15_handler_mouse:
  call _int15_function_mouse
  jmp int15_handler_mouse_ret
int15_handler32:
  pushad
  call _int15_function32
  popad
  jmp int15_handler32_ret
;; Protected mode IDT descriptor
;;
;; I just make the limit 0, so the machine will shutdown
;; if an exception occurs during protected mode memory
;; transfers.
;;
;; Set base to f0000 to correspond to beginning of BIOS,
;; in case I actually define an IDT later
;; Set limit to 0
pmode_IDT_info:
dw 0x0000 ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x0f ;; base 23:16
;; Real mode IDT descriptor
;;
;; Set to typical real-mode values.
;; base = 000000
;; limit = 03ff
rmode_IDT_info:
dw 0x03ff ;; limit 15:00
dw 0x0000 ;; base 15:00
db 0x00 ;; base 23:16
;----------
;- INT1Ah -
;----------
.org 0xfe6e ; INT 1Ah Time-of-day Service Entry Point
int1a_handler:
  cmp ah, #0xb1
  jne int1a_normal
  call pcibios_real
  jc pcibios_error
  retf 2
pcibios_error:
  mov bl, ah
  mov ah, #0xb1
  push ds
  pusha
  mov ax, ss ; set readable descriptor to ds, for calling pcibios
  mov ds, ax ; on 16bit protected mode.
  jmp int1a_callfunction
int1a_normal:
  push ds
  pusha
  xor ax, ax
  mov ds, ax
int1a_callfunction:
  call _int1a_function
  popa
  pop ds
  iret
;;
;; int70h: IRQ8 - CMOS RTC
;;
int70_handler:
  push ds
  pushad
  xor ax, ax
  mov ds, ax
  call _int70_function
  popad
  pop ds
  iret
;---------
;- INT08 -
;---------
.org 0xfea5 ; INT 08h System Timer ISR Entry Point
int08_handler:
  sti
  push eax
  push ds
  xor ax, ax
  mov ds, ax
  ;; time to turn off drive(s)?
  mov al,0x0440
  or al,al
  jz int08_floppy_off
  dec al
  mov 0x0440,al
  jnz int08_floppy_off
  ;; turn motor(s) off
  push dx
  mov dx,#0x03f2
  in al,dx
  and al,#0xcf
  out dx,al
  pop dx
int08_floppy_off:
  mov eax, 0x046c ;; get ticks dword
  inc eax
  ;; compare eax to one days worth of timer ticks at 18.2 hz
  cmp eax, #0x001800B0
  jb int08_store_ticks
  ;; there has been a midnight rollover at this point
  xor eax, eax ;; zero out counter
  inc BYTE 0x0470 ;; increment rollover flag
int08_store_ticks:
  mov 0x046c, eax ;; store new ticks dword
  ;; chain to user timer tick INT #0x1c
  int #0x1c
  cli
  call eoi_master_pic
  pop ds
  pop eax
  iret
.org 0xfef3 ; Initial Interrupt Vector Offsets Loaded by POST
.org 0xff00
.ascii "(c) 2002 MandrakeSoft S.A. Written by Kevin Lawton & the Bochs team."
;------------------------------------------------
;- IRET Instruction for Dummy Interrupt Handler -
;------------------------------------------------
.org 0xff53 ; IRET Instruction for Dummy Interrupt Handler
dummy_iret_handler:
  iret
.org 0xff54 ; INT 05h Print Screen Service Entry Point
  HALT(11694)
  iret
.org 0xfff0 ; Power-up Entry Point
   jmp 0xf000:post
.org 0xfff5 ; ASCII Date ROM was built - 8 characters in MM/DD/YY
.ascii "06/23/99"
.org 0xfffe ; System Model ID
db 0xFC
db 0x00 ; filler
.org 0xfa6e ;; Character Font for 320x200 & 640x200 Graphics (lower 128 characters)
! 8242 endasm
!BCC_ENDASM
! 8243 static Bit8u vgafont8[128*8]=
! Register BX used in function int1a_function32
! 8244 {
.data
_vgafont8:
! 8245  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8246  0x7e, 0x81, 0xa5, 0x81, 0xbd, 0x99, 0x81, 0x7e,
.byte	$7E
.byte	$81
.byte	$A5
.byte	$81
.byte	$BD
.byte	$99
.byte	$81
.byte	$7E
! 8247  0x7e, 0xff, 0xdb, 0xff, 0xc3, 0xe7, 0xff, 0x7e,
.byte	$7E
.byte	$FF
.byte	$DB
.byte	$FF
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$7E
! 8248  0x6c, 0xfe, 0xfe, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$6C
.byte	$FE
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8249  0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x10, 0x00,
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$10
.byte	0
! 8250  0x38, 0x7c, 0x38, 0xfe, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$38
.byte	$7C
.byte	$38
.byte	$FE
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8251  0x10, 0x10, 0x38, 0x7c, 0xfe, 0x7c, 0x38, 0x7c,
.byte	$10
.byte	$10
.byte	$38
.byte	$7C
.byte	$FE
.byte	$7C
.byte	$38
.byte	$7C
! 8252  0x00, 0x00, 0x18, 0x3c, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	0
.byte	$18
.byte	$3C
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8253  0xff, 0xff, 0xe7, 0xc3, 0xc3, 0xe7, 0xff, 0xff,
.byte	$FF
.byte	$FF
.byte	$E7
.byte	$C3
.byte	$C3
.byte	$E7
.byte	$FF
.byte	$FF
! 8254  0x00, 0x3c, 0x66, 0x42, 0x42, 0x66, 0x3c, 0x00,
.byte	0
.byte	$3C
.byte	$66
.byte	$42
.byte	$42
.byte	$66
.byte	$3C
.byte	0
! 8255  0xff, 0xc3, 0x99, 0xbd, 0xbd, 0x99, 0xc3, 0xff,
.byte	$FF
.byte	$C3
.byte	$99
.byte	$BD
.byte	$BD
.byte	$99
.byte	$C3
.byte	$FF
! 8256  0x0f, 0x07, 0x0f, 0x7d, 0xcc, 0xcc, 0xcc, 0x78,
.byte	$F
.byte	7
.byte	$F
.byte	$7D
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
! 8257  0x3c, 0x66, 0x66, 0x66, 0x3c, 0x18, 0x7e, 0x18,
.byte	$3C
.byte	$66
.byte	$66
.byte	$66
.byte	$3C
.byte	$18
.byte	$7E
.byte	$18
! 8258  0x3f, 0x33, 0x3f, 0x30, 0x30, 0x70, 0xf0, 0xe0,
.byte	$3F
.byte	$33
.byte	$3F
.byte	$30
.byte	$30
.byte	$70
.byte	$F0
.byte	$E0
! 8259  0x7f, 0x63, 0x7f, 0x63, 0x63, 0x67, 0xe6, 0xc0,
.byte	$7F
.byte	$63
.byte	$7F
.byte	$63
.byte	$63
.byte	$67
.byte	$E6
.byte	$C0
! 8260  0x99, 0x5a, 0x3c, 0xe7, 0xe7, 0x3c, 0x5a, 0x99,
.byte	$99
.byte	$5A
.byte	$3C
.byte	$E7
.byte	$E7
.byte	$3C
.byte	$5A
.byte	$99
! 8261  0x80, 0xe0, 0xf8, 0xfe, 0xf8, 0x
.byte	$80
.byte	$E0
.byte	$F8
.byte	$FE
.byte	$F8
! 8261 e0, 0x80, 0x00,
.byte	$E0
.byte	$80
.byte	0
! 8262  0x02, 0x0e, 0x3e, 0xfe, 0x3e, 0x0e, 0x02, 0x00,
.byte	2
.byte	$E
.byte	$3E
.byte	$FE
.byte	$3E
.byte	$E
.byte	2
.byte	0
! 8263  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x7e, 0x3c, 0x18,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
! 8264  0x66, 0x66, 0x66, 0x66, 0x66, 0x00, 0x66, 0x00,
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	$66
.byte	0
.byte	$66
.byte	0
! 8265  0x7f, 0xdb, 0xdb, 0x7b, 0x1b, 0x1b, 0x1b, 0x00,
.byte	$7F
.byte	$DB
.byte	$DB
.byte	$7B
.byte	$1B
.byte	$1B
.byte	$1B
.byte	0
! 8266  0x3e, 0x63, 0x38, 0x6c, 0x6c, 0x38, 0xcc, 0x78,
.byte	$3E
.byte	$63
.byte	$38
.byte	$6C
.byte	$6C
.byte	$38
.byte	$CC
.byte	$78
! 8267  0x00, 0x00, 0x00, 0x00, 0x7e, 0x7e, 0x7e, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$7E
.byte	$7E
.byte	$7E
.byte	0
! 8268  0x18, 0x3c, 0x7e, 0x18, 0x7e, 0x3c, 0x18, 0xff,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	$FF
! 8269  0x18, 0x3c, 0x7e, 0x18, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$3C
.byte	$7E
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8270  0x18, 0x18, 0x18, 0x18, 0x7e, 0x3c, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
! 8271  0x00, 0x18, 0x0c, 0xfe, 0x0c, 0x18, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$C
.byte	$FE
.byte	$C
.byte	$18
.byte	0
.byte	0
! 8272  0x00, 0x30, 0x60, 0xfe, 0x60, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$60
.byte	$FE
.byte	$60
.byte	$30
.byte	0
.byte	0
! 8273  0x00, 0x00, 0xc0, 0xc0, 0xc0, 0xfe, 0x00, 0x00,
.byte	0
.byte	0
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$FE
.byte	0
.byte	0
! 8274  0x00, 0x24, 0x66, 0xff, 0x66, 0x24, 0x00, 0x00,
.byte	0
.byte	$24
.byte	$66
.byte	$FF
.byte	$66
.byte	$24
.byte	0
.byte	0
! 8275  0x00, 0x18, 0x3c, 0x7e, 0xff, 0xff, 0x00, 0x00,
.byte	0
.byte	$18
.byte	$3C
.byte	$7E
.byte	$FF
.byte	$FF
.byte	0
.byte	0
! 8276  0x00, 0xff, 0xff, 0x7e, 0x3c, 0x18, 0x00, 0x00,
.byte	0
.byte	$FF
.byte	$FF
.byte	$7E
.byte	$3C
.byte	$18
.byte	0
.byte	0
! 8277  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8278  0x30, 0x78, 0x78, 0x30, 0x30, 0x00, 0x30, 0x00,
.byte	$30
.byte	$78
.byte	$78
.byte	$30
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8279  0x6c, 0x6c, 0x6c, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$6C
.byte	$6C
.byte	$6C
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8280  0x6c, 0x6c, 0xfe, 0x6c, 0xfe, 0x6c, 0x6c, 0x00,
.byte	$6C
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$FE
.byte	$6C
.byte	$6C
.byte	0
! 8281  0x30, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x30, 0x00,
.byte	$30
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	$30
.byte	0
! 8282  0x00, 0xc6, 0xcc, 0x18, 0x30, 0x66, 0xc6, 0x00,
.byte	0
.byte	$C6
.byte	$CC
.byte	$18
.byte	$30
.byte	$66
.byte	$C6
.byte	0
! 8283  0x38, 0x6c, 0x38, 0x76, 0xdc, 0xcc, 0x76, 0x00,
.byte	$38
.byte	$6C
.byte	$38
.byte	$76
.byte	$DC
.byte	$CC
.byte	$76
.byte	0
! 8284  0x60, 0x60, 0xc0, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$60
.byte	$60
.byte	$C0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8285  0x18, 0x30, 0x60, 0x60, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$60
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8286  0x60, 0x30, 0x18, 0x18, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$18
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8287  0x00, 0x66, 0x3c, 0xff, 0x3c, 0x66, 0x00, 0x00,
.byte	0
.byte	$66
.byte	$3C
.byte	$FF
.byte	$3C
.byte	$66
.byte	0
.byte	0
! 8288  0x00, 0x30, 0x30, 0xfc, 0x30, 0x30, 0x00, 0x00,
.byte	0
.byte	$30
.byte	$30
.byte	$FC
.byte	$30
.byte	$30
.byte	0
.byte	0
! 8289  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8290  0x00, 0x00, 0x00, 0xfc, 0x00, 0x00, 0x00, 0x00,
.byte	0
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	0
.byte	0
! 8291  0x00, 0x00, 0x00, 0x00, 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8292  0x06, 0x0c, 0x18, 0x30, 0x60, 0xc0, 0x80, 0x00,
.byte	6
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$80
.byte	0
! 8293  0x7c, 0xc6, 0xce, 0xde, 0xf6, 0xe6, 0x7c, 0x00,
.byte	$7C
.byte	$C6
.byte	$CE
.byte	$DE
.byte	$F6
.byte	$E6
.byte	$7C
.byte	0
! 8294  0x30, 0x70, 0x30, 0x30, 0x30, 0x30, 0xfc, 0x00,
.byte	$30
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$FC
.byte	0
! 8295  0x78, 0xcc, 0x0c, 0x38, 0x60, 0xcc, 0xfc, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$60
.byte	$CC
.byte	$FC
.byte	0
! 8296  0x78, 0xcc, 0x0c, 0x38, 0x0c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$38
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8297  0x1c, 0x3c, 0x6c, 0xcc, 0xfe, 0x0c, 0x1e, 0x00,
.byte	$1C
.byte	$3C
.byte	$6C
.byte	$CC
.byte	$FE
.byte	$C
.byte	$1E
.byte	0
! 8298  0xfc, 0xc0, 0xf8, 0x0c, 0x0c, 0xcc, 0x78, 0x00,
.byte	$FC
.byte	$C0
.byte	$F8
.byte	$C
.byte	$C
.byte	$CC
.byte	$78
.byte	0
! 8299  0x38, 0x60, 0xc0, 0xf8, 0xcc, 0xcc, 0x78, 0x00,
.byte	$38
.byte	$60
.byte	$C0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8300  0xfc, 0xcc, 0x0c, 0x18, 0x30, 0x30, 0x30, 0x00,
.byte	$FC
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	$30
.byte	$30
.byte	0
! 8301  0x78, 0xcc, 0xcc, 0x78, 0xcc, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$78
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8302  0x78, 0xcc, 0xcc, 0x7c, 0x0c, 0x18, 0x70, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$18
.byte	$70
.byte	0
! 8303  0x00, 0x30, 0x30, 0x00
.byte	0
.byte	$30
.byte	$30
! 8303 , 0x00, 0x30, 0x30, 0x00,
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	0
! 8304  0x00, 0x30, 0x30, 0x00, 0x00, 0x30, 0x30, 0x60,
.byte	0
.byte	$30
.byte	$30
.byte	0
.byte	0
.byte	$30
.byte	$30
.byte	$60
! 8305  0x18, 0x30, 0x60, 0xc0, 0x60, 0x30, 0x18, 0x00,
.byte	$18
.byte	$30
.byte	$60
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	0
! 8306  0x00, 0x00, 0xfc, 0x00, 0x00, 0xfc, 0x00, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
.byte	$FC
.byte	0
.byte	0
! 8307  0x60, 0x30, 0x18, 0x0c, 0x18, 0x30, 0x60, 0x00,
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	$18
.byte	$30
.byte	$60
.byte	0
! 8308  0x78, 0xcc, 0x0c, 0x18, 0x30, 0x00, 0x30, 0x00,
.byte	$78
.byte	$CC
.byte	$C
.byte	$18
.byte	$30
.byte	0
.byte	$30
.byte	0
! 8309  0x7c, 0xc6, 0xde, 0xde, 0xde, 0xc0, 0x78, 0x00,
.byte	$7C
.byte	$C6
.byte	$DE
.byte	$DE
.byte	$DE
.byte	$C0
.byte	$78
.byte	0
! 8310  0x30, 0x78, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0x00,
.byte	$30
.byte	$78
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
.byte	0
! 8311  0xfc, 0x66, 0x66, 0x7c, 0x66, 0x66, 0xfc, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$66
.byte	$66
.byte	$FC
.byte	0
! 8312  0x3c, 0x66, 0xc0, 0xc0, 0xc0, 0x66, 0x3c, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$C0
.byte	$66
.byte	$3C
.byte	0
! 8313  0xf8, 0x6c, 0x66, 0x66, 0x66, 0x6c, 0xf8, 0x00,
.byte	$F8
.byte	$6C
.byte	$66
.byte	$66
.byte	$66
.byte	$6C
.byte	$F8
.byte	0
! 8314  0xfe, 0x62, 0x68, 0x78, 0x68, 0x62, 0xfe, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$62
.byte	$FE
.byte	0
! 8315  0xfe, 0x62, 0x68, 0x78, 0x68, 0x60, 0xf0, 0x00,
.byte	$FE
.byte	$62
.byte	$68
.byte	$78
.byte	$68
.byte	$60
.byte	$F0
.byte	0
! 8316  0x3c, 0x66, 0xc0, 0xc0, 0xce, 0x66, 0x3e, 0x00,
.byte	$3C
.byte	$66
.byte	$C0
.byte	$C0
.byte	$CE
.byte	$66
.byte	$3E
.byte	0
! 8317  0xcc, 0xcc, 0xcc, 0xfc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8318  0x78, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$78
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8319  0x1e, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78, 0x00,
.byte	$1E
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8320  0xe6, 0x66, 0x6c, 0x78, 0x6c, 0x66, 0xe6, 0x00,
.byte	$E6
.byte	$66
.byte	$6C
.byte	$78
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8321  0xf0, 0x60, 0x60, 0x60, 0x62, 0x66, 0xfe, 0x00,
.byte	$F0
.byte	$60
.byte	$60
.byte	$60
.byte	$62
.byte	$66
.byte	$FE
.byte	0
! 8322  0xc6, 0xee, 0xfe, 0xfe, 0xd6, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$EE
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	$C6
.byte	0
! 8323  0xc6, 0xe6, 0xf6, 0xde, 0xce, 0xc6, 0xc6, 0x00,
.byte	$C6
.byte	$E6
.byte	$F6
.byte	$DE
.byte	$CE
.byte	$C6
.byte	$C6
.byte	0
! 8324  0x38, 0x6c, 0xc6, 0xc6, 0xc6, 0x6c, 0x38, 0x00,
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	0
! 8325  0xfc, 0x66, 0x66, 0x7c, 0x60, 0x60, 0xf0, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8326  0x78, 0xcc, 0xcc, 0xcc, 0xdc, 0x78, 0x1c, 0x00,
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$DC
.byte	$78
.byte	$1C
.byte	0
! 8327  0xfc, 0x66, 0x66, 0x7c, 0x6c, 0x66, 0xe6, 0x00,
.byte	$FC
.byte	$66
.byte	$66
.byte	$7C
.byte	$6C
.byte	$66
.byte	$E6
.byte	0
! 8328  0x78, 0xcc, 0xe0, 0x70, 0x1c, 0xcc, 0x78, 0x00,
.byte	$78
.byte	$CC
.byte	$E0
.byte	$70
.byte	$1C
.byte	$CC
.byte	$78
.byte	0
! 8329  0xfc, 0xb4, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$FC
.byte	$B4
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8330  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0xfc, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$FC
.byte	0
! 8331  0xcc, 0xcc, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8332  0xc6, 0xc6, 0xc6, 0xd6, 0xfe, 0xee, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$EE
.byte	$C6
.byte	0
! 8333  0xc6, 0xc6, 0x6c, 0x38, 0x38, 0x6c, 0xc6, 0x00,
.byte	$C6
.byte	$C6
.byte	$6C
.byte	$38
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8334  0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x30, 0x78, 0x00,
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8335  0xfe, 0xc6, 0x8c, 0x18, 0x32, 0x66, 0xfe, 0x00,
.byte	$FE
.byte	$C6
.byte	$8C
.byte	$18
.byte	$32
.byte	$66
.byte	$FE
.byte	0
! 8336  0x78, 0x60, 0x60, 0x60, 0x60, 0x60, 0x78, 0x00,
.byte	$78
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$60
.byte	$78
.byte	0
! 8337  0xc0, 0x60, 0x30, 0x18, 0x0c, 0x06, 0x02, 0x00,
.byte	$C0
.byte	$60
.byte	$30
.byte	$18
.byte	$C
.byte	6
.byte	2
.byte	0
! 8338  0x78, 0x18, 0x18, 0x18, 0x18, 0x18, 0x78, 0x00,
.byte	$78
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$18
.byte	$78
.byte	0
! 8339  0x10, 0x38, 0x6c, 0xc6, 0x00, 0x00, 0x00, 0x00,
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
.byte	0
.byte	0
.byte	0
! 8340  0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xff,
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	$FF
! 8341  0x30, 0x30, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$30
.byte	$30
.byte	$18
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8342  0x00, 0x00, 0x78, 0x0c, 0x7c, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$C
.byte	$7C
.byte	$CC
.byte	$76
.byte	0
! 8343  0xe0, 0x60, 0x60, 0x7c, 0x66, 0x66, 0xdc, 0x00,
.byte	$E0
.byte	$60
.byte	$60
.byte	$7C
.byte	$66
.byte	$66
.byte	$DC
.byte	0
! 8344  0x00, 0x00, 0x78, 0xcc, 0xc0, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$C0
.byte	$CC
.byte	$78
.byte	0
! 8345  0x1c, 0x0c, 
.byte	$1C
.byte	$C
! 8345 0x0c, 0x7c, 0xcc, 0xcc, 0x76, 0x00,
.byte	$C
.byte	$7C
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8346  0x00, 0x00, 0x78, 0xcc, 0xfc, 0xc0, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$FC
.byte	$C0
.byte	$78
.byte	0
! 8347  0x38, 0x6c, 0x60, 0xf0, 0x60, 0x60, 0xf0, 0x00,
.byte	$38
.byte	$6C
.byte	$60
.byte	$F0
.byte	$60
.byte	$60
.byte	$F0
.byte	0
! 8348  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8349  0xe0, 0x60, 0x6c, 0x76, 0x66, 0x66, 0xe6, 0x00,
.byte	$E0
.byte	$60
.byte	$6C
.byte	$76
.byte	$66
.byte	$66
.byte	$E6
.byte	0
! 8350  0x30, 0x00, 0x70, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$30
.byte	0
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8351  0x0c, 0x00, 0x0c, 0x0c, 0x0c, 0xcc, 0xcc, 0x78,
.byte	$C
.byte	0
.byte	$C
.byte	$C
.byte	$C
.byte	$CC
.byte	$CC
.byte	$78
! 8352  0xe0, 0x60, 0x66, 0x6c, 0x78, 0x6c, 0xe6, 0x00,
.byte	$E0
.byte	$60
.byte	$66
.byte	$6C
.byte	$78
.byte	$6C
.byte	$E6
.byte	0
! 8353  0x70, 0x30, 0x30, 0x30, 0x30, 0x30, 0x78, 0x00,
.byte	$70
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$30
.byte	$78
.byte	0
! 8354  0x00, 0x00, 0xcc, 0xfe, 0xfe, 0xd6, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$FE
.byte	$FE
.byte	$D6
.byte	$C6
.byte	0
! 8355  0x00, 0x00, 0xf8, 0xcc, 0xcc, 0xcc, 0xcc, 0x00,
.byte	0
.byte	0
.byte	$F8
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	0
! 8356  0x00, 0x00, 0x78, 0xcc, 0xcc, 0xcc, 0x78, 0x00,
.byte	0
.byte	0
.byte	$78
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	0
! 8357  0x00, 0x00, 0xdc, 0x66, 0x66, 0x7c, 0x60, 0xf0,
.byte	0
.byte	0
.byte	$DC
.byte	$66
.byte	$66
.byte	$7C
.byte	$60
.byte	$F0
! 8358  0x00, 0x00, 0x76, 0xcc, 0xcc, 0x7c, 0x0c, 0x1e,
.byte	0
.byte	0
.byte	$76
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$1E
! 8359  0x00, 0x00, 0xdc, 0x76, 0x66, 0x60, 0xf0, 0x00,
.byte	0
.byte	0
.byte	$DC
.byte	$76
.byte	$66
.byte	$60
.byte	$F0
.byte	0
! 8360  0x00, 0x00, 0x7c, 0xc0, 0x78, 0x0c, 0xf8, 0x00,
.byte	0
.byte	0
.byte	$7C
.byte	$C0
.byte	$78
.byte	$C
.byte	$F8
.byte	0
! 8361  0x10, 0x30, 0x7c, 0x30, 0x30, 0x34, 0x18, 0x00,
.byte	$10
.byte	$30
.byte	$7C
.byte	$30
.byte	$30
.byte	$34
.byte	$18
.byte	0
! 8362  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0xcc, 0x76, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$76
.byte	0
! 8363  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x78, 0x30, 0x00,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$78
.byte	$30
.byte	0
! 8364  0x00, 0x00, 0xc6, 0xd6, 0xfe, 0xfe, 0x6c, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$D6
.byte	$FE
.byte	$FE
.byte	$6C
.byte	0
! 8365  0x00, 0x00, 0xc6, 0x6c, 0x38, 0x6c, 0xc6, 0x00,
.byte	0
.byte	0
.byte	$C6
.byte	$6C
.byte	$38
.byte	$6C
.byte	$C6
.byte	0
! 8366  0x00, 0x00, 0xcc, 0xcc, 0xcc, 0x7c, 0x0c, 0xf8,
.byte	0
.byte	0
.byte	$CC
.byte	$CC
.byte	$CC
.byte	$7C
.byte	$C
.byte	$F8
! 8367  0x00, 0x00, 0xfc, 0x98, 0x30, 0x64, 0xfc, 0x00,
.byte	0
.byte	0
.byte	$FC
.byte	$98
.byte	$30
.byte	$64
.byte	$FC
.byte	0
! 8368  0x1c, 0x30, 0x30, 0xe0, 0x30, 0x30, 0x1c, 0x00,
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	0
! 8369  0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00,
.byte	$18
.byte	$18
.byte	$18
.byte	0
.byte	$18
.byte	$18
.byte	$18
.byte	0
! 8370  0xe0, 0x30, 0x30, 0x1c, 0x30, 0x30, 0xe0, 0x00,
.byte	$E0
.byte	$30
.byte	$30
.byte	$1C
.byte	$30
.byte	$30
.byte	$E0
.byte	0
! 8371  0x76, 0xdc, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00,
.byte	$76
.byte	$DC
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
.byte	0
! 8372  0x00, 0x10, 0x38, 0x6c, 0xc6, 0xc6, 0xfe, 0x00,
.byte	0
.byte	$10
.byte	$38
.byte	$6C
.byte	$C6
.byte	$C6
.byte	$FE
.byte	0
! 8373 };
!BCC_EOS
! 8374 #asm
!BCC_ASM
.org 0xcff0
bios_table_area_end:
! 8377 endasm
!BCC_ENDASM
! 8378 
.723:
.784:
.byte	0
.722:
.785:
.ascii	"Powering off in 30 seconds."
.byte	$A
.byte	0
.721:
.786:
.byte	$A
.ascii	"No bootable device."
.byte	$A
.byte	0
.70B:
.787:
.ascii	"set_diskette_current_cyl(): drive > 1"
.byte	$A
.byte	0
.6F5:
.788:
.ascii	"floppy: int13: bad floppy type"
.byte	$A
.byte	0
.6DD:
.789:
.ascii	"int13_diskette_function: write error"
.byte	$A
.byte	0
.6D7:
.78A:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6BC:
.78B:
.ascii	"int13_diskette_function: read error"
.byte	$A
.byte	0
.6B6:
.78C:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.6A4:
.78D:
.ascii	"int13_diskette: ctrl not ready"
.byte	$A
.byte	0
.5F3:
.78E:
.ascii	"Int13 eltorito call with AX=%04x. Please"
.ascii	" report"
.byte	$A
.byte	0
.59D:
.78F:
.ascii	"int13_cdrom: function %02x. Can't use 64"
.ascii	"bits lba"
.byte	$A
.byte	0
.4A5:
.790:
.ascii	"setkbdcomm"
.byte	0
.49E:
.791:
.ascii	"sendmouse"
.byte	0
.49B:
.792:
.ascii	"enabmouse"
.byte	0
.494:
.793:
.ascii	"enabmouse"
.byte	0
.491:
.794:
.ascii	"inhibmouse"
.byte	0
.48A:
.795:
.ascii	"inhibmouse"
.byte	0
.46D:
.796:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.43F:
.797:
.ascii	"KBD: int16h: out of keyboard input"
.byte	$A
.byte	0
.3F1:
.798:
.ascii	"INT 15h C2 AL=6, BH=%02x"
.byte	$A
.byte	0
.3DB:
.799:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3CB:
.79A:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3C8:
.79B:
.ascii	"Mouse status returned %02x (should be ac"
.ascii	"k)"
.byte	$A
.byte	0
.3A6:
.79C:
.ascii	"Mouse reset returned %02x (should be ack"
.ascii	")"
.byte	$A
.byte	0
.37E:
.79D:
.ascii	"EISA BIOS not present"
.byte	$A
.byte	0
.2E9:
.79E:
.ascii	"%dMB medium detected"
.byte	$A
.byte	0
.2E4:
.79F:
.ascii	"Unsupported sector size %u"
.byte	$A
.byte	0
.2DF:
.7A0:
.ascii	"Waiting for device to detect medium... "
.byte	0
.2D1:
.7A1:
.ascii	"not implemented for non-ATAPI device"
.byte	$A
.byte	0
.248:
.7A2:
.byte	$A
.byte	0
.243:
.7A3:
.ascii	"master"
.byte	0
.242:
.7A4:
.ascii	" slave"
.byte	0
.241:
.7A5:
.ascii	"ata%d %s: Unknown device"
.byte	$A
.byte	0
.23F:
.7A6:
.ascii	" ATAPI-%d Device"
.byte	$A
.byte	0
.23D:
.7A7:
.ascii	" ATAPI-%d CD-Rom/DVD-Rom"
.byte	$A
.byte	0
.239:
.7A8:
.ascii	"%c"
.byte	0
.232:
.7A9:
.ascii	"master"
.byte	0
.231:
.7AA:
.ascii	" slave"
.byte	0
.230:
.7AB:
.ascii	"ata%d %s: "
.byte	0
.22E:
.7AC:
.ascii	" ATA-%d Hard-Disk (%4u GBytes)"
.byte	$A
.byte	0
.22C:
.7AD:
.ascii	" ATA-%d Hard-Disk (%4u MBytes)"
.byte	$A
.byte	0
.228:
.7AE:
.ascii	"%c"
.byte	0
.221:
.7AF:
.ascii	"master"
.byte	0
.220:
.7B0:
.ascii	" slave"
.byte	0
.21F:
.7B1:
.ascii	"ata%d %s: "
.byte	0
.1F4:
.7B2:
.ascii	"ata-detect: Failed to detect ATAPI devic"
.ascii	"e"
.byte	$A
.byte	0
.1BB:
.7B3:
.ascii	"ata-detect: Failed to detect ATA device"
.byte	$A
.byte	0
.157:
.7B4:
.ascii	"INT18: BOOT FAILURE"
.byte	$A
.byte	0
.156:
.7B5:
.ascii	"NMI Handler called"
.byte	$A
.byte	0
.155:
.7B6:
.ascii	"CDROM boot failure code : %04x"
.byte	$A
.byte	0
.154:
.7B7:
.byte	$A,$A
.byte	0
.153:
.7B8:
.ascii	": could not read the boot disk"
.byte	0
.151:
.7B9:
.ascii	": not a bootable disk"
.byte	0
.14C:
.7BA:
.ascii	"Boot from %s failed"
.byte	0
.14B:
.7BB:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.147:
.7BC:
.ascii	"..."
.byte	$A
.byte	0
.146:
.7BD:
.ascii	" [%S]"
.byte	0
.142:
.7BE:
.ascii	"Booting from %s"
.byte	0
.141:
.7BF:
.ascii	"Bad drive type"
.byte	$A
.byte	0
.13A:
.7C0:
.byte	$A
.byte	0
.12E:
.7C1:
.byte	$A
.byte	0
.12D:
.7C2:
.ascii	" [%S]"
.byte	0
.12A:
.7C3:
.ascii	"%s"
.byte	0
.128:
.7C4:
.ascii	"%s"
.byte	$A
.byte	0
.121:
.7C5:
.ascii	"%d. "
.byte	0
.11C:
.7C6:
.ascii	"Select boot device:"
.byte	$A,$A
.byte	0
.112:
.7C7:
.byte	$A,$A
.ascii	"Press F12 for boot menu."
.byte	$A,$A
.byte	0
.10A:
.7C8:
.ascii	"apmbios pcibios eltorito PMM "
.byte	$A,$A
.byte	0
.109:
.7C9:
.ascii	"06/23/99"
.byte	0
.108:
.7CA:
.ascii	"Bochs BIOS - build: %s"
.byte	$A
.ascii	"%s"
.byte	$A
.ascii	"Options: "
.byte	0
.107:
.7CB:
.ascii	"Returned from s3_resume."
.byte	$A
.byte	0
.106:
.7CC:
.ascii	"Unimplemented shutdown status: %02x"
.byte	$A
.byte	0
.105:
.7CD:
.ascii	"Couldn't reset the machine"
.byte	$A
.byte	0
.104:
.7CE:
.ascii	"Keyboard error:%u"
.byte	$A
.byte	0
.8D:
.7CF:
.ascii	"bios_printf: unknown format"
.byte	$A
.byte	0
.41:
.7D0:
.ascii	"FATAL: "
.byte	0
.bss

! 0 errors detected
