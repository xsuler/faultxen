#line 1 "../../../xen/xsm/flask/policy/security_classes"
# FLASK

#
# Define the security object classes 
#

# Classes marked as userspace are classes
# for userspace object managers

class xen
class xen2
class domain
class domain2
class hvm
class mmu
class resource
class shadow
class event
class grant
class security
class version
class argo

# FLASK
#line 1 "policy/security_classes"
# Locally defined security classes
#
# These classes are not used by the hypervisor, but may be used by domains or
# daemons that need to make access control decisions using the hypervisor's
# security policy.
#
# Access vectors for these classes must be defined in the access_vectors file.
#line 1 "../../../xen/xsm/flask/policy/initial_sids"
# FLASK

#
# Define initial security identifiers 
#
sid xen
sid dom0
sid domio
sid domxen
sid unlabeled
sid security
sid ioport
sid iomem
sid irq
sid device
sid domU
sid domDM
# FLASK
#line 1 "../../../xen/xsm/flask/policy/access_vectors"
#
# Define the access vectors.
#
# class class_name { permission_name ... }

# Class xen and xen2 consists of dom0-only operations dealing with the
# hypervisor itself. Unless otherwise specified, the source is the domain
# executing the hypercall, and the target is the xen initial sid (type xen_t).
class xen
{
# XENPF_settime32
# XENPF_settime64
    settime
# XEN_SYSCTL_tbuf_op
    tbufcontrol
# CONSOLEIO_read, XEN_SYSCTL_readconsole
    readconsole
# XEN_SYSCTL_readconsole with clear=1
    clearconsole
# XEN_SYSCTL_perfc_op
    perfcontrol
# XENPF_add_memtype
    mtrr_add
# XENPF_del_memtype
    mtrr_del
# XENPF_read_memtype
    mtrr_read
# XENPF_microcode_update
    microcode
# XEN_SYSCTL_physinfo, XEN_SYSCTL_cputopoinfo, XEN_SYSCTL_numainfo
# XEN_SYSCTL_pcitopoinfo, XEN_SYSCTL_get_cpu_policy
    physinfo
# XENPF_platform_quirk
    quirk
# CONSOLEIO_write
    writeconsole
# PHYSDEVOP_apic_read, PHYSDEVOP_alloc_irq_vector
    readapic
# PHYSDEVOP_apic_write
    writeapic
# Most XENOPROF_*
    privprofile
# XENOPROF_{init,enable_virq,disable_virq,get_buffer}
    nonprivprofile
# kexec hypercall
    kexec
# XENPF_firmware_info, XENPF_efi_runtime_call
    firmware
# XENPF_enter_acpi_sleep
    sleep
# XENPF_change_freq
    frequency
# XENPF_getidletime
    getidle
# XEN_SYSCTL_debug_keys
    debug
# XEN_SYSCTL_getcpuinfo, XENPF_get_cpu_version, XENPF_get_cpuinfo
    getcpuinfo
# XEN_SYSCTL_availheap
    heap
# XEN_SYSCTL_get_pmstat, XEN_SYSCTL_pm_op, XENPF_set_processor_pminfo,
# XENPF_core_parking
    pm_op
# mca hypercall
    mca_op
# XEN_SYSCTL_lockprof_op
    lockprof
# XEN_SYSCTL_cpupool_op
    cpupool_op
# XEN_SYSCTL_scheduler_op with XEN_DOMCTL_SCHEDOP_getinfo, XEN_SYSCTL_sched_id, XEN_DOMCTL_SCHEDOP_getvcpuinfo
    getscheduler
# XEN_SYSCTL_scheduler_op with XEN_DOMCTL_SCHEDOP_putinfo, XEN_DOMCTL_SCHEDOP_putvcpuinfo
    setscheduler
}

# This is a continuation of class xen, since only 32 permissions can be
# defined per class
class xen2
{
# XENPF_resource_op
    resource_op
# XEN_SYSCTL_psr_cmt_op
    psr_cmt_op
# XEN_SYSCTL_psr_alloc
    psr_alloc
# XENPF_get_symbol
    get_symbol
# PMU control
    pmu_ctrl
# PMU use (domains, including unprivileged ones, will be using this operation)
    pmu_use
# XEN_SYSCTL_get_cpu_levelling_caps
    get_cpu_levelling_caps
# XEN_SYSCTL_get_cpu_featureset
    get_cpu_featureset
# XEN_SYSCTL_livepatch_op
    livepatch_op
# XEN_SYSCTL_coverage_op
    coverage_op
# XEN_SYSCTL_set_parameter
    set_parameter
}

# Classes domain and domain2 consist of operations that a domain performs on
# another domain or on itself.  Unless otherwise specified, the source is the
# domain executing the hypercall, and the target is the domain being operated on
# (which may result in a _self or _target type).
#
# transitions in class domain are used to produce the _self and _target types;
# see docs/misc/xsm-flask.txt and the example XSM policy for details.
class domain
{
# XEN_DOMCTL_setvcpucontext
# XEN_DOMCTL_setvcpuextstate
# XEN_DOMCTL_set_ext_vcpucontext
# XEN_DOMCTL_set_vcpu_msrs
    setvcpucontext
# XEN_DOMCTL_pausedomain
    pause
# XEN_DOMCTL_unpausedomain
    unpause
# XEN_DOMCTL_resumedomain
    resume
# XEN_DOMCTL_arm_createdomain
    create
# checked in FLASK_RELABEL_DOMAIN for any relabel operation:
#  source = the old label of the domain
#  target = the new label of the domain
# see also the domain2 relabel{from,to,self} permissions
    transition
# XEN_DOMCTL_max_vcpus
    max_vcpus
# XEN_DOMCTL_destroydomain
    destroy
# XEN_DOMCTL_setvcpuaffinity
# XEN_DOMCTL_setnodeaffinity
    setaffinity
# XEN_DOMCTL_getvcpuaffinity
# XEN_DOMCTL_getnodeaffinity
    getaffinity
# XEN_DOMCTL_scheduler_op with XEN_DOMCTL_SCHEDOP_getinfo
    getscheduler
# XEN_DOMCTL_getdomaininfo, XEN_SYSCTL_getdomaininfolist
    getdomaininfo
# XEN_DOMCTL_getvcpuinfo
    getvcpuinfo
# XEN_DOMCTL_getvcpucontext
# XEN_DOMCTL_get_ext_vcpucontext
# XEN_DOMCTL_getvcpuextstate
# XEN_DOMCTL_get_vcpu_msrs
    getvcpucontext
# XEN_DOMCTL_max_mem
    setdomainmaxmem
# XEN_DOMCTL_setdomainhandle
    setdomainhandle
# XEN_DOMCTL_setdebugging
    setdebugging
# XEN_DOMCTL_hypercall_init
    hypercall
# XEN_DOMCTL_settimeoffset
    settime
# checked in XEN_DOMCTL_set_target:
#  source = the new device model domain
#  target = the new target domain
# see also the domain2 make_priv_for and set_as_target checks
    set_target
# SCHEDOP_remote_shutdown
    shutdown
# XEN_DOMCTL_set_address_size
    setaddrsize
# XEN_DOMCTL_get_address_size
    getaddrsize
# XEN_DOMCTL_sendtrigger
    trigger
# XENMEM_get_pod_target
    getpodtarget
# XENMEM_set_pod_target
    setpodtarget
# XEN_DOMCTL_subscribe, XEN_DOMCTL_disable_migrate
    set_misc_info
# XEN_DOMCTL_set_virq_handler
    set_virq_handler
}

# This is a continuation of class domain, since only 32 permissions can be
# defined per class
class domain2
{
# checked in FLASK_RELABEL_DOMAIN with non-DOMID_SELF:
#  source = the domain making the hypercall
#  target = the old label of the domain being relabeled
    relabelfrom
# checked in FLASK_RELABEL_DOMAIN with non-DOMID_SELF:
#  source = the domain making the hypercall
#  target = the new label of the domain being relabeled
    relabelto
# checked in FLASK_RELABEL_DOMAIN, only with DOMID_SELF:
#  source = the old label of the domain
#  target = the new label of the domain
# see also domain__transition
    relabelself
# checked in XEN_DOMCTL_set_target:
#  source = the domain making the hypercall
#  target = the new device model domain
    make_priv_for
# checked in XEN_DOMCTL_set_target:
#  source = the domain making the hypercall
#  target = the new target domain
    set_as_target
# XEN_DOMCTL_set_cpu_policy
    set_cpu_policy
# XEN_DOMCTL_gettscinfo
    gettsc
# XEN_DOMCTL_settscinfo
    settsc
# XEN_DOMCTL_scheduler_op with XEN_DOMCTL_SCHEDOP_putinfo
    setscheduler
# XENMEM_claim_pages
    setclaim
# XEN_DOMCTL_cacheflush
    cacheflush
# Creation of the hardware domain when it is not dom0
    create_hardware_domain
# XEN_DOMCTL_setvnumainfo
    set_vnumainfo
# XENMEM_getvnumainfo
    get_vnumainfo
# XEN_DOMCTL_psr_cmt_op
    psr_cmt_op
# XEN_DOMCTL_set_access_required
# XEN_DOMCTL_monitor_op
# XEN_DOMCTL_vm_event_op
    vm_event
# XEN_DOMCTL_soft_reset
    soft_reset
# XENMEM_access_op
    mem_access
# XENMEM_paging_op
    mem_paging
# XENMEM_sharing_op
    mem_sharing
# XEN_DOMCTL_psr_alloc
    psr_alloc
# XENMEM_resource_map
    resource_map
# XEN_DOMCTL_get_cpu_policy
    get_cpu_policy
}

# Similar to class domain, but primarily contains domctls related to HVM domains
class hvm
{
# XEN_DOMCTL_sethvmcontext
    sethvmc
# XEN_DOMCTL_gethvmcontext, XEN_DOMCTL_gethvmcontext_partial
    gethvmc
# HVMOP_set_param
    setparam
# HVMOP_get_param
    getparam
    bind_irq
# HVMOP_get_mem_type,
# HVMOP_set_mem_access, HVMOP_get_mem_access, HVMOP_pagetable_dying
    hvmctl
# XEN_DOMCTL_mem_sharing_op and XENMEM_sharing_op_{share,add_physmap} with:
#  source = the domain making the hypercall
#  target = domain whose memory is being shared
    mem_sharing
# XEN_DOMCTL_audit_p2m
    audit_p2m
# checked in XENMEM_sharing_op_{share,add_physmap} with:
#  source = domain whose memory is being shared
#  target = client domain
    share_mem
# HVMOP_set_param setting HVM_PARAM_NESTEDHVM
    nested
# HVMOP_set_param setting HVM_PARAM_ALTP2MHVM
    altp2mhvm
# HVMOP_altp2m_set_domain_state HVMOP_altp2m_get_domain_state
# HVMOP_altp2m_vcpu_enable_notify HVMOP_altp2m_create_p2m
# HVMOP_altp2m_destroy_p2m HVMOP_altp2m_switch_p2m
# HVMOP_altp2m_set_mem_access HVMOP_altp2m_change_gfn
    altp2mhvm_op
# DMOP
    dm
}

# Class event describes event channels.  Interdomain event channels have their
# own security label which is computed using a type transition between the
# source and target domains.  Each endpoint has its own label, and the
# permission checks must pass on both endpoints for an event channel to be
# established.
class event
{
# when creating an interdomain event channel endpoint:
#  source = event channel label
#  target = remote domain the event channel binds to.  This may be a _self or
#           _target label if the endpoints are related as such.
# This permission is checked when creating an unbound event channel and when the
# interdomain event channel is established.
    bind
# EVTCHNOP_send:
#  source = domain sending the event
#  target = event channel label
    send
# EVTCHNOP_status; same as _send
    status
# when creating an interdomain event channel endpoint:
#  source = the domain creating the channel (which might not be an endpoint)
#  target = event channel label
    create
# EVTCHNOP_reset:
#  source = domain making the hypercall
#  target = domain whose event channels are being reset
    reset
}

# Class grant describes pages shared by grant mappings.  Pages use the security
# label of their owning domain.
class grant
{
# GNTTABOP_map_grant_ref with any access
    map_read
# GNTTABOP_map_grant_ref with write access
    map_write
# GNTTABOP_unmap_grant_ref
    unmap
# GNTTABOP_transfer
    transfer
# GNTTABOP_setup_table, GNTTABOP_get_status_frames (target is commonly _self)
    setup
# GNTTABOP_copy
    copy
# GNTTABOP_query_size, GNTTABOP_get_version
    query
}

# Class mmu describes pages of memory not accessed using grants.  Permissions
# are checked using the domain ID used to access the page - the most common case
# is a domain's own ID (the _self label).  Using DOMID_IO in the map command to
# restrict the mapping to IO memory will result in the target being domio_t, and
# migration uses read-only mappings with a target of DOMID_XEN (domxen_t).
class mmu
{
# checked when using mmu_update to map a page readably
#  source = domain making the hypercall (which might not own the page table)
#  target = domain whose pages are being mapped
    map_read
# checked when using mmu_update to map a page writably
#  source = domain making the hypercall
#  target = domain whose pages are being mapped
    map_write
# XEN_DOMCTL_getpageframeinfo3
    pageinfo
# XENMEM_{increase,decrease}_reservation, XENMEM_populate_physmap
    adjust
# XENMEM_{current,maximum}_reservation, XENMEM_maximum_gpfn
    stat
# mmu_update MMU_MACHPHYS_UPDATE
    updatemp
# XENMEM_add_to_physmap, XENMEM_remove_from_physmap
    physmap
# MMUEXT_PIN_L*_TABLE
    pinpage
# XENMEM_machine_memory_map (with target xen_t)
# XENMEM_set_memory_map (with domain target)
    memorymap
# checked when using mmu_update to update the page tables of another domain
#  source = domain making the hypercall
#  target = domain whose page tables are being modified
    remote_remap
# the mmuext_op hypercall acting on the target domain
    mmuext_op
# XENMEM_exchange:
#  source = domain making the hypercall
#  target = domain whose pages are being exchanged
    exchange
# Allow a privileged domain to install a map of a page it does not own.  Used
# for stub domain device models with the PV framebuffer.
    target_hack
}

# control of the paging_domctl split by subop
class shadow
{
# XEN_DOMCTL_SHADOW_OP_OFF
    disable
# enable, get/set allocation
    enable
# enable, read, and clean log
    logdirty
}

# Class resource is used to describe the resources used in hardware device
# passthrough.  Resources include: hardware IRQs, MMIO regions, x86 I/O ports,
# and PCI devices; see docs/misc/xsm-flask.txt for how to label them.
#
# Access to the legacy PCI configuration space on x86 via port 0xCF8/CFC
# requires IS_PRIV, even with FLASK.  Writes to the BARs are checked as "setup",
# while other reads/writes are "use"; the target is the PCI device whose
# configuration space is being modified.  Accesses to the MMIO-based PCI express
# configuration space described by the ACPI MCFG table are controlled as MMIO
# accesses, and cannot special-case BAR writes.
#
# The {add,remove}_{irq,ioport,iomem,device} permissions use:
#  source = domain making the hypercall
#  target = resource's security label
class resource
{
# checked when adding a resource to a domain:
#  source = domain making the hypercall
#  target = domain which will have access to the resource
    add
# checked when removing a resource from a domain:
#  source = domain making the hypercall
#  target = domain which will no longer have access to the resource
    remove
# checked when using some core Xen devices (target xen_t)
#  source = domain which will have access to the resource
#  target = xen_t
    use
# checked when adding a resource to a domain:
#  source = domain which will have access to the resource
#  target = resource's security label
# Requires an active IOMMU capable of interrupt remapping in order to
# enforce isolation.
    use_iommu
# checked when adding a resource to a domain when an IOMMU is available
# but it is not capable of interrupt mapping:
#  source = domain which will have access to the resource
#  target = resource's security label
# Enable this to allow some less secure systems to still work.
    use_iommu_nointremap
# checked when adding a resource to a domain when no IOMMU present:
#  source = domain which will have access to the resource
#  target = resource's security label
# Enable this to allow resource use without an active IOMMU.
    use_noiommu
# PHYSDEVOP_map_pirq and ioapic writes for dom0, when acting on real IRQs
#  For GSI interrupts, the IRQ's label is indexed by the IRQ number
#  For MSI interrupts, the label of the PCI device is used
    add_irq
# PHYSDEVOP_unmap_pirq (same as map, and only for real IRQs)
    remove_irq
# XEN_DOMCTL_ioport_permission, XEN_DOMCTL_ioport_mapping
    add_ioport
    remove_ioport
# XEN_DOMCTL_iomem_permission, XEN_DOMCTL_memory_mapping
    add_iomem
    remove_iomem
# XEN_DOMCTL_get_device_group, XEN_DOMCTL_test_assign_device:
#  source = domain making the hypercall
#  target = device being queried
    stat_device
# XEN_DOMCTL_assign_device
    add_device
# XEN_DOMCTL_deassign_device
    remove_device
# checked for PCI hot and cold-plug hypercalls, with target as the PCI device
# checked for CPU and memory hotplug with xen_t as the target
    plug
# checked for PCI hot-unplug hypercalls, with target as the PCI device
# checked for CPU offlining with xen_t as the target
    unplug
# checked for PHYSDEVOP_restore_msi* (target PCI device)
# checked for PHYSDEVOP_setup_gsi (target IRQ)
# checked for PHYSDEVOP_pci_mmcfg_reserved (target xen_t)
    setup
}

# Class security describes the FLASK security server itself; these operations
# are accessed using the xsm_op hypercall.  The source is the domain invoking
# the hypercall, and the target is security_t.
#
# Any domain with access to load_policy or setenforce must be trusted, since it
# can bypass the rest of the security policy.
class security
{
# use the security server to compute an access check
    compute_av
# use the security server to compute a type transition
    compute_create
# use the security server to compute member selection
    compute_member
# sid <-> context string conversions
    check_context
# allow loading a new XSM/FLASK policy
    load_policy
# use the security server to compute an object relabel
    compute_relabel
# allow switching between enforcing and permissive mode
    setenforce
# allow changing policy booleans
    setbool
# allow changing security server configuration parmeters
    setsecparam
# add ocontext label definitions for resources
    add_ocontext
# remove ocontext label definitions for resources
    del_ocontext
}

# Class version is used to describe the XENVER_ hypercall.
# Almost all sub-ops are described here - in the default case all of them should
# be allowed except the XENVER_commandline.
#
# The ones that are omitted are XENVER_version, XENVER_platform_parameters,
# and XENVER_get_features  - as they MUST always be returned to a guest.
#
class version
{
# Extra informations (-unstable).
    xen_extraversion
# Compile information of the hypervisor.
    xen_compile_info
# Such as "xen-3.0-x86_64 xen-3.0-x86_32p hvm-3.0-x86_32 hvm-3.0-x86_32p hvm-3.0-x86_64".
    xen_capabilities
# Source code changeset.
    xen_changeset
# Page size the hypervisor uses.
    xen_pagesize
# An value that the control stack can choose.
    xen_guest_handle
# Xen command line.
    xen_commandline
# Xen build id
    xen_build_id
}

# Class argo is used to describe the Argo interdomain communication system.
class argo
{
    # Enable initialization of a domain's argo subsystem and
    # permission to access the argo hypercall operations.
    enable
    # Domain requesting registration of a communication ring
    # to receive messages from a specific other domain.
    register_single_source
    # Domain requesting registration of a communication ring
    # to receive messages from any other domain.
    register_any_source
    # Domain sending a message to another domain.
    send
}
#line 1 "policy/access_vectors"
# Locally defined access vectors
#
# Define access vectors for the security classes defined in security_classes.
# Access vectors defined in this file should not be used by the hypervisor.
#
#line 1 "policy/support/mls_macros.spt"
########################################
#
# gen_cats(N)
#
# declares categores c0 to c(N-1)
#
#line 10




########################################
#
# gen_sens(N)
#
# declares sensitivites s0 to s(N-1) with dominance
# in increasing numeric order with s0 lowest, s(N-1) highest
#
#line 24




#line 34


########################################
#
# gen_levels(N,M)
#
# levels from s0 to (N-1) with categories c0 to (M-1)
#
#line 45




########################################
#
# Basic level names for system low and high
#



#line 1 "policy/support/misc_macros.spt"

########################################
#
# Helper macros
#

#
# shiftn(num,list...)
#
# shift the list num times
#


#
# ifndef(expr,true_block,false_block)
#
# m4 does not have this.
#


#
# __endline__
#
# dummy macro to insert a newline.  used for 
# errprint, so the close parentheses can be
# indented correctly.
#
#line 29


########################################
#
# refpolwarn(message)
#
# print a warning message
#


########################################
#
# refpolerr(message)
#
# print an error message.  does not
# make anything fail.
#


########################################
#
# gen_user(username, prefix, role_set, mls_defaultlevel, mls_range)
#
#line 54




########################################
#
# gen_context(context,mls_sensitivity,[mcs_categories])
#




########################################
#
# gen_bool(name,default_value)
#
#line 72

#line 83 "policy/mls"
 # Macro definitions for FLASK policy
#line 2 "modules/xen.if"

################################################################################
#
# Domain creation and setup
#
################################################################################
#line 13


# declare_domain(type, attrs...)
#   Declare a domain type, along with associated _self and _channel types
#   Allow the domain to perform basic operations on itself
#line 25


# declare_singleton_domain(type, attrs...)
#   Declare a domain type and associated _channel types.
#   Note: Because the domain can perform basic operations on itself and any
#   other domain of the same type, this constructor should be used for types
#   containing at most one domain. This is not enforced by policy.
#line 38


# declare_build_label(type)
#   Declare a paired _building type for the given domain type
#line 46


#line 63


# create_domain(priv, target)
#   Allow a domain to be created directly
#line 70


# create_domain_build_label(priv, target)
#   Allow a domain to be created via its domain build label
#line 80


# manage_domain(priv, target)
#   Allow managing a running domain
#line 90


# migrate_domain_out(priv, target)
#   Allow creation of a snapshot or migration image from a domain
#   (inbound migration is the same as domain creation)
#line 102


################################################################################
#
# Inter-domain communication
#
################################################################################

# create_channel(source, dest, chan-label)
#   This allows an event channel to be created from domains with labels
#   <source> to <dest> and will label it <chan-label>
#line 116


# domain_event_comms(dom1, dom2)
#   Allow two domain types to communicate using event channels
#line 123


# domain_comms(dom1, dom2)
#   Allow two domain types to communicate using grants and event channels
#line 131


# domain_self_comms(domain)
#   Allow a non-singleton domain type to communicate with itself using grants
#   and event channels
#line 139


# device_model(dm_dom, hvm_dom)
#   Define how a device model domain interacts with its target
#line 157


# make_device_model(priv, dm_dom, hvm_dom)
#   Allow creation of a device model and HVM domain pair
#line 165

################################################################################
#
# Device types and delegation (PCI passthrough)
#
################################################################################

# use_device_iommu(domain, device)
#   Allow a device to be used by a domain
#   only if an IOMMU provides isolation.
#line 179


# use_device_iommu_nointremap(domain, device)
#   Allow a device to be used by a domain
#   only if an IOMMU is active, even if it does not support
#   interrupt remapping.
#   Allows acceptance of (typically older) less isolating hardware.
#line 190


# use_device_noiommu(domain, device)
#   Allow a device to be used by a domain
#   even without an IOMMU available.
#line 199


# admin_device(domain, device)
#   Allow a device to be used and delegated by a domain
#line 207


# delegate_devices(priv-domain, target-domain)
#   Allow devices to be delegated
#line 213

#line 1 "policy/global_tunables"
#
# This file is for the declaration of global policy tunables, booleans,
# and other components not defined within a specific policy module.
#

#line 1 "modules/xen.te"
################################################################################
#
# Attributes for types
#
# An attribute may be used in a rule as shorthand for all types with that
# attribute.
#
################################################################################
attribute xen_type;
attribute domain_type;
attribute domain_self_type;
attribute domain_target_type;
attribute resource_type;
attribute event_type;
attribute mls_priv;

################################################################################
#
# Types for the initial SIDs
#
# These types are used internally for objects created during Xen startup or for
# devices that have not yet been labeled
#
################################################################################

# The hypervisor itself
type xen_t, xen_type, mls_priv;

# Domain 0

#line 30
	type dom0_t, domain_type,mls_priv;
#line 30
	
#line 30
	type dom0_t_channel, event_type;
#line 30
	type_transition dom0_t domain_type:event dom0_t_channel;
#line 30
	
#line 30
	allow dom0_t dom0_t:grant { query setup };
#line 30
	allow dom0_t dom0_t:mmu { adjust physmap map_read map_write stat pinpage updatemp mmuext_op };
#line 30
	allow dom0_t dom0_t:hvm { getparam setparam altp2mhvm_op };
#line 30
	allow dom0_t dom0_t:domain2 get_vnumainfo;
#line 30

#line 30
;

# I/O memory (DOMID_IO pseudo-domain)
type domio_t, xen_type;

# Xen heap (DOMID_XEN pseudo-domain)
type domxen_t, xen_type;

# Unlabeled objects
type unlabeled_t, xen_type;

# The XSM/FLASK security server
type security_t, xen_type;

# Unlabeled device resources
# Note: don't allow access to these types directly; see below for how to label
#       devices and use that label for allow rules
type irq_t, resource_type;
type ioport_t, resource_type;
type iomem_t, resource_type;
type device_t, resource_type;

# Domain destruction can result in some access checks for actions performed by
# the hypervisor.  These should always be allowed.
allow xen_t resource_type : resource { remove_irq remove_ioport remove_iomem };

################################################################################
#
# Policy constraints
#
# Neverallow rules will cause the policy build to fail if an allow rule exists
# that violates the expression. This is used to ensure proper labeling of
# objects.
#
################################################################################

# Domains must be declared using domain_type
neverallow * ~domain_type:domain { create transition };

# Resources must be declared using resource_type
neverallow * ~resource_type:resource { use use_iommu use_iommu_nointremap
                                       use_noiommu };

# Events must use event_type (see create_channel for a template)
neverallow ~event_type *:event bind;
neverallow * ~event_type:event { create send status };

################################################################################
#
# Users and Roles
#
################################################################################

# The object role (object_r) is used for devices, resources, and event channels;
# it does not need to be defined here and should not be used for domains.

# The system user and role are used for utility domains and pseudo-domains.  In
# systems where users and roles are not being used for separation, all domains
# can use the system user and role.


role system_r;
role system_r types { xen_type dom0_t };
#line 1 "modules/dom0.te"
################################################################################
#
# Allow dom0 access to all sysctls, devices, and the security server.
#
# While this could be written more briefly using wildcards, the permissions are
# listed out to make removing specific permissions simpler.
#
################################################################################
allow dom0_t xen_t:xen {
	settime tbufcontrol readconsole clearconsole perfcontrol mtrr_add
	mtrr_del mtrr_read microcode physinfo quirk writeconsole readapic
	writeapic privprofile nonprivprofile kexec firmware sleep frequency
	getidle debug getcpuinfo heap pm_op mca_op lockprof cpupool_op
	getscheduler setscheduler
};
allow dom0_t xen_t:xen2 {
	resource_op psr_cmt_op psr_alloc pmu_ctrl get_symbol
	get_cpu_levelling_caps get_cpu_featureset livepatch_op
	coverage_op set_parameter
};

# Allow dom0 to use all XENVER_ subops that have checks.
# Note that dom0 is part of domain_type so this has duplicates.
allow dom0_t xen_t:version {
	xen_extraversion xen_compile_info xen_capabilities
	xen_changeset xen_pagesize xen_guest_handle xen_commandline
	xen_build_id
};

allow dom0_t xen_t:mmu memorymap;

# Allow dom0 to use these domctls on itself. For domctls acting on other
# domains, see the definitions of create_domain and manage_domain.
allow dom0_t dom0_t:domain {
	setvcpucontext max_vcpus setaffinity getaffinity getscheduler
	getdomaininfo getvcpuinfo getvcpucontext setdomainmaxmem setdomainhandle
	setdebugging hypercall settime setaddrsize getaddrsize trigger
	getpodtarget setpodtarget set_misc_info set_virq_handler
};
allow dom0_t dom0_t:domain2 {
	set_cpu_policy gettsc settsc setscheduler set_vnumainfo
	get_vnumainfo psr_cmt_op psr_alloc get_cpu_policy
};
allow dom0_t dom0_t:resource { add remove };

# These permissions allow using the FLASK security server to compute access
# checks locally, which could be used by a domain or service (such as xenstore)
# that does not have its own security server to make access decisions based on
# Xen's security policy.
allow dom0_t security_t:security {
	compute_av compute_create compute_member compute_relabel
};

# Allow string/SID conversions (for "xl list -Z" and similar)
allow dom0_t security_t:security check_context;

# Allow flask-label-pci to add and change labels
allow dom0_t security_t:security { add_ocontext del_ocontext };

# Allow performance parameters of the security server to be tweaked
allow dom0_t security_t:security setsecparam;

# Allow changing the security policy
allow dom0_t security_t:security { load_policy setenforce setbool };

# Audit policy change events even when they are allowed
auditallow dom0_t security_t:security { load_policy setenforce setbool };

# Allow dom0 to report platform configuration changes back to the hypervisor
allow dom0_t xen_t:resource setup;


#line 72
    allow dom0_t device_t:resource { setup stat_device add_device add_irq add_iomem add_ioport remove_device remove_irq remove_iomem remove_ioport plug unplug };
#line 72
    allow dom0_t device_t:hvm bind_irq;
#line 72
    
#line 72
    allow dom0_t dom0_t:mmu exchange;
#line 72
    allow dom0_t device_t:resource { use_iommu use_iommu_nointremap use_noiommu };
#line 72
    allow dom0_t domio_t:mmu { map_read map_write };
#line 72

#line 72


#line 73
    allow dom0_t irq_t:resource { setup stat_device add_device add_irq add_iomem add_ioport remove_device remove_irq remove_iomem remove_ioport plug unplug };
#line 73
    allow dom0_t irq_t:hvm bind_irq;
#line 73
    
#line 73
    allow dom0_t dom0_t:mmu exchange;
#line 73
    allow dom0_t irq_t:resource { use_iommu use_iommu_nointremap use_noiommu };
#line 73
    allow dom0_t domio_t:mmu { map_read map_write };
#line 73

#line 73


#line 74
    allow dom0_t ioport_t:resource { setup stat_device add_device add_irq add_iomem add_ioport remove_device remove_irq remove_iomem remove_ioport plug unplug };
#line 74
    allow dom0_t ioport_t:hvm bind_irq;
#line 74
    
#line 74
    allow dom0_t dom0_t:mmu exchange;
#line 74
    allow dom0_t ioport_t:resource { use_iommu use_iommu_nointremap use_noiommu };
#line 74
    allow dom0_t domio_t:mmu { map_read map_write };
#line 74

#line 74


#line 75
    allow dom0_t iomem_t:resource { setup stat_device add_device add_irq add_iomem add_ioport remove_device remove_irq remove_iomem remove_ioport plug unplug };
#line 75
    allow dom0_t iomem_t:hvm bind_irq;
#line 75
    
#line 75
    allow dom0_t dom0_t:mmu exchange;
#line 75
    allow dom0_t iomem_t:resource { use_iommu use_iommu_nointremap use_noiommu };
#line 75
    allow dom0_t domio_t:mmu { map_read map_write };
#line 75

#line 75



#line 77
	
#line 77
	
#line 77
	allow dom0_t dom0_t_channel:event { create send status };
#line 77
	allow dom0_t_channel dom0_t:event { bind };
#line 77

#line 77
	
#line 77
	allow dom0_t dom0_t_channel:event { create send status };
#line 77
	allow dom0_t_channel dom0_t:event { bind };
#line 77

#line 77

#line 77
	allow dom0_t dom0_t:grant { map_read map_write copy unmap };
#line 77
	allow dom0_t dom0_t:grant { map_read map_write copy unmap };
#line 77

#line 1 "modules/guest_features.te"
# Allow all domains to use PMU (but not to change its settings --- that's what
# pmu_ctrl is for)
allow domain_type xen_t:xen2 pmu_use;

# Allow all domains to enable the Argo interdomain communication hypercall;
# to register single-sender (unicast) rings to partner with any domain;
# to register any-sender (wildcard) rings that can be sent to by any domain;
# and send messages to rings.
allow domain_type xen_t:argo { enable register_any_source };
allow domain_type domain_type:argo { send register_single_source };

# Allow guest console output to the serial console.  This is used by PV Linux
# and stub domains for early boot output, so don't audit even when we deny it.
# Without XSM, this is enabled only if the Xen was compiled in debug mode.

#line 15
	bool guest_writeconsole true;
#line 15

if (guest_writeconsole) {
	allow domain_type xen_t : xen writeconsole;
} else {
	dontaudit domain_type xen_t : xen writeconsole;
}

# For normal guests, allow all queries except XENVER_commandline.
allow domain_type xen_t:version {
    xen_extraversion xen_compile_info xen_capabilities
    xen_changeset xen_pagesize xen_guest_handle
};

# Version queries don't need auditing when denied.  They can be
# encountered in normal operation by xl or by reading sysfs files in
# Linux, so without this they will show up in the logs.  Since these
# operations return valid responses (like "denied"), hiding the denials
# should not break anything.
dontaudit domain_type xen_t:version {
	xen_commandline xen_build_id
};
#line 1 "modules/domU.te"
###############################################################################
#
# Domain creation
#
###############################################################################


#line 7
	type domU_t, domain_type;
#line 7
	type domU_t_self, domain_type, domain_self_type;
#line 7
	type_transition domU_t domU_t:domain domU_t_self;
#line 7
	type domU_t_channel, event_type;
#line 7
	type_transition domU_t domain_type:event domU_t_channel;
#line 7
	
#line 7
	allow domU_t domU_t_self:grant { query setup };
#line 7
	allow domU_t domU_t_self:mmu { adjust physmap map_read map_write stat pinpage updatemp mmuext_op };
#line 7
	allow domU_t domU_t_self:hvm { getparam setparam altp2mhvm_op };
#line 7
	allow domU_t domU_t_self:domain2 get_vnumainfo;
#line 7

#line 7


#line 8
	
#line 8
	allow domU_t domU_t_channel:event { create send status };
#line 8
	allow domU_t_channel domU_t_self:event { bind };
#line 8

#line 8
	allow domU_t domU_t_self:grant { map_read map_write copy unmap };
#line 8


#line 9
	
#line 9
	allow dom0_t domU_t:domain { create max_vcpus setdomainmaxmem setaddrsize
#line 9
			getdomaininfo hypercall setvcpucontext getscheduler
#line 9
			getvcpuinfo getaddrsize getaffinity setaffinity
#line 9
			settime setdomainhandle getvcpucontext set_misc_info };
#line 9
	allow dom0_t domU_t:domain2 { set_cpu_policy settsc setscheduler setclaim
#line 9
			set_vnumainfo get_vnumainfo cacheflush
#line 9
			psr_cmt_op psr_alloc soft_reset
#line 9
			resource_map get_cpu_policy };
#line 9
	allow dom0_t domU_t:security check_context;
#line 9
	allow dom0_t domU_t:shadow enable;
#line 9
	allow dom0_t domU_t:mmu { map_read map_write adjust memorymap physmap pinpage mmuext_op updatemp };
#line 9
	allow dom0_t domU_t:grant setup;
#line 9
	allow dom0_t domU_t:hvm { getparam hvmctl sethvmc
#line 9
			setparam nested altp2mhvm altp2mhvm_op dm };
#line 9

#line 9
	allow dom0_t domU_t_channel:event create;
#line 9


#line 10
	allow dom0_t domU_t:domain { getdomaininfo getvcpuinfo getaffinity
#line 10
			getaddrsize pause unpause trigger shutdown destroy
#line 10
			setaffinity setdomainmaxmem getscheduler resume
#line 10
			setpodtarget getpodtarget };
#line 10
    allow dom0_t domU_t:domain2 set_vnumainfo;
#line 10


#line 11
	
#line 11
	
#line 11
	allow dom0_t dom0_t_channel:event { create send status };
#line 11
	allow dom0_t_channel domU_t:event { bind };
#line 11

#line 11
	
#line 11
	allow domU_t domU_t_channel:event { create send status };
#line 11
	allow domU_t_channel dom0_t:event { bind };
#line 11

#line 11

#line 11
	allow dom0_t domU_t:grant { map_read map_write copy unmap };
#line 11
	allow domU_t dom0_t:grant { map_read map_write copy unmap };
#line 11


#line 12
	
#line 12
	
#line 12
	allow domU_t domU_t_channel:event { create send status };
#line 12
	allow domU_t_channel domU_t:event { bind };
#line 12

#line 12
	
#line 12
	allow domU_t domU_t_channel:event { create send status };
#line 12
	allow domU_t_channel domU_t:event { bind };
#line 12

#line 12

#line 12
	allow domU_t domU_t:grant { map_read map_write copy unmap };
#line 12
	allow domU_t domU_t:grant { map_read map_write copy unmap };
#line 12


#line 13
	allow dom0_t domxen_t:mmu map_read;
#line 13
	allow dom0_t domU_t:hvm { gethvmc getparam };
#line 13
	allow dom0_t domU_t:mmu { stat pageinfo map_read };
#line 13
	allow dom0_t domU_t:domain { getaddrsize getvcpucontext pause destroy };
#line 13
	allow dom0_t domU_t:domain2 gettsc;
#line 13
	allow dom0_t domU_t:shadow { enable disable logdirty };
#line 13


#line 14
	
#line 14
	allow domU_t domU_t_channel:event { create send status };
#line 14
	allow domU_t_channel domU_t_self:event { bind };
#line 14

#line 14
	allow domU_t domU_t_self:grant { map_read map_write copy unmap };
#line 14


# Device model for domU_t.  You can define distinct types for device models for
# domains of other types, or add more make_device_model lines for this type.

#line 18
	type dm_dom_t, domain_type;
#line 18
	type dm_dom_t_self, domain_type, domain_self_type;
#line 18
	type_transition dm_dom_t dm_dom_t:domain dm_dom_t_self;
#line 18
	type dm_dom_t_channel, event_type;
#line 18
	type_transition dm_dom_t domain_type:event dm_dom_t_channel;
#line 18
	
#line 18
	allow dm_dom_t dm_dom_t_self:grant { query setup };
#line 18
	allow dm_dom_t dm_dom_t_self:mmu { adjust physmap map_read map_write stat pinpage updatemp mmuext_op };
#line 18
	allow dm_dom_t dm_dom_t_self:hvm { getparam setparam altp2mhvm_op };
#line 18
	allow dm_dom_t dm_dom_t_self:domain2 get_vnumainfo;
#line 18

#line 18


#line 19
	
#line 19
	allow dom0_t dm_dom_t:domain { create max_vcpus setdomainmaxmem setaddrsize
#line 19
			getdomaininfo hypercall setvcpucontext getscheduler
#line 19
			getvcpuinfo getaddrsize getaffinity setaffinity
#line 19
			settime setdomainhandle getvcpucontext set_misc_info };
#line 19
	allow dom0_t dm_dom_t:domain2 { set_cpu_policy settsc setscheduler setclaim
#line 19
			set_vnumainfo get_vnumainfo cacheflush
#line 19
			psr_cmt_op psr_alloc soft_reset
#line 19
			resource_map get_cpu_policy };
#line 19
	allow dom0_t dm_dom_t:security check_context;
#line 19
	allow dom0_t dm_dom_t:shadow enable;
#line 19
	allow dom0_t dm_dom_t:mmu { map_read map_write adjust memorymap physmap pinpage mmuext_op updatemp };
#line 19
	allow dom0_t dm_dom_t:grant setup;
#line 19
	allow dom0_t dm_dom_t:hvm { getparam hvmctl sethvmc
#line 19
			setparam nested altp2mhvm altp2mhvm_op dm };
#line 19

#line 19
	allow dom0_t dm_dom_t_channel:event create;
#line 19


#line 20
	allow dom0_t dm_dom_t:domain { getdomaininfo getvcpuinfo getaffinity
#line 20
			getaddrsize pause unpause trigger shutdown destroy
#line 20
			setaffinity setdomainmaxmem getscheduler resume
#line 20
			setpodtarget getpodtarget };
#line 20
    allow dom0_t dm_dom_t:domain2 set_vnumainfo;
#line 20


#line 21
	
#line 21
	
#line 21
	allow dom0_t dom0_t_channel:event { create send status };
#line 21
	allow dom0_t_channel dm_dom_t:event { bind };
#line 21

#line 21
	
#line 21
	allow dm_dom_t dm_dom_t_channel:event { create send status };
#line 21
	allow dm_dom_t_channel dom0_t:event { bind };
#line 21

#line 21

#line 21
	allow dom0_t dm_dom_t:grant { map_read map_write copy unmap };
#line 21
	allow dm_dom_t dom0_t:grant { map_read map_write copy unmap };
#line 21


#line 22
	
#line 22
	type domU_t_target, domain_type, domain_target_type;
#line 22
	type_transition domU_t dm_dom_t:domain domU_t_target;
#line 22
	allow dm_dom_t domU_t:domain set_target;
#line 22

#line 22
	type_transition domU_t_target domain_type:event domU_t_channel;
#line 22
	
#line 22
	allow dm_dom_t dm_dom_t_channel:event { create send status };
#line 22
	allow dm_dom_t_channel domU_t_target:event { bind };
#line 22

#line 22
	
#line 22
	allow domU_t domU_t_channel:event { create send status };
#line 22
	allow domU_t_channel dm_dom_t:event { bind };
#line 22

#line 22
	allow dm_dom_t domU_t_channel:event create;
#line 22

#line 22
	allow dm_dom_t domU_t_target:domain { getdomaininfo shutdown };
#line 22
	allow dm_dom_t domU_t_target:mmu { map_read map_write adjust physmap target_hack };
#line 22
	allow dm_dom_t domU_t_target:hvm { getparam setparam hvmctl dm };
#line 22
	allow dm_dom_t domU_t_target:domain2 resource_map;
#line 22

#line 22
	allow dom0_t dm_dom_t:domain2 make_priv_for;
#line 22
	allow dom0_t domU_t:domain2 set_as_target;
#line 22


# This is required for PCI (or other device) passthrough

#line 25
    allow dom0_t domU_t:resource { add remove };
#line 25


# Both of these domain types can be created using the default (system) role
role system_r types { domU_t dm_dom_t };
#line 1 "modules/isolated_domU.te"

#line 1
	type isolated_domU_t, domain_type;
#line 1
	type isolated_domU_t_self, domain_type, domain_self_type;
#line 1
	type_transition isolated_domU_t isolated_domU_t:domain isolated_domU_t_self;
#line 1
	type isolated_domU_t_channel, event_type;
#line 1
	type_transition isolated_domU_t domain_type:event isolated_domU_t_channel;
#line 1
	
#line 1
	allow isolated_domU_t isolated_domU_t_self:grant { query setup };
#line 1
	allow isolated_domU_t isolated_domU_t_self:mmu { adjust physmap map_read map_write stat pinpage updatemp mmuext_op };
#line 1
	allow isolated_domU_t isolated_domU_t_self:hvm { getparam setparam altp2mhvm_op };
#line 1
	allow isolated_domU_t isolated_domU_t_self:domain2 get_vnumainfo;
#line 1

#line 1


#line 2
	
#line 2
	allow dom0_t isolated_domU_t:domain { create max_vcpus setdomainmaxmem setaddrsize
#line 2
			getdomaininfo hypercall setvcpucontext getscheduler
#line 2
			getvcpuinfo getaddrsize getaffinity setaffinity
#line 2
			settime setdomainhandle getvcpucontext set_misc_info };
#line 2
	allow dom0_t isolated_domU_t:domain2 { set_cpu_policy settsc setscheduler setclaim
#line 2
			set_vnumainfo get_vnumainfo cacheflush
#line 2
			psr_cmt_op psr_alloc soft_reset
#line 2
			resource_map get_cpu_policy };
#line 2
	allow dom0_t isolated_domU_t:security check_context;
#line 2
	allow dom0_t isolated_domU_t:shadow enable;
#line 2
	allow dom0_t isolated_domU_t:mmu { map_read map_write adjust memorymap physmap pinpage mmuext_op updatemp };
#line 2
	allow dom0_t isolated_domU_t:grant setup;
#line 2
	allow dom0_t isolated_domU_t:hvm { getparam hvmctl sethvmc
#line 2
			setparam nested altp2mhvm altp2mhvm_op dm };
#line 2

#line 2
	allow dom0_t isolated_domU_t_channel:event create;
#line 2


#line 3
	allow dom0_t isolated_domU_t:domain { getdomaininfo getvcpuinfo getaffinity
#line 3
			getaddrsize pause unpause trigger shutdown destroy
#line 3
			setaffinity setdomainmaxmem getscheduler resume
#line 3
			setpodtarget getpodtarget };
#line 3
    allow dom0_t isolated_domU_t:domain2 set_vnumainfo;
#line 3


#line 4
	
#line 4
	
#line 4
	allow dom0_t dom0_t_channel:event { create send status };
#line 4
	allow dom0_t_channel isolated_domU_t:event { bind };
#line 4

#line 4
	
#line 4
	allow isolated_domU_t isolated_domU_t_channel:event { create send status };
#line 4
	allow isolated_domU_t_channel dom0_t:event { bind };
#line 4

#line 4

#line 4
	allow dom0_t isolated_domU_t:grant { map_read map_write copy unmap };
#line 4
	allow isolated_domU_t dom0_t:grant { map_read map_write copy unmap };
#line 4


#line 5
	allow dom0_t domxen_t:mmu map_read;
#line 5
	allow dom0_t isolated_domU_t:hvm { gethvmc getparam };
#line 5
	allow dom0_t isolated_domU_t:mmu { stat pageinfo map_read };
#line 5
	allow dom0_t isolated_domU_t:domain { getaddrsize getvcpucontext pause destroy };
#line 5
	allow dom0_t isolated_domU_t:domain2 gettsc;
#line 5
	allow dom0_t isolated_domU_t:shadow { enable disable logdirty };
#line 5


#line 6
	
#line 6
	allow isolated_domU_t isolated_domU_t_channel:event { create send status };
#line 6
	allow isolated_domU_t_channel isolated_domU_t_self:event { bind };
#line 6

#line 6
	allow isolated_domU_t isolated_domU_t_self:grant { map_read map_write copy unmap };
#line 6


#line 1 "modules/prot_domU.te"
# This is an alternative to nomigrate_t: a policy boolean controls the ability
# to create or migrate a domain of type prot_domU_t.  If disabled, dom0 cannot
# map memory belonging to those domains.

#line 4
	bool prot_doms_locked false;
#line 4


#line 5
	type prot_domU_t, domain_type;
#line 5
	type prot_domU_t_self, domain_type, domain_self_type;
#line 5
	type_transition prot_domU_t prot_domU_t:domain prot_domU_t_self;
#line 5
	type prot_domU_t_channel, event_type;
#line 5
	type_transition prot_domU_t domain_type:event prot_domU_t_channel;
#line 5
	
#line 5
	allow prot_domU_t prot_domU_t_self:grant { query setup };
#line 5
	allow prot_domU_t prot_domU_t_self:mmu { adjust physmap map_read map_write stat pinpage updatemp mmuext_op };
#line 5
	allow prot_domU_t prot_domU_t_self:hvm { getparam setparam altp2mhvm_op };
#line 5
	allow prot_domU_t prot_domU_t_self:domain2 get_vnumainfo;
#line 5

#line 5

if (!prot_doms_locked) {
	
#line 7
	
#line 7
	allow dom0_t prot_domU_t:domain { create max_vcpus setdomainmaxmem setaddrsize
#line 7
			getdomaininfo hypercall setvcpucontext getscheduler
#line 7
			getvcpuinfo getaddrsize getaffinity setaffinity
#line 7
			settime setdomainhandle getvcpucontext set_misc_info };
#line 7
	allow dom0_t prot_domU_t:domain2 { set_cpu_policy settsc setscheduler setclaim
#line 7
			set_vnumainfo get_vnumainfo cacheflush
#line 7
			psr_cmt_op psr_alloc soft_reset
#line 7
			resource_map get_cpu_policy };
#line 7
	allow dom0_t prot_domU_t:security check_context;
#line 7
	allow dom0_t prot_domU_t:shadow enable;
#line 7
	allow dom0_t prot_domU_t:mmu { map_read map_write adjust memorymap physmap pinpage mmuext_op updatemp };
#line 7
	allow dom0_t prot_domU_t:grant setup;
#line 7
	allow dom0_t prot_domU_t:hvm { getparam hvmctl sethvmc
#line 7
			setparam nested altp2mhvm altp2mhvm_op dm };
#line 7

#line 7
	allow dom0_t prot_domU_t_channel:event create;
#line 7

	
#line 8
	allow dom0_t domxen_t:mmu map_read;
#line 8
	allow dom0_t prot_domU_t:hvm { gethvmc getparam };
#line 8
	allow dom0_t prot_domU_t:mmu { stat pageinfo map_read };
#line 8
	allow dom0_t prot_domU_t:domain { getaddrsize getvcpucontext pause destroy };
#line 8
	allow dom0_t prot_domU_t:domain2 gettsc;
#line 8
	allow dom0_t prot_domU_t:shadow { enable disable logdirty };
#line 8

}

#line 10
	
#line 10
	
#line 10
	allow dom0_t dom0_t_channel:event { create send status };
#line 10
	allow dom0_t_channel prot_domU_t:event { bind };
#line 10

#line 10
	
#line 10
	allow prot_domU_t prot_domU_t_channel:event { create send status };
#line 10
	allow prot_domU_t_channel dom0_t:event { bind };
#line 10

#line 10

#line 10
	allow dom0_t prot_domU_t:grant { map_read map_write copy unmap };
#line 10
	allow prot_domU_t dom0_t:grant { map_read map_write copy unmap };
#line 10


#line 11
	
#line 11
	
#line 11
	allow domU_t domU_t_channel:event { create send status };
#line 11
	allow domU_t_channel prot_domU_t:event { bind };
#line 11

#line 11
	
#line 11
	allow prot_domU_t prot_domU_t_channel:event { create send status };
#line 11
	allow prot_domU_t_channel domU_t:event { bind };
#line 11

#line 11

#line 11
	allow domU_t prot_domU_t:grant { map_read map_write copy unmap };
#line 11
	allow prot_domU_t domU_t:grant { map_read map_write copy unmap };
#line 11


#line 12
	
#line 12
	
#line 12
	allow prot_domU_t prot_domU_t_channel:event { create send status };
#line 12
	allow prot_domU_t_channel prot_domU_t:event { bind };
#line 12

#line 12
	
#line 12
	allow prot_domU_t prot_domU_t_channel:event { create send status };
#line 12
	allow prot_domU_t_channel prot_domU_t:event { bind };
#line 12

#line 12

#line 12
	allow prot_domU_t prot_domU_t:grant { map_read map_write copy unmap };
#line 12
	allow prot_domU_t prot_domU_t:grant { map_read map_write copy unmap };
#line 12


#line 13
	
#line 13
	allow prot_domU_t prot_domU_t_channel:event { create send status };
#line 13
	allow prot_domU_t_channel prot_domU_t_self:event { bind };
#line 13

#line 13
	allow prot_domU_t prot_domU_t_self:grant { map_read map_write copy unmap };
#line 13

#line 1 "modules/nomigrate.te"
# Domains of type nomigrate_t must be built via the nomigrate_t_building label;
# once built, dom0 cannot read their memory.

#line 3
	type nomigrate_t, domain_type;
#line 3
	type nomigrate_t_self, domain_type, domain_self_type;
#line 3
	type_transition nomigrate_t nomigrate_t:domain nomigrate_t_self;
#line 3
	type nomigrate_t_channel, event_type;
#line 3
	type_transition nomigrate_t domain_type:event nomigrate_t_channel;
#line 3
	
#line 3
	allow nomigrate_t nomigrate_t_self:grant { query setup };
#line 3
	allow nomigrate_t nomigrate_t_self:mmu { adjust physmap map_read map_write stat pinpage updatemp mmuext_op };
#line 3
	allow nomigrate_t nomigrate_t_self:hvm { getparam setparam altp2mhvm_op };
#line 3
	allow nomigrate_t nomigrate_t_self:domain2 get_vnumainfo;
#line 3

#line 3


#line 4
	type nomigrate_t_building, domain_type;
#line 4
	type_transition nomigrate_t_building domain_type:event nomigrate_t_channel;
#line 4
	allow nomigrate_t_building nomigrate_t : domain transition;
#line 4


#line 5
	
#line 5
	allow dom0_t nomigrate_t_building:domain { create max_vcpus setdomainmaxmem setaddrsize
#line 5
			getdomaininfo hypercall setvcpucontext getscheduler
#line 5
			getvcpuinfo getaddrsize getaffinity setaffinity
#line 5
			settime setdomainhandle getvcpucontext set_misc_info };
#line 5
	allow dom0_t nomigrate_t_building:domain2 { set_cpu_policy settsc setscheduler setclaim
#line 5
			set_vnumainfo get_vnumainfo cacheflush
#line 5
			psr_cmt_op psr_alloc soft_reset
#line 5
			resource_map get_cpu_policy };
#line 5
	allow dom0_t nomigrate_t_building:security check_context;
#line 5
	allow dom0_t nomigrate_t_building:shadow enable;
#line 5
	allow dom0_t nomigrate_t_building:mmu { map_read map_write adjust memorymap physmap pinpage mmuext_op updatemp };
#line 5
	allow dom0_t nomigrate_t_building:grant setup;
#line 5
	allow dom0_t nomigrate_t_building:hvm { getparam hvmctl sethvmc
#line 5
			setparam nested altp2mhvm altp2mhvm_op dm };
#line 5

#line 5
	allow dom0_t nomigrate_t_channel:event create;
#line 5
	allow dom0_t nomigrate_t_building:domain2 relabelfrom;
#line 5
	allow dom0_t nomigrate_t:domain2 relabelto;
#line 5
	allow nomigrate_t_building nomigrate_t:domain transition;
#line 5


#line 6
	allow dom0_t nomigrate_t:domain { getdomaininfo getvcpuinfo getaffinity
#line 6
			getaddrsize pause unpause trigger shutdown destroy
#line 6
			setaffinity setdomainmaxmem getscheduler resume
#line 6
			setpodtarget getpodtarget };
#line 6
    allow dom0_t nomigrate_t:domain2 set_vnumainfo;
#line 6


#line 7
	
#line 7
	
#line 7
	allow dom0_t dom0_t_channel:event { create send status };
#line 7
	allow dom0_t_channel nomigrate_t:event { bind };
#line 7

#line 7
	
#line 7
	allow nomigrate_t nomigrate_t_channel:event { create send status };
#line 7
	allow nomigrate_t_channel dom0_t:event { bind };
#line 7

#line 7

#line 7
	allow dom0_t nomigrate_t:grant { map_read map_write copy unmap };
#line 7
	allow nomigrate_t dom0_t:grant { map_read map_write copy unmap };
#line 7


#line 8
	
#line 8
	allow nomigrate_t nomigrate_t_channel:event { create send status };
#line 8
	allow nomigrate_t_channel nomigrate_t_self:event { bind };
#line 8

#line 8
	allow nomigrate_t nomigrate_t_self:grant { map_read map_write copy unmap };
#line 8

#line 1 "modules/nic_dev.te"
###############################################################################
#
# Device delegation
#
# This requires that the device be labeled with a type defined here.  You can
# use flask-label-pci to dynamically label devices on each boot or define the
# labels statically in tools/flask/policy/policy/device_contexts
#
###############################################################################

type nic_dev_t, resource_type;


#line 13
    allow dom0_t nic_dev_t:resource { setup stat_device add_device add_irq add_iomem add_ioport remove_device remove_irq remove_iomem remove_ioport plug unplug };
#line 13
    allow dom0_t nic_dev_t:hvm bind_irq;
#line 13
    
#line 13
    allow dom0_t dom0_t:mmu exchange;
#line 13
    allow dom0_t nic_dev_t:resource { use_iommu use_iommu_nointremap use_noiommu };
#line 13
    allow dom0_t domio_t:mmu { map_read map_write };
#line 13

#line 13


#line 14
    allow domU_t domU_t_self:mmu exchange;
#line 14
    allow domU_t nic_dev_t:resource { use_iommu use_iommu_nointremap use_noiommu };
#line 14
    allow domU_t domio_t:mmu { map_read map_write };
#line 14

#line 1 "modules/xenstore.te"
################################################################################
#
# Xenstore stubdomain
#
################################################################################

#line 6
	type xenstore_t, domain_type;
#line 6
	
#line 6
	type xenstore_t_channel, event_type;
#line 6
	type_transition xenstore_t domain_type:event xenstore_t_channel;
#line 6
	
#line 6
	allow xenstore_t xenstore_t:grant { query setup };
#line 6
	allow xenstore_t xenstore_t:mmu { adjust physmap map_read map_write stat pinpage updatemp mmuext_op };
#line 6
	allow xenstore_t xenstore_t:hvm { getparam setparam altp2mhvm_op };
#line 6
	allow xenstore_t xenstore_t:domain2 get_vnumainfo;
#line 6

#line 6


#line 7
	
#line 7
	allow dom0_t xenstore_t:domain { create max_vcpus setdomainmaxmem setaddrsize
#line 7
			getdomaininfo hypercall setvcpucontext getscheduler
#line 7
			getvcpuinfo getaddrsize getaffinity setaffinity
#line 7
			settime setdomainhandle getvcpucontext set_misc_info };
#line 7
	allow dom0_t xenstore_t:domain2 { set_cpu_policy settsc setscheduler setclaim
#line 7
			set_vnumainfo get_vnumainfo cacheflush
#line 7
			psr_cmt_op psr_alloc soft_reset
#line 7
			resource_map get_cpu_policy };
#line 7
	allow dom0_t xenstore_t:security check_context;
#line 7
	allow dom0_t xenstore_t:shadow enable;
#line 7
	allow dom0_t xenstore_t:mmu { map_read map_write adjust memorymap physmap pinpage mmuext_op updatemp };
#line 7
	allow dom0_t xenstore_t:grant setup;
#line 7
	allow dom0_t xenstore_t:hvm { getparam hvmctl sethvmc
#line 7
			setparam nested altp2mhvm altp2mhvm_op dm };
#line 7

#line 7
	allow dom0_t xenstore_t_channel:event create;
#line 7


#line 8
	allow dom0_t xenstore_t:domain { getdomaininfo getvcpuinfo getaffinity
#line 8
			getaddrsize pause unpause trigger shutdown destroy
#line 8
			setaffinity setdomainmaxmem getscheduler resume
#line 8
			setpodtarget getpodtarget };
#line 8
    allow dom0_t xenstore_t:domain2 set_vnumainfo;
#line 8


# Xenstore requires the global VIRQ for domain destroy operations
allow dom0_t xenstore_t:domain set_virq_handler;
# Current xenstore stubdom uses the hypervisor console, not "xl console"
allow xenstore_t xen_t:xen writeconsole;
# Xenstore queries domaininfo on all domains
allow xenstore_t domain_type:domain getdomaininfo;

# As a shortcut, the following 3 rules are used instead of adding a domain_comms
# rule between xenstore_t and every domain type that talks to xenstore

#line 19
	allow xenstore_t xenstore_t_channel:event { create send status };
#line 19
	allow xenstore_t_channel domain_type:event { bind };
#line 19

allow event_type xenstore_t: event bind;
allow xenstore_t domain_type:grant { map_read map_write unmap };

# Xenstore is a utility domain, so it should use the system role
role system_r types xenstore_t;
#line 1 "modules/all_system_role.te"
# Allow all domains to use system_r so that systems that are not using the
# user/role separation feature will work properly.
role system_r types domain_type;
#line 1 "modules/vm_role.te"
# The vm role is used as part of user separation.  Allow all domain types to use
# this role except dom0.
role vm_r;
role vm_r types { domain_type -dom0_t };

# Define some users that must use this role (full type "user_1:vm_r:domU_t").




# Alternate: define and use a macro to generate 1000 users
#line 14


# def_vm_users(0,999)
#line 1 "policy/users"
 user system_u roles { system_r };
#line 1
 user user_1 roles { vm_r };
#line 1
 user user_2 roles { vm_r };
#line 1
 user user_3 roles { vm_r };
#line 1

#line 1 "modules/vm_role.cons"
#
# Constraints are defined by:
#
# constrain class_set perm_set expression ;
#
# expression : ( expression ) 
#	     | not expression
#	     | expression and expression
#	     | expression or expression
#	     | u1 op u2
#	     | r1 role_op r2
#	     | t1 op t2
#	     | u1 op names
#	     | u2 op names
#	     | r1 op names
#	     | r2 op names
#	     | t1 op names
#	     | t2 op names
#
# op : == | != 
# role_op : == | != | eq | dom | domby | incomp
#
# names : name | { name_list }
# name_list : name | name_list name
#


# Prevent event channels and grants between different users.  This could be
# further limited to only restricting those domains using the vm_r role.
constrain event bind (
	u1 == system_u or
	u2 == system_u or
	u1 == u2
);

constrain grant { map_read map_write copy } (
	u1 == system_u or
	u2 == system_u or
	u1 == u2
);
#line 1 "policy/initial_sids"
# Labels for initial SIDs. These initial SIDs are used by the hypervisor for
# objects created before the policy is loaded or for objects that do not have a
# label defined in some other manner.

sid xen system_u:system_r:xen_t
sid dom0 system_u:system_r:dom0_t
sid domxen system_u:system_r:domxen_t
sid domio system_u:system_r:domio_t
sid unlabeled system_u:system_r:unlabeled_t
sid security system_u:system_r:security_t
sid irq system_u:object_r:irq_t
sid iomem system_u:object_r:iomem_t
sid ioport system_u:object_r:ioport_t
sid device system_u:object_r:device_t

# Initial SIDs used by the toolstack for domains without defined labels
sid domU system_u:system_r:domU_t
sid domDM system_u:system_r:dm_dom_t
#line 1 "policy/device_contexts"
###############################################################################
#
# Label devices for delegation
#
# The PCI, IRQ, memory, and I/O port ranges are hardware-specific.
#
###############################################################################

# label e1000e nic
#pirqcon 33 system_u:object_r:nic_dev_t
#pirqcon 55 system_u:object_r:nic_dev_t
#iomemcon 0xfebe0-0xfebff system_u:object_r:nic_dev_t
#iomemcon 0xfebd9 system_u:object_r:nic_dev_t
#ioportcon 0xecc0-0xecdf system_u:object_r:nic_dev_t
#pcidevicecon 0xc800 system_u:object_r:nic_dev_t

# label e100 nic
#pirqcon 16 system_u:object_r:nic_dev_t
#iomemcon 0xfe5df system_u:object_r:nic_dev_t
#iomemcon 0xfe5e0-0xfe5ff system_u:object_r:nic_dev_t
#iomemcon 0xc2000-0xc200f system_u:object_r:nic_dev_t
#ioportcon 0xccc0-0xcd00 system_u:object_r:nic_dev_t

# label usb 1d.0-2 1d.7
#pirqcon 23 system_u:object_r:nic_dev_t
#pirqcon 17 system_u:object_r:nic_dev_t
#pirqcon 18 system_u:object_r:nic_dev_t
#ioportcon 0xff80-0xFF9F system_u:object_r:nic_dev_t
#ioportcon 0xff60-0xff7f system_u:object_r:nic_dev_t
#ioportcon 0xff40-0xff5f system_u:object_r:nic_dev_t
#iomemcon 0xff980 system_u:object_r:nic_dev_t
#ioportcon 0xff00-0xff1f system_u:object_r:nic_dev_t
