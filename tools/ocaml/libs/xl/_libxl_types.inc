/* AUTO-GENERATED FILE DO NOT EDIT */
/* autogenerated by 
   genwrap.py /root/tm/faultxen/tools/ocaml/libs/xl/../../../../tools/libxl/libxl_types.idl _libxl_types.mli.in _libxl_types.ml.in _libxl_types.inc
 */

/* Convert caml value to error */
static int error_val (libxl_ctx *ctx, libxl_error *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = ERROR_NONSPECIFIC; break;
	    case 1: *c_val = ERROR_VERSION; break;
	    case 2: *c_val = ERROR_FAIL; break;
	    case 3: *c_val = ERROR_NI; break;
	    case 4: *c_val = ERROR_NOMEM; break;
	    case 5: *c_val = ERROR_INVAL; break;
	    case 6: *c_val = ERROR_BADFAIL; break;
	    case 7: *c_val = ERROR_GUEST_TIMEDOUT; break;
	    case 8: *c_val = ERROR_TIMEDOUT; break;
	    case 9: *c_val = ERROR_NOPARAVIRT; break;
	    case 10: *c_val = ERROR_NOT_READY; break;
	    case 11: *c_val = ERROR_OSEVENT_REG_FAIL; break;
	    case 12: *c_val = ERROR_BUFFERFULL; break;
	    case 13: *c_val = ERROR_UNKNOWN_CHILD; break;
	    case 14: *c_val = ERROR_LOCK_FAIL; break;
	    case 15: *c_val = ERROR_JSON_CONFIG_EMPTY; break;
	    case 16: *c_val = ERROR_DEVICE_EXISTS; break;
	    case 17: *c_val = ERROR_CHECKPOINT_DEVOPS_DOES_NOT_MATCH; break;
	    case 18: *c_val = ERROR_CHECKPOINT_DEVICE_NOT_SUPPORTED; break;
	    case 19: *c_val = ERROR_VNUMA_CONFIG_INVALID; break;
	    case 20: *c_val = ERROR_DOMAIN_NOTFOUND; break;
	    case 21: *c_val = ERROR_ABORTED; break;
	    case 22: *c_val = ERROR_NOTFOUND; break;
	    case 23: *c_val = ERROR_DOMAIN_DESTROYED; break;
	    case 24: *c_val = ERROR_FEATURE_REMOVED; break;
	    case 25: *c_val = ERROR_PROTOCOL_ERROR_QMP; break;
	    case 26: *c_val = ERROR_UNKNOWN_QMP_ERROR; break;
	    case 27: *c_val = ERROR_QMP_GENERIC_ERROR; break;
	    case 28: *c_val = ERROR_QMP_COMMAND_NOT_FOUND; break;
	    case 29: *c_val = ERROR_QMP_DEVICE_NOT_ACTIVE; break;
	    case 30: *c_val = ERROR_QMP_DEVICE_NOT_FOUND; break;
	    case 31: *c_val = ERROR_QEMU_API; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_error"); break;
	}
	CAMLreturn(0);
}

/* Convert error to a caml value */
static value Val_error (libxl_error error_c)
{
	CAMLparam0();
	CAMLlocal1(error_ocaml);
	switch(error_c) {
	    case ERROR_NONSPECIFIC: error_ocaml = Val_int(0); break;
	    case ERROR_VERSION: error_ocaml = Val_int(1); break;
	    case ERROR_FAIL: error_ocaml = Val_int(2); break;
	    case ERROR_NI: error_ocaml = Val_int(3); break;
	    case ERROR_NOMEM: error_ocaml = Val_int(4); break;
	    case ERROR_INVAL: error_ocaml = Val_int(5); break;
	    case ERROR_BADFAIL: error_ocaml = Val_int(6); break;
	    case ERROR_GUEST_TIMEDOUT: error_ocaml = Val_int(7); break;
	    case ERROR_TIMEDOUT: error_ocaml = Val_int(8); break;
	    case ERROR_NOPARAVIRT: error_ocaml = Val_int(9); break;
	    case ERROR_NOT_READY: error_ocaml = Val_int(10); break;
	    case ERROR_OSEVENT_REG_FAIL: error_ocaml = Val_int(11); break;
	    case ERROR_BUFFERFULL: error_ocaml = Val_int(12); break;
	    case ERROR_UNKNOWN_CHILD: error_ocaml = Val_int(13); break;
	    case ERROR_LOCK_FAIL: error_ocaml = Val_int(14); break;
	    case ERROR_JSON_CONFIG_EMPTY: error_ocaml = Val_int(15); break;
	    case ERROR_DEVICE_EXISTS: error_ocaml = Val_int(16); break;
	    case ERROR_CHECKPOINT_DEVOPS_DOES_NOT_MATCH: error_ocaml = Val_int(17); break;
	    case ERROR_CHECKPOINT_DEVICE_NOT_SUPPORTED: error_ocaml = Val_int(18); break;
	    case ERROR_VNUMA_CONFIG_INVALID: error_ocaml = Val_int(19); break;
	    case ERROR_DOMAIN_NOTFOUND: error_ocaml = Val_int(20); break;
	    case ERROR_ABORTED: error_ocaml = Val_int(21); break;
	    case ERROR_NOTFOUND: error_ocaml = Val_int(22); break;
	    case ERROR_DOMAIN_DESTROYED: error_ocaml = Val_int(23); break;
	    case ERROR_FEATURE_REMOVED: error_ocaml = Val_int(24); break;
	    case ERROR_PROTOCOL_ERROR_QMP: error_ocaml = Val_int(25); break;
	    case ERROR_UNKNOWN_QMP_ERROR: error_ocaml = Val_int(26); break;
	    case ERROR_QMP_GENERIC_ERROR: error_ocaml = Val_int(27); break;
	    case ERROR_QMP_COMMAND_NOT_FOUND: error_ocaml = Val_int(28); break;
	    case ERROR_QMP_DEVICE_NOT_ACTIVE: error_ocaml = Val_int(29); break;
	    case ERROR_QMP_DEVICE_NOT_FOUND: error_ocaml = Val_int(30); break;
	    case ERROR_QEMU_API: error_ocaml = Val_int(31); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_error"); break;
	}
	CAMLreturn(error_ocaml);
}

/* Convert caml value to domain_type */
static int domain_type_val (libxl_ctx *ctx, libxl_domain_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_DOMAIN_TYPE_INVALID; break;
	    case 1: *c_val = LIBXL_DOMAIN_TYPE_HVM; break;
	    case 2: *c_val = LIBXL_DOMAIN_TYPE_PV; break;
	    case 3: *c_val = LIBXL_DOMAIN_TYPE_PVH; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_domain_type"); break;
	}
	CAMLreturn(0);
}

/* Convert domain_type to a caml value */
static value Val_domain_type (libxl_domain_type domain_type_c)
{
	CAMLparam0();
	CAMLlocal1(domain_type_ocaml);
	switch(domain_type_c) {
	    case LIBXL_DOMAIN_TYPE_INVALID: domain_type_ocaml = Val_int(0); break;
	    case LIBXL_DOMAIN_TYPE_HVM: domain_type_ocaml = Val_int(1); break;
	    case LIBXL_DOMAIN_TYPE_PV: domain_type_ocaml = Val_int(2); break;
	    case LIBXL_DOMAIN_TYPE_PVH: domain_type_ocaml = Val_int(3); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_domain_type"); break;
	}
	CAMLreturn(domain_type_ocaml);
}

/* Convert caml value to rdm_reserve_strategy */
static int rdm_reserve_strategy_val (libxl_ctx *ctx, libxl_rdm_reserve_strategy *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_RDM_RESERVE_STRATEGY_IGNORE; break;
	    case 1: *c_val = LIBXL_RDM_RESERVE_STRATEGY_HOST; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_rdm_reserve_strategy"); break;
	}
	CAMLreturn(0);
}

/* Convert rdm_reserve_strategy to a caml value */
static value Val_rdm_reserve_strategy (libxl_rdm_reserve_strategy rdm_reserve_strategy_c)
{
	CAMLparam0();
	CAMLlocal1(rdm_reserve_strategy_ocaml);
	switch(rdm_reserve_strategy_c) {
	    case LIBXL_RDM_RESERVE_STRATEGY_IGNORE: rdm_reserve_strategy_ocaml = Val_int(0); break;
	    case LIBXL_RDM_RESERVE_STRATEGY_HOST: rdm_reserve_strategy_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_rdm_reserve_strategy"); break;
	}
	CAMLreturn(rdm_reserve_strategy_ocaml);
}

/* Convert caml value to rdm_reserve_policy */
static int rdm_reserve_policy_val (libxl_ctx *ctx, libxl_rdm_reserve_policy *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_RDM_RESERVE_POLICY_INVALID; break;
	    case 1: *c_val = LIBXL_RDM_RESERVE_POLICY_STRICT; break;
	    case 2: *c_val = LIBXL_RDM_RESERVE_POLICY_RELAXED; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_rdm_reserve_policy"); break;
	}
	CAMLreturn(0);
}

/* Convert rdm_reserve_policy to a caml value */
static value Val_rdm_reserve_policy (libxl_rdm_reserve_policy rdm_reserve_policy_c)
{
	CAMLparam0();
	CAMLlocal1(rdm_reserve_policy_ocaml);
	switch(rdm_reserve_policy_c) {
	    case LIBXL_RDM_RESERVE_POLICY_INVALID: rdm_reserve_policy_ocaml = Val_int(0); break;
	    case LIBXL_RDM_RESERVE_POLICY_STRICT: rdm_reserve_policy_ocaml = Val_int(1); break;
	    case LIBXL_RDM_RESERVE_POLICY_RELAXED: rdm_reserve_policy_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_rdm_reserve_policy"); break;
	}
	CAMLreturn(rdm_reserve_policy_ocaml);
}

/* Convert caml value to channel_connection */
static int channel_connection_val (libxl_ctx *ctx, libxl_channel_connection *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_CHANNEL_CONNECTION_UNKNOWN; break;
	    case 1: *c_val = LIBXL_CHANNEL_CONNECTION_PTY; break;
	    case 2: *c_val = LIBXL_CHANNEL_CONNECTION_SOCKET; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_channel_connection"); break;
	}
	CAMLreturn(0);
}

/* Convert channel_connection to a caml value */
static value Val_channel_connection (libxl_channel_connection channel_connection_c)
{
	CAMLparam0();
	CAMLlocal1(channel_connection_ocaml);
	switch(channel_connection_c) {
	    case LIBXL_CHANNEL_CONNECTION_UNKNOWN: channel_connection_ocaml = Val_int(0); break;
	    case LIBXL_CHANNEL_CONNECTION_PTY: channel_connection_ocaml = Val_int(1); break;
	    case LIBXL_CHANNEL_CONNECTION_SOCKET: channel_connection_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_channel_connection"); break;
	}
	CAMLreturn(channel_connection_ocaml);
}

/* Convert caml value to device_model_version */
static int device_model_version_val (libxl_ctx *ctx, libxl_device_model_version *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_DEVICE_MODEL_VERSION_UNKNOWN; break;
	    case 1: *c_val = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL; break;
	    case 2: *c_val = LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_device_model_version"); break;
	}
	CAMLreturn(0);
}

/* Convert device_model_version to a caml value */
static value Val_device_model_version (libxl_device_model_version device_model_version_c)
{
	CAMLparam0();
	CAMLlocal1(device_model_version_ocaml);
	switch(device_model_version_c) {
	    case LIBXL_DEVICE_MODEL_VERSION_UNKNOWN: device_model_version_ocaml = Val_int(0); break;
	    case LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL: device_model_version_ocaml = Val_int(1); break;
	    case LIBXL_DEVICE_MODEL_VERSION_QEMU_XEN: device_model_version_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_device_model_version"); break;
	}
	CAMLreturn(device_model_version_ocaml);
}

/* Convert caml value to console_type */
static int console_type_val (libxl_ctx *ctx, libxl_console_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_CONSOLE_TYPE_UNKNOWN; break;
	    case 1: *c_val = LIBXL_CONSOLE_TYPE_SERIAL; break;
	    case 2: *c_val = LIBXL_CONSOLE_TYPE_PV; break;
	    case 3: *c_val = LIBXL_CONSOLE_TYPE_VUART; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_console_type"); break;
	}
	CAMLreturn(0);
}

/* Convert console_type to a caml value */
static value Val_console_type (libxl_console_type console_type_c)
{
	CAMLparam0();
	CAMLlocal1(console_type_ocaml);
	switch(console_type_c) {
	    case LIBXL_CONSOLE_TYPE_UNKNOWN: console_type_ocaml = Val_int(0); break;
	    case LIBXL_CONSOLE_TYPE_SERIAL: console_type_ocaml = Val_int(1); break;
	    case LIBXL_CONSOLE_TYPE_PV: console_type_ocaml = Val_int(2); break;
	    case LIBXL_CONSOLE_TYPE_VUART: console_type_ocaml = Val_int(3); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_console_type"); break;
	}
	CAMLreturn(console_type_ocaml);
}

/* Convert caml value to disk_format */
static int disk_format_val (libxl_ctx *ctx, libxl_disk_format *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_DISK_FORMAT_UNKNOWN; break;
	    case 1: *c_val = LIBXL_DISK_FORMAT_QCOW; break;
	    case 2: *c_val = LIBXL_DISK_FORMAT_QCOW2; break;
	    case 3: *c_val = LIBXL_DISK_FORMAT_VHD; break;
	    case 4: *c_val = LIBXL_DISK_FORMAT_RAW; break;
	    case 5: *c_val = LIBXL_DISK_FORMAT_EMPTY; break;
	    case 6: *c_val = LIBXL_DISK_FORMAT_QED; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_disk_format"); break;
	}
	CAMLreturn(0);
}

/* Convert disk_format to a caml value */
static value Val_disk_format (libxl_disk_format disk_format_c)
{
	CAMLparam0();
	CAMLlocal1(disk_format_ocaml);
	switch(disk_format_c) {
	    case LIBXL_DISK_FORMAT_UNKNOWN: disk_format_ocaml = Val_int(0); break;
	    case LIBXL_DISK_FORMAT_QCOW: disk_format_ocaml = Val_int(1); break;
	    case LIBXL_DISK_FORMAT_QCOW2: disk_format_ocaml = Val_int(2); break;
	    case LIBXL_DISK_FORMAT_VHD: disk_format_ocaml = Val_int(3); break;
	    case LIBXL_DISK_FORMAT_RAW: disk_format_ocaml = Val_int(4); break;
	    case LIBXL_DISK_FORMAT_EMPTY: disk_format_ocaml = Val_int(5); break;
	    case LIBXL_DISK_FORMAT_QED: disk_format_ocaml = Val_int(6); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_disk_format"); break;
	}
	CAMLreturn(disk_format_ocaml);
}

/* Convert caml value to disk_backend */
static int disk_backend_val (libxl_ctx *ctx, libxl_disk_backend *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_DISK_BACKEND_UNKNOWN; break;
	    case 1: *c_val = LIBXL_DISK_BACKEND_PHY; break;
	    case 2: *c_val = LIBXL_DISK_BACKEND_TAP; break;
	    case 3: *c_val = LIBXL_DISK_BACKEND_QDISK; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_disk_backend"); break;
	}
	CAMLreturn(0);
}

/* Convert disk_backend to a caml value */
static value Val_disk_backend (libxl_disk_backend disk_backend_c)
{
	CAMLparam0();
	CAMLlocal1(disk_backend_ocaml);
	switch(disk_backend_c) {
	    case LIBXL_DISK_BACKEND_UNKNOWN: disk_backend_ocaml = Val_int(0); break;
	    case LIBXL_DISK_BACKEND_PHY: disk_backend_ocaml = Val_int(1); break;
	    case LIBXL_DISK_BACKEND_TAP: disk_backend_ocaml = Val_int(2); break;
	    case LIBXL_DISK_BACKEND_QDISK: disk_backend_ocaml = Val_int(3); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_disk_backend"); break;
	}
	CAMLreturn(disk_backend_ocaml);
}

/* Convert caml value to nic_type */
static int nic_type_val (libxl_ctx *ctx, libxl_nic_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_NIC_TYPE_UNKNOWN; break;
	    case 1: *c_val = LIBXL_NIC_TYPE_VIF_IOEMU; break;
	    case 2: *c_val = LIBXL_NIC_TYPE_VIF; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_nic_type"); break;
	}
	CAMLreturn(0);
}

/* Convert nic_type to a caml value */
static value Val_nic_type (libxl_nic_type nic_type_c)
{
	CAMLparam0();
	CAMLlocal1(nic_type_ocaml);
	switch(nic_type_c) {
	    case LIBXL_NIC_TYPE_UNKNOWN: nic_type_ocaml = Val_int(0); break;
	    case LIBXL_NIC_TYPE_VIF_IOEMU: nic_type_ocaml = Val_int(1); break;
	    case LIBXL_NIC_TYPE_VIF: nic_type_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_nic_type"); break;
	}
	CAMLreturn(nic_type_ocaml);
}

/* Convert caml value to action_on_shutdown */
static int action_on_shutdown_val (libxl_ctx *ctx, libxl_action_on_shutdown *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_ACTION_ON_SHUTDOWN_DESTROY; break;
	    case 1: *c_val = LIBXL_ACTION_ON_SHUTDOWN_RESTART; break;
	    case 2: *c_val = LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME; break;
	    case 3: *c_val = LIBXL_ACTION_ON_SHUTDOWN_PRESERVE; break;
	    case 4: *c_val = LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY; break;
	    case 5: *c_val = LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART; break;
	    case 6: *c_val = LIBXL_ACTION_ON_SHUTDOWN_SOFT_RESET; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_action_on_shutdown"); break;
	}
	CAMLreturn(0);
}

/* Convert action_on_shutdown to a caml value */
static value Val_action_on_shutdown (libxl_action_on_shutdown action_on_shutdown_c)
{
	CAMLparam0();
	CAMLlocal1(action_on_shutdown_ocaml);
	switch(action_on_shutdown_c) {
	    case LIBXL_ACTION_ON_SHUTDOWN_DESTROY: action_on_shutdown_ocaml = Val_int(0); break;
	    case LIBXL_ACTION_ON_SHUTDOWN_RESTART: action_on_shutdown_ocaml = Val_int(1); break;
	    case LIBXL_ACTION_ON_SHUTDOWN_RESTART_RENAME: action_on_shutdown_ocaml = Val_int(2); break;
	    case LIBXL_ACTION_ON_SHUTDOWN_PRESERVE: action_on_shutdown_ocaml = Val_int(3); break;
	    case LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_DESTROY: action_on_shutdown_ocaml = Val_int(4); break;
	    case LIBXL_ACTION_ON_SHUTDOWN_COREDUMP_RESTART: action_on_shutdown_ocaml = Val_int(5); break;
	    case LIBXL_ACTION_ON_SHUTDOWN_SOFT_RESET: action_on_shutdown_ocaml = Val_int(6); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_action_on_shutdown"); break;
	}
	CAMLreturn(action_on_shutdown_ocaml);
}

/* Convert caml value to trigger */
static int trigger_val (libxl_ctx *ctx, libxl_trigger *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_TRIGGER_UNKNOWN; break;
	    case 1: *c_val = LIBXL_TRIGGER_POWER; break;
	    case 2: *c_val = LIBXL_TRIGGER_SLEEP; break;
	    case 3: *c_val = LIBXL_TRIGGER_NMI; break;
	    case 4: *c_val = LIBXL_TRIGGER_INIT; break;
	    case 5: *c_val = LIBXL_TRIGGER_RESET; break;
	    case 6: *c_val = LIBXL_TRIGGER_S3RESUME; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_trigger"); break;
	}
	CAMLreturn(0);
}

/* Convert trigger to a caml value */
static value Val_trigger (libxl_trigger trigger_c)
{
	CAMLparam0();
	CAMLlocal1(trigger_ocaml);
	switch(trigger_c) {
	    case LIBXL_TRIGGER_UNKNOWN: trigger_ocaml = Val_int(0); break;
	    case LIBXL_TRIGGER_POWER: trigger_ocaml = Val_int(1); break;
	    case LIBXL_TRIGGER_SLEEP: trigger_ocaml = Val_int(2); break;
	    case LIBXL_TRIGGER_NMI: trigger_ocaml = Val_int(3); break;
	    case LIBXL_TRIGGER_INIT: trigger_ocaml = Val_int(4); break;
	    case LIBXL_TRIGGER_RESET: trigger_ocaml = Val_int(5); break;
	    case LIBXL_TRIGGER_S3RESUME: trigger_ocaml = Val_int(6); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_trigger"); break;
	}
	CAMLreturn(trigger_ocaml);
}

/* Convert caml value to tsc_mode */
static int tsc_mode_val (libxl_ctx *ctx, libxl_tsc_mode *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_TSC_MODE_DEFAULT; break;
	    case 1: *c_val = LIBXL_TSC_MODE_ALWAYS_EMULATE; break;
	    case 2: *c_val = LIBXL_TSC_MODE_NATIVE; break;
	    case 3: *c_val = LIBXL_TSC_MODE_NATIVE_PARAVIRT; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_tsc_mode"); break;
	}
	CAMLreturn(0);
}

/* Convert tsc_mode to a caml value */
static value Val_tsc_mode (libxl_tsc_mode tsc_mode_c)
{
	CAMLparam0();
	CAMLlocal1(tsc_mode_ocaml);
	switch(tsc_mode_c) {
	    case LIBXL_TSC_MODE_DEFAULT: tsc_mode_ocaml = Val_int(0); break;
	    case LIBXL_TSC_MODE_ALWAYS_EMULATE: tsc_mode_ocaml = Val_int(1); break;
	    case LIBXL_TSC_MODE_NATIVE: tsc_mode_ocaml = Val_int(2); break;
	    case LIBXL_TSC_MODE_NATIVE_PARAVIRT: tsc_mode_ocaml = Val_int(3); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_tsc_mode"); break;
	}
	CAMLreturn(tsc_mode_ocaml);
}

/* Convert caml value to gfx_passthru_kind */
static int gfx_passthru_kind_val (libxl_ctx *ctx, libxl_gfx_passthru_kind *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_GFX_PASSTHRU_KIND_DEFAULT; break;
	    case 1: *c_val = LIBXL_GFX_PASSTHRU_KIND_IGD; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_gfx_passthru_kind"); break;
	}
	CAMLreturn(0);
}

/* Convert gfx_passthru_kind to a caml value */
static value Val_gfx_passthru_kind (libxl_gfx_passthru_kind gfx_passthru_kind_c)
{
	CAMLparam0();
	CAMLlocal1(gfx_passthru_kind_ocaml);
	switch(gfx_passthru_kind_c) {
	    case LIBXL_GFX_PASSTHRU_KIND_DEFAULT: gfx_passthru_kind_ocaml = Val_int(0); break;
	    case LIBXL_GFX_PASSTHRU_KIND_IGD: gfx_passthru_kind_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_gfx_passthru_kind"); break;
	}
	CAMLreturn(gfx_passthru_kind_ocaml);
}

/* Convert caml value to timer_mode */
static int timer_mode_val (libxl_ctx *ctx, libxl_timer_mode *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_TIMER_MODE_UNKNOWN; break;
	    case 1: *c_val = LIBXL_TIMER_MODE_DELAY_FOR_MISSED_TICKS; break;
	    case 2: *c_val = LIBXL_TIMER_MODE_NO_DELAY_FOR_MISSED_TICKS; break;
	    case 3: *c_val = LIBXL_TIMER_MODE_NO_MISSED_TICKS_PENDING; break;
	    case 4: *c_val = LIBXL_TIMER_MODE_ONE_MISSED_TICK_PENDING; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_timer_mode"); break;
	}
	CAMLreturn(0);
}

/* Convert timer_mode to a caml value */
static value Val_timer_mode (libxl_timer_mode timer_mode_c)
{
	CAMLparam0();
	CAMLlocal1(timer_mode_ocaml);
	switch(timer_mode_c) {
	    case LIBXL_TIMER_MODE_UNKNOWN: timer_mode_ocaml = Val_int(0); break;
	    case LIBXL_TIMER_MODE_DELAY_FOR_MISSED_TICKS: timer_mode_ocaml = Val_int(1); break;
	    case LIBXL_TIMER_MODE_NO_DELAY_FOR_MISSED_TICKS: timer_mode_ocaml = Val_int(2); break;
	    case LIBXL_TIMER_MODE_NO_MISSED_TICKS_PENDING: timer_mode_ocaml = Val_int(3); break;
	    case LIBXL_TIMER_MODE_ONE_MISSED_TICK_PENDING: timer_mode_ocaml = Val_int(4); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_timer_mode"); break;
	}
	CAMLreturn(timer_mode_ocaml);
}

/* Convert caml value to bios_type */
static int bios_type_val (libxl_ctx *ctx, libxl_bios_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_BIOS_TYPE_UNKNOWN; break;
	    case 1: *c_val = LIBXL_BIOS_TYPE_ROMBIOS; break;
	    case 2: *c_val = LIBXL_BIOS_TYPE_SEABIOS; break;
	    case 3: *c_val = LIBXL_BIOS_TYPE_OVMF; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_bios_type"); break;
	}
	CAMLreturn(0);
}

/* Convert bios_type to a caml value */
static value Val_bios_type (libxl_bios_type bios_type_c)
{
	CAMLparam0();
	CAMLlocal1(bios_type_ocaml);
	switch(bios_type_c) {
	    case LIBXL_BIOS_TYPE_UNKNOWN: bios_type_ocaml = Val_int(0); break;
	    case LIBXL_BIOS_TYPE_ROMBIOS: bios_type_ocaml = Val_int(1); break;
	    case LIBXL_BIOS_TYPE_SEABIOS: bios_type_ocaml = Val_int(2); break;
	    case LIBXL_BIOS_TYPE_OVMF: bios_type_ocaml = Val_int(3); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_bios_type"); break;
	}
	CAMLreturn(bios_type_ocaml);
}

/* Convert caml value to scheduler */
static int scheduler_val (libxl_ctx *ctx, libxl_scheduler *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_SCHEDULER_UNKNOWN; break;
	    case 1: *c_val = LIBXL_SCHEDULER_SEDF; break;
	    case 2: *c_val = LIBXL_SCHEDULER_CREDIT; break;
	    case 3: *c_val = LIBXL_SCHEDULER_CREDIT2; break;
	    case 4: *c_val = LIBXL_SCHEDULER_ARINC653; break;
	    case 5: *c_val = LIBXL_SCHEDULER_RTDS; break;
	    case 6: *c_val = LIBXL_SCHEDULER_NULL; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_scheduler"); break;
	}
	CAMLreturn(0);
}

/* Convert scheduler to a caml value */
static value Val_scheduler (libxl_scheduler scheduler_c)
{
	CAMLparam0();
	CAMLlocal1(scheduler_ocaml);
	switch(scheduler_c) {
	    case LIBXL_SCHEDULER_UNKNOWN: scheduler_ocaml = Val_int(0); break;
	    case LIBXL_SCHEDULER_SEDF: scheduler_ocaml = Val_int(1); break;
	    case LIBXL_SCHEDULER_CREDIT: scheduler_ocaml = Val_int(2); break;
	    case LIBXL_SCHEDULER_CREDIT2: scheduler_ocaml = Val_int(3); break;
	    case LIBXL_SCHEDULER_ARINC653: scheduler_ocaml = Val_int(4); break;
	    case LIBXL_SCHEDULER_RTDS: scheduler_ocaml = Val_int(5); break;
	    case LIBXL_SCHEDULER_NULL: scheduler_ocaml = Val_int(6); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_scheduler"); break;
	}
	CAMLreturn(scheduler_ocaml);
}

/* Convert caml value to shutdown_reason */
static int shutdown_reason_val (libxl_ctx *ctx, libxl_shutdown_reason *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_SHUTDOWN_REASON_UNKNOWN; break;
	    case 1: *c_val = LIBXL_SHUTDOWN_REASON_POWEROFF; break;
	    case 2: *c_val = LIBXL_SHUTDOWN_REASON_REBOOT; break;
	    case 3: *c_val = LIBXL_SHUTDOWN_REASON_SUSPEND; break;
	    case 4: *c_val = LIBXL_SHUTDOWN_REASON_CRASH; break;
	    case 5: *c_val = LIBXL_SHUTDOWN_REASON_WATCHDOG; break;
	    case 6: *c_val = LIBXL_SHUTDOWN_REASON_SOFT_RESET; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_shutdown_reason"); break;
	}
	CAMLreturn(0);
}

/* Convert shutdown_reason to a caml value */
static value Val_shutdown_reason (libxl_shutdown_reason shutdown_reason_c)
{
	CAMLparam0();
	CAMLlocal1(shutdown_reason_ocaml);
	switch(shutdown_reason_c) {
	    case LIBXL_SHUTDOWN_REASON_UNKNOWN: shutdown_reason_ocaml = Val_int(0); break;
	    case LIBXL_SHUTDOWN_REASON_POWEROFF: shutdown_reason_ocaml = Val_int(1); break;
	    case LIBXL_SHUTDOWN_REASON_REBOOT: shutdown_reason_ocaml = Val_int(2); break;
	    case LIBXL_SHUTDOWN_REASON_SUSPEND: shutdown_reason_ocaml = Val_int(3); break;
	    case LIBXL_SHUTDOWN_REASON_CRASH: shutdown_reason_ocaml = Val_int(4); break;
	    case LIBXL_SHUTDOWN_REASON_WATCHDOG: shutdown_reason_ocaml = Val_int(5); break;
	    case LIBXL_SHUTDOWN_REASON_SOFT_RESET: shutdown_reason_ocaml = Val_int(6); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_shutdown_reason"); break;
	}
	CAMLreturn(shutdown_reason_ocaml);
}

/* Convert caml value to vga_interface_type */
static int vga_interface_type_val (libxl_ctx *ctx, libxl_vga_interface_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_VGA_INTERFACE_TYPE_UNKNOWN; break;
	    case 1: *c_val = LIBXL_VGA_INTERFACE_TYPE_CIRRUS; break;
	    case 2: *c_val = LIBXL_VGA_INTERFACE_TYPE_STD; break;
	    case 3: *c_val = LIBXL_VGA_INTERFACE_TYPE_NONE; break;
	    case 4: *c_val = LIBXL_VGA_INTERFACE_TYPE_QXL; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_vga_interface_type"); break;
	}
	CAMLreturn(0);
}

/* Convert vga_interface_type to a caml value */
static value Val_vga_interface_type (libxl_vga_interface_type vga_interface_type_c)
{
	CAMLparam0();
	CAMLlocal1(vga_interface_type_ocaml);
	switch(vga_interface_type_c) {
	    case LIBXL_VGA_INTERFACE_TYPE_UNKNOWN: vga_interface_type_ocaml = Val_int(0); break;
	    case LIBXL_VGA_INTERFACE_TYPE_CIRRUS: vga_interface_type_ocaml = Val_int(1); break;
	    case LIBXL_VGA_INTERFACE_TYPE_STD: vga_interface_type_ocaml = Val_int(2); break;
	    case LIBXL_VGA_INTERFACE_TYPE_NONE: vga_interface_type_ocaml = Val_int(3); break;
	    case LIBXL_VGA_INTERFACE_TYPE_QXL: vga_interface_type_ocaml = Val_int(4); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_vga_interface_type"); break;
	}
	CAMLreturn(vga_interface_type_ocaml);
}

/* Convert caml value to vendor_device */
static int vendor_device_val (libxl_ctx *ctx, libxl_vendor_device *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_VENDOR_DEVICE_NONE; break;
	    case 1: *c_val = LIBXL_VENDOR_DEVICE_XENSERVER; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_vendor_device"); break;
	}
	CAMLreturn(0);
}

/* Convert vendor_device to a caml value */
static value Val_vendor_device (libxl_vendor_device vendor_device_c)
{
	CAMLparam0();
	CAMLlocal1(vendor_device_ocaml);
	switch(vendor_device_c) {
	    case LIBXL_VENDOR_DEVICE_NONE: vendor_device_ocaml = Val_int(0); break;
	    case LIBXL_VENDOR_DEVICE_XENSERVER: vendor_device_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_vendor_device"); break;
	}
	CAMLreturn(vendor_device_ocaml);
}

/* Convert caml value to viridian_enlightenment */
static int viridian_enlightenment_val (libxl_ctx *ctx, libxl_viridian_enlightenment *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_BASE; break;
	    case 1: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_FREQ; break;
	    case 2: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_TIME_REF_COUNT; break;
	    case 3: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_REFERENCE_TSC; break;
	    case 4: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_HCALL_REMOTE_TLB_FLUSH; break;
	    case 5: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_APIC_ASSIST; break;
	    case 6: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_CRASH_CTL; break;
	    case 7: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_SYNIC; break;
	    case 8: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_STIMER; break;
	    case 9: *c_val = LIBXL_VIRIDIAN_ENLIGHTENMENT_HCALL_IPI; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_viridian_enlightenment"); break;
	}
	CAMLreturn(0);
}

/* Convert viridian_enlightenment to a caml value */
static value Val_viridian_enlightenment (libxl_viridian_enlightenment viridian_enlightenment_c)
{
	CAMLparam0();
	CAMLlocal1(viridian_enlightenment_ocaml);
	switch(viridian_enlightenment_c) {
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_BASE: viridian_enlightenment_ocaml = Val_int(0); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_FREQ: viridian_enlightenment_ocaml = Val_int(1); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_TIME_REF_COUNT: viridian_enlightenment_ocaml = Val_int(2); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_REFERENCE_TSC: viridian_enlightenment_ocaml = Val_int(3); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_HCALL_REMOTE_TLB_FLUSH: viridian_enlightenment_ocaml = Val_int(4); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_APIC_ASSIST: viridian_enlightenment_ocaml = Val_int(5); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_CRASH_CTL: viridian_enlightenment_ocaml = Val_int(6); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_SYNIC: viridian_enlightenment_ocaml = Val_int(7); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_STIMER: viridian_enlightenment_ocaml = Val_int(8); break;
	    case LIBXL_VIRIDIAN_ENLIGHTENMENT_HCALL_IPI: viridian_enlightenment_ocaml = Val_int(9); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_viridian_enlightenment"); break;
	}
	CAMLreturn(viridian_enlightenment_ocaml);
}

/* Convert caml value to hdtype */
static int hdtype_val (libxl_ctx *ctx, libxl_hdtype *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_HDTYPE_IDE; break;
	    case 1: *c_val = LIBXL_HDTYPE_AHCI; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_hdtype"); break;
	}
	CAMLreturn(0);
}

/* Convert hdtype to a caml value */
static value Val_hdtype (libxl_hdtype hdtype_c)
{
	CAMLparam0();
	CAMLlocal1(hdtype_ocaml);
	switch(hdtype_c) {
	    case LIBXL_HDTYPE_IDE: hdtype_ocaml = Val_int(0); break;
	    case LIBXL_HDTYPE_AHCI: hdtype_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_hdtype"); break;
	}
	CAMLreturn(hdtype_ocaml);
}

/* Convert caml value to checkpointed_stream */
static int checkpointed_stream_val (libxl_ctx *ctx, libxl_checkpointed_stream *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_CHECKPOINTED_STREAM_NONE; break;
	    case 1: *c_val = LIBXL_CHECKPOINTED_STREAM_REMUS; break;
	    case 2: *c_val = LIBXL_CHECKPOINTED_STREAM_COLO; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_checkpointed_stream"); break;
	}
	CAMLreturn(0);
}

/* Convert checkpointed_stream to a caml value */
static value Val_checkpointed_stream (libxl_checkpointed_stream checkpointed_stream_c)
{
	CAMLparam0();
	CAMLlocal1(checkpointed_stream_ocaml);
	switch(checkpointed_stream_c) {
	    case LIBXL_CHECKPOINTED_STREAM_NONE: checkpointed_stream_ocaml = Val_int(0); break;
	    case LIBXL_CHECKPOINTED_STREAM_REMUS: checkpointed_stream_ocaml = Val_int(1); break;
	    case LIBXL_CHECKPOINTED_STREAM_COLO: checkpointed_stream_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_checkpointed_stream"); break;
	}
	CAMLreturn(checkpointed_stream_ocaml);
}

/* Convert caml value to vuart_type */
static int vuart_type_val (libxl_ctx *ctx, libxl_vuart_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_VUART_TYPE_UNKNOWN; break;
	    case 1: *c_val = LIBXL_VUART_TYPE_SBSA_UART; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_vuart_type"); break;
	}
	CAMLreturn(0);
}

/* Convert vuart_type to a caml value */
static value Val_vuart_type (libxl_vuart_type vuart_type_c)
{
	CAMLparam0();
	CAMLlocal1(vuart_type_ocaml);
	switch(vuart_type_c) {
	    case LIBXL_VUART_TYPE_UNKNOWN: vuart_type_ocaml = Val_int(0); break;
	    case LIBXL_VUART_TYPE_SBSA_UART: vuart_type_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_vuart_type"); break;
	}
	CAMLreturn(vuart_type_ocaml);
}

/* Convert caml value to vkb_backend */
static int vkb_backend_val (libxl_ctx *ctx, libxl_vkb_backend *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_VKB_BACKEND_UNKNOWN; break;
	    case 1: *c_val = LIBXL_VKB_BACKEND_QEMU; break;
	    case 2: *c_val = LIBXL_VKB_BACKEND_LINUX; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_vkb_backend"); break;
	}
	CAMLreturn(0);
}

/* Convert vkb_backend to a caml value */
static value Val_vkb_backend (libxl_vkb_backend vkb_backend_c)
{
	CAMLparam0();
	CAMLlocal1(vkb_backend_ocaml);
	switch(vkb_backend_c) {
	    case LIBXL_VKB_BACKEND_UNKNOWN: vkb_backend_ocaml = Val_int(0); break;
	    case LIBXL_VKB_BACKEND_QEMU: vkb_backend_ocaml = Val_int(1); break;
	    case LIBXL_VKB_BACKEND_LINUX: vkb_backend_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_vkb_backend"); break;
	}
	CAMLreturn(vkb_backend_ocaml);
}

/* Convert caml value to passthrough */
static int passthrough_val (libxl_ctx *ctx, libxl_passthrough *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_PASSTHROUGH_DEFAULT; break;
	    case 1: *c_val = LIBXL_PASSTHROUGH_DISABLED; break;
	    case 2: *c_val = LIBXL_PASSTHROUGH_ENABLED; break;
	    case 3: *c_val = LIBXL_PASSTHROUGH_SYNC_PT; break;
	    case 4: *c_val = LIBXL_PASSTHROUGH_SHARE_PT; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_passthrough"); break;
	}
	CAMLreturn(0);
}

/* Convert passthrough to a caml value */
static value Val_passthrough (libxl_passthrough passthrough_c)
{
	CAMLparam0();
	CAMLlocal1(passthrough_ocaml);
	switch(passthrough_c) {
	    case LIBXL_PASSTHROUGH_DEFAULT: passthrough_ocaml = Val_int(0); break;
	    case LIBXL_PASSTHROUGH_DISABLED: passthrough_ocaml = Val_int(1); break;
	    case LIBXL_PASSTHROUGH_ENABLED: passthrough_ocaml = Val_int(2); break;
	    case LIBXL_PASSTHROUGH_SYNC_PT: passthrough_ocaml = Val_int(3); break;
	    case LIBXL_PASSTHROUGH_SHARE_PT: passthrough_ocaml = Val_int(4); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_passthrough"); break;
	}
	CAMLreturn(passthrough_ocaml);
}

/* Convert caml value to ioport_range */
static int ioport_range_val (libxl_ctx *ctx, libxl_ioport_range *c_val, value v)
{
	CAMLparam1(v);

	c_val->first = Int32_val(Field(v, 0));
	c_val->number = Int32_val(Field(v, 1));
	
	CAMLreturn(0);
}

/* Convert ioport_range to a caml value */
static value Val_ioport_range (libxl_ioport_range *ioport_range_c)
{
	CAMLparam0();
	CAMLlocal1(ioport_range_ocaml);
	{
		CAMLlocal1(ioport_range_field);
	
		ioport_range_ocaml = caml_alloc_tuple(2);
	
		ioport_range_field = caml_copy_int32(ioport_range_c->first);
		Store_field(ioport_range_ocaml, 0, ioport_range_field);
	
		ioport_range_field = caml_copy_int32(ioport_range_c->number);
		Store_field(ioport_range_ocaml, 1, ioport_range_field);
	}
	CAMLreturn(ioport_range_ocaml);
}

/* Get the defaults for ioport_range */
value stub_libxl_ioport_range_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_ioport_range c_val;
	libxl_ioport_range_init(&c_val);
	val = Val_ioport_range(&c_val);
	libxl_ioport_range_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to iomem_range */
static int iomem_range_val (libxl_ctx *ctx, libxl_iomem_range *c_val, value v)
{
	CAMLparam1(v);

	c_val->start = Int64_val(Field(v, 0));
	c_val->number = Int64_val(Field(v, 1));
	c_val->gfn = Int64_val(Field(v, 2));
	
	CAMLreturn(0);
}

/* Convert iomem_range to a caml value */
static value Val_iomem_range (libxl_iomem_range *iomem_range_c)
{
	CAMLparam0();
	CAMLlocal1(iomem_range_ocaml);
	{
		CAMLlocal1(iomem_range_field);
	
		iomem_range_ocaml = caml_alloc_tuple(3);
	
		iomem_range_field = caml_copy_int64(iomem_range_c->start);
		Store_field(iomem_range_ocaml, 0, iomem_range_field);
	
		iomem_range_field = caml_copy_int64(iomem_range_c->number);
		Store_field(iomem_range_ocaml, 1, iomem_range_field);
	
		iomem_range_field = caml_copy_int64(iomem_range_c->gfn);
		Store_field(iomem_range_ocaml, 2, iomem_range_field);
	}
	CAMLreturn(iomem_range_ocaml);
}

/* Get the defaults for iomem_range */
value stub_libxl_iomem_range_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_iomem_range c_val;
	libxl_iomem_range_init(&c_val);
	val = Val_iomem_range(&c_val);
	libxl_iomem_range_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vga_interface_info */
static int vga_interface_info_val (libxl_ctx *ctx, libxl_vga_interface_info *c_val, value v)
{
	CAMLparam1(v);

	vga_interface_type_val(ctx, &c_val->kind, Field(v, 0));
	
	CAMLreturn(0);
}

/* Convert vga_interface_info to a caml value */
static value Val_vga_interface_info (libxl_vga_interface_info *vga_interface_info_c)
{
	CAMLparam0();
	CAMLlocal1(vga_interface_info_ocaml);
	{
		CAMLlocal1(vga_interface_info_field);
	
		vga_interface_info_ocaml = caml_alloc_tuple(1);
	
		vga_interface_info_field = Val_vga_interface_type(vga_interface_info_c->kind);
		Store_field(vga_interface_info_ocaml, 0, vga_interface_info_field);
	}
	CAMLreturn(vga_interface_info_ocaml);
}

/* Get the defaults for vga_interface_info */
value stub_libxl_vga_interface_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vga_interface_info c_val;
	libxl_vga_interface_info_init(&c_val);
	val = Val_vga_interface_info(&c_val);
	libxl_vga_interface_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vnc_info */
static int vnc_info_val (libxl_ctx *ctx, libxl_vnc_info *c_val, value v)
{
	CAMLparam1(v);

	c_val->enable = Defbool_val(Field(v, 0));
	c_val->listen = String_option_val(Field(v, 1));
	c_val->passwd = String_option_val(Field(v, 2));
	c_val->display = Int_val(Field(v, 3));
	c_val->findunused = Defbool_val(Field(v, 4));
	
	CAMLreturn(0);
}

/* Convert vnc_info to a caml value */
static value Val_vnc_info (libxl_vnc_info *vnc_info_c)
{
	CAMLparam0();
	CAMLlocal1(vnc_info_ocaml);
	{
		CAMLlocal1(vnc_info_field);
	
		vnc_info_ocaml = caml_alloc_tuple(5);
	
		vnc_info_field = Val_defbool(vnc_info_c->enable);
		Store_field(vnc_info_ocaml, 0, vnc_info_field);
	
		vnc_info_field = Val_string_option(vnc_info_c->listen);
		Store_field(vnc_info_ocaml, 1, vnc_info_field);
	
		vnc_info_field = Val_string_option(vnc_info_c->passwd);
		Store_field(vnc_info_ocaml, 2, vnc_info_field);
	
		vnc_info_field = Val_int(vnc_info_c->display);
		Store_field(vnc_info_ocaml, 3, vnc_info_field);
	
		vnc_info_field = Val_defbool(vnc_info_c->findunused);
		Store_field(vnc_info_ocaml, 4, vnc_info_field);
	}
	CAMLreturn(vnc_info_ocaml);
}

/* Get the defaults for vnc_info */
value stub_libxl_vnc_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vnc_info c_val;
	libxl_vnc_info_init(&c_val);
	val = Val_vnc_info(&c_val);
	libxl_vnc_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to spice_info */
static int spice_info_val (libxl_ctx *ctx, libxl_spice_info *c_val, value v)
{
	CAMLparam1(v);

	c_val->enable = Defbool_val(Field(v, 0));
	c_val->port = Int_val(Field(v, 1));
	c_val->tls_port = Int_val(Field(v, 2));
	c_val->host = String_option_val(Field(v, 3));
	c_val->disable_ticketing = Defbool_val(Field(v, 4));
	c_val->passwd = String_option_val(Field(v, 5));
	c_val->agent_mouse = Defbool_val(Field(v, 6));
	c_val->vdagent = Defbool_val(Field(v, 7));
	c_val->clipboard_sharing = Defbool_val(Field(v, 8));
	c_val->usbredirection = Int_val(Field(v, 9));
	c_val->image_compression = String_option_val(Field(v, 10));
	c_val->streaming_video = String_option_val(Field(v, 11));
	
	CAMLreturn(0);
}

/* Convert spice_info to a caml value */
static value Val_spice_info (libxl_spice_info *spice_info_c)
{
	CAMLparam0();
	CAMLlocal1(spice_info_ocaml);
	{
		CAMLlocal1(spice_info_field);
	
		spice_info_ocaml = caml_alloc_tuple(12);
	
		spice_info_field = Val_defbool(spice_info_c->enable);
		Store_field(spice_info_ocaml, 0, spice_info_field);
	
		spice_info_field = Val_int(spice_info_c->port);
		Store_field(spice_info_ocaml, 1, spice_info_field);
	
		spice_info_field = Val_int(spice_info_c->tls_port);
		Store_field(spice_info_ocaml, 2, spice_info_field);
	
		spice_info_field = Val_string_option(spice_info_c->host);
		Store_field(spice_info_ocaml, 3, spice_info_field);
	
		spice_info_field = Val_defbool(spice_info_c->disable_ticketing);
		Store_field(spice_info_ocaml, 4, spice_info_field);
	
		spice_info_field = Val_string_option(spice_info_c->passwd);
		Store_field(spice_info_ocaml, 5, spice_info_field);
	
		spice_info_field = Val_defbool(spice_info_c->agent_mouse);
		Store_field(spice_info_ocaml, 6, spice_info_field);
	
		spice_info_field = Val_defbool(spice_info_c->vdagent);
		Store_field(spice_info_ocaml, 7, spice_info_field);
	
		spice_info_field = Val_defbool(spice_info_c->clipboard_sharing);
		Store_field(spice_info_ocaml, 8, spice_info_field);
	
		spice_info_field = Val_int(spice_info_c->usbredirection);
		Store_field(spice_info_ocaml, 9, spice_info_field);
	
		spice_info_field = Val_string_option(spice_info_c->image_compression);
		Store_field(spice_info_ocaml, 10, spice_info_field);
	
		spice_info_field = Val_string_option(spice_info_c->streaming_video);
		Store_field(spice_info_ocaml, 11, spice_info_field);
	}
	CAMLreturn(spice_info_ocaml);
}

/* Get the defaults for spice_info */
value stub_libxl_spice_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_spice_info c_val;
	libxl_spice_info_init(&c_val);
	val = Val_spice_info(&c_val);
	libxl_spice_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to sdl_info */
static int sdl_info_val (libxl_ctx *ctx, libxl_sdl_info *c_val, value v)
{
	CAMLparam1(v);

	c_val->enable = Defbool_val(Field(v, 0));
	c_val->opengl = Defbool_val(Field(v, 1));
	c_val->display = String_option_val(Field(v, 2));
	c_val->xauthority = String_option_val(Field(v, 3));
	
	CAMLreturn(0);
}

/* Convert sdl_info to a caml value */
static value Val_sdl_info (libxl_sdl_info *sdl_info_c)
{
	CAMLparam0();
	CAMLlocal1(sdl_info_ocaml);
	{
		CAMLlocal1(sdl_info_field);
	
		sdl_info_ocaml = caml_alloc_tuple(4);
	
		sdl_info_field = Val_defbool(sdl_info_c->enable);
		Store_field(sdl_info_ocaml, 0, sdl_info_field);
	
		sdl_info_field = Val_defbool(sdl_info_c->opengl);
		Store_field(sdl_info_ocaml, 1, sdl_info_field);
	
		sdl_info_field = Val_string_option(sdl_info_c->display);
		Store_field(sdl_info_ocaml, 2, sdl_info_field);
	
		sdl_info_field = Val_string_option(sdl_info_c->xauthority);
		Store_field(sdl_info_ocaml, 3, sdl_info_field);
	}
	CAMLreturn(sdl_info_ocaml);
}

/* Get the defaults for sdl_info */
value stub_libxl_sdl_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_sdl_info c_val;
	libxl_sdl_info_init(&c_val);
	val = Val_sdl_info(&c_val);
	libxl_sdl_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert dominfo to a caml value */
static value Val_dominfo (libxl_dominfo *dominfo_c)
{
	CAMLparam0();
	CAMLlocal1(dominfo_ocaml);
	{
		CAMLlocal1(dominfo_field);
	
		dominfo_ocaml = caml_alloc_tuple(21);
	
		dominfo_field = Val_uuid(&dominfo_c->uuid);
		Store_field(dominfo_ocaml, 0, dominfo_field);
	
		dominfo_field = Val_int(dominfo_c->domid);
		Store_field(dominfo_ocaml, 1, dominfo_field);
	
		dominfo_field = caml_copy_int32(dominfo_c->ssidref);
		Store_field(dominfo_ocaml, 2, dominfo_field);
	
		dominfo_field = Val_string_option(dominfo_c->ssid_label);
		Store_field(dominfo_ocaml, 3, dominfo_field);
	
		dominfo_field = Val_bool(dominfo_c->running);
		Store_field(dominfo_ocaml, 4, dominfo_field);
	
		dominfo_field = Val_bool(dominfo_c->blocked);
		Store_field(dominfo_ocaml, 5, dominfo_field);
	
		dominfo_field = Val_bool(dominfo_c->paused);
		Store_field(dominfo_ocaml, 6, dominfo_field);
	
		dominfo_field = Val_bool(dominfo_c->shutdown);
		Store_field(dominfo_ocaml, 7, dominfo_field);
	
		dominfo_field = Val_bool(dominfo_c->dying);
		Store_field(dominfo_ocaml, 8, dominfo_field);
	
		dominfo_field = Val_bool(dominfo_c->never_stop);
		Store_field(dominfo_ocaml, 9, dominfo_field);
	
		dominfo_field = Val_shutdown_reason(dominfo_c->shutdown_reason);
		Store_field(dominfo_ocaml, 10, dominfo_field);
	
		dominfo_field = caml_copy_int64(dominfo_c->outstanding_memkb);
		Store_field(dominfo_ocaml, 11, dominfo_field);
	
		dominfo_field = caml_copy_int64(dominfo_c->current_memkb);
		Store_field(dominfo_ocaml, 12, dominfo_field);
	
		dominfo_field = caml_copy_int64(dominfo_c->shared_memkb);
		Store_field(dominfo_ocaml, 13, dominfo_field);
	
		dominfo_field = caml_copy_int64(dominfo_c->paged_memkb);
		Store_field(dominfo_ocaml, 14, dominfo_field);
	
		dominfo_field = caml_copy_int64(dominfo_c->max_memkb);
		Store_field(dominfo_ocaml, 15, dominfo_field);
	
		dominfo_field = caml_copy_int64(dominfo_c->cpu_time);
		Store_field(dominfo_ocaml, 16, dominfo_field);
	
		dominfo_field = caml_copy_int32(dominfo_c->vcpu_max_id);
		Store_field(dominfo_ocaml, 17, dominfo_field);
	
		dominfo_field = caml_copy_int32(dominfo_c->vcpu_online);
		Store_field(dominfo_ocaml, 18, dominfo_field);
	
		dominfo_field = caml_copy_int32(dominfo_c->cpupool);
		Store_field(dominfo_ocaml, 19, dominfo_field);
	
		dominfo_field = Val_domain_type(dominfo_c->domain_type);
		Store_field(dominfo_ocaml, 20, dominfo_field);
	}
	CAMLreturn(dominfo_ocaml);
}

/* Stubs for dominfo */
value stub_xl_dominfo_list(value v1);
value stub_xl_dominfo_get(value v1, value v2);

/* Get the defaults for dominfo */
value stub_libxl_dominfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_dominfo c_val;
	libxl_dominfo_init(&c_val);
	val = Val_dominfo(&c_val);
	libxl_dominfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert channelinfo to a caml value */
static value Val_channelinfo (libxl_channelinfo *channelinfo_c)
{
	CAMLparam0();
	CAMLlocal1(channelinfo_ocaml);
	{
		CAMLlocal1(channelinfo_field);
	
		channelinfo_ocaml = caml_alloc_tuple(9);
	
		channelinfo_field = Val_string_option(channelinfo_c->backend);
		Store_field(channelinfo_ocaml, 0, channelinfo_field);
	
		channelinfo_field = caml_copy_int32(channelinfo_c->backend_id);
		Store_field(channelinfo_ocaml, 1, channelinfo_field);
	
		channelinfo_field = Val_string_option(channelinfo_c->frontend);
		Store_field(channelinfo_ocaml, 2, channelinfo_field);
	
		channelinfo_field = caml_copy_int32(channelinfo_c->frontend_id);
		Store_field(channelinfo_ocaml, 3, channelinfo_field);
	
		channelinfo_field = Val_int(channelinfo_c->devid);
		Store_field(channelinfo_ocaml, 4, channelinfo_field);
	
		channelinfo_field = Val_int(channelinfo_c->state);
		Store_field(channelinfo_ocaml, 5, channelinfo_field);
	
		channelinfo_field = Val_int(channelinfo_c->evtch);
		Store_field(channelinfo_ocaml, 6, channelinfo_field);
	
		channelinfo_field = Val_int(channelinfo_c->rref);
		Store_field(channelinfo_ocaml, 7, channelinfo_field);
	
		switch(channelinfo_c->connection) {
		    case LIBXL_CHANNEL_CONNECTION_UNKNOWN:
		        /* 0: None */
		        channelinfo_field = Val_long(0);
		        break;
		    case LIBXL_CHANNEL_CONNECTION_PTY:
		        /* 0: Block */
		        {
			        CAMLlocal1(tmp);
			        channelinfo_field = caml_alloc(1,0);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(1);
			        
			        	anon_field = Val_string_option(channelinfo_c->u.pty.path);
			        	Store_field(tmp, 0, anon_field);
			        }
			        Store_field(channelinfo_field, 0, tmp);
		        }
		        break;
		    case LIBXL_CHANNEL_CONNECTION_SOCKET:
		        /* 1: None */
		        channelinfo_field = Val_long(1);
		        break;
		    default: failwith_xl(ERROR_FAIL, "cannot convert value from None"); break;
		}
		Store_field(channelinfo_ocaml, 8, channelinfo_field);
	}
	CAMLreturn(channelinfo_ocaml);
}

/* Get the defaults for channelinfo */
value stub_libxl_channelinfo_init(value ctx, value connection, value unit)
{
	CAMLparam3(ctx, connection, unit);
	CAMLlocal1(val);
	libxl_channelinfo c_val;
	libxl_channelinfo_init(&c_val);
	if (connection != Val_none) {
		libxl_channel_connection c = 0;
		channel_connection_val(CTX, &c, Some_val(connection));
		libxl_channelinfo_init_connection(&c_val, c);
	}
	val = Val_channelinfo(&c_val);
	libxl_channelinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert vminfo to a caml value */
static value Val_vminfo (libxl_vminfo *vminfo_c)
{
	CAMLparam0();
	CAMLlocal1(vminfo_ocaml);
	{
		CAMLlocal1(vminfo_field);
	
		vminfo_ocaml = caml_alloc_tuple(2);
	
		vminfo_field = Val_uuid(&vminfo_c->uuid);
		Store_field(vminfo_ocaml, 0, vminfo_field);
	
		vminfo_field = Val_int(vminfo_c->domid);
		Store_field(vminfo_ocaml, 1, vminfo_field);
	}
	CAMLreturn(vminfo_ocaml);
}

/* Get the defaults for vminfo */
value stub_libxl_vminfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vminfo c_val;
	libxl_vminfo_init(&c_val);
	val = Val_vminfo(&c_val);
	libxl_vminfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert version_info to a caml value */
static value Val_version_info (libxl_version_info *version_info_c)
{
	CAMLparam0();
	CAMLlocal1(version_info_ocaml);
	{
		CAMLlocal1(version_info_field);
	
		version_info_ocaml = caml_alloc_tuple(13);
	
		version_info_field = Val_int(version_info_c->xen_version_major);
		Store_field(version_info_ocaml, 0, version_info_field);
	
		version_info_field = Val_int(version_info_c->xen_version_minor);
		Store_field(version_info_ocaml, 1, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->xen_version_extra);
		Store_field(version_info_ocaml, 2, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->compiler);
		Store_field(version_info_ocaml, 3, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->compile_by);
		Store_field(version_info_ocaml, 4, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->compile_domain);
		Store_field(version_info_ocaml, 5, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->compile_date);
		Store_field(version_info_ocaml, 6, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->capabilities);
		Store_field(version_info_ocaml, 7, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->changeset);
		Store_field(version_info_ocaml, 8, version_info_field);
	
		version_info_field = caml_copy_int64(version_info_c->virt_start);
		Store_field(version_info_ocaml, 9, version_info_field);
	
		version_info_field = Val_int(version_info_c->pagesize);
		Store_field(version_info_ocaml, 10, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->commandline);
		Store_field(version_info_ocaml, 11, version_info_field);
	
		version_info_field = Val_string_option(version_info_c->build_id);
		Store_field(version_info_ocaml, 12, version_info_field);
	}
	CAMLreturn(version_info_ocaml);
}

/* Get the defaults for version_info */
value stub_libxl_version_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_version_info c_val;
	libxl_version_info_init(&c_val);
	val = Val_version_info(&c_val);
	libxl_version_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to domain_create_info */
static int domain_create_info_val (libxl_ctx *ctx, libxl_domain_create_info *c_val, value v)
{
	CAMLparam1(v);

	domain_type_val(ctx, &c_val->type, Field(v, 0));
	c_val->hap = Defbool_val(Field(v, 1));
	c_val->oos = Defbool_val(Field(v, 2));
	c_val->ssidref = Int32_val(Field(v, 3));
	c_val->ssid_label = String_option_val(Field(v, 4));
	c_val->name = String_option_val(Field(v, 5));
	Uuid_val(&c_val->uuid, Field(v, 6));
	libxl_key_value_list_val(&c_val->xsdata, Field(v, 7));
	libxl_key_value_list_val(&c_val->platformdata, Field(v, 8));
	c_val->poolid = Int32_val(Field(v, 9));
	c_val->pool_name = String_option_val(Field(v, 10));
	c_val->run_hotplug_scripts = Defbool_val(Field(v, 11));
	c_val->driver_domain = Defbool_val(Field(v, 12));
	passthrough_val(ctx, &c_val->passthrough, Field(v, 13));
	
	CAMLreturn(0);
}

/* Convert domain_create_info to a caml value */
static value Val_domain_create_info (libxl_domain_create_info *domain_create_info_c)
{
	CAMLparam0();
	CAMLlocal1(domain_create_info_ocaml);
	{
		CAMLlocal1(domain_create_info_field);
	
		domain_create_info_ocaml = caml_alloc_tuple(14);
	
		domain_create_info_field = Val_domain_type(domain_create_info_c->type);
		Store_field(domain_create_info_ocaml, 0, domain_create_info_field);
	
		domain_create_info_field = Val_defbool(domain_create_info_c->hap);
		Store_field(domain_create_info_ocaml, 1, domain_create_info_field);
	
		domain_create_info_field = Val_defbool(domain_create_info_c->oos);
		Store_field(domain_create_info_ocaml, 2, domain_create_info_field);
	
		domain_create_info_field = caml_copy_int32(domain_create_info_c->ssidref);
		Store_field(domain_create_info_ocaml, 3, domain_create_info_field);
	
		domain_create_info_field = Val_string_option(domain_create_info_c->ssid_label);
		Store_field(domain_create_info_ocaml, 4, domain_create_info_field);
	
		domain_create_info_field = Val_string_option(domain_create_info_c->name);
		Store_field(domain_create_info_ocaml, 5, domain_create_info_field);
	
		domain_create_info_field = Val_uuid(&domain_create_info_c->uuid);
		Store_field(domain_create_info_ocaml, 6, domain_create_info_field);
	
		domain_create_info_field = Val_key_value_list(&domain_create_info_c->xsdata);
		Store_field(domain_create_info_ocaml, 7, domain_create_info_field);
	
		domain_create_info_field = Val_key_value_list(&domain_create_info_c->platformdata);
		Store_field(domain_create_info_ocaml, 8, domain_create_info_field);
	
		domain_create_info_field = caml_copy_int32(domain_create_info_c->poolid);
		Store_field(domain_create_info_ocaml, 9, domain_create_info_field);
	
		domain_create_info_field = Val_string_option(domain_create_info_c->pool_name);
		Store_field(domain_create_info_ocaml, 10, domain_create_info_field);
	
		domain_create_info_field = Val_defbool(domain_create_info_c->run_hotplug_scripts);
		Store_field(domain_create_info_ocaml, 11, domain_create_info_field);
	
		domain_create_info_field = Val_defbool(domain_create_info_c->driver_domain);
		Store_field(domain_create_info_ocaml, 12, domain_create_info_field);
	
		domain_create_info_field = Val_passthrough(domain_create_info_c->passthrough);
		Store_field(domain_create_info_ocaml, 13, domain_create_info_field);
	}
	CAMLreturn(domain_create_info_ocaml);
}

/* Get the defaults for domain_create_info */
value stub_libxl_domain_create_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_domain_create_info c_val;
	libxl_domain_create_info_init(&c_val);
	val = Val_domain_create_info(&c_val);
	libxl_domain_create_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to domain_restore_params */
static int domain_restore_params_val (libxl_ctx *ctx, libxl_domain_restore_params *c_val, value v)
{
	CAMLparam1(v);

	c_val->checkpointed_stream = Int_val(Field(v, 0));
	c_val->stream_version = Int32_val(Field(v, 1));
	c_val->colo_proxy_script = String_option_val(Field(v, 2));
	c_val->userspace_colo_proxy = Defbool_val(Field(v, 3));
	
	CAMLreturn(0);
}

/* Convert domain_restore_params to a caml value */
static value Val_domain_restore_params (libxl_domain_restore_params *domain_restore_params_c)
{
	CAMLparam0();
	CAMLlocal1(domain_restore_params_ocaml);
	{
		CAMLlocal1(domain_restore_params_field);
	
		domain_restore_params_ocaml = caml_alloc_tuple(4);
	
		domain_restore_params_field = Val_int(domain_restore_params_c->checkpointed_stream);
		Store_field(domain_restore_params_ocaml, 0, domain_restore_params_field);
	
		domain_restore_params_field = caml_copy_int32(domain_restore_params_c->stream_version);
		Store_field(domain_restore_params_ocaml, 1, domain_restore_params_field);
	
		domain_restore_params_field = Val_string_option(domain_restore_params_c->colo_proxy_script);
		Store_field(domain_restore_params_ocaml, 2, domain_restore_params_field);
	
		domain_restore_params_field = Val_defbool(domain_restore_params_c->userspace_colo_proxy);
		Store_field(domain_restore_params_ocaml, 3, domain_restore_params_field);
	}
	CAMLreturn(domain_restore_params_ocaml);
}

/* Get the defaults for domain_restore_params */
value stub_libxl_domain_restore_params_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_domain_restore_params c_val;
	libxl_domain_restore_params_init(&c_val);
	val = Val_domain_restore_params(&c_val);
	libxl_domain_restore_params_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to sched_params */
static int sched_params_val (libxl_ctx *ctx, libxl_sched_params *c_val, value v)
{
	CAMLparam1(v);

	c_val->vcpuid = Int_val(Field(v, 0));
	c_val->weight = Int_val(Field(v, 1));
	c_val->cap = Int_val(Field(v, 2));
	c_val->period = Int_val(Field(v, 3));
	c_val->extratime = Int_val(Field(v, 4));
	c_val->budget = Int_val(Field(v, 5));
	
	CAMLreturn(0);
}

/* Convert sched_params to a caml value */
static value Val_sched_params (libxl_sched_params *sched_params_c)
{
	CAMLparam0();
	CAMLlocal1(sched_params_ocaml);
	{
		CAMLlocal1(sched_params_field);
	
		sched_params_ocaml = caml_alloc_tuple(6);
	
		sched_params_field = Val_int(sched_params_c->vcpuid);
		Store_field(sched_params_ocaml, 0, sched_params_field);
	
		sched_params_field = Val_int(sched_params_c->weight);
		Store_field(sched_params_ocaml, 1, sched_params_field);
	
		sched_params_field = Val_int(sched_params_c->cap);
		Store_field(sched_params_ocaml, 2, sched_params_field);
	
		sched_params_field = Val_int(sched_params_c->period);
		Store_field(sched_params_ocaml, 3, sched_params_field);
	
		sched_params_field = Val_int(sched_params_c->extratime);
		Store_field(sched_params_ocaml, 4, sched_params_field);
	
		sched_params_field = Val_int(sched_params_c->budget);
		Store_field(sched_params_ocaml, 5, sched_params_field);
	}
	CAMLreturn(sched_params_ocaml);
}

/* Get the defaults for sched_params */
value stub_libxl_sched_params_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_sched_params c_val;
	libxl_sched_params_init(&c_val);
	val = Val_sched_params(&c_val);
	libxl_sched_params_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vcpu_sched_params */
static int vcpu_sched_params_val (libxl_ctx *ctx, libxl_vcpu_sched_params *c_val, value v)
{
	CAMLparam1(v);

	scheduler_val(ctx, &c_val->sched, Field(v, 0));
	{
		int i;
		c_val->num_vcpus = Wosize_val(Field(v, 1));
		c_val->vcpus = (libxl_sched_params *) calloc(c_val->num_vcpus, sizeof(*c_val->vcpus));
		for(i=0; i<c_val->num_vcpus; i++) {
			sched_params_val(ctx, &c_val->vcpus[i], Field(Field(v, 1), i));
		}
	}
	
	
	CAMLreturn(0);
}

/* Convert vcpu_sched_params to a caml value */
static value Val_vcpu_sched_params (libxl_vcpu_sched_params *vcpu_sched_params_c)
{
	CAMLparam0();
	CAMLlocal1(vcpu_sched_params_ocaml);
	{
		CAMLlocal1(vcpu_sched_params_field);
	
		vcpu_sched_params_ocaml = caml_alloc_tuple(2);
	
		vcpu_sched_params_field = Val_scheduler(vcpu_sched_params_c->sched);
		Store_field(vcpu_sched_params_ocaml, 0, vcpu_sched_params_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    vcpu_sched_params_field = caml_alloc(vcpu_sched_params_c->num_vcpus,0);
		    for(i=0; i<vcpu_sched_params_c->num_vcpus; i++) {
		        array_elem = Val_sched_params(&vcpu_sched_params_c->vcpus[i]);
		        Store_field(vcpu_sched_params_field, i, array_elem);
		    }
		}
		Store_field(vcpu_sched_params_ocaml, 1, vcpu_sched_params_field);
	}
	CAMLreturn(vcpu_sched_params_ocaml);
}

/* Get the defaults for vcpu_sched_params */
value stub_libxl_vcpu_sched_params_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vcpu_sched_params c_val;
	libxl_vcpu_sched_params_init(&c_val);
	val = Val_vcpu_sched_params(&c_val);
	libxl_vcpu_sched_params_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to domain_sched_params */
static int domain_sched_params_val (libxl_ctx *ctx, libxl_domain_sched_params *c_val, value v)
{
	CAMLparam1(v);

	scheduler_val(ctx, &c_val->sched, Field(v, 0));
	c_val->weight = Int_val(Field(v, 1));
	c_val->cap = Int_val(Field(v, 2));
	c_val->period = Int_val(Field(v, 3));
	c_val->budget = Int_val(Field(v, 4));
	c_val->extratime = Int_val(Field(v, 5));
	c_val->slice = Int_val(Field(v, 6));
	c_val->latency = Int_val(Field(v, 7));
	
	CAMLreturn(0);
}

/* Convert domain_sched_params to a caml value */
static value Val_domain_sched_params (libxl_domain_sched_params *domain_sched_params_c)
{
	CAMLparam0();
	CAMLlocal1(domain_sched_params_ocaml);
	{
		CAMLlocal1(domain_sched_params_field);
	
		domain_sched_params_ocaml = caml_alloc_tuple(8);
	
		domain_sched_params_field = Val_scheduler(domain_sched_params_c->sched);
		Store_field(domain_sched_params_ocaml, 0, domain_sched_params_field);
	
		domain_sched_params_field = Val_int(domain_sched_params_c->weight);
		Store_field(domain_sched_params_ocaml, 1, domain_sched_params_field);
	
		domain_sched_params_field = Val_int(domain_sched_params_c->cap);
		Store_field(domain_sched_params_ocaml, 2, domain_sched_params_field);
	
		domain_sched_params_field = Val_int(domain_sched_params_c->period);
		Store_field(domain_sched_params_ocaml, 3, domain_sched_params_field);
	
		domain_sched_params_field = Val_int(domain_sched_params_c->budget);
		Store_field(domain_sched_params_ocaml, 4, domain_sched_params_field);
	
		domain_sched_params_field = Val_int(domain_sched_params_c->extratime);
		Store_field(domain_sched_params_ocaml, 5, domain_sched_params_field);
	
		domain_sched_params_field = Val_int(domain_sched_params_c->slice);
		Store_field(domain_sched_params_ocaml, 6, domain_sched_params_field);
	
		domain_sched_params_field = Val_int(domain_sched_params_c->latency);
		Store_field(domain_sched_params_ocaml, 7, domain_sched_params_field);
	}
	CAMLreturn(domain_sched_params_ocaml);
}

/* Stubs for domain_sched_params */
value stub_xl_domain_sched_params_get(value v1, value v2);
value stub_xl_domain_sched_params_set(value v1, value v2, value v3);

/* Get the defaults for domain_sched_params */
value stub_libxl_domain_sched_params_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_domain_sched_params c_val;
	libxl_domain_sched_params_init(&c_val);
	val = Val_domain_sched_params(&c_val);
	libxl_domain_sched_params_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vnode_info */
static int vnode_info_val (libxl_ctx *ctx, libxl_vnode_info *c_val, value v)
{
	CAMLparam1(v);

	c_val->memkb = Int64_val(Field(v, 0));
	{
		int i;
		c_val->num_distances = Wosize_val(Field(v, 1));
		c_val->distances = (uint32_t *) calloc(c_val->num_distances, sizeof(*c_val->distances));
		for(i=0; i<c_val->num_distances; i++) {
			c_val->distances[i] = Int32_val(Field(Field(v, 1), i));
		}
	}
	
	c_val->pnode = Int32_val(Field(v, 2));
	Bitmap_val(ctx, &c_val->vcpus, Field(v, 3));
	
	CAMLreturn(0);
}

/* Convert vnode_info to a caml value */
static value Val_vnode_info (libxl_vnode_info *vnode_info_c)
{
	CAMLparam0();
	CAMLlocal1(vnode_info_ocaml);
	{
		CAMLlocal1(vnode_info_field);
	
		vnode_info_ocaml = caml_alloc_tuple(4);
	
		vnode_info_field = caml_copy_int64(vnode_info_c->memkb);
		Store_field(vnode_info_ocaml, 0, vnode_info_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    vnode_info_field = caml_alloc(vnode_info_c->num_distances,0);
		    for(i=0; i<vnode_info_c->num_distances; i++) {
		        array_elem = caml_copy_int32(vnode_info_c->distances[i]);
		        Store_field(vnode_info_field, i, array_elem);
		    }
		}
		Store_field(vnode_info_ocaml, 1, vnode_info_field);
	
		vnode_info_field = caml_copy_int32(vnode_info_c->pnode);
		Store_field(vnode_info_ocaml, 2, vnode_info_field);
	
		vnode_info_field = Val_bitmap(&vnode_info_c->vcpus);
		Store_field(vnode_info_ocaml, 3, vnode_info_field);
	}
	CAMLreturn(vnode_info_ocaml);
}

/* Get the defaults for vnode_info */
value stub_libxl_vnode_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vnode_info c_val;
	libxl_vnode_info_init(&c_val);
	val = Val_vnode_info(&c_val);
	libxl_vnode_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to gic_version */
static int gic_version_val (libxl_ctx *ctx, libxl_gic_version *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_GIC_VERSION_DEFAULT; break;
	    case 1: *c_val = LIBXL_GIC_VERSION_V2; break;
	    case 2: *c_val = LIBXL_GIC_VERSION_V3; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_gic_version"); break;
	}
	CAMLreturn(0);
}

/* Convert gic_version to a caml value */
static value Val_gic_version (libxl_gic_version gic_version_c)
{
	CAMLparam0();
	CAMLlocal1(gic_version_ocaml);
	switch(gic_version_c) {
	    case LIBXL_GIC_VERSION_DEFAULT: gic_version_ocaml = Val_int(0); break;
	    case LIBXL_GIC_VERSION_V2: gic_version_ocaml = Val_int(1); break;
	    case LIBXL_GIC_VERSION_V3: gic_version_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_gic_version"); break;
	}
	CAMLreturn(gic_version_ocaml);
}

/* Convert caml value to tee_type */
static int tee_type_val (libxl_ctx *ctx, libxl_tee_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_TEE_TYPE_NONE; break;
	    case 1: *c_val = LIBXL_TEE_TYPE_OPTEE; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_tee_type"); break;
	}
	CAMLreturn(0);
}

/* Convert tee_type to a caml value */
static value Val_tee_type (libxl_tee_type tee_type_c)
{
	CAMLparam0();
	CAMLlocal1(tee_type_ocaml);
	switch(tee_type_c) {
	    case LIBXL_TEE_TYPE_NONE: tee_type_ocaml = Val_int(0); break;
	    case LIBXL_TEE_TYPE_OPTEE: tee_type_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_tee_type"); break;
	}
	CAMLreturn(tee_type_ocaml);
}

/* Convert caml value to rdm_reserve */
static int rdm_reserve_val (libxl_ctx *ctx, libxl_rdm_reserve *c_val, value v)
{
	CAMLparam1(v);

	rdm_reserve_strategy_val(ctx, &c_val->strategy, Field(v, 0));
	rdm_reserve_policy_val(ctx, &c_val->policy, Field(v, 1));
	
	CAMLreturn(0);
}

/* Convert rdm_reserve to a caml value */
static value Val_rdm_reserve (libxl_rdm_reserve *rdm_reserve_c)
{
	CAMLparam0();
	CAMLlocal1(rdm_reserve_ocaml);
	{
		CAMLlocal1(rdm_reserve_field);
	
		rdm_reserve_ocaml = caml_alloc_tuple(2);
	
		rdm_reserve_field = Val_rdm_reserve_strategy(rdm_reserve_c->strategy);
		Store_field(rdm_reserve_ocaml, 0, rdm_reserve_field);
	
		rdm_reserve_field = Val_rdm_reserve_policy(rdm_reserve_c->policy);
		Store_field(rdm_reserve_ocaml, 1, rdm_reserve_field);
	}
	CAMLreturn(rdm_reserve_ocaml);
}

/* Get the defaults for rdm_reserve */
value stub_libxl_rdm_reserve_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_rdm_reserve c_val;
	libxl_rdm_reserve_init(&c_val);
	val = Val_rdm_reserve(&c_val);
	libxl_rdm_reserve_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to altp2m_mode */
static int altp2m_mode_val (libxl_ctx *ctx, libxl_altp2m_mode *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_ALTP2M_MODE_DISABLED; break;
	    case 1: *c_val = LIBXL_ALTP2M_MODE_MIXED; break;
	    case 2: *c_val = LIBXL_ALTP2M_MODE_EXTERNAL; break;
	    case 3: *c_val = LIBXL_ALTP2M_MODE_LIMITED; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_altp2m_mode"); break;
	}
	CAMLreturn(0);
}

/* Convert altp2m_mode to a caml value */
static value Val_altp2m_mode (libxl_altp2m_mode altp2m_mode_c)
{
	CAMLparam0();
	CAMLlocal1(altp2m_mode_ocaml);
	switch(altp2m_mode_c) {
	    case LIBXL_ALTP2M_MODE_DISABLED: altp2m_mode_ocaml = Val_int(0); break;
	    case LIBXL_ALTP2M_MODE_MIXED: altp2m_mode_ocaml = Val_int(1); break;
	    case LIBXL_ALTP2M_MODE_EXTERNAL: altp2m_mode_ocaml = Val_int(2); break;
	    case LIBXL_ALTP2M_MODE_LIMITED: altp2m_mode_ocaml = Val_int(3); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_altp2m_mode"); break;
	}
	CAMLreturn(altp2m_mode_ocaml);
}

/* Convert caml value to domain_build_info */
static int domain_build_info_val (libxl_ctx *ctx, libxl_domain_build_info *c_val, value v)
{
	CAMLparam1(v);

	c_val->max_vcpus = Int_val(Field(v, 0));
	Bitmap_val(ctx, &c_val->avail_vcpus, Field(v, 1));
	Bitmap_val(ctx, &c_val->cpumap, Field(v, 2));
	Bitmap_val(ctx, &c_val->nodemap, Field(v, 3));
	{
		int i;
		c_val->num_vcpu_hard_affinity = Wosize_val(Field(v, 4));
		c_val->vcpu_hard_affinity = (libxl_bitmap *) calloc(c_val->num_vcpu_hard_affinity, sizeof(*c_val->vcpu_hard_affinity));
		for(i=0; i<c_val->num_vcpu_hard_affinity; i++) {
			Bitmap_val(ctx, &c_val->vcpu_hard_affinity[i], Field(Field(v, 4), i));
		}
	}
	
	{
		int i;
		c_val->num_vcpu_soft_affinity = Wosize_val(Field(v, 5));
		c_val->vcpu_soft_affinity = (libxl_bitmap *) calloc(c_val->num_vcpu_soft_affinity, sizeof(*c_val->vcpu_soft_affinity));
		for(i=0; i<c_val->num_vcpu_soft_affinity; i++) {
			Bitmap_val(ctx, &c_val->vcpu_soft_affinity[i], Field(Field(v, 5), i));
		}
	}
	
	c_val->numa_placement = Defbool_val(Field(v, 6));
	tsc_mode_val(ctx, &c_val->tsc_mode, Field(v, 7));
	c_val->max_memkb = Int64_val(Field(v, 8));
	c_val->target_memkb = Int64_val(Field(v, 9));
	c_val->video_memkb = Int64_val(Field(v, 10));
	c_val->shadow_memkb = Int64_val(Field(v, 11));
	c_val->iommu_memkb = Int64_val(Field(v, 12));
	c_val->rtc_timeoffset = Int32_val(Field(v, 13));
	c_val->exec_ssidref = Int32_val(Field(v, 14));
	c_val->exec_ssid_label = String_option_val(Field(v, 15));
	c_val->localtime = Defbool_val(Field(v, 16));
	c_val->disable_migrate = Defbool_val(Field(v, 17));
	c_val->cpuid = 0;
	c_val->blkdev_start = String_option_val(Field(v, 19));
	{
		int i;
		c_val->num_vnuma_nodes = Wosize_val(Field(v, 20));
		c_val->vnuma_nodes = (libxl_vnode_info *) calloc(c_val->num_vnuma_nodes, sizeof(*c_val->vnuma_nodes));
		for(i=0; i<c_val->num_vnuma_nodes; i++) {
			vnode_info_val(ctx, &c_val->vnuma_nodes[i], Field(Field(v, 20), i));
		}
	}
	
	c_val->max_grant_frames = Int32_val(Field(v, 21));
	c_val->max_maptrack_frames = Int32_val(Field(v, 22));
	device_model_version_val(ctx, &c_val->device_model_version, Field(v, 23));
	c_val->device_model_stubdomain = Defbool_val(Field(v, 24));
	c_val->device_model = String_option_val(Field(v, 25));
	c_val->device_model_ssidref = Int32_val(Field(v, 26));
	c_val->device_model_ssid_label = String_option_val(Field(v, 27));
	c_val->device_model_user = String_option_val(Field(v, 28));
	libxl_string_list_val(&c_val->extra, Field(v, 29));
	libxl_string_list_val(&c_val->extra_pv, Field(v, 30));
	libxl_string_list_val(&c_val->extra_hvm, Field(v, 31));
	domain_sched_params_val(ctx, &c_val->sched_params, Field(v, 32));
	{
		int i;
		c_val->num_ioports = Wosize_val(Field(v, 33));
		c_val->ioports = (libxl_ioport_range *) calloc(c_val->num_ioports, sizeof(*c_val->ioports));
		for(i=0; i<c_val->num_ioports; i++) {
			ioport_range_val(ctx, &c_val->ioports[i], Field(Field(v, 33), i));
		}
	}
	
	{
		int i;
		c_val->num_irqs = Wosize_val(Field(v, 34));
		c_val->irqs = (uint32_t *) calloc(c_val->num_irqs, sizeof(*c_val->irqs));
		for(i=0; i<c_val->num_irqs; i++) {
			c_val->irqs[i] = Int32_val(Field(Field(v, 34), i));
		}
	}
	
	{
		int i;
		c_val->num_iomem = Wosize_val(Field(v, 35));
		c_val->iomem = (libxl_iomem_range *) calloc(c_val->num_iomem, sizeof(*c_val->iomem));
		for(i=0; i<c_val->num_iomem; i++) {
			iomem_range_val(ctx, &c_val->iomem[i], Field(Field(v, 35), i));
		}
	}
	
	c_val->claim_mode = Defbool_val(Field(v, 36));
	c_val->event_channels = Int32_val(Field(v, 37));
	c_val->kernel = String_option_val(Field(v, 38));
	c_val->cmdline = String_option_val(Field(v, 39));
	c_val->ramdisk = String_option_val(Field(v, 40));
	c_val->device_tree = String_option_val(Field(v, 41));
	c_val->acpi = Defbool_val(Field(v, 42));
	c_val->bootloader = String_option_val(Field(v, 43));
	libxl_string_list_val(&c_val->bootloader_args, Field(v, 44));
	timer_mode_val(ctx, &c_val->timer_mode, Field(v, 45));
	c_val->nested_hvm = Defbool_val(Field(v, 46));
	c_val->apic = Defbool_val(Field(v, 47));
	c_val->dm_restrict = Defbool_val(Field(v, 48));
	tee_type_val(ctx, &c_val->tee, Field(v, 49));
	{
		if(Is_long(Field(v, 50))) {
			switch(Int_val(Field(v, 50))) {
			    case 0: c_val->type = LIBXL_DOMAIN_TYPE_INVALID; break;
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->type (long)"); break;
			}
		} else {
			/* Is block... */
			switch(Tag_val(Field(v, 50))) {
			    case 0:
			        c_val->type = LIBXL_DOMAIN_TYPE_HVM;
			        c_val->u.hvm.firmware = String_option_val(Field(Field(Field(v, 50), 0), 0));
			        bios_type_val(ctx, &c_val->u.hvm.bios, Field(Field(Field(v, 50), 0), 1));
			        c_val->u.hvm.pae = Defbool_val(Field(Field(Field(v, 50), 0), 2));
			        c_val->u.hvm.apic = Defbool_val(Field(Field(Field(v, 50), 0), 3));
			        c_val->u.hvm.acpi = Defbool_val(Field(Field(Field(v, 50), 0), 4));
			        c_val->u.hvm.acpi_s3 = Defbool_val(Field(Field(Field(v, 50), 0), 5));
			        c_val->u.hvm.acpi_s4 = Defbool_val(Field(Field(Field(v, 50), 0), 6));
			        c_val->u.hvm.acpi_laptop_slate = Defbool_val(Field(Field(Field(v, 50), 0), 7));
			        c_val->u.hvm.nx = Defbool_val(Field(Field(Field(v, 50), 0), 8));
			        c_val->u.hvm.viridian = Defbool_val(Field(Field(Field(v, 50), 0), 9));
			        Bitmap_val(ctx, &c_val->u.hvm.viridian_enable, Field(Field(Field(v, 50), 0), 10));
			        Bitmap_val(ctx, &c_val->u.hvm.viridian_disable, Field(Field(Field(v, 50), 0), 11));
			        c_val->u.hvm.timeoffset = String_option_val(Field(Field(Field(v, 50), 0), 12));
			        c_val->u.hvm.hpet = Defbool_val(Field(Field(Field(v, 50), 0), 13));
			        c_val->u.hvm.vpt_align = Defbool_val(Field(Field(Field(v, 50), 0), 14));
			        c_val->u.hvm.mmio_hole_memkb = Int64_val(Field(Field(Field(v, 50), 0), 15));
			        timer_mode_val(ctx, &c_val->u.hvm.timer_mode, Field(Field(Field(v, 50), 0), 16));
			        c_val->u.hvm.nested_hvm = Defbool_val(Field(Field(Field(v, 50), 0), 17));
			        c_val->u.hvm.altp2m = Defbool_val(Field(Field(Field(v, 50), 0), 18));
			        c_val->u.hvm.system_firmware = String_option_val(Field(Field(Field(v, 50), 0), 19));
			        c_val->u.hvm.smbios_firmware = String_option_val(Field(Field(Field(v, 50), 0), 20));
			        c_val->u.hvm.acpi_firmware = String_option_val(Field(Field(Field(v, 50), 0), 21));
			        hdtype_val(ctx, &c_val->u.hvm.hdtype, Field(Field(Field(v, 50), 0), 22));
			        c_val->u.hvm.nographic = Defbool_val(Field(Field(Field(v, 50), 0), 23));
			        vga_interface_info_val(ctx, &c_val->u.hvm.vga, Field(Field(Field(v, 50), 0), 24));
			        vnc_info_val(ctx, &c_val->u.hvm.vnc, Field(Field(Field(v, 50), 0), 25));
			        c_val->u.hvm.keymap = String_option_val(Field(Field(Field(v, 50), 0), 26));
			        sdl_info_val(ctx, &c_val->u.hvm.sdl, Field(Field(Field(v, 50), 0), 27));
			        spice_info_val(ctx, &c_val->u.hvm.spice, Field(Field(Field(v, 50), 0), 28));
			        c_val->u.hvm.gfx_passthru = Defbool_val(Field(Field(Field(v, 50), 0), 29));
			        gfx_passthru_kind_val(ctx, &c_val->u.hvm.gfx_passthru_kind, Field(Field(Field(v, 50), 0), 30));
			        c_val->u.hvm.serial = String_option_val(Field(Field(Field(v, 50), 0), 31));
			        c_val->u.hvm.boot = String_option_val(Field(Field(Field(v, 50), 0), 32));
			        c_val->u.hvm.usb = Defbool_val(Field(Field(Field(v, 50), 0), 33));
			        c_val->u.hvm.usbversion = Int_val(Field(Field(Field(v, 50), 0), 34));
			        c_val->u.hvm.usbdevice = String_option_val(Field(Field(Field(v, 50), 0), 35));
			        c_val->u.hvm.vkb_device = Defbool_val(Field(Field(Field(v, 50), 0), 36));
			        c_val->u.hvm.soundhw = String_option_val(Field(Field(Field(v, 50), 0), 37));
			        c_val->u.hvm.xen_platform_pci = Defbool_val(Field(Field(Field(v, 50), 0), 38));
			        libxl_string_list_val(&c_val->u.hvm.usbdevice_list, Field(Field(Field(v, 50), 0), 39));
			        vendor_device_val(ctx, &c_val->u.hvm.vendor_device, Field(Field(Field(v, 50), 0), 40));
			        Ms_vm_genid_val(&c_val->u.hvm.ms_vm_genid, Field(Field(Field(v, 50), 0), 41));
			        libxl_string_list_val(&c_val->u.hvm.serial_list, Field(Field(Field(v, 50), 0), 42));
			        rdm_reserve_val(ctx, &c_val->u.hvm.rdm, Field(Field(Field(v, 50), 0), 43));
			        c_val->u.hvm.rdm_mem_boundary_memkb = Int64_val(Field(Field(Field(v, 50), 0), 44));
			        c_val->u.hvm.mca_caps = Int64_val(Field(Field(Field(v, 50), 0), 45));
			        break;
			    case 1:
			        c_val->type = LIBXL_DOMAIN_TYPE_PV;
			        c_val->u.pv.kernel = String_option_val(Field(Field(Field(v, 50), 0), 0));
			        c_val->u.pv.slack_memkb = Int64_val(Field(Field(Field(v, 50), 0), 1));
			        c_val->u.pv.bootloader = String_option_val(Field(Field(Field(v, 50), 0), 2));
			        libxl_string_list_val(&c_val->u.pv.bootloader_args, Field(Field(Field(v, 50), 0), 3));
			        c_val->u.pv.cmdline = String_option_val(Field(Field(Field(v, 50), 0), 4));
			        c_val->u.pv.ramdisk = String_option_val(Field(Field(Field(v, 50), 0), 5));
			        c_val->u.pv.features = String_option_val(Field(Field(Field(v, 50), 0), 6));
			        c_val->u.pv.e820_host = Defbool_val(Field(Field(Field(v, 50), 0), 7));
			        break;
			    case 2:
			        c_val->type = LIBXL_DOMAIN_TYPE_PVH;
			        c_val->u.pvh.pvshim = Defbool_val(Field(Field(Field(v, 50), 0), 0));
			        c_val->u.pvh.pvshim_path = String_option_val(Field(Field(Field(v, 50), 0), 1));
			        c_val->u.pvh.pvshim_cmdline = String_option_val(Field(Field(Field(v, 50), 0), 2));
			        c_val->u.pvh.pvshim_extra = String_option_val(Field(Field(Field(v, 50), 0), 3));
			        break;
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->type (block)"); break;
			}
		}
	}
	gic_version_val(ctx, &c_val->arch_arm.gic_version, Field(Field(v, 51), 0));
	vuart_type_val(ctx, &c_val->arch_arm.vuart, Field(Field(v, 51), 1));
	
	altp2m_mode_val(ctx, &c_val->altp2m, Field(v, 52));
	
	CAMLreturn(0);
}

/* Convert domain_build_info to a caml value */
static value Val_domain_build_info (libxl_domain_build_info *domain_build_info_c)
{
	CAMLparam0();
	CAMLlocal1(domain_build_info_ocaml);
	{
		CAMLlocal1(domain_build_info_field);
	
		domain_build_info_ocaml = caml_alloc_tuple(53);
	
		domain_build_info_field = Val_int(domain_build_info_c->max_vcpus);
		Store_field(domain_build_info_ocaml, 0, domain_build_info_field);
	
		domain_build_info_field = Val_bitmap(&domain_build_info_c->avail_vcpus);
		Store_field(domain_build_info_ocaml, 1, domain_build_info_field);
	
		domain_build_info_field = Val_bitmap(&domain_build_info_c->cpumap);
		Store_field(domain_build_info_ocaml, 2, domain_build_info_field);
	
		domain_build_info_field = Val_bitmap(&domain_build_info_c->nodemap);
		Store_field(domain_build_info_ocaml, 3, domain_build_info_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_build_info_field = caml_alloc(domain_build_info_c->num_vcpu_hard_affinity,0);
		    for(i=0; i<domain_build_info_c->num_vcpu_hard_affinity; i++) {
		        array_elem = Val_bitmap(&domain_build_info_c->vcpu_hard_affinity[i]);
		        Store_field(domain_build_info_field, i, array_elem);
		    }
		}
		Store_field(domain_build_info_ocaml, 4, domain_build_info_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_build_info_field = caml_alloc(domain_build_info_c->num_vcpu_soft_affinity,0);
		    for(i=0; i<domain_build_info_c->num_vcpu_soft_affinity; i++) {
		        array_elem = Val_bitmap(&domain_build_info_c->vcpu_soft_affinity[i]);
		        Store_field(domain_build_info_field, i, array_elem);
		    }
		}
		Store_field(domain_build_info_ocaml, 5, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->numa_placement);
		Store_field(domain_build_info_ocaml, 6, domain_build_info_field);
	
		domain_build_info_field = Val_tsc_mode(domain_build_info_c->tsc_mode);
		Store_field(domain_build_info_ocaml, 7, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int64(domain_build_info_c->max_memkb);
		Store_field(domain_build_info_ocaml, 8, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int64(domain_build_info_c->target_memkb);
		Store_field(domain_build_info_ocaml, 9, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int64(domain_build_info_c->video_memkb);
		Store_field(domain_build_info_ocaml, 10, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int64(domain_build_info_c->shadow_memkb);
		Store_field(domain_build_info_ocaml, 11, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int64(domain_build_info_c->iommu_memkb);
		Store_field(domain_build_info_ocaml, 12, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int32(domain_build_info_c->rtc_timeoffset);
		Store_field(domain_build_info_ocaml, 13, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int32(domain_build_info_c->exec_ssidref);
		Store_field(domain_build_info_ocaml, 14, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->exec_ssid_label);
		Store_field(domain_build_info_ocaml, 15, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->localtime);
		Store_field(domain_build_info_ocaml, 16, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->disable_migrate);
		Store_field(domain_build_info_ocaml, 17, domain_build_info_field);
	
		domain_build_info_field = Val_unit;
		Store_field(domain_build_info_ocaml, 18, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->blkdev_start);
		Store_field(domain_build_info_ocaml, 19, domain_build_info_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_build_info_field = caml_alloc(domain_build_info_c->num_vnuma_nodes,0);
		    for(i=0; i<domain_build_info_c->num_vnuma_nodes; i++) {
		        array_elem = Val_vnode_info(&domain_build_info_c->vnuma_nodes[i]);
		        Store_field(domain_build_info_field, i, array_elem);
		    }
		}
		Store_field(domain_build_info_ocaml, 20, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int32(domain_build_info_c->max_grant_frames);
		Store_field(domain_build_info_ocaml, 21, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int32(domain_build_info_c->max_maptrack_frames);
		Store_field(domain_build_info_ocaml, 22, domain_build_info_field);
	
		domain_build_info_field = Val_device_model_version(domain_build_info_c->device_model_version);
		Store_field(domain_build_info_ocaml, 23, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->device_model_stubdomain);
		Store_field(domain_build_info_ocaml, 24, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->device_model);
		Store_field(domain_build_info_ocaml, 25, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int32(domain_build_info_c->device_model_ssidref);
		Store_field(domain_build_info_ocaml, 26, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->device_model_ssid_label);
		Store_field(domain_build_info_ocaml, 27, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->device_model_user);
		Store_field(domain_build_info_ocaml, 28, domain_build_info_field);
	
		domain_build_info_field = Val_string_list(&domain_build_info_c->extra);
		Store_field(domain_build_info_ocaml, 29, domain_build_info_field);
	
		domain_build_info_field = Val_string_list(&domain_build_info_c->extra_pv);
		Store_field(domain_build_info_ocaml, 30, domain_build_info_field);
	
		domain_build_info_field = Val_string_list(&domain_build_info_c->extra_hvm);
		Store_field(domain_build_info_ocaml, 31, domain_build_info_field);
	
		domain_build_info_field = Val_domain_sched_params(&domain_build_info_c->sched_params);
		Store_field(domain_build_info_ocaml, 32, domain_build_info_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_build_info_field = caml_alloc(domain_build_info_c->num_ioports,0);
		    for(i=0; i<domain_build_info_c->num_ioports; i++) {
		        array_elem = Val_ioport_range(&domain_build_info_c->ioports[i]);
		        Store_field(domain_build_info_field, i, array_elem);
		    }
		}
		Store_field(domain_build_info_ocaml, 33, domain_build_info_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_build_info_field = caml_alloc(domain_build_info_c->num_irqs,0);
		    for(i=0; i<domain_build_info_c->num_irqs; i++) {
		        array_elem = caml_copy_int32(domain_build_info_c->irqs[i]);
		        Store_field(domain_build_info_field, i, array_elem);
		    }
		}
		Store_field(domain_build_info_ocaml, 34, domain_build_info_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_build_info_field = caml_alloc(domain_build_info_c->num_iomem,0);
		    for(i=0; i<domain_build_info_c->num_iomem; i++) {
		        array_elem = Val_iomem_range(&domain_build_info_c->iomem[i]);
		        Store_field(domain_build_info_field, i, array_elem);
		    }
		}
		Store_field(domain_build_info_ocaml, 35, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->claim_mode);
		Store_field(domain_build_info_ocaml, 36, domain_build_info_field);
	
		domain_build_info_field = caml_copy_int32(domain_build_info_c->event_channels);
		Store_field(domain_build_info_ocaml, 37, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->kernel);
		Store_field(domain_build_info_ocaml, 38, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->cmdline);
		Store_field(domain_build_info_ocaml, 39, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->ramdisk);
		Store_field(domain_build_info_ocaml, 40, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->device_tree);
		Store_field(domain_build_info_ocaml, 41, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->acpi);
		Store_field(domain_build_info_ocaml, 42, domain_build_info_field);
	
		domain_build_info_field = Val_string_option(domain_build_info_c->bootloader);
		Store_field(domain_build_info_ocaml, 43, domain_build_info_field);
	
		domain_build_info_field = Val_string_list(&domain_build_info_c->bootloader_args);
		Store_field(domain_build_info_ocaml, 44, domain_build_info_field);
	
		domain_build_info_field = Val_timer_mode(domain_build_info_c->timer_mode);
		Store_field(domain_build_info_ocaml, 45, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->nested_hvm);
		Store_field(domain_build_info_ocaml, 46, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->apic);
		Store_field(domain_build_info_ocaml, 47, domain_build_info_field);
	
		domain_build_info_field = Val_defbool(domain_build_info_c->dm_restrict);
		Store_field(domain_build_info_ocaml, 48, domain_build_info_field);
	
		domain_build_info_field = Val_tee_type(domain_build_info_c->tee);
		Store_field(domain_build_info_ocaml, 49, domain_build_info_field);
	
		switch(domain_build_info_c->type) {
		    case LIBXL_DOMAIN_TYPE_HVM:
		        /* 0: Block */
		        {
			        CAMLlocal1(tmp);
			        domain_build_info_field = caml_alloc(1,0);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(46);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.firmware);
			        	Store_field(tmp, 0, anon_field);
			        
			        	anon_field = Val_bios_type(domain_build_info_c->u.hvm.bios);
			        	Store_field(tmp, 1, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.pae);
			        	Store_field(tmp, 2, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.apic);
			        	Store_field(tmp, 3, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.acpi);
			        	Store_field(tmp, 4, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.acpi_s3);
			        	Store_field(tmp, 5, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.acpi_s4);
			        	Store_field(tmp, 6, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.acpi_laptop_slate);
			        	Store_field(tmp, 7, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.nx);
			        	Store_field(tmp, 8, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.viridian);
			        	Store_field(tmp, 9, anon_field);
			        
			        	anon_field = Val_bitmap(&domain_build_info_c->u.hvm.viridian_enable);
			        	Store_field(tmp, 10, anon_field);
			        
			        	anon_field = Val_bitmap(&domain_build_info_c->u.hvm.viridian_disable);
			        	Store_field(tmp, 11, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.timeoffset);
			        	Store_field(tmp, 12, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.hpet);
			        	Store_field(tmp, 13, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.vpt_align);
			        	Store_field(tmp, 14, anon_field);
			        
			        	anon_field = caml_copy_int64(domain_build_info_c->u.hvm.mmio_hole_memkb);
			        	Store_field(tmp, 15, anon_field);
			        
			        	anon_field = Val_timer_mode(domain_build_info_c->u.hvm.timer_mode);
			        	Store_field(tmp, 16, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.nested_hvm);
			        	Store_field(tmp, 17, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.altp2m);
			        	Store_field(tmp, 18, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.system_firmware);
			        	Store_field(tmp, 19, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.smbios_firmware);
			        	Store_field(tmp, 20, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.acpi_firmware);
			        	Store_field(tmp, 21, anon_field);
			        
			        	anon_field = Val_hdtype(domain_build_info_c->u.hvm.hdtype);
			        	Store_field(tmp, 22, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.nographic);
			        	Store_field(tmp, 23, anon_field);
			        
			        	anon_field = Val_vga_interface_info(&domain_build_info_c->u.hvm.vga);
			        	Store_field(tmp, 24, anon_field);
			        
			        	anon_field = Val_vnc_info(&domain_build_info_c->u.hvm.vnc);
			        	Store_field(tmp, 25, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.keymap);
			        	Store_field(tmp, 26, anon_field);
			        
			        	anon_field = Val_sdl_info(&domain_build_info_c->u.hvm.sdl);
			        	Store_field(tmp, 27, anon_field);
			        
			        	anon_field = Val_spice_info(&domain_build_info_c->u.hvm.spice);
			        	Store_field(tmp, 28, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.gfx_passthru);
			        	Store_field(tmp, 29, anon_field);
			        
			        	anon_field = Val_gfx_passthru_kind(domain_build_info_c->u.hvm.gfx_passthru_kind);
			        	Store_field(tmp, 30, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.serial);
			        	Store_field(tmp, 31, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.boot);
			        	Store_field(tmp, 32, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.usb);
			        	Store_field(tmp, 33, anon_field);
			        
			        	anon_field = Val_int(domain_build_info_c->u.hvm.usbversion);
			        	Store_field(tmp, 34, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.usbdevice);
			        	Store_field(tmp, 35, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.vkb_device);
			        	Store_field(tmp, 36, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.hvm.soundhw);
			        	Store_field(tmp, 37, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.hvm.xen_platform_pci);
			        	Store_field(tmp, 38, anon_field);
			        
			        	anon_field = Val_string_list(&domain_build_info_c->u.hvm.usbdevice_list);
			        	Store_field(tmp, 39, anon_field);
			        
			        	anon_field = Val_vendor_device(domain_build_info_c->u.hvm.vendor_device);
			        	Store_field(tmp, 40, anon_field);
			        
			        	anon_field = Val_ms_vm_genid(&domain_build_info_c->u.hvm.ms_vm_genid);
			        	Store_field(tmp, 41, anon_field);
			        
			        	anon_field = Val_string_list(&domain_build_info_c->u.hvm.serial_list);
			        	Store_field(tmp, 42, anon_field);
			        
			        	anon_field = Val_rdm_reserve(&domain_build_info_c->u.hvm.rdm);
			        	Store_field(tmp, 43, anon_field);
			        
			        	anon_field = caml_copy_int64(domain_build_info_c->u.hvm.rdm_mem_boundary_memkb);
			        	Store_field(tmp, 44, anon_field);
			        
			        	anon_field = caml_copy_int64(domain_build_info_c->u.hvm.mca_caps);
			        	Store_field(tmp, 45, anon_field);
			        }
			        Store_field(domain_build_info_field, 0, tmp);
		        }
		        break;
		    case LIBXL_DOMAIN_TYPE_PV:
		        /* 1: Block */
		        {
			        CAMLlocal1(tmp);
			        domain_build_info_field = caml_alloc(1,1);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(8);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pv.kernel);
			        	Store_field(tmp, 0, anon_field);
			        
			        	anon_field = caml_copy_int64(domain_build_info_c->u.pv.slack_memkb);
			        	Store_field(tmp, 1, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pv.bootloader);
			        	Store_field(tmp, 2, anon_field);
			        
			        	anon_field = Val_string_list(&domain_build_info_c->u.pv.bootloader_args);
			        	Store_field(tmp, 3, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pv.cmdline);
			        	Store_field(tmp, 4, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pv.ramdisk);
			        	Store_field(tmp, 5, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pv.features);
			        	Store_field(tmp, 6, anon_field);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.pv.e820_host);
			        	Store_field(tmp, 7, anon_field);
			        }
			        Store_field(domain_build_info_field, 0, tmp);
		        }
		        break;
		    case LIBXL_DOMAIN_TYPE_PVH:
		        /* 2: Block */
		        {
			        CAMLlocal1(tmp);
			        domain_build_info_field = caml_alloc(1,2);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(4);
			        
			        	anon_field = Val_defbool(domain_build_info_c->u.pvh.pvshim);
			        	Store_field(tmp, 0, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pvh.pvshim_path);
			        	Store_field(tmp, 1, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pvh.pvshim_cmdline);
			        	Store_field(tmp, 2, anon_field);
			        
			        	anon_field = Val_string_option(domain_build_info_c->u.pvh.pvshim_extra);
			        	Store_field(tmp, 3, anon_field);
			        }
			        Store_field(domain_build_info_field, 0, tmp);
		        }
		        break;
		    case LIBXL_DOMAIN_TYPE_INVALID:
		        /* 0: None */
		        domain_build_info_field = Val_long(0);
		        break;
		    default: failwith_xl(ERROR_FAIL, "cannot convert value from None"); break;
		}
		Store_field(domain_build_info_ocaml, 50, domain_build_info_field);
	
		{
		CAMLlocal1(anon_field);
	
		domain_build_info_field = caml_alloc_tuple(2);
	
		anon_field = Val_gic_version(domain_build_info_c->arch_arm.gic_version);
		Store_field(domain_build_info_field, 0, anon_field);
	
		anon_field = Val_vuart_type(domain_build_info_c->arch_arm.vuart);
		Store_field(domain_build_info_field, 1, anon_field);
	}
		Store_field(domain_build_info_ocaml, 51, domain_build_info_field);
	
		domain_build_info_field = Val_altp2m_mode(domain_build_info_c->altp2m);
		Store_field(domain_build_info_ocaml, 52, domain_build_info_field);
	}
	CAMLreturn(domain_build_info_ocaml);
}

/* Get the defaults for domain_build_info */
value stub_libxl_domain_build_info_init(value ctx, value type, value unit)
{
	CAMLparam3(ctx, type, unit);
	CAMLlocal1(val);
	libxl_domain_build_info c_val;
	libxl_domain_build_info_init(&c_val);
	if (type != Val_none) {
		libxl_domain_type c = 0;
		domain_type_val(CTX, &c, Some_val(type));
		libxl_domain_build_info_init_type(&c_val, c);
	}
	val = Val_domain_build_info(&c_val);
	libxl_domain_build_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_vfb */
static int device_vfb_val (libxl_ctx *ctx, libxl_device_vfb *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	vnc_info_val(ctx, &c_val->vnc, Field(v, 3));
	sdl_info_val(ctx, &c_val->sdl, Field(v, 4));
	c_val->keymap = String_option_val(Field(v, 5));
	
	CAMLreturn(0);
}

/* Convert device_vfb to a caml value */
static value Val_device_vfb (libxl_device_vfb *device_vfb_c)
{
	CAMLparam0();
	CAMLlocal1(device_vfb_ocaml);
	{
		CAMLlocal1(device_vfb_field);
	
		device_vfb_ocaml = caml_alloc_tuple(6);
	
		device_vfb_field = Val_int(device_vfb_c->backend_domid);
		Store_field(device_vfb_ocaml, 0, device_vfb_field);
	
		device_vfb_field = Val_string_option(device_vfb_c->backend_domname);
		Store_field(device_vfb_ocaml, 1, device_vfb_field);
	
		device_vfb_field = Val_int(device_vfb_c->devid);
		Store_field(device_vfb_ocaml, 2, device_vfb_field);
	
		device_vfb_field = Val_vnc_info(&device_vfb_c->vnc);
		Store_field(device_vfb_ocaml, 3, device_vfb_field);
	
		device_vfb_field = Val_sdl_info(&device_vfb_c->sdl);
		Store_field(device_vfb_ocaml, 4, device_vfb_field);
	
		device_vfb_field = Val_string_option(device_vfb_c->keymap);
		Store_field(device_vfb_ocaml, 5, device_vfb_field);
	}
	CAMLreturn(device_vfb_ocaml);
}

/* Stubs for device_vfb */
value stub_xl_device_vfb_add(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_vfb_remove(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_vfb_destroy(value v1, value v2, value v3, value v4, value v5);

/* Get the defaults for device_vfb */
value stub_libxl_device_vfb_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_vfb c_val;
	libxl_device_vfb_init(&c_val);
	val = Val_device_vfb(&c_val);
	libxl_device_vfb_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_vkb */
static int device_vkb_val (libxl_ctx *ctx, libxl_device_vkb *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	vkb_backend_val(ctx, &c_val->backend_type, Field(v, 3));
	c_val->unique_id = String_option_val(Field(v, 4));
	c_val->feature_disable_keyboard = Bool_val(Field(v, 5));
	c_val->feature_disable_pointer = Bool_val(Field(v, 6));
	c_val->feature_abs_pointer = Bool_val(Field(v, 7));
	c_val->feature_raw_pointer = Bool_val(Field(v, 8));
	c_val->feature_multi_touch = Bool_val(Field(v, 9));
	c_val->width = Int32_val(Field(v, 10));
	c_val->height = Int32_val(Field(v, 11));
	c_val->multi_touch_width = Int32_val(Field(v, 12));
	c_val->multi_touch_height = Int32_val(Field(v, 13));
	c_val->multi_touch_num_contacts = Int32_val(Field(v, 14));
	
	CAMLreturn(0);
}

/* Convert device_vkb to a caml value */
static value Val_device_vkb (libxl_device_vkb *device_vkb_c)
{
	CAMLparam0();
	CAMLlocal1(device_vkb_ocaml);
	{
		CAMLlocal1(device_vkb_field);
	
		device_vkb_ocaml = caml_alloc_tuple(15);
	
		device_vkb_field = Val_int(device_vkb_c->backend_domid);
		Store_field(device_vkb_ocaml, 0, device_vkb_field);
	
		device_vkb_field = Val_string_option(device_vkb_c->backend_domname);
		Store_field(device_vkb_ocaml, 1, device_vkb_field);
	
		device_vkb_field = Val_int(device_vkb_c->devid);
		Store_field(device_vkb_ocaml, 2, device_vkb_field);
	
		device_vkb_field = Val_vkb_backend(device_vkb_c->backend_type);
		Store_field(device_vkb_ocaml, 3, device_vkb_field);
	
		device_vkb_field = Val_string_option(device_vkb_c->unique_id);
		Store_field(device_vkb_ocaml, 4, device_vkb_field);
	
		device_vkb_field = Val_bool(device_vkb_c->feature_disable_keyboard);
		Store_field(device_vkb_ocaml, 5, device_vkb_field);
	
		device_vkb_field = Val_bool(device_vkb_c->feature_disable_pointer);
		Store_field(device_vkb_ocaml, 6, device_vkb_field);
	
		device_vkb_field = Val_bool(device_vkb_c->feature_abs_pointer);
		Store_field(device_vkb_ocaml, 7, device_vkb_field);
	
		device_vkb_field = Val_bool(device_vkb_c->feature_raw_pointer);
		Store_field(device_vkb_ocaml, 8, device_vkb_field);
	
		device_vkb_field = Val_bool(device_vkb_c->feature_multi_touch);
		Store_field(device_vkb_ocaml, 9, device_vkb_field);
	
		device_vkb_field = caml_copy_int32(device_vkb_c->width);
		Store_field(device_vkb_ocaml, 10, device_vkb_field);
	
		device_vkb_field = caml_copy_int32(device_vkb_c->height);
		Store_field(device_vkb_ocaml, 11, device_vkb_field);
	
		device_vkb_field = caml_copy_int32(device_vkb_c->multi_touch_width);
		Store_field(device_vkb_ocaml, 12, device_vkb_field);
	
		device_vkb_field = caml_copy_int32(device_vkb_c->multi_touch_height);
		Store_field(device_vkb_ocaml, 13, device_vkb_field);
	
		device_vkb_field = caml_copy_int32(device_vkb_c->multi_touch_num_contacts);
		Store_field(device_vkb_ocaml, 14, device_vkb_field);
	}
	CAMLreturn(device_vkb_ocaml);
}

/* Stubs for device_vkb */
value stub_xl_device_vkb_add(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_vkb_remove(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_vkb_destroy(value v1, value v2, value v3, value v4, value v5);

/* Get the defaults for device_vkb */
value stub_libxl_device_vkb_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_vkb c_val;
	libxl_device_vkb_init(&c_val);
	val = Val_device_vkb(&c_val);
	libxl_device_vkb_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_disk */
static int device_disk_val (libxl_ctx *ctx, libxl_device_disk *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->pdev_path = String_option_val(Field(v, 2));
	c_val->vdev = String_option_val(Field(v, 3));
	disk_backend_val(ctx, &c_val->backend, Field(v, 4));
	disk_format_val(ctx, &c_val->format, Field(v, 5));
	c_val->script = String_option_val(Field(v, 6));
	c_val->removable = Int_val(Field(v, 7));
	c_val->readwrite = Int_val(Field(v, 8));
	c_val->is_cdrom = Int_val(Field(v, 9));
	c_val->direct_io_safe = Bool_val(Field(v, 10));
	c_val->discard_enable = Defbool_val(Field(v, 11));
	c_val->colo_enable = Defbool_val(Field(v, 12));
	c_val->colo_restore_enable = Defbool_val(Field(v, 13));
	c_val->colo_host = String_option_val(Field(v, 14));
	c_val->colo_port = Int_val(Field(v, 15));
	c_val->colo_export = String_option_val(Field(v, 16));
	c_val->active_disk = String_option_val(Field(v, 17));
	c_val->hidden_disk = String_option_val(Field(v, 18));
	
	CAMLreturn(0);
}

/* Convert device_disk to a caml value */
static value Val_device_disk (libxl_device_disk *device_disk_c)
{
	CAMLparam0();
	CAMLlocal1(device_disk_ocaml);
	{
		CAMLlocal1(device_disk_field);
	
		device_disk_ocaml = caml_alloc_tuple(19);
	
		device_disk_field = Val_int(device_disk_c->backend_domid);
		Store_field(device_disk_ocaml, 0, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->backend_domname);
		Store_field(device_disk_ocaml, 1, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->pdev_path);
		Store_field(device_disk_ocaml, 2, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->vdev);
		Store_field(device_disk_ocaml, 3, device_disk_field);
	
		device_disk_field = Val_disk_backend(device_disk_c->backend);
		Store_field(device_disk_ocaml, 4, device_disk_field);
	
		device_disk_field = Val_disk_format(device_disk_c->format);
		Store_field(device_disk_ocaml, 5, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->script);
		Store_field(device_disk_ocaml, 6, device_disk_field);
	
		device_disk_field = Val_int(device_disk_c->removable);
		Store_field(device_disk_ocaml, 7, device_disk_field);
	
		device_disk_field = Val_int(device_disk_c->readwrite);
		Store_field(device_disk_ocaml, 8, device_disk_field);
	
		device_disk_field = Val_int(device_disk_c->is_cdrom);
		Store_field(device_disk_ocaml, 9, device_disk_field);
	
		device_disk_field = Val_bool(device_disk_c->direct_io_safe);
		Store_field(device_disk_ocaml, 10, device_disk_field);
	
		device_disk_field = Val_defbool(device_disk_c->discard_enable);
		Store_field(device_disk_ocaml, 11, device_disk_field);
	
		device_disk_field = Val_defbool(device_disk_c->colo_enable);
		Store_field(device_disk_ocaml, 12, device_disk_field);
	
		device_disk_field = Val_defbool(device_disk_c->colo_restore_enable);
		Store_field(device_disk_ocaml, 13, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->colo_host);
		Store_field(device_disk_ocaml, 14, device_disk_field);
	
		device_disk_field = Val_int(device_disk_c->colo_port);
		Store_field(device_disk_ocaml, 15, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->colo_export);
		Store_field(device_disk_ocaml, 16, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->active_disk);
		Store_field(device_disk_ocaml, 17, device_disk_field);
	
		device_disk_field = Val_string_option(device_disk_c->hidden_disk);
		Store_field(device_disk_ocaml, 18, device_disk_field);
	}
	CAMLreturn(device_disk_ocaml);
}

/* Stubs for device_disk */
value stub_xl_device_disk_add(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_disk_remove(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_disk_destroy(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_disk_list(value v1, value v2);
value stub_xl_device_disk_insert(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_disk_of_vdev(value v1, value v2, value v3);

/* Get the defaults for device_disk */
value stub_libxl_device_disk_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_disk c_val;
	libxl_device_disk_init(&c_val);
	val = Val_device_disk(&c_val);
	libxl_device_disk_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_nic */
static int device_nic_val (libxl_ctx *ctx, libxl_device_nic *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	c_val->mtu = Int_val(Field(v, 3));
	c_val->model = String_option_val(Field(v, 4));
	Mac_val(&c_val->mac, Field(v, 5));
	c_val->ip = String_option_val(Field(v, 6));
	c_val->bridge = String_option_val(Field(v, 7));
	c_val->ifname = String_option_val(Field(v, 8));
	c_val->script = String_option_val(Field(v, 9));
	nic_type_val(ctx, &c_val->nictype, Field(v, 10));
	c_val->rate_bytes_per_interval = Int64_val(Field(v, 11));
	c_val->rate_interval_usecs = Int32_val(Field(v, 12));
	c_val->gatewaydev = String_option_val(Field(v, 13));
	c_val->coloft_forwarddev = String_option_val(Field(v, 14));
	c_val->colo_sock_mirror_id = String_option_val(Field(v, 15));
	c_val->colo_sock_mirror_ip = String_option_val(Field(v, 16));
	c_val->colo_sock_mirror_port = String_option_val(Field(v, 17));
	c_val->colo_sock_compare_pri_in_id = String_option_val(Field(v, 18));
	c_val->colo_sock_compare_pri_in_ip = String_option_val(Field(v, 19));
	c_val->colo_sock_compare_pri_in_port = String_option_val(Field(v, 20));
	c_val->colo_sock_compare_sec_in_id = String_option_val(Field(v, 21));
	c_val->colo_sock_compare_sec_in_ip = String_option_val(Field(v, 22));
	c_val->colo_sock_compare_sec_in_port = String_option_val(Field(v, 23));
	c_val->colo_sock_compare_notify_id = String_option_val(Field(v, 24));
	c_val->colo_sock_compare_notify_ip = String_option_val(Field(v, 25));
	c_val->colo_sock_compare_notify_port = String_option_val(Field(v, 26));
	c_val->colo_sock_redirector0_id = String_option_val(Field(v, 27));
	c_val->colo_sock_redirector0_ip = String_option_val(Field(v, 28));
	c_val->colo_sock_redirector0_port = String_option_val(Field(v, 29));
	c_val->colo_sock_redirector1_id = String_option_val(Field(v, 30));
	c_val->colo_sock_redirector1_ip = String_option_val(Field(v, 31));
	c_val->colo_sock_redirector1_port = String_option_val(Field(v, 32));
	c_val->colo_sock_redirector2_id = String_option_val(Field(v, 33));
	c_val->colo_sock_redirector2_ip = String_option_val(Field(v, 34));
	c_val->colo_sock_redirector2_port = String_option_val(Field(v, 35));
	c_val->colo_filter_mirror_queue = String_option_val(Field(v, 36));
	c_val->colo_filter_mirror_outdev = String_option_val(Field(v, 37));
	c_val->colo_filter_redirector0_queue = String_option_val(Field(v, 38));
	c_val->colo_filter_redirector0_indev = String_option_val(Field(v, 39));
	c_val->colo_filter_redirector0_outdev = String_option_val(Field(v, 40));
	c_val->colo_filter_redirector1_queue = String_option_val(Field(v, 41));
	c_val->colo_filter_redirector1_indev = String_option_val(Field(v, 42));
	c_val->colo_filter_redirector1_outdev = String_option_val(Field(v, 43));
	c_val->colo_compare_pri_in = String_option_val(Field(v, 44));
	c_val->colo_compare_sec_in = String_option_val(Field(v, 45));
	c_val->colo_compare_out = String_option_val(Field(v, 46));
	c_val->colo_compare_notify_dev = String_option_val(Field(v, 47));
	c_val->colo_sock_sec_redirector0_id = String_option_val(Field(v, 48));
	c_val->colo_sock_sec_redirector0_ip = String_option_val(Field(v, 49));
	c_val->colo_sock_sec_redirector0_port = String_option_val(Field(v, 50));
	c_val->colo_sock_sec_redirector1_id = String_option_val(Field(v, 51));
	c_val->colo_sock_sec_redirector1_ip = String_option_val(Field(v, 52));
	c_val->colo_sock_sec_redirector1_port = String_option_val(Field(v, 53));
	c_val->colo_filter_sec_redirector0_queue = String_option_val(Field(v, 54));
	c_val->colo_filter_sec_redirector0_indev = String_option_val(Field(v, 55));
	c_val->colo_filter_sec_redirector0_outdev = String_option_val(Field(v, 56));
	c_val->colo_filter_sec_redirector1_queue = String_option_val(Field(v, 57));
	c_val->colo_filter_sec_redirector1_indev = String_option_val(Field(v, 58));
	c_val->colo_filter_sec_redirector1_outdev = String_option_val(Field(v, 59));
	c_val->colo_filter_sec_rewriter0_queue = String_option_val(Field(v, 60));
	c_val->colo_checkpoint_host = String_option_val(Field(v, 61));
	c_val->colo_checkpoint_port = String_option_val(Field(v, 62));
	
	CAMLreturn(0);
}

/* Convert device_nic to a caml value */
static value Val_device_nic (libxl_device_nic *device_nic_c)
{
	CAMLparam0();
	CAMLlocal1(device_nic_ocaml);
	{
		CAMLlocal1(device_nic_field);
	
		device_nic_ocaml = caml_alloc_tuple(63);
	
		device_nic_field = Val_int(device_nic_c->backend_domid);
		Store_field(device_nic_ocaml, 0, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->backend_domname);
		Store_field(device_nic_ocaml, 1, device_nic_field);
	
		device_nic_field = Val_int(device_nic_c->devid);
		Store_field(device_nic_ocaml, 2, device_nic_field);
	
		device_nic_field = Val_int(device_nic_c->mtu);
		Store_field(device_nic_ocaml, 3, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->model);
		Store_field(device_nic_ocaml, 4, device_nic_field);
	
		device_nic_field = Val_mac(&device_nic_c->mac);
		Store_field(device_nic_ocaml, 5, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->ip);
		Store_field(device_nic_ocaml, 6, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->bridge);
		Store_field(device_nic_ocaml, 7, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->ifname);
		Store_field(device_nic_ocaml, 8, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->script);
		Store_field(device_nic_ocaml, 9, device_nic_field);
	
		device_nic_field = Val_nic_type(device_nic_c->nictype);
		Store_field(device_nic_ocaml, 10, device_nic_field);
	
		device_nic_field = caml_copy_int64(device_nic_c->rate_bytes_per_interval);
		Store_field(device_nic_ocaml, 11, device_nic_field);
	
		device_nic_field = caml_copy_int32(device_nic_c->rate_interval_usecs);
		Store_field(device_nic_ocaml, 12, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->gatewaydev);
		Store_field(device_nic_ocaml, 13, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->coloft_forwarddev);
		Store_field(device_nic_ocaml, 14, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_mirror_id);
		Store_field(device_nic_ocaml, 15, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_mirror_ip);
		Store_field(device_nic_ocaml, 16, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_mirror_port);
		Store_field(device_nic_ocaml, 17, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_pri_in_id);
		Store_field(device_nic_ocaml, 18, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_pri_in_ip);
		Store_field(device_nic_ocaml, 19, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_pri_in_port);
		Store_field(device_nic_ocaml, 20, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_sec_in_id);
		Store_field(device_nic_ocaml, 21, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_sec_in_ip);
		Store_field(device_nic_ocaml, 22, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_sec_in_port);
		Store_field(device_nic_ocaml, 23, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_notify_id);
		Store_field(device_nic_ocaml, 24, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_notify_ip);
		Store_field(device_nic_ocaml, 25, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_compare_notify_port);
		Store_field(device_nic_ocaml, 26, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector0_id);
		Store_field(device_nic_ocaml, 27, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector0_ip);
		Store_field(device_nic_ocaml, 28, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector0_port);
		Store_field(device_nic_ocaml, 29, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector1_id);
		Store_field(device_nic_ocaml, 30, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector1_ip);
		Store_field(device_nic_ocaml, 31, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector1_port);
		Store_field(device_nic_ocaml, 32, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector2_id);
		Store_field(device_nic_ocaml, 33, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector2_ip);
		Store_field(device_nic_ocaml, 34, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_redirector2_port);
		Store_field(device_nic_ocaml, 35, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_mirror_queue);
		Store_field(device_nic_ocaml, 36, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_mirror_outdev);
		Store_field(device_nic_ocaml, 37, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_redirector0_queue);
		Store_field(device_nic_ocaml, 38, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_redirector0_indev);
		Store_field(device_nic_ocaml, 39, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_redirector0_outdev);
		Store_field(device_nic_ocaml, 40, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_redirector1_queue);
		Store_field(device_nic_ocaml, 41, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_redirector1_indev);
		Store_field(device_nic_ocaml, 42, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_redirector1_outdev);
		Store_field(device_nic_ocaml, 43, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_compare_pri_in);
		Store_field(device_nic_ocaml, 44, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_compare_sec_in);
		Store_field(device_nic_ocaml, 45, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_compare_out);
		Store_field(device_nic_ocaml, 46, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_compare_notify_dev);
		Store_field(device_nic_ocaml, 47, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_sec_redirector0_id);
		Store_field(device_nic_ocaml, 48, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_sec_redirector0_ip);
		Store_field(device_nic_ocaml, 49, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_sec_redirector0_port);
		Store_field(device_nic_ocaml, 50, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_sec_redirector1_id);
		Store_field(device_nic_ocaml, 51, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_sec_redirector1_ip);
		Store_field(device_nic_ocaml, 52, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_sock_sec_redirector1_port);
		Store_field(device_nic_ocaml, 53, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_sec_redirector0_queue);
		Store_field(device_nic_ocaml, 54, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_sec_redirector0_indev);
		Store_field(device_nic_ocaml, 55, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_sec_redirector0_outdev);
		Store_field(device_nic_ocaml, 56, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_sec_redirector1_queue);
		Store_field(device_nic_ocaml, 57, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_sec_redirector1_indev);
		Store_field(device_nic_ocaml, 58, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_sec_redirector1_outdev);
		Store_field(device_nic_ocaml, 59, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_filter_sec_rewriter0_queue);
		Store_field(device_nic_ocaml, 60, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_checkpoint_host);
		Store_field(device_nic_ocaml, 61, device_nic_field);
	
		device_nic_field = Val_string_option(device_nic_c->colo_checkpoint_port);
		Store_field(device_nic_ocaml, 62, device_nic_field);
	}
	CAMLreturn(device_nic_ocaml);
}

/* Stubs for device_nic */
value stub_xl_device_nic_add(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_nic_remove(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_nic_destroy(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_nic_list(value v1, value v2);
value stub_xl_device_nic_of_devid(value v1, value v2, value v3);

/* Get the defaults for device_nic */
value stub_libxl_device_nic_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_nic c_val;
	libxl_device_nic_init(&c_val);
	val = Val_device_nic(&c_val);
	libxl_device_nic_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_pci */
static int device_pci_val (libxl_ctx *ctx, libxl_device_pci *c_val, value v)
{
	CAMLparam1(v);

	c_val->func = Int_val(Field(v, 0));
	c_val->dev = Int_val(Field(v, 1));
	c_val->bus = Int_val(Field(v, 2));
	c_val->domain = Int_val(Field(v, 3));
	c_val->vdevfn = Int32_val(Field(v, 4));
	c_val->vfunc_mask = Int32_val(Field(v, 5));
	c_val->msitranslate = Bool_val(Field(v, 6));
	c_val->power_mgmt = Bool_val(Field(v, 7));
	c_val->permissive = Bool_val(Field(v, 8));
	c_val->seize = Bool_val(Field(v, 9));
	rdm_reserve_policy_val(ctx, &c_val->rdm_policy, Field(v, 10));
	
	CAMLreturn(0);
}

/* Convert device_pci to a caml value */
static value Val_device_pci (libxl_device_pci *device_pci_c)
{
	CAMLparam0();
	CAMLlocal1(device_pci_ocaml);
	{
		CAMLlocal1(device_pci_field);
	
		device_pci_ocaml = caml_alloc_tuple(11);
	
		device_pci_field = Val_int(device_pci_c->func);
		Store_field(device_pci_ocaml, 0, device_pci_field);
	
		device_pci_field = Val_int(device_pci_c->dev);
		Store_field(device_pci_ocaml, 1, device_pci_field);
	
		device_pci_field = Val_int(device_pci_c->bus);
		Store_field(device_pci_ocaml, 2, device_pci_field);
	
		device_pci_field = Val_int(device_pci_c->domain);
		Store_field(device_pci_ocaml, 3, device_pci_field);
	
		device_pci_field = caml_copy_int32(device_pci_c->vdevfn);
		Store_field(device_pci_ocaml, 4, device_pci_field);
	
		device_pci_field = caml_copy_int32(device_pci_c->vfunc_mask);
		Store_field(device_pci_ocaml, 5, device_pci_field);
	
		device_pci_field = Val_bool(device_pci_c->msitranslate);
		Store_field(device_pci_ocaml, 6, device_pci_field);
	
		device_pci_field = Val_bool(device_pci_c->power_mgmt);
		Store_field(device_pci_ocaml, 7, device_pci_field);
	
		device_pci_field = Val_bool(device_pci_c->permissive);
		Store_field(device_pci_ocaml, 8, device_pci_field);
	
		device_pci_field = Val_bool(device_pci_c->seize);
		Store_field(device_pci_ocaml, 9, device_pci_field);
	
		device_pci_field = Val_rdm_reserve_policy(device_pci_c->rdm_policy);
		Store_field(device_pci_ocaml, 10, device_pci_field);
	}
	CAMLreturn(device_pci_ocaml);
}

/* Stubs for device_pci */
value stub_xl_device_pci_add(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_pci_remove(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_pci_destroy(value v1, value v2, value v3, value v4, value v5);
value stub_xl_device_pci_list(value v1, value v2);
value stub_xl_device_pci_assignable_add(value v1, value v2, value v3);
value stub_xl_device_pci_assignable_remove(value v1, value v2, value v3);
value stub_xl_device_pci_assignable_list(value v1);

/* Get the defaults for device_pci */
value stub_libxl_device_pci_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_pci c_val;
	libxl_device_pci_init(&c_val);
	val = Val_device_pci(&c_val);
	libxl_device_pci_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_rdm */
static int device_rdm_val (libxl_ctx *ctx, libxl_device_rdm *c_val, value v)
{
	CAMLparam1(v);

	c_val->start = Int64_val(Field(v, 0));
	c_val->size = Int64_val(Field(v, 1));
	rdm_reserve_policy_val(ctx, &c_val->policy, Field(v, 2));
	
	CAMLreturn(0);
}

/* Convert device_rdm to a caml value */
static value Val_device_rdm (libxl_device_rdm *device_rdm_c)
{
	CAMLparam0();
	CAMLlocal1(device_rdm_ocaml);
	{
		CAMLlocal1(device_rdm_field);
	
		device_rdm_ocaml = caml_alloc_tuple(3);
	
		device_rdm_field = caml_copy_int64(device_rdm_c->start);
		Store_field(device_rdm_ocaml, 0, device_rdm_field);
	
		device_rdm_field = caml_copy_int64(device_rdm_c->size);
		Store_field(device_rdm_ocaml, 1, device_rdm_field);
	
		device_rdm_field = Val_rdm_reserve_policy(device_rdm_c->policy);
		Store_field(device_rdm_ocaml, 2, device_rdm_field);
	}
	CAMLreturn(device_rdm_ocaml);
}

/* Get the defaults for device_rdm */
value stub_libxl_device_rdm_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_rdm c_val;
	libxl_device_rdm_init(&c_val);
	val = Val_device_rdm(&c_val);
	libxl_device_rdm_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to usbctrl_type */
static int usbctrl_type_val (libxl_ctx *ctx, libxl_usbctrl_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_USBCTRL_TYPE_AUTO; break;
	    case 1: *c_val = LIBXL_USBCTRL_TYPE_PV; break;
	    case 2: *c_val = LIBXL_USBCTRL_TYPE_DEVICEMODEL; break;
	    case 3: *c_val = LIBXL_USBCTRL_TYPE_QUSB; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_usbctrl_type"); break;
	}
	CAMLreturn(0);
}

/* Convert usbctrl_type to a caml value */
static value Val_usbctrl_type (libxl_usbctrl_type usbctrl_type_c)
{
	CAMLparam0();
	CAMLlocal1(usbctrl_type_ocaml);
	switch(usbctrl_type_c) {
	    case LIBXL_USBCTRL_TYPE_AUTO: usbctrl_type_ocaml = Val_int(0); break;
	    case LIBXL_USBCTRL_TYPE_PV: usbctrl_type_ocaml = Val_int(1); break;
	    case LIBXL_USBCTRL_TYPE_DEVICEMODEL: usbctrl_type_ocaml = Val_int(2); break;
	    case LIBXL_USBCTRL_TYPE_QUSB: usbctrl_type_ocaml = Val_int(3); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_usbctrl_type"); break;
	}
	CAMLreturn(usbctrl_type_ocaml);
}

/* Convert caml value to usbdev_type */
static int usbdev_type_val (libxl_ctx *ctx, libxl_usbdev_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_USBDEV_TYPE_HOSTDEV; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_usbdev_type"); break;
	}
	CAMLreturn(0);
}

/* Convert usbdev_type to a caml value */
static value Val_usbdev_type (libxl_usbdev_type usbdev_type_c)
{
	CAMLparam0();
	CAMLlocal1(usbdev_type_ocaml);
	switch(usbdev_type_c) {
	    case LIBXL_USBDEV_TYPE_HOSTDEV: usbdev_type_ocaml = Val_int(0); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_usbdev_type"); break;
	}
	CAMLreturn(usbdev_type_ocaml);
}

/* Convert caml value to device_usbctrl */
static int device_usbctrl_val (libxl_ctx *ctx, libxl_device_usbctrl *c_val, value v)
{
	CAMLparam1(v);

	usbctrl_type_val(ctx, &c_val->type, Field(v, 0));
	c_val->devid = Int_val(Field(v, 1));
	c_val->version = Int_val(Field(v, 2));
	c_val->ports = Int_val(Field(v, 3));
	c_val->backend_domid = Int_val(Field(v, 4));
	c_val->backend_domname = String_option_val(Field(v, 5));
	
	CAMLreturn(0);
}

/* Convert device_usbctrl to a caml value */
static value Val_device_usbctrl (libxl_device_usbctrl *device_usbctrl_c)
{
	CAMLparam0();
	CAMLlocal1(device_usbctrl_ocaml);
	{
		CAMLlocal1(device_usbctrl_field);
	
		device_usbctrl_ocaml = caml_alloc_tuple(6);
	
		device_usbctrl_field = Val_usbctrl_type(device_usbctrl_c->type);
		Store_field(device_usbctrl_ocaml, 0, device_usbctrl_field);
	
		device_usbctrl_field = Val_int(device_usbctrl_c->devid);
		Store_field(device_usbctrl_ocaml, 1, device_usbctrl_field);
	
		device_usbctrl_field = Val_int(device_usbctrl_c->version);
		Store_field(device_usbctrl_ocaml, 2, device_usbctrl_field);
	
		device_usbctrl_field = Val_int(device_usbctrl_c->ports);
		Store_field(device_usbctrl_ocaml, 3, device_usbctrl_field);
	
		device_usbctrl_field = Val_int(device_usbctrl_c->backend_domid);
		Store_field(device_usbctrl_ocaml, 4, device_usbctrl_field);
	
		device_usbctrl_field = Val_string_option(device_usbctrl_c->backend_domname);
		Store_field(device_usbctrl_ocaml, 5, device_usbctrl_field);
	}
	CAMLreturn(device_usbctrl_ocaml);
}

/* Get the defaults for device_usbctrl */
value stub_libxl_device_usbctrl_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_usbctrl c_val;
	libxl_device_usbctrl_init(&c_val);
	val = Val_device_usbctrl(&c_val);
	libxl_device_usbctrl_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_usbdev */
static int device_usbdev_val (libxl_ctx *ctx, libxl_device_usbdev *c_val, value v)
{
	CAMLparam1(v);

	c_val->ctrl = Int_val(Field(v, 0));
	c_val->port = Int_val(Field(v, 1));
	{
		if(Is_long(Field(v, 2))) {
			switch(Int_val(Field(v, 2))) {
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->type (long)"); break;
			}
		} else {
			/* Is block... */
			switch(Tag_val(Field(v, 2))) {
			    case 0:
			        c_val->type = LIBXL_USBDEV_TYPE_HOSTDEV;
			        c_val->u.hostdev.hostbus = Int_val(Field(Field(Field(v, 2), 0), 0));
			        c_val->u.hostdev.hostaddr = Int_val(Field(Field(Field(v, 2), 0), 1));
			        break;
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->type (block)"); break;
			}
		}
	}
	
	CAMLreturn(0);
}

/* Convert device_usbdev to a caml value */
static value Val_device_usbdev (libxl_device_usbdev *device_usbdev_c)
{
	CAMLparam0();
	CAMLlocal1(device_usbdev_ocaml);
	{
		CAMLlocal1(device_usbdev_field);
	
		device_usbdev_ocaml = caml_alloc_tuple(3);
	
		device_usbdev_field = Val_int(device_usbdev_c->ctrl);
		Store_field(device_usbdev_ocaml, 0, device_usbdev_field);
	
		device_usbdev_field = Val_int(device_usbdev_c->port);
		Store_field(device_usbdev_ocaml, 1, device_usbdev_field);
	
		switch(device_usbdev_c->type) {
		    case LIBXL_USBDEV_TYPE_HOSTDEV:
		        /* 0: Block */
		        {
			        CAMLlocal1(tmp);
			        device_usbdev_field = caml_alloc(1,0);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(2);
			        
			        	anon_field = Val_int(device_usbdev_c->u.hostdev.hostbus);
			        	Store_field(tmp, 0, anon_field);
			        
			        	anon_field = Val_int(device_usbdev_c->u.hostdev.hostaddr);
			        	Store_field(tmp, 1, anon_field);
			        }
			        Store_field(device_usbdev_field, 0, tmp);
		        }
		        break;
		    default: failwith_xl(ERROR_FAIL, "cannot convert value from None"); break;
		}
		Store_field(device_usbdev_ocaml, 2, device_usbdev_field);
	}
	CAMLreturn(device_usbdev_ocaml);
}

/* Get the defaults for device_usbdev */
value stub_libxl_device_usbdev_init(value ctx, value type, value unit)
{
	CAMLparam3(ctx, type, unit);
	CAMLlocal1(val);
	libxl_device_usbdev c_val;
	libxl_device_usbdev_init(&c_val);
	if (type != Val_none) {
		libxl_usbdev_type c = 0;
		usbdev_type_val(CTX, &c, Some_val(type));
		libxl_device_usbdev_init_type(&c_val, c);
	}
	val = Val_device_usbdev(&c_val);
	libxl_device_usbdev_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_dtdev */
static int device_dtdev_val (libxl_ctx *ctx, libxl_device_dtdev *c_val, value v)
{
	CAMLparam1(v);

	c_val->path = String_option_val(Field(v, 0));
	
	CAMLreturn(0);
}

/* Convert device_dtdev to a caml value */
static value Val_device_dtdev (libxl_device_dtdev *device_dtdev_c)
{
	CAMLparam0();
	CAMLlocal1(device_dtdev_ocaml);
	{
		CAMLlocal1(device_dtdev_field);
	
		device_dtdev_ocaml = caml_alloc_tuple(1);
	
		device_dtdev_field = Val_string_option(device_dtdev_c->path);
		Store_field(device_dtdev_ocaml, 0, device_dtdev_field);
	}
	CAMLreturn(device_dtdev_ocaml);
}

/* Get the defaults for device_dtdev */
value stub_libxl_device_dtdev_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_dtdev c_val;
	libxl_device_dtdev_init(&c_val);
	val = Val_device_dtdev(&c_val);
	libxl_device_dtdev_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_vtpm */
static int device_vtpm_val (libxl_ctx *ctx, libxl_device_vtpm *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	Uuid_val(&c_val->uuid, Field(v, 3));
	
	CAMLreturn(0);
}

/* Convert device_vtpm to a caml value */
static value Val_device_vtpm (libxl_device_vtpm *device_vtpm_c)
{
	CAMLparam0();
	CAMLlocal1(device_vtpm_ocaml);
	{
		CAMLlocal1(device_vtpm_field);
	
		device_vtpm_ocaml = caml_alloc_tuple(4);
	
		device_vtpm_field = Val_int(device_vtpm_c->backend_domid);
		Store_field(device_vtpm_ocaml, 0, device_vtpm_field);
	
		device_vtpm_field = Val_string_option(device_vtpm_c->backend_domname);
		Store_field(device_vtpm_ocaml, 1, device_vtpm_field);
	
		device_vtpm_field = Val_int(device_vtpm_c->devid);
		Store_field(device_vtpm_ocaml, 2, device_vtpm_field);
	
		device_vtpm_field = Val_uuid(&device_vtpm_c->uuid);
		Store_field(device_vtpm_ocaml, 3, device_vtpm_field);
	}
	CAMLreturn(device_vtpm_ocaml);
}

/* Get the defaults for device_vtpm */
value stub_libxl_device_vtpm_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_vtpm c_val;
	libxl_device_vtpm_init(&c_val);
	val = Val_device_vtpm(&c_val);
	libxl_device_vtpm_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_p9 */
static int device_p9_val (libxl_ctx *ctx, libxl_device_p9 *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->tag = String_option_val(Field(v, 2));
	c_val->path = String_option_val(Field(v, 3));
	c_val->security_model = String_option_val(Field(v, 4));
	c_val->devid = Int_val(Field(v, 5));
	
	CAMLreturn(0);
}

/* Convert device_p9 to a caml value */
static value Val_device_p9 (libxl_device_p9 *device_p9_c)
{
	CAMLparam0();
	CAMLlocal1(device_p9_ocaml);
	{
		CAMLlocal1(device_p9_field);
	
		device_p9_ocaml = caml_alloc_tuple(6);
	
		device_p9_field = Val_int(device_p9_c->backend_domid);
		Store_field(device_p9_ocaml, 0, device_p9_field);
	
		device_p9_field = Val_string_option(device_p9_c->backend_domname);
		Store_field(device_p9_ocaml, 1, device_p9_field);
	
		device_p9_field = Val_string_option(device_p9_c->tag);
		Store_field(device_p9_ocaml, 2, device_p9_field);
	
		device_p9_field = Val_string_option(device_p9_c->path);
		Store_field(device_p9_ocaml, 3, device_p9_field);
	
		device_p9_field = Val_string_option(device_p9_c->security_model);
		Store_field(device_p9_ocaml, 4, device_p9_field);
	
		device_p9_field = Val_int(device_p9_c->devid);
		Store_field(device_p9_ocaml, 5, device_p9_field);
	}
	CAMLreturn(device_p9_ocaml);
}

/* Get the defaults for device_p9 */
value stub_libxl_device_p9_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_p9 c_val;
	libxl_device_p9_init(&c_val);
	val = Val_device_p9(&c_val);
	libxl_device_p9_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_pvcallsif */
static int device_pvcallsif_val (libxl_ctx *ctx, libxl_device_pvcallsif *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	
	CAMLreturn(0);
}

/* Convert device_pvcallsif to a caml value */
static value Val_device_pvcallsif (libxl_device_pvcallsif *device_pvcallsif_c)
{
	CAMLparam0();
	CAMLlocal1(device_pvcallsif_ocaml);
	{
		CAMLlocal1(device_pvcallsif_field);
	
		device_pvcallsif_ocaml = caml_alloc_tuple(3);
	
		device_pvcallsif_field = Val_int(device_pvcallsif_c->backend_domid);
		Store_field(device_pvcallsif_ocaml, 0, device_pvcallsif_field);
	
		device_pvcallsif_field = Val_string_option(device_pvcallsif_c->backend_domname);
		Store_field(device_pvcallsif_ocaml, 1, device_pvcallsif_field);
	
		device_pvcallsif_field = Val_int(device_pvcallsif_c->devid);
		Store_field(device_pvcallsif_ocaml, 2, device_pvcallsif_field);
	}
	CAMLreturn(device_pvcallsif_ocaml);
}

/* Get the defaults for device_pvcallsif */
value stub_libxl_device_pvcallsif_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_pvcallsif c_val;
	libxl_device_pvcallsif_init(&c_val);
	val = Val_device_pvcallsif(&c_val);
	libxl_device_pvcallsif_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_channel */
static int device_channel_val (libxl_ctx *ctx, libxl_device_channel *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	c_val->name = String_option_val(Field(v, 3));
	{
		if(Is_long(Field(v, 4))) {
			switch(Int_val(Field(v, 4))) {
			    case 0: c_val->connection = LIBXL_CHANNEL_CONNECTION_UNKNOWN; break;
			    case 1: c_val->connection = LIBXL_CHANNEL_CONNECTION_PTY; break;
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->connection (long)"); break;
			}
		} else {
			/* Is block... */
			switch(Tag_val(Field(v, 4))) {
			    case 0:
			        c_val->connection = LIBXL_CHANNEL_CONNECTION_SOCKET;
			        c_val->u.socket.path = String_option_val(Field(Field(Field(v, 4), 0), 0));
			        break;
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->connection (block)"); break;
			}
		}
	}
	
	CAMLreturn(0);
}

/* Convert device_channel to a caml value */
static value Val_device_channel (libxl_device_channel *device_channel_c)
{
	CAMLparam0();
	CAMLlocal1(device_channel_ocaml);
	{
		CAMLlocal1(device_channel_field);
	
		device_channel_ocaml = caml_alloc_tuple(5);
	
		device_channel_field = Val_int(device_channel_c->backend_domid);
		Store_field(device_channel_ocaml, 0, device_channel_field);
	
		device_channel_field = Val_string_option(device_channel_c->backend_domname);
		Store_field(device_channel_ocaml, 1, device_channel_field);
	
		device_channel_field = Val_int(device_channel_c->devid);
		Store_field(device_channel_ocaml, 2, device_channel_field);
	
		device_channel_field = Val_string_option(device_channel_c->name);
		Store_field(device_channel_ocaml, 3, device_channel_field);
	
		switch(device_channel_c->connection) {
		    case LIBXL_CHANNEL_CONNECTION_UNKNOWN:
		        /* 0: None */
		        device_channel_field = Val_long(0);
		        break;
		    case LIBXL_CHANNEL_CONNECTION_PTY:
		        /* 1: None */
		        device_channel_field = Val_long(1);
		        break;
		    case LIBXL_CHANNEL_CONNECTION_SOCKET:
		        /* 0: Block */
		        {
			        CAMLlocal1(tmp);
			        device_channel_field = caml_alloc(1,0);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(1);
			        
			        	anon_field = Val_string_option(device_channel_c->u.socket.path);
			        	Store_field(tmp, 0, anon_field);
			        }
			        Store_field(device_channel_field, 0, tmp);
		        }
		        break;
		    default: failwith_xl(ERROR_FAIL, "cannot convert value from None"); break;
		}
		Store_field(device_channel_ocaml, 4, device_channel_field);
	}
	CAMLreturn(device_channel_ocaml);
}

/* Get the defaults for device_channel */
value stub_libxl_device_channel_init(value ctx, value connection, value unit)
{
	CAMLparam3(ctx, connection, unit);
	CAMLlocal1(val);
	libxl_device_channel c_val;
	libxl_device_channel_init(&c_val);
	if (connection != Val_none) {
		libxl_channel_connection c = 0;
		channel_connection_val(CTX, &c, Some_val(connection));
		libxl_device_channel_init_connection(&c_val, c);
	}
	val = Val_device_channel(&c_val);
	libxl_device_channel_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to connector_param */
static int connector_param_val (libxl_ctx *ctx, libxl_connector_param *c_val, value v)
{
	CAMLparam1(v);

	c_val->unique_id = String_option_val(Field(v, 0));
	c_val->width = Int32_val(Field(v, 1));
	c_val->height = Int32_val(Field(v, 2));
	
	CAMLreturn(0);
}

/* Convert connector_param to a caml value */
static value Val_connector_param (libxl_connector_param *connector_param_c)
{
	CAMLparam0();
	CAMLlocal1(connector_param_ocaml);
	{
		CAMLlocal1(connector_param_field);
	
		connector_param_ocaml = caml_alloc_tuple(3);
	
		connector_param_field = Val_string_option(connector_param_c->unique_id);
		Store_field(connector_param_ocaml, 0, connector_param_field);
	
		connector_param_field = caml_copy_int32(connector_param_c->width);
		Store_field(connector_param_ocaml, 1, connector_param_field);
	
		connector_param_field = caml_copy_int32(connector_param_c->height);
		Store_field(connector_param_ocaml, 2, connector_param_field);
	}
	CAMLreturn(connector_param_ocaml);
}

/* Get the defaults for connector_param */
value stub_libxl_connector_param_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_connector_param c_val;
	libxl_connector_param_init(&c_val);
	val = Val_connector_param(&c_val);
	libxl_connector_param_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_vdispl */
static int device_vdispl_val (libxl_ctx *ctx, libxl_device_vdispl *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	c_val->be_alloc = Bool_val(Field(v, 3));
	{
		int i;
		c_val->num_connectors = Wosize_val(Field(v, 4));
		c_val->connectors = (libxl_connector_param *) calloc(c_val->num_connectors, sizeof(*c_val->connectors));
		for(i=0; i<c_val->num_connectors; i++) {
			connector_param_val(ctx, &c_val->connectors[i], Field(Field(v, 4), i));
		}
	}
	
	
	CAMLreturn(0);
}

/* Convert device_vdispl to a caml value */
static value Val_device_vdispl (libxl_device_vdispl *device_vdispl_c)
{
	CAMLparam0();
	CAMLlocal1(device_vdispl_ocaml);
	{
		CAMLlocal1(device_vdispl_field);
	
		device_vdispl_ocaml = caml_alloc_tuple(5);
	
		device_vdispl_field = Val_int(device_vdispl_c->backend_domid);
		Store_field(device_vdispl_ocaml, 0, device_vdispl_field);
	
		device_vdispl_field = Val_string_option(device_vdispl_c->backend_domname);
		Store_field(device_vdispl_ocaml, 1, device_vdispl_field);
	
		device_vdispl_field = Val_int(device_vdispl_c->devid);
		Store_field(device_vdispl_ocaml, 2, device_vdispl_field);
	
		device_vdispl_field = Val_bool(device_vdispl_c->be_alloc);
		Store_field(device_vdispl_ocaml, 3, device_vdispl_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    device_vdispl_field = caml_alloc(device_vdispl_c->num_connectors,0);
		    for(i=0; i<device_vdispl_c->num_connectors; i++) {
		        array_elem = Val_connector_param(&device_vdispl_c->connectors[i]);
		        Store_field(device_vdispl_field, i, array_elem);
		    }
		}
		Store_field(device_vdispl_ocaml, 4, device_vdispl_field);
	}
	CAMLreturn(device_vdispl_ocaml);
}

/* Get the defaults for device_vdispl */
value stub_libxl_device_vdispl_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_vdispl c_val;
	libxl_device_vdispl_init(&c_val);
	val = Val_device_vdispl(&c_val);
	libxl_device_vdispl_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vsnd_pcm_format */
static int vsnd_pcm_format_val (libxl_ctx *ctx, libxl_vsnd_pcm_format *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_VSND_PCM_FORMAT_S8; break;
	    case 1: *c_val = LIBXL_VSND_PCM_FORMAT_U8; break;
	    case 2: *c_val = LIBXL_VSND_PCM_FORMAT_S16_LE; break;
	    case 3: *c_val = LIBXL_VSND_PCM_FORMAT_S16_BE; break;
	    case 4: *c_val = LIBXL_VSND_PCM_FORMAT_U16_LE; break;
	    case 5: *c_val = LIBXL_VSND_PCM_FORMAT_U16_BE; break;
	    case 6: *c_val = LIBXL_VSND_PCM_FORMAT_S24_LE; break;
	    case 7: *c_val = LIBXL_VSND_PCM_FORMAT_S24_BE; break;
	    case 8: *c_val = LIBXL_VSND_PCM_FORMAT_U24_LE; break;
	    case 9: *c_val = LIBXL_VSND_PCM_FORMAT_U24_BE; break;
	    case 10: *c_val = LIBXL_VSND_PCM_FORMAT_S32_LE; break;
	    case 11: *c_val = LIBXL_VSND_PCM_FORMAT_S32_BE; break;
	    case 12: *c_val = LIBXL_VSND_PCM_FORMAT_U32_LE; break;
	    case 13: *c_val = LIBXL_VSND_PCM_FORMAT_U32_BE; break;
	    case 14: *c_val = LIBXL_VSND_PCM_FORMAT_F32_LE; break;
	    case 15: *c_val = LIBXL_VSND_PCM_FORMAT_F32_BE; break;
	    case 16: *c_val = LIBXL_VSND_PCM_FORMAT_F64_LE; break;
	    case 17: *c_val = LIBXL_VSND_PCM_FORMAT_F64_BE; break;
	    case 18: *c_val = LIBXL_VSND_PCM_FORMAT_IEC958_SUBFRAME_LE; break;
	    case 19: *c_val = LIBXL_VSND_PCM_FORMAT_IEC958_SUBFRAME_BE; break;
	    case 20: *c_val = LIBXL_VSND_PCM_FORMAT_MU_LAW; break;
	    case 21: *c_val = LIBXL_VSND_PCM_FORMAT_A_LAW; break;
	    case 22: *c_val = LIBXL_VSND_PCM_FORMAT_IMA_ADPCM; break;
	    case 23: *c_val = LIBXL_VSND_PCM_FORMAT_MPEG; break;
	    case 24: *c_val = LIBXL_VSND_PCM_FORMAT_GSM; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_vsnd_pcm_format"); break;
	}
	CAMLreturn(0);
}

/* Convert vsnd_pcm_format to a caml value */
static value Val_vsnd_pcm_format (libxl_vsnd_pcm_format vsnd_pcm_format_c)
{
	CAMLparam0();
	CAMLlocal1(vsnd_pcm_format_ocaml);
	switch(vsnd_pcm_format_c) {
	    case LIBXL_VSND_PCM_FORMAT_S8: vsnd_pcm_format_ocaml = Val_int(0); break;
	    case LIBXL_VSND_PCM_FORMAT_U8: vsnd_pcm_format_ocaml = Val_int(1); break;
	    case LIBXL_VSND_PCM_FORMAT_S16_LE: vsnd_pcm_format_ocaml = Val_int(2); break;
	    case LIBXL_VSND_PCM_FORMAT_S16_BE: vsnd_pcm_format_ocaml = Val_int(3); break;
	    case LIBXL_VSND_PCM_FORMAT_U16_LE: vsnd_pcm_format_ocaml = Val_int(4); break;
	    case LIBXL_VSND_PCM_FORMAT_U16_BE: vsnd_pcm_format_ocaml = Val_int(5); break;
	    case LIBXL_VSND_PCM_FORMAT_S24_LE: vsnd_pcm_format_ocaml = Val_int(6); break;
	    case LIBXL_VSND_PCM_FORMAT_S24_BE: vsnd_pcm_format_ocaml = Val_int(7); break;
	    case LIBXL_VSND_PCM_FORMAT_U24_LE: vsnd_pcm_format_ocaml = Val_int(8); break;
	    case LIBXL_VSND_PCM_FORMAT_U24_BE: vsnd_pcm_format_ocaml = Val_int(9); break;
	    case LIBXL_VSND_PCM_FORMAT_S32_LE: vsnd_pcm_format_ocaml = Val_int(10); break;
	    case LIBXL_VSND_PCM_FORMAT_S32_BE: vsnd_pcm_format_ocaml = Val_int(11); break;
	    case LIBXL_VSND_PCM_FORMAT_U32_LE: vsnd_pcm_format_ocaml = Val_int(12); break;
	    case LIBXL_VSND_PCM_FORMAT_U32_BE: vsnd_pcm_format_ocaml = Val_int(13); break;
	    case LIBXL_VSND_PCM_FORMAT_F32_LE: vsnd_pcm_format_ocaml = Val_int(14); break;
	    case LIBXL_VSND_PCM_FORMAT_F32_BE: vsnd_pcm_format_ocaml = Val_int(15); break;
	    case LIBXL_VSND_PCM_FORMAT_F64_LE: vsnd_pcm_format_ocaml = Val_int(16); break;
	    case LIBXL_VSND_PCM_FORMAT_F64_BE: vsnd_pcm_format_ocaml = Val_int(17); break;
	    case LIBXL_VSND_PCM_FORMAT_IEC958_SUBFRAME_LE: vsnd_pcm_format_ocaml = Val_int(18); break;
	    case LIBXL_VSND_PCM_FORMAT_IEC958_SUBFRAME_BE: vsnd_pcm_format_ocaml = Val_int(19); break;
	    case LIBXL_VSND_PCM_FORMAT_MU_LAW: vsnd_pcm_format_ocaml = Val_int(20); break;
	    case LIBXL_VSND_PCM_FORMAT_A_LAW: vsnd_pcm_format_ocaml = Val_int(21); break;
	    case LIBXL_VSND_PCM_FORMAT_IMA_ADPCM: vsnd_pcm_format_ocaml = Val_int(22); break;
	    case LIBXL_VSND_PCM_FORMAT_MPEG: vsnd_pcm_format_ocaml = Val_int(23); break;
	    case LIBXL_VSND_PCM_FORMAT_GSM: vsnd_pcm_format_ocaml = Val_int(24); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_vsnd_pcm_format"); break;
	}
	CAMLreturn(vsnd_pcm_format_ocaml);
}

/* Convert caml value to vsnd_params */
static int vsnd_params_val (libxl_ctx *ctx, libxl_vsnd_params *c_val, value v)
{
	CAMLparam1(v);

	{
		int i;
		c_val->num_sample_rates = Wosize_val(Field(v, 0));
		c_val->sample_rates = (uint32_t *) calloc(c_val->num_sample_rates, sizeof(*c_val->sample_rates));
		for(i=0; i<c_val->num_sample_rates; i++) {
			c_val->sample_rates[i] = Int32_val(Field(Field(v, 0), i));
		}
	}
	
	{
		int i;
		c_val->num_sample_formats = Wosize_val(Field(v, 1));
		c_val->sample_formats = (libxl_vsnd_pcm_format *) calloc(c_val->num_sample_formats, sizeof(*c_val->sample_formats));
		for(i=0; i<c_val->num_sample_formats; i++) {
			vsnd_pcm_format_val(ctx, &c_val->sample_formats[i], Field(Field(v, 1), i));
		}
	}
	
	c_val->channels_min = Int32_val(Field(v, 2));
	c_val->channels_max = Int32_val(Field(v, 3));
	c_val->buffer_size = Int32_val(Field(v, 4));
	
	CAMLreturn(0);
}

/* Convert vsnd_params to a caml value */
static value Val_vsnd_params (libxl_vsnd_params *vsnd_params_c)
{
	CAMLparam0();
	CAMLlocal1(vsnd_params_ocaml);
	{
		CAMLlocal1(vsnd_params_field);
	
		vsnd_params_ocaml = caml_alloc_tuple(5);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    vsnd_params_field = caml_alloc(vsnd_params_c->num_sample_rates,0);
		    for(i=0; i<vsnd_params_c->num_sample_rates; i++) {
		        array_elem = caml_copy_int32(vsnd_params_c->sample_rates[i]);
		        Store_field(vsnd_params_field, i, array_elem);
		    }
		}
		Store_field(vsnd_params_ocaml, 0, vsnd_params_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    vsnd_params_field = caml_alloc(vsnd_params_c->num_sample_formats,0);
		    for(i=0; i<vsnd_params_c->num_sample_formats; i++) {
		        array_elem = Val_vsnd_pcm_format(vsnd_params_c->sample_formats[i]);
		        Store_field(vsnd_params_field, i, array_elem);
		    }
		}
		Store_field(vsnd_params_ocaml, 1, vsnd_params_field);
	
		vsnd_params_field = caml_copy_int32(vsnd_params_c->channels_min);
		Store_field(vsnd_params_ocaml, 2, vsnd_params_field);
	
		vsnd_params_field = caml_copy_int32(vsnd_params_c->channels_max);
		Store_field(vsnd_params_ocaml, 3, vsnd_params_field);
	
		vsnd_params_field = caml_copy_int32(vsnd_params_c->buffer_size);
		Store_field(vsnd_params_ocaml, 4, vsnd_params_field);
	}
	CAMLreturn(vsnd_params_ocaml);
}

/* Get the defaults for vsnd_params */
value stub_libxl_vsnd_params_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vsnd_params c_val;
	libxl_vsnd_params_init(&c_val);
	val = Val_vsnd_params(&c_val);
	libxl_vsnd_params_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vsnd_stream_type */
static int vsnd_stream_type_val (libxl_ctx *ctx, libxl_vsnd_stream_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_VSND_STREAM_TYPE_P; break;
	    case 1: *c_val = LIBXL_VSND_STREAM_TYPE_C; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_vsnd_stream_type"); break;
	}
	CAMLreturn(0);
}

/* Convert vsnd_stream_type to a caml value */
static value Val_vsnd_stream_type (libxl_vsnd_stream_type vsnd_stream_type_c)
{
	CAMLparam0();
	CAMLlocal1(vsnd_stream_type_ocaml);
	switch(vsnd_stream_type_c) {
	    case LIBXL_VSND_STREAM_TYPE_P: vsnd_stream_type_ocaml = Val_int(0); break;
	    case LIBXL_VSND_STREAM_TYPE_C: vsnd_stream_type_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_vsnd_stream_type"); break;
	}
	CAMLreturn(vsnd_stream_type_ocaml);
}

/* Convert caml value to vsnd_stream */
static int vsnd_stream_val (libxl_ctx *ctx, libxl_vsnd_stream *c_val, value v)
{
	CAMLparam1(v);

	c_val->unique_id = String_option_val(Field(v, 0));
	vsnd_stream_type_val(ctx, &c_val->type, Field(v, 1));
	vsnd_params_val(ctx, &c_val->params, Field(v, 2));
	
	CAMLreturn(0);
}

/* Convert vsnd_stream to a caml value */
static value Val_vsnd_stream (libxl_vsnd_stream *vsnd_stream_c)
{
	CAMLparam0();
	CAMLlocal1(vsnd_stream_ocaml);
	{
		CAMLlocal1(vsnd_stream_field);
	
		vsnd_stream_ocaml = caml_alloc_tuple(3);
	
		vsnd_stream_field = Val_string_option(vsnd_stream_c->unique_id);
		Store_field(vsnd_stream_ocaml, 0, vsnd_stream_field);
	
		vsnd_stream_field = Val_vsnd_stream_type(vsnd_stream_c->type);
		Store_field(vsnd_stream_ocaml, 1, vsnd_stream_field);
	
		vsnd_stream_field = Val_vsnd_params(&vsnd_stream_c->params);
		Store_field(vsnd_stream_ocaml, 2, vsnd_stream_field);
	}
	CAMLreturn(vsnd_stream_ocaml);
}

/* Get the defaults for vsnd_stream */
value stub_libxl_vsnd_stream_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vsnd_stream c_val;
	libxl_vsnd_stream_init(&c_val);
	val = Val_vsnd_stream(&c_val);
	libxl_vsnd_stream_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vsnd_pcm */
static int vsnd_pcm_val (libxl_ctx *ctx, libxl_vsnd_pcm *c_val, value v)
{
	CAMLparam1(v);

	c_val->name = String_option_val(Field(v, 0));
	vsnd_params_val(ctx, &c_val->params, Field(v, 1));
	{
		int i;
		c_val->num_vsnd_streams = Wosize_val(Field(v, 2));
		c_val->streams = (libxl_vsnd_stream *) calloc(c_val->num_vsnd_streams, sizeof(*c_val->streams));
		for(i=0; i<c_val->num_vsnd_streams; i++) {
			vsnd_stream_val(ctx, &c_val->streams[i], Field(Field(v, 2), i));
		}
	}
	
	
	CAMLreturn(0);
}

/* Convert vsnd_pcm to a caml value */
static value Val_vsnd_pcm (libxl_vsnd_pcm *vsnd_pcm_c)
{
	CAMLparam0();
	CAMLlocal1(vsnd_pcm_ocaml);
	{
		CAMLlocal1(vsnd_pcm_field);
	
		vsnd_pcm_ocaml = caml_alloc_tuple(3);
	
		vsnd_pcm_field = Val_string_option(vsnd_pcm_c->name);
		Store_field(vsnd_pcm_ocaml, 0, vsnd_pcm_field);
	
		vsnd_pcm_field = Val_vsnd_params(&vsnd_pcm_c->params);
		Store_field(vsnd_pcm_ocaml, 1, vsnd_pcm_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    vsnd_pcm_field = caml_alloc(vsnd_pcm_c->num_vsnd_streams,0);
		    for(i=0; i<vsnd_pcm_c->num_vsnd_streams; i++) {
		        array_elem = Val_vsnd_stream(&vsnd_pcm_c->streams[i]);
		        Store_field(vsnd_pcm_field, i, array_elem);
		    }
		}
		Store_field(vsnd_pcm_ocaml, 2, vsnd_pcm_field);
	}
	CAMLreturn(vsnd_pcm_ocaml);
}

/* Get the defaults for vsnd_pcm */
value stub_libxl_vsnd_pcm_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vsnd_pcm c_val;
	libxl_vsnd_pcm_init(&c_val);
	val = Val_vsnd_pcm(&c_val);
	libxl_vsnd_pcm_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to device_vsnd */
static int device_vsnd_val (libxl_ctx *ctx, libxl_device_vsnd *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend_domid = Int_val(Field(v, 0));
	c_val->backend_domname = String_option_val(Field(v, 1));
	c_val->devid = Int_val(Field(v, 2));
	c_val->short_name = String_option_val(Field(v, 3));
	c_val->long_name = String_option_val(Field(v, 4));
	vsnd_params_val(ctx, &c_val->params, Field(v, 5));
	{
		int i;
		c_val->num_vsnd_pcms = Wosize_val(Field(v, 6));
		c_val->pcms = (libxl_vsnd_pcm *) calloc(c_val->num_vsnd_pcms, sizeof(*c_val->pcms));
		for(i=0; i<c_val->num_vsnd_pcms; i++) {
			vsnd_pcm_val(ctx, &c_val->pcms[i], Field(Field(v, 6), i));
		}
	}
	
	
	CAMLreturn(0);
}

/* Convert device_vsnd to a caml value */
static value Val_device_vsnd (libxl_device_vsnd *device_vsnd_c)
{
	CAMLparam0();
	CAMLlocal1(device_vsnd_ocaml);
	{
		CAMLlocal1(device_vsnd_field);
	
		device_vsnd_ocaml = caml_alloc_tuple(7);
	
		device_vsnd_field = Val_int(device_vsnd_c->backend_domid);
		Store_field(device_vsnd_ocaml, 0, device_vsnd_field);
	
		device_vsnd_field = Val_string_option(device_vsnd_c->backend_domname);
		Store_field(device_vsnd_ocaml, 1, device_vsnd_field);
	
		device_vsnd_field = Val_int(device_vsnd_c->devid);
		Store_field(device_vsnd_ocaml, 2, device_vsnd_field);
	
		device_vsnd_field = Val_string_option(device_vsnd_c->short_name);
		Store_field(device_vsnd_ocaml, 3, device_vsnd_field);
	
		device_vsnd_field = Val_string_option(device_vsnd_c->long_name);
		Store_field(device_vsnd_ocaml, 4, device_vsnd_field);
	
		device_vsnd_field = Val_vsnd_params(&device_vsnd_c->params);
		Store_field(device_vsnd_ocaml, 5, device_vsnd_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    device_vsnd_field = caml_alloc(device_vsnd_c->num_vsnd_pcms,0);
		    for(i=0; i<device_vsnd_c->num_vsnd_pcms; i++) {
		        array_elem = Val_vsnd_pcm(&device_vsnd_c->pcms[i]);
		        Store_field(device_vsnd_field, i, array_elem);
		    }
		}
		Store_field(device_vsnd_ocaml, 6, device_vsnd_field);
	}
	CAMLreturn(device_vsnd_ocaml);
}

/* Get the defaults for device_vsnd */
value stub_libxl_device_vsnd_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_device_vsnd c_val;
	libxl_device_vsnd_init(&c_val);
	val = Val_device_vsnd(&c_val);
	libxl_device_vsnd_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to domain_config */
static int domain_config_val (libxl_ctx *ctx, libxl_domain_config *c_val, value v)
{
	CAMLparam1(v);

	domain_create_info_val(ctx, &c_val->c_info, Field(v, 0));
	domain_build_info_val(ctx, &c_val->b_info, Field(v, 1));
	{
		int i;
		c_val->num_disks = Wosize_val(Field(v, 2));
		c_val->disks = (libxl_device_disk *) calloc(c_val->num_disks, sizeof(*c_val->disks));
		for(i=0; i<c_val->num_disks; i++) {
			device_disk_val(ctx, &c_val->disks[i], Field(Field(v, 2), i));
		}
	}
	
	{
		int i;
		c_val->num_nics = Wosize_val(Field(v, 3));
		c_val->nics = (libxl_device_nic *) calloc(c_val->num_nics, sizeof(*c_val->nics));
		for(i=0; i<c_val->num_nics; i++) {
			device_nic_val(ctx, &c_val->nics[i], Field(Field(v, 3), i));
		}
	}
	
	{
		int i;
		c_val->num_pcidevs = Wosize_val(Field(v, 4));
		c_val->pcidevs = (libxl_device_pci *) calloc(c_val->num_pcidevs, sizeof(*c_val->pcidevs));
		for(i=0; i<c_val->num_pcidevs; i++) {
			device_pci_val(ctx, &c_val->pcidevs[i], Field(Field(v, 4), i));
		}
	}
	
	{
		int i;
		c_val->num_rdms = Wosize_val(Field(v, 5));
		c_val->rdms = (libxl_device_rdm *) calloc(c_val->num_rdms, sizeof(*c_val->rdms));
		for(i=0; i<c_val->num_rdms; i++) {
			device_rdm_val(ctx, &c_val->rdms[i], Field(Field(v, 5), i));
		}
	}
	
	{
		int i;
		c_val->num_dtdevs = Wosize_val(Field(v, 6));
		c_val->dtdevs = (libxl_device_dtdev *) calloc(c_val->num_dtdevs, sizeof(*c_val->dtdevs));
		for(i=0; i<c_val->num_dtdevs; i++) {
			device_dtdev_val(ctx, &c_val->dtdevs[i], Field(Field(v, 6), i));
		}
	}
	
	{
		int i;
		c_val->num_vfbs = Wosize_val(Field(v, 7));
		c_val->vfbs = (libxl_device_vfb *) calloc(c_val->num_vfbs, sizeof(*c_val->vfbs));
		for(i=0; i<c_val->num_vfbs; i++) {
			device_vfb_val(ctx, &c_val->vfbs[i], Field(Field(v, 7), i));
		}
	}
	
	{
		int i;
		c_val->num_vkbs = Wosize_val(Field(v, 8));
		c_val->vkbs = (libxl_device_vkb *) calloc(c_val->num_vkbs, sizeof(*c_val->vkbs));
		for(i=0; i<c_val->num_vkbs; i++) {
			device_vkb_val(ctx, &c_val->vkbs[i], Field(Field(v, 8), i));
		}
	}
	
	{
		int i;
		c_val->num_vtpms = Wosize_val(Field(v, 9));
		c_val->vtpms = (libxl_device_vtpm *) calloc(c_val->num_vtpms, sizeof(*c_val->vtpms));
		for(i=0; i<c_val->num_vtpms; i++) {
			device_vtpm_val(ctx, &c_val->vtpms[i], Field(Field(v, 9), i));
		}
	}
	
	{
		int i;
		c_val->num_p9s = Wosize_val(Field(v, 10));
		c_val->p9s = (libxl_device_p9 *) calloc(c_val->num_p9s, sizeof(*c_val->p9s));
		for(i=0; i<c_val->num_p9s; i++) {
			device_p9_val(ctx, &c_val->p9s[i], Field(Field(v, 10), i));
		}
	}
	
	{
		int i;
		c_val->num_pvcallsifs = Wosize_val(Field(v, 11));
		c_val->pvcallsifs = (libxl_device_pvcallsif *) calloc(c_val->num_pvcallsifs, sizeof(*c_val->pvcallsifs));
		for(i=0; i<c_val->num_pvcallsifs; i++) {
			device_pvcallsif_val(ctx, &c_val->pvcallsifs[i], Field(Field(v, 11), i));
		}
	}
	
	{
		int i;
		c_val->num_vdispls = Wosize_val(Field(v, 12));
		c_val->vdispls = (libxl_device_vdispl *) calloc(c_val->num_vdispls, sizeof(*c_val->vdispls));
		for(i=0; i<c_val->num_vdispls; i++) {
			device_vdispl_val(ctx, &c_val->vdispls[i], Field(Field(v, 12), i));
		}
	}
	
	{
		int i;
		c_val->num_vsnds = Wosize_val(Field(v, 13));
		c_val->vsnds = (libxl_device_vsnd *) calloc(c_val->num_vsnds, sizeof(*c_val->vsnds));
		for(i=0; i<c_val->num_vsnds; i++) {
			device_vsnd_val(ctx, &c_val->vsnds[i], Field(Field(v, 13), i));
		}
	}
	
	{
		int i;
		c_val->num_channels = Wosize_val(Field(v, 14));
		c_val->channels = (libxl_device_channel *) calloc(c_val->num_channels, sizeof(*c_val->channels));
		for(i=0; i<c_val->num_channels; i++) {
			device_channel_val(ctx, &c_val->channels[i], Field(Field(v, 14), i));
		}
	}
	
	{
		int i;
		c_val->num_usbctrls = Wosize_val(Field(v, 15));
		c_val->usbctrls = (libxl_device_usbctrl *) calloc(c_val->num_usbctrls, sizeof(*c_val->usbctrls));
		for(i=0; i<c_val->num_usbctrls; i++) {
			device_usbctrl_val(ctx, &c_val->usbctrls[i], Field(Field(v, 15), i));
		}
	}
	
	{
		int i;
		c_val->num_usbdevs = Wosize_val(Field(v, 16));
		c_val->usbdevs = (libxl_device_usbdev *) calloc(c_val->num_usbdevs, sizeof(*c_val->usbdevs));
		for(i=0; i<c_val->num_usbdevs; i++) {
			device_usbdev_val(ctx, &c_val->usbdevs[i], Field(Field(v, 16), i));
		}
	}
	
	action_on_shutdown_val(ctx, &c_val->on_poweroff, Field(v, 17));
	action_on_shutdown_val(ctx, &c_val->on_reboot, Field(v, 18));
	action_on_shutdown_val(ctx, &c_val->on_watchdog, Field(v, 19));
	action_on_shutdown_val(ctx, &c_val->on_crash, Field(v, 20));
	action_on_shutdown_val(ctx, &c_val->on_soft_reset, Field(v, 21));
	
	CAMLreturn(0);
}

/* Convert domain_config to a caml value */
static value Val_domain_config (libxl_domain_config *domain_config_c)
{
	CAMLparam0();
	CAMLlocal1(domain_config_ocaml);
	{
		CAMLlocal1(domain_config_field);
	
		domain_config_ocaml = caml_alloc_tuple(22);
	
		domain_config_field = Val_domain_create_info(&domain_config_c->c_info);
		Store_field(domain_config_ocaml, 0, domain_config_field);
	
		domain_config_field = Val_domain_build_info(&domain_config_c->b_info);
		Store_field(domain_config_ocaml, 1, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_disks,0);
		    for(i=0; i<domain_config_c->num_disks; i++) {
		        array_elem = Val_device_disk(&domain_config_c->disks[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 2, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_nics,0);
		    for(i=0; i<domain_config_c->num_nics; i++) {
		        array_elem = Val_device_nic(&domain_config_c->nics[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 3, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_pcidevs,0);
		    for(i=0; i<domain_config_c->num_pcidevs; i++) {
		        array_elem = Val_device_pci(&domain_config_c->pcidevs[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 4, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_rdms,0);
		    for(i=0; i<domain_config_c->num_rdms; i++) {
		        array_elem = Val_device_rdm(&domain_config_c->rdms[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 5, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_dtdevs,0);
		    for(i=0; i<domain_config_c->num_dtdevs; i++) {
		        array_elem = Val_device_dtdev(&domain_config_c->dtdevs[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 6, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_vfbs,0);
		    for(i=0; i<domain_config_c->num_vfbs; i++) {
		        array_elem = Val_device_vfb(&domain_config_c->vfbs[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 7, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_vkbs,0);
		    for(i=0; i<domain_config_c->num_vkbs; i++) {
		        array_elem = Val_device_vkb(&domain_config_c->vkbs[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 8, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_vtpms,0);
		    for(i=0; i<domain_config_c->num_vtpms; i++) {
		        array_elem = Val_device_vtpm(&domain_config_c->vtpms[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 9, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_p9s,0);
		    for(i=0; i<domain_config_c->num_p9s; i++) {
		        array_elem = Val_device_p9(&domain_config_c->p9s[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 10, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_pvcallsifs,0);
		    for(i=0; i<domain_config_c->num_pvcallsifs; i++) {
		        array_elem = Val_device_pvcallsif(&domain_config_c->pvcallsifs[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 11, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_vdispls,0);
		    for(i=0; i<domain_config_c->num_vdispls; i++) {
		        array_elem = Val_device_vdispl(&domain_config_c->vdispls[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 12, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_vsnds,0);
		    for(i=0; i<domain_config_c->num_vsnds; i++) {
		        array_elem = Val_device_vsnd(&domain_config_c->vsnds[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 13, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_channels,0);
		    for(i=0; i<domain_config_c->num_channels; i++) {
		        array_elem = Val_device_channel(&domain_config_c->channels[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 14, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_usbctrls,0);
		    for(i=0; i<domain_config_c->num_usbctrls; i++) {
		        array_elem = Val_device_usbctrl(&domain_config_c->usbctrls[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 15, domain_config_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    domain_config_field = caml_alloc(domain_config_c->num_usbdevs,0);
		    for(i=0; i<domain_config_c->num_usbdevs; i++) {
		        array_elem = Val_device_usbdev(&domain_config_c->usbdevs[i]);
		        Store_field(domain_config_field, i, array_elem);
		    }
		}
		Store_field(domain_config_ocaml, 16, domain_config_field);
	
		domain_config_field = Val_action_on_shutdown(domain_config_c->on_poweroff);
		Store_field(domain_config_ocaml, 17, domain_config_field);
	
		domain_config_field = Val_action_on_shutdown(domain_config_c->on_reboot);
		Store_field(domain_config_ocaml, 18, domain_config_field);
	
		domain_config_field = Val_action_on_shutdown(domain_config_c->on_watchdog);
		Store_field(domain_config_ocaml, 19, domain_config_field);
	
		domain_config_field = Val_action_on_shutdown(domain_config_c->on_crash);
		Store_field(domain_config_ocaml, 20, domain_config_field);
	
		domain_config_field = Val_action_on_shutdown(domain_config_c->on_soft_reset);
		Store_field(domain_config_ocaml, 21, domain_config_field);
	}
	CAMLreturn(domain_config_ocaml);
}

/* Get the defaults for domain_config */
value stub_libxl_domain_config_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_domain_config c_val;
	libxl_domain_config_init(&c_val);
	val = Val_domain_config(&c_val);
	libxl_domain_config_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert diskinfo to a caml value */
static value Val_diskinfo (libxl_diskinfo *diskinfo_c)
{
	CAMLparam0();
	CAMLlocal1(diskinfo_ocaml);
	{
		CAMLlocal1(diskinfo_field);
	
		diskinfo_ocaml = caml_alloc_tuple(8);
	
		diskinfo_field = Val_string_option(diskinfo_c->backend);
		Store_field(diskinfo_ocaml, 0, diskinfo_field);
	
		diskinfo_field = caml_copy_int32(diskinfo_c->backend_id);
		Store_field(diskinfo_ocaml, 1, diskinfo_field);
	
		diskinfo_field = Val_string_option(diskinfo_c->frontend);
		Store_field(diskinfo_ocaml, 2, diskinfo_field);
	
		diskinfo_field = caml_copy_int32(diskinfo_c->frontend_id);
		Store_field(diskinfo_ocaml, 3, diskinfo_field);
	
		diskinfo_field = Val_int(diskinfo_c->devid);
		Store_field(diskinfo_ocaml, 4, diskinfo_field);
	
		diskinfo_field = Val_int(diskinfo_c->state);
		Store_field(diskinfo_ocaml, 5, diskinfo_field);
	
		diskinfo_field = Val_int(diskinfo_c->evtch);
		Store_field(diskinfo_ocaml, 6, diskinfo_field);
	
		diskinfo_field = Val_int(diskinfo_c->rref);
		Store_field(diskinfo_ocaml, 7, diskinfo_field);
	}
	CAMLreturn(diskinfo_ocaml);
}

/* Get the defaults for diskinfo */
value stub_libxl_diskinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_diskinfo c_val;
	libxl_diskinfo_init(&c_val);
	val = Val_diskinfo(&c_val);
	libxl_diskinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert nicinfo to a caml value */
static value Val_nicinfo (libxl_nicinfo *nicinfo_c)
{
	CAMLparam0();
	CAMLlocal1(nicinfo_ocaml);
	{
		CAMLlocal1(nicinfo_field);
	
		nicinfo_ocaml = caml_alloc_tuple(9);
	
		nicinfo_field = Val_string_option(nicinfo_c->backend);
		Store_field(nicinfo_ocaml, 0, nicinfo_field);
	
		nicinfo_field = caml_copy_int32(nicinfo_c->backend_id);
		Store_field(nicinfo_ocaml, 1, nicinfo_field);
	
		nicinfo_field = Val_string_option(nicinfo_c->frontend);
		Store_field(nicinfo_ocaml, 2, nicinfo_field);
	
		nicinfo_field = caml_copy_int32(nicinfo_c->frontend_id);
		Store_field(nicinfo_ocaml, 3, nicinfo_field);
	
		nicinfo_field = Val_int(nicinfo_c->devid);
		Store_field(nicinfo_ocaml, 4, nicinfo_field);
	
		nicinfo_field = Val_int(nicinfo_c->state);
		Store_field(nicinfo_ocaml, 5, nicinfo_field);
	
		nicinfo_field = Val_int(nicinfo_c->evtch);
		Store_field(nicinfo_ocaml, 6, nicinfo_field);
	
		nicinfo_field = Val_int(nicinfo_c->rref_tx);
		Store_field(nicinfo_ocaml, 7, nicinfo_field);
	
		nicinfo_field = Val_int(nicinfo_c->rref_rx);
		Store_field(nicinfo_ocaml, 8, nicinfo_field);
	}
	CAMLreturn(nicinfo_ocaml);
}

/* Get the defaults for nicinfo */
value stub_libxl_nicinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_nicinfo c_val;
	libxl_nicinfo_init(&c_val);
	val = Val_nicinfo(&c_val);
	libxl_nicinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert vtpminfo to a caml value */
static value Val_vtpminfo (libxl_vtpminfo *vtpminfo_c)
{
	CAMLparam0();
	CAMLlocal1(vtpminfo_ocaml);
	{
		CAMLlocal1(vtpminfo_field);
	
		vtpminfo_ocaml = caml_alloc_tuple(9);
	
		vtpminfo_field = Val_string_option(vtpminfo_c->backend);
		Store_field(vtpminfo_ocaml, 0, vtpminfo_field);
	
		vtpminfo_field = caml_copy_int32(vtpminfo_c->backend_id);
		Store_field(vtpminfo_ocaml, 1, vtpminfo_field);
	
		vtpminfo_field = Val_string_option(vtpminfo_c->frontend);
		Store_field(vtpminfo_ocaml, 2, vtpminfo_field);
	
		vtpminfo_field = caml_copy_int32(vtpminfo_c->frontend_id);
		Store_field(vtpminfo_ocaml, 3, vtpminfo_field);
	
		vtpminfo_field = Val_int(vtpminfo_c->devid);
		Store_field(vtpminfo_ocaml, 4, vtpminfo_field);
	
		vtpminfo_field = Val_int(vtpminfo_c->state);
		Store_field(vtpminfo_ocaml, 5, vtpminfo_field);
	
		vtpminfo_field = Val_int(vtpminfo_c->evtch);
		Store_field(vtpminfo_ocaml, 6, vtpminfo_field);
	
		vtpminfo_field = Val_int(vtpminfo_c->rref);
		Store_field(vtpminfo_ocaml, 7, vtpminfo_field);
	
		vtpminfo_field = Val_uuid(&vtpminfo_c->uuid);
		Store_field(vtpminfo_ocaml, 8, vtpminfo_field);
	}
	CAMLreturn(vtpminfo_ocaml);
}

/* Get the defaults for vtpminfo */
value stub_libxl_vtpminfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vtpminfo c_val;
	libxl_vtpminfo_init(&c_val);
	val = Val_vtpminfo(&c_val);
	libxl_vtpminfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert usbctrlinfo to a caml value */
static value Val_usbctrlinfo (libxl_usbctrlinfo *usbctrlinfo_c)
{
	CAMLparam0();
	CAMLlocal1(usbctrlinfo_ocaml);
	{
		CAMLlocal1(usbctrlinfo_field);
	
		usbctrlinfo_ocaml = caml_alloc_tuple(12);
	
		usbctrlinfo_field = Val_usbctrl_type(usbctrlinfo_c->type);
		Store_field(usbctrlinfo_ocaml, 0, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_int(usbctrlinfo_c->devid);
		Store_field(usbctrlinfo_ocaml, 1, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_int(usbctrlinfo_c->version);
		Store_field(usbctrlinfo_ocaml, 2, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_int(usbctrlinfo_c->ports);
		Store_field(usbctrlinfo_ocaml, 3, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_string_option(usbctrlinfo_c->backend);
		Store_field(usbctrlinfo_ocaml, 4, usbctrlinfo_field);
	
		usbctrlinfo_field = caml_copy_int32(usbctrlinfo_c->backend_id);
		Store_field(usbctrlinfo_ocaml, 5, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_string_option(usbctrlinfo_c->frontend);
		Store_field(usbctrlinfo_ocaml, 6, usbctrlinfo_field);
	
		usbctrlinfo_field = caml_copy_int32(usbctrlinfo_c->frontend_id);
		Store_field(usbctrlinfo_ocaml, 7, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_int(usbctrlinfo_c->state);
		Store_field(usbctrlinfo_ocaml, 8, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_int(usbctrlinfo_c->evtch);
		Store_field(usbctrlinfo_ocaml, 9, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_int(usbctrlinfo_c->ref_urb);
		Store_field(usbctrlinfo_ocaml, 10, usbctrlinfo_field);
	
		usbctrlinfo_field = Val_int(usbctrlinfo_c->ref_conn);
		Store_field(usbctrlinfo_ocaml, 11, usbctrlinfo_field);
	}
	CAMLreturn(usbctrlinfo_ocaml);
}

/* Get the defaults for usbctrlinfo */
value stub_libxl_usbctrlinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_usbctrlinfo c_val;
	libxl_usbctrlinfo_init(&c_val);
	val = Val_usbctrlinfo(&c_val);
	libxl_usbctrlinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert physinfo to a caml value */
static value Val_physinfo (libxl_physinfo *physinfo_c)
{
	CAMLparam0();
	CAMLlocal1(physinfo_ocaml);
	{
		CAMLlocal1(physinfo_field);
	
		physinfo_ocaml = caml_alloc_tuple(20);
	
		physinfo_field = caml_copy_int32(physinfo_c->threads_per_core);
		Store_field(physinfo_ocaml, 0, physinfo_field);
	
		physinfo_field = caml_copy_int32(physinfo_c->cores_per_socket);
		Store_field(physinfo_ocaml, 1, physinfo_field);
	
		physinfo_field = caml_copy_int32(physinfo_c->max_cpu_id);
		Store_field(physinfo_ocaml, 2, physinfo_field);
	
		physinfo_field = caml_copy_int32(physinfo_c->nr_cpus);
		Store_field(physinfo_ocaml, 3, physinfo_field);
	
		physinfo_field = caml_copy_int32(physinfo_c->cpu_khz);
		Store_field(physinfo_ocaml, 4, physinfo_field);
	
		physinfo_field = caml_copy_int64(physinfo_c->total_pages);
		Store_field(physinfo_ocaml, 5, physinfo_field);
	
		physinfo_field = caml_copy_int64(physinfo_c->free_pages);
		Store_field(physinfo_ocaml, 6, physinfo_field);
	
		physinfo_field = caml_copy_int64(physinfo_c->scrub_pages);
		Store_field(physinfo_ocaml, 7, physinfo_field);
	
		physinfo_field = caml_copy_int64(physinfo_c->outstanding_pages);
		Store_field(physinfo_ocaml, 8, physinfo_field);
	
		physinfo_field = caml_copy_int64(physinfo_c->sharing_freed_pages);
		Store_field(physinfo_ocaml, 9, physinfo_field);
	
		physinfo_field = caml_copy_int64(physinfo_c->sharing_used_frames);
		Store_field(physinfo_ocaml, 10, physinfo_field);
	
		physinfo_field = caml_copy_int64(physinfo_c->max_possible_mfn);
		Store_field(physinfo_ocaml, 11, physinfo_field);
	
		physinfo_field = caml_copy_int32(physinfo_c->nr_nodes);
		Store_field(physinfo_ocaml, 12, physinfo_field);
	
		physinfo_field = Val_hwcap(&physinfo_c->hw_cap);
		Store_field(physinfo_ocaml, 13, physinfo_field);
	
		physinfo_field = Val_bool(physinfo_c->cap_hvm);
		Store_field(physinfo_ocaml, 14, physinfo_field);
	
		physinfo_field = Val_bool(physinfo_c->cap_pv);
		Store_field(physinfo_ocaml, 15, physinfo_field);
	
		physinfo_field = Val_bool(physinfo_c->cap_hvm_directio);
		Store_field(physinfo_ocaml, 16, physinfo_field);
	
		physinfo_field = Val_bool(physinfo_c->cap_hap);
		Store_field(physinfo_ocaml, 17, physinfo_field);
	
		physinfo_field = Val_bool(physinfo_c->cap_shadow);
		Store_field(physinfo_ocaml, 18, physinfo_field);
	
		physinfo_field = Val_bool(physinfo_c->cap_iommu_hap_pt_share);
		Store_field(physinfo_ocaml, 19, physinfo_field);
	}
	CAMLreturn(physinfo_ocaml);
}

/* Stubs for physinfo */
value stub_xl_physinfo_get(value v1);

/* Get the defaults for physinfo */
value stub_libxl_physinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_physinfo c_val;
	libxl_physinfo_init(&c_val);
	val = Val_physinfo(&c_val);
	libxl_physinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert connectorinfo to a caml value */
static value Val_connectorinfo (libxl_connectorinfo *connectorinfo_c)
{
	CAMLparam0();
	CAMLlocal1(connectorinfo_ocaml);
	{
		CAMLlocal1(connectorinfo_field);
	
		connectorinfo_ocaml = caml_alloc_tuple(7);
	
		connectorinfo_field = Val_string_option(connectorinfo_c->unique_id);
		Store_field(connectorinfo_ocaml, 0, connectorinfo_field);
	
		connectorinfo_field = caml_copy_int32(connectorinfo_c->width);
		Store_field(connectorinfo_ocaml, 1, connectorinfo_field);
	
		connectorinfo_field = caml_copy_int32(connectorinfo_c->height);
		Store_field(connectorinfo_ocaml, 2, connectorinfo_field);
	
		connectorinfo_field = Val_int(connectorinfo_c->req_evtch);
		Store_field(connectorinfo_ocaml, 3, connectorinfo_field);
	
		connectorinfo_field = Val_int(connectorinfo_c->req_rref);
		Store_field(connectorinfo_ocaml, 4, connectorinfo_field);
	
		connectorinfo_field = Val_int(connectorinfo_c->evt_evtch);
		Store_field(connectorinfo_ocaml, 5, connectorinfo_field);
	
		connectorinfo_field = Val_int(connectorinfo_c->evt_rref);
		Store_field(connectorinfo_ocaml, 6, connectorinfo_field);
	}
	CAMLreturn(connectorinfo_ocaml);
}

/* Get the defaults for connectorinfo */
value stub_libxl_connectorinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_connectorinfo c_val;
	libxl_connectorinfo_init(&c_val);
	val = Val_connectorinfo(&c_val);
	libxl_connectorinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert vdisplinfo to a caml value */
static value Val_vdisplinfo (libxl_vdisplinfo *vdisplinfo_c)
{
	CAMLparam0();
	CAMLlocal1(vdisplinfo_ocaml);
	{
		CAMLlocal1(vdisplinfo_field);
	
		vdisplinfo_ocaml = caml_alloc_tuple(8);
	
		vdisplinfo_field = Val_string_option(vdisplinfo_c->backend);
		Store_field(vdisplinfo_ocaml, 0, vdisplinfo_field);
	
		vdisplinfo_field = caml_copy_int32(vdisplinfo_c->backend_id);
		Store_field(vdisplinfo_ocaml, 1, vdisplinfo_field);
	
		vdisplinfo_field = Val_string_option(vdisplinfo_c->frontend);
		Store_field(vdisplinfo_ocaml, 2, vdisplinfo_field);
	
		vdisplinfo_field = caml_copy_int32(vdisplinfo_c->frontend_id);
		Store_field(vdisplinfo_ocaml, 3, vdisplinfo_field);
	
		vdisplinfo_field = Val_int(vdisplinfo_c->devid);
		Store_field(vdisplinfo_ocaml, 4, vdisplinfo_field);
	
		vdisplinfo_field = Val_int(vdisplinfo_c->state);
		Store_field(vdisplinfo_ocaml, 5, vdisplinfo_field);
	
		vdisplinfo_field = Val_bool(vdisplinfo_c->be_alloc);
		Store_field(vdisplinfo_ocaml, 6, vdisplinfo_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    vdisplinfo_field = caml_alloc(vdisplinfo_c->num_connectors,0);
		    for(i=0; i<vdisplinfo_c->num_connectors; i++) {
		        array_elem = Val_connectorinfo(&vdisplinfo_c->connectors[i]);
		        Store_field(vdisplinfo_field, i, array_elem);
		    }
		}
		Store_field(vdisplinfo_ocaml, 7, vdisplinfo_field);
	}
	CAMLreturn(vdisplinfo_ocaml);
}

/* Get the defaults for vdisplinfo */
value stub_libxl_vdisplinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vdisplinfo c_val;
	libxl_vdisplinfo_init(&c_val);
	val = Val_vdisplinfo(&c_val);
	libxl_vdisplinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to streaminfo */
static int streaminfo_val (libxl_ctx *ctx, libxl_streaminfo *c_val, value v)
{
	CAMLparam1(v);

	c_val->req_evtch = Int_val(Field(v, 0));
	c_val->req_rref = Int_val(Field(v, 1));
	
	CAMLreturn(0);
}

/* Convert streaminfo to a caml value */
static value Val_streaminfo (libxl_streaminfo *streaminfo_c)
{
	CAMLparam0();
	CAMLlocal1(streaminfo_ocaml);
	{
		CAMLlocal1(streaminfo_field);
	
		streaminfo_ocaml = caml_alloc_tuple(2);
	
		streaminfo_field = Val_int(streaminfo_c->req_evtch);
		Store_field(streaminfo_ocaml, 0, streaminfo_field);
	
		streaminfo_field = Val_int(streaminfo_c->req_rref);
		Store_field(streaminfo_ocaml, 1, streaminfo_field);
	}
	CAMLreturn(streaminfo_ocaml);
}

/* Get the defaults for streaminfo */
value stub_libxl_streaminfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_streaminfo c_val;
	libxl_streaminfo_init(&c_val);
	val = Val_streaminfo(&c_val);
	libxl_streaminfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to pcminfo */
static int pcminfo_val (libxl_ctx *ctx, libxl_pcminfo *c_val, value v)
{
	CAMLparam1(v);

	{
		int i;
		c_val->num_vsnd_streams = Wosize_val(Field(v, 0));
		c_val->streams = (libxl_streaminfo *) calloc(c_val->num_vsnd_streams, sizeof(*c_val->streams));
		for(i=0; i<c_val->num_vsnd_streams; i++) {
			streaminfo_val(ctx, &c_val->streams[i], Field(Field(v, 0), i));
		}
	}
	
	
	CAMLreturn(0);
}

/* Convert pcminfo to a caml value */
static value Val_pcminfo (libxl_pcminfo *pcminfo_c)
{
	CAMLparam0();
	CAMLlocal1(pcminfo_ocaml);
	{
		CAMLlocal1(pcminfo_field);
	
		pcminfo_ocaml = caml_alloc_tuple(1);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    pcminfo_field = caml_alloc(pcminfo_c->num_vsnd_streams,0);
		    for(i=0; i<pcminfo_c->num_vsnd_streams; i++) {
		        array_elem = Val_streaminfo(&pcminfo_c->streams[i]);
		        Store_field(pcminfo_field, i, array_elem);
		    }
		}
		Store_field(pcminfo_ocaml, 0, pcminfo_field);
	}
	CAMLreturn(pcminfo_ocaml);
}

/* Get the defaults for pcminfo */
value stub_libxl_pcminfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_pcminfo c_val;
	libxl_pcminfo_init(&c_val);
	val = Val_pcminfo(&c_val);
	libxl_pcminfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to vsndinfo */
static int vsndinfo_val (libxl_ctx *ctx, libxl_vsndinfo *c_val, value v)
{
	CAMLparam1(v);

	c_val->backend = String_option_val(Field(v, 0));
	c_val->backend_id = Int32_val(Field(v, 1));
	c_val->frontend = String_option_val(Field(v, 2));
	c_val->frontend_id = Int32_val(Field(v, 3));
	c_val->devid = Int_val(Field(v, 4));
	c_val->state = Int_val(Field(v, 5));
	{
		int i;
		c_val->num_vsnd_pcms = Wosize_val(Field(v, 6));
		c_val->pcms = (libxl_pcminfo *) calloc(c_val->num_vsnd_pcms, sizeof(*c_val->pcms));
		for(i=0; i<c_val->num_vsnd_pcms; i++) {
			pcminfo_val(ctx, &c_val->pcms[i], Field(Field(v, 6), i));
		}
	}
	
	
	CAMLreturn(0);
}

/* Convert vsndinfo to a caml value */
static value Val_vsndinfo (libxl_vsndinfo *vsndinfo_c)
{
	CAMLparam0();
	CAMLlocal1(vsndinfo_ocaml);
	{
		CAMLlocal1(vsndinfo_field);
	
		vsndinfo_ocaml = caml_alloc_tuple(7);
	
		vsndinfo_field = Val_string_option(vsndinfo_c->backend);
		Store_field(vsndinfo_ocaml, 0, vsndinfo_field);
	
		vsndinfo_field = caml_copy_int32(vsndinfo_c->backend_id);
		Store_field(vsndinfo_ocaml, 1, vsndinfo_field);
	
		vsndinfo_field = Val_string_option(vsndinfo_c->frontend);
		Store_field(vsndinfo_ocaml, 2, vsndinfo_field);
	
		vsndinfo_field = caml_copy_int32(vsndinfo_c->frontend_id);
		Store_field(vsndinfo_ocaml, 3, vsndinfo_field);
	
		vsndinfo_field = Val_int(vsndinfo_c->devid);
		Store_field(vsndinfo_ocaml, 4, vsndinfo_field);
	
		vsndinfo_field = Val_int(vsndinfo_c->state);
		Store_field(vsndinfo_ocaml, 5, vsndinfo_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    vsndinfo_field = caml_alloc(vsndinfo_c->num_vsnd_pcms,0);
		    for(i=0; i<vsndinfo_c->num_vsnd_pcms; i++) {
		        array_elem = Val_pcminfo(&vsndinfo_c->pcms[i]);
		        Store_field(vsndinfo_field, i, array_elem);
		    }
		}
		Store_field(vsndinfo_ocaml, 6, vsndinfo_field);
	}
	CAMLreturn(vsndinfo_ocaml);
}

/* Get the defaults for vsndinfo */
value stub_libxl_vsndinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vsndinfo c_val;
	libxl_vsndinfo_init(&c_val);
	val = Val_vsndinfo(&c_val);
	libxl_vsndinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert vkbinfo to a caml value */
static value Val_vkbinfo (libxl_vkbinfo *vkbinfo_c)
{
	CAMLparam0();
	CAMLlocal1(vkbinfo_ocaml);
	{
		CAMLlocal1(vkbinfo_field);
	
		vkbinfo_ocaml = caml_alloc_tuple(8);
	
		vkbinfo_field = Val_string_option(vkbinfo_c->backend);
		Store_field(vkbinfo_ocaml, 0, vkbinfo_field);
	
		vkbinfo_field = caml_copy_int32(vkbinfo_c->backend_id);
		Store_field(vkbinfo_ocaml, 1, vkbinfo_field);
	
		vkbinfo_field = Val_string_option(vkbinfo_c->frontend);
		Store_field(vkbinfo_ocaml, 2, vkbinfo_field);
	
		vkbinfo_field = caml_copy_int32(vkbinfo_c->frontend_id);
		Store_field(vkbinfo_ocaml, 3, vkbinfo_field);
	
		vkbinfo_field = Val_int(vkbinfo_c->devid);
		Store_field(vkbinfo_ocaml, 4, vkbinfo_field);
	
		vkbinfo_field = Val_int(vkbinfo_c->state);
		Store_field(vkbinfo_ocaml, 5, vkbinfo_field);
	
		vkbinfo_field = Val_int(vkbinfo_c->evtch);
		Store_field(vkbinfo_ocaml, 6, vkbinfo_field);
	
		vkbinfo_field = Val_int(vkbinfo_c->rref);
		Store_field(vkbinfo_ocaml, 7, vkbinfo_field);
	}
	CAMLreturn(vkbinfo_ocaml);
}

/* Get the defaults for vkbinfo */
value stub_libxl_vkbinfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_vkbinfo c_val;
	libxl_vkbinfo_init(&c_val);
	val = Val_vkbinfo(&c_val);
	libxl_vkbinfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert numainfo to a caml value */
static value Val_numainfo (libxl_numainfo *numainfo_c)
{
	CAMLparam0();
	CAMLlocal1(numainfo_ocaml);
	{
		CAMLlocal1(numainfo_field);
	
		numainfo_ocaml = caml_alloc_tuple(3);
	
		numainfo_field = caml_copy_int64(numainfo_c->size);
		Store_field(numainfo_ocaml, 0, numainfo_field);
	
		numainfo_field = caml_copy_int64(numainfo_c->free);
		Store_field(numainfo_ocaml, 1, numainfo_field);
	
		{
		    int i;
		    CAMLlocal1(array_elem);
		    numainfo_field = caml_alloc(numainfo_c->num_dists,0);
		    for(i=0; i<numainfo_c->num_dists; i++) {
		        array_elem = caml_copy_int32(numainfo_c->dists[i]);
		        Store_field(numainfo_field, i, array_elem);
		    }
		}
		Store_field(numainfo_ocaml, 2, numainfo_field);
	}
	CAMLreturn(numainfo_ocaml);
}

/* Get the defaults for numainfo */
value stub_libxl_numainfo_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_numainfo c_val;
	libxl_numainfo_init(&c_val);
	val = Val_numainfo(&c_val);
	libxl_numainfo_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert cputopology to a caml value */
static value Val_cputopology (libxl_cputopology *cputopology_c)
{
	CAMLparam0();
	CAMLlocal1(cputopology_ocaml);
	{
		CAMLlocal1(cputopology_field);
	
		cputopology_ocaml = caml_alloc_tuple(3);
	
		cputopology_field = caml_copy_int32(cputopology_c->core);
		Store_field(cputopology_ocaml, 0, cputopology_field);
	
		cputopology_field = caml_copy_int32(cputopology_c->socket);
		Store_field(cputopology_ocaml, 1, cputopology_field);
	
		cputopology_field = caml_copy_int32(cputopology_c->node);
		Store_field(cputopology_ocaml, 2, cputopology_field);
	}
	CAMLreturn(cputopology_ocaml);
}

/* Stubs for cputopology */
value stub_xl_cputopology_get(value v1);

/* Get the defaults for cputopology */
value stub_libxl_cputopology_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_cputopology c_val;
	libxl_cputopology_init(&c_val);
	val = Val_cputopology(&c_val);
	libxl_cputopology_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert pcitopology to a caml value */
static value Val_pcitopology (libxl_pcitopology *pcitopology_c)
{
	CAMLparam0();
	CAMLlocal1(pcitopology_ocaml);
	{
		CAMLlocal1(pcitopology_field);
	
		pcitopology_ocaml = caml_alloc_tuple(4);
	
		pcitopology_field = Val_int(pcitopology_c->seg);
		Store_field(pcitopology_ocaml, 0, pcitopology_field);
	
		pcitopology_field = Val_int(pcitopology_c->bus);
		Store_field(pcitopology_ocaml, 1, pcitopology_field);
	
		pcitopology_field = Val_int(pcitopology_c->devfn);
		Store_field(pcitopology_ocaml, 2, pcitopology_field);
	
		pcitopology_field = caml_copy_int32(pcitopology_c->node);
		Store_field(pcitopology_ocaml, 3, pcitopology_field);
	}
	CAMLreturn(pcitopology_ocaml);
}

/* Get the defaults for pcitopology */
value stub_libxl_pcitopology_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_pcitopology c_val;
	libxl_pcitopology_init(&c_val);
	val = Val_pcitopology(&c_val);
	libxl_pcitopology_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to sched_credit_params */
static int sched_credit_params_val (libxl_ctx *ctx, libxl_sched_credit_params *c_val, value v)
{
	CAMLparam1(v);

	c_val->tslice_ms = Int_val(Field(v, 0));
	c_val->ratelimit_us = Int_val(Field(v, 1));
	c_val->vcpu_migr_delay_us = Int_val(Field(v, 2));
	
	CAMLreturn(0);
}

/* Convert sched_credit_params to a caml value */
static value Val_sched_credit_params (libxl_sched_credit_params *sched_credit_params_c)
{
	CAMLparam0();
	CAMLlocal1(sched_credit_params_ocaml);
	{
		CAMLlocal1(sched_credit_params_field);
	
		sched_credit_params_ocaml = caml_alloc_tuple(3);
	
		sched_credit_params_field = Val_int(sched_credit_params_c->tslice_ms);
		Store_field(sched_credit_params_ocaml, 0, sched_credit_params_field);
	
		sched_credit_params_field = Val_int(sched_credit_params_c->ratelimit_us);
		Store_field(sched_credit_params_ocaml, 1, sched_credit_params_field);
	
		sched_credit_params_field = Val_int(sched_credit_params_c->vcpu_migr_delay_us);
		Store_field(sched_credit_params_ocaml, 2, sched_credit_params_field);
	}
	CAMLreturn(sched_credit_params_ocaml);
}

/* Get the defaults for sched_credit_params */
value stub_libxl_sched_credit_params_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_sched_credit_params c_val;
	libxl_sched_credit_params_init(&c_val);
	val = Val_sched_credit_params(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to sched_credit2_params */
static int sched_credit2_params_val (libxl_ctx *ctx, libxl_sched_credit2_params *c_val, value v)
{
	CAMLparam1(v);

	c_val->ratelimit_us = Int_val(Field(v, 0));
	
	CAMLreturn(0);
}

/* Convert sched_credit2_params to a caml value */
static value Val_sched_credit2_params (libxl_sched_credit2_params *sched_credit2_params_c)
{
	CAMLparam0();
	CAMLlocal1(sched_credit2_params_ocaml);
	{
		CAMLlocal1(sched_credit2_params_field);
	
		sched_credit2_params_ocaml = caml_alloc_tuple(1);
	
		sched_credit2_params_field = Val_int(sched_credit2_params_c->ratelimit_us);
		Store_field(sched_credit2_params_ocaml, 0, sched_credit2_params_field);
	}
	CAMLreturn(sched_credit2_params_ocaml);
}

/* Get the defaults for sched_credit2_params */
value stub_libxl_sched_credit2_params_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_sched_credit2_params c_val;
	libxl_sched_credit2_params_init(&c_val);
	val = Val_sched_credit2_params(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to domain_remus_info */
static int domain_remus_info_val (libxl_ctx *ctx, libxl_domain_remus_info *c_val, value v)
{
	CAMLparam1(v);

	c_val->interval = Int_val(Field(v, 0));
	c_val->allow_unsafe = Defbool_val(Field(v, 1));
	c_val->blackhole = Defbool_val(Field(v, 2));
	c_val->compression = Defbool_val(Field(v, 3));
	c_val->netbuf = Defbool_val(Field(v, 4));
	c_val->netbufscript = String_option_val(Field(v, 5));
	c_val->diskbuf = Defbool_val(Field(v, 6));
	c_val->colo = Defbool_val(Field(v, 7));
	c_val->userspace_colo_proxy = Defbool_val(Field(v, 8));
	
	CAMLreturn(0);
}

/* Convert domain_remus_info to a caml value */
static value Val_domain_remus_info (libxl_domain_remus_info *domain_remus_info_c)
{
	CAMLparam0();
	CAMLlocal1(domain_remus_info_ocaml);
	{
		CAMLlocal1(domain_remus_info_field);
	
		domain_remus_info_ocaml = caml_alloc_tuple(9);
	
		domain_remus_info_field = Val_int(domain_remus_info_c->interval);
		Store_field(domain_remus_info_ocaml, 0, domain_remus_info_field);
	
		domain_remus_info_field = Val_defbool(domain_remus_info_c->allow_unsafe);
		Store_field(domain_remus_info_ocaml, 1, domain_remus_info_field);
	
		domain_remus_info_field = Val_defbool(domain_remus_info_c->blackhole);
		Store_field(domain_remus_info_ocaml, 2, domain_remus_info_field);
	
		domain_remus_info_field = Val_defbool(domain_remus_info_c->compression);
		Store_field(domain_remus_info_ocaml, 3, domain_remus_info_field);
	
		domain_remus_info_field = Val_defbool(domain_remus_info_c->netbuf);
		Store_field(domain_remus_info_ocaml, 4, domain_remus_info_field);
	
		domain_remus_info_field = Val_string_option(domain_remus_info_c->netbufscript);
		Store_field(domain_remus_info_ocaml, 5, domain_remus_info_field);
	
		domain_remus_info_field = Val_defbool(domain_remus_info_c->diskbuf);
		Store_field(domain_remus_info_ocaml, 6, domain_remus_info_field);
	
		domain_remus_info_field = Val_defbool(domain_remus_info_c->colo);
		Store_field(domain_remus_info_ocaml, 7, domain_remus_info_field);
	
		domain_remus_info_field = Val_defbool(domain_remus_info_c->userspace_colo_proxy);
		Store_field(domain_remus_info_ocaml, 8, domain_remus_info_field);
	}
	CAMLreturn(domain_remus_info_ocaml);
}

/* Get the defaults for domain_remus_info */
value stub_libxl_domain_remus_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_domain_remus_info c_val;
	libxl_domain_remus_info_init(&c_val);
	val = Val_domain_remus_info(&c_val);
	libxl_domain_remus_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to event_type */
static int event_type_val (libxl_ctx *ctx, libxl_event_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN; break;
	    case 1: *c_val = LIBXL_EVENT_TYPE_DOMAIN_DEATH; break;
	    case 2: *c_val = LIBXL_EVENT_TYPE_DISK_EJECT; break;
	    case 3: *c_val = LIBXL_EVENT_TYPE_OPERATION_COMPLETE; break;
	    case 4: *c_val = LIBXL_EVENT_TYPE_DOMAIN_CREATE_CONSOLE_AVAILABLE; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_event_type"); break;
	}
	CAMLreturn(0);
}

/* Convert event_type to a caml value */
static value Val_event_type (libxl_event_type event_type_c)
{
	CAMLparam0();
	CAMLlocal1(event_type_ocaml);
	switch(event_type_c) {
	    case LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN: event_type_ocaml = Val_int(0); break;
	    case LIBXL_EVENT_TYPE_DOMAIN_DEATH: event_type_ocaml = Val_int(1); break;
	    case LIBXL_EVENT_TYPE_DISK_EJECT: event_type_ocaml = Val_int(2); break;
	    case LIBXL_EVENT_TYPE_OPERATION_COMPLETE: event_type_ocaml = Val_int(3); break;
	    case LIBXL_EVENT_TYPE_DOMAIN_CREATE_CONSOLE_AVAILABLE: event_type_ocaml = Val_int(4); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_event_type"); break;
	}
	CAMLreturn(event_type_ocaml);
}

/* Convert caml value to event */
static int event_val (libxl_ctx *ctx, libxl_event *c_val, value v)
{
	CAMLparam1(v);

	c_val->domid = Int_val(Field(v, 0));
	Uuid_val(&c_val->domuuid, Field(v, 1));
	c_val->for_user = Int64_val(Field(v, 2));
	{
		if(Is_long(Field(v, 3))) {
			switch(Int_val(Field(v, 3))) {
			    case 0: c_val->type = LIBXL_EVENT_TYPE_DOMAIN_DEATH; break;
			    case 1: c_val->type = LIBXL_EVENT_TYPE_DOMAIN_CREATE_CONSOLE_AVAILABLE; break;
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->type (long)"); break;
			}
		} else {
			/* Is block... */
			switch(Tag_val(Field(v, 3))) {
			    case 0:
			        c_val->type = LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN;
			        c_val->u.domain_shutdown.shutdown_reason = Int_val(Field(Field(Field(v, 3), 0), 0));
			        break;
			    case 1:
			        c_val->type = LIBXL_EVENT_TYPE_DISK_EJECT;
			        c_val->u.disk_eject.vdev = String_option_val(Field(Field(Field(v, 3), 0), 0));
			        device_disk_val(ctx, &c_val->u.disk_eject.disk, Field(Field(Field(v, 3), 0), 1));
			        break;
			    case 2:
			        c_val->type = LIBXL_EVENT_TYPE_OPERATION_COMPLETE;
			        c_val->u.operation_complete.rc = Int_val(Field(Field(Field(v, 3), 0), 0));
			        break;
			    default: failwith_xl(ERROR_FAIL, "variant handling bug c_val->type (block)"); break;
			}
		}
	}
	
	CAMLreturn(0);
}

/* Convert event to a caml value */
static value Val_event (libxl_event *event_c)
{
	CAMLparam0();
	CAMLlocal1(event_ocaml);
	{
		CAMLlocal1(event_field);
	
		event_ocaml = caml_alloc_tuple(5);
	
		event_field = Val_int(event_c->domid);
		Store_field(event_ocaml, 0, event_field);
	
		event_field = Val_uuid(&event_c->domuuid);
		Store_field(event_ocaml, 1, event_field);
	
		event_field = caml_copy_int64(event_c->for_user);
		Store_field(event_ocaml, 2, event_field);
	
		switch(event_c->type) {
		    case LIBXL_EVENT_TYPE_DOMAIN_SHUTDOWN:
		        /* 0: Block */
		        {
			        CAMLlocal1(tmp);
			        event_field = caml_alloc(1,0);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(1);
			        
			        	anon_field = Val_int(event_c->u.domain_shutdown.shutdown_reason);
			        	Store_field(tmp, 0, anon_field);
			        }
			        Store_field(event_field, 0, tmp);
		        }
		        break;
		    case LIBXL_EVENT_TYPE_DOMAIN_DEATH:
		        /* 0: None */
		        event_field = Val_long(0);
		        break;
		    case LIBXL_EVENT_TYPE_DISK_EJECT:
		        /* 1: Block */
		        {
			        CAMLlocal1(tmp);
			        event_field = caml_alloc(1,1);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(2);
			        
			        	anon_field = Val_string_option(event_c->u.disk_eject.vdev);
			        	Store_field(tmp, 0, anon_field);
			        
			        	anon_field = Val_device_disk(&event_c->u.disk_eject.disk);
			        	Store_field(tmp, 1, anon_field);
			        }
			        Store_field(event_field, 0, tmp);
		        }
		        break;
		    case LIBXL_EVENT_TYPE_OPERATION_COMPLETE:
		        /* 2: Block */
		        {
			        CAMLlocal1(tmp);
			        event_field = caml_alloc(1,2);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(1);
			        
			        	anon_field = Val_int(event_c->u.operation_complete.rc);
			        	Store_field(tmp, 0, anon_field);
			        }
			        Store_field(event_field, 0, tmp);
		        }
		        break;
		    case LIBXL_EVENT_TYPE_DOMAIN_CREATE_CONSOLE_AVAILABLE:
		        /* 1: None */
		        event_field = Val_long(1);
		        break;
		    default: failwith_xl(ERROR_FAIL, "cannot convert value from None"); break;
		}
		Store_field(event_ocaml, 3, event_field);
	}
	CAMLreturn(event_ocaml);
}

/* Get the defaults for event */
value stub_libxl_event_init(value ctx, value type, value unit)
{
	CAMLparam3(ctx, type, unit);
	CAMLlocal1(val);
	libxl_event c_val;
	libxl_event_init(&c_val);
	if (type != Val_none) {
		libxl_event_type c = 0;
		event_type_val(CTX, &c, Some_val(type));
		libxl_event_init_type(&c_val, c);
	}
	val = Val_event(&c_val);
	libxl_event_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to psr_cmt_type */
static int psr_cmt_type_val (libxl_ctx *ctx, libxl_psr_cmt_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_PSR_CMT_TYPE_CACHE_OCCUPANCY; break;
	    case 1: *c_val = LIBXL_PSR_CMT_TYPE_TOTAL_MEM_COUNT; break;
	    case 2: *c_val = LIBXL_PSR_CMT_TYPE_LOCAL_MEM_COUNT; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_psr_cmt_type"); break;
	}
	CAMLreturn(0);
}

/* Convert psr_cmt_type to a caml value */
static value Val_psr_cmt_type (libxl_psr_cmt_type psr_cmt_type_c)
{
	CAMLparam0();
	CAMLlocal1(psr_cmt_type_ocaml);
	switch(psr_cmt_type_c) {
	    case LIBXL_PSR_CMT_TYPE_CACHE_OCCUPANCY: psr_cmt_type_ocaml = Val_int(0); break;
	    case LIBXL_PSR_CMT_TYPE_TOTAL_MEM_COUNT: psr_cmt_type_ocaml = Val_int(1); break;
	    case LIBXL_PSR_CMT_TYPE_LOCAL_MEM_COUNT: psr_cmt_type_ocaml = Val_int(2); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_psr_cmt_type"); break;
	}
	CAMLreturn(psr_cmt_type_ocaml);
}

/* Convert caml value to psr_cbm_type */
static int psr_cbm_type_val (libxl_ctx *ctx, libxl_psr_cbm_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_PSR_CBM_TYPE_UNKNOWN; break;
	    case 1: *c_val = LIBXL_PSR_CBM_TYPE_L3_CBM; break;
	    case 2: *c_val = LIBXL_PSR_CBM_TYPE_L3_CBM_CODE; break;
	    case 3: *c_val = LIBXL_PSR_CBM_TYPE_L3_CBM_DATA; break;
	    case 4: *c_val = LIBXL_PSR_CBM_TYPE_L2_CBM; break;
	    case 5: *c_val = LIBXL_PSR_CBM_TYPE_MBA_THRTL; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_psr_cbm_type"); break;
	}
	CAMLreturn(0);
}

/* Convert psr_cbm_type to a caml value */
static value Val_psr_cbm_type (libxl_psr_cbm_type psr_cbm_type_c)
{
	CAMLparam0();
	CAMLlocal1(psr_cbm_type_ocaml);
	switch(psr_cbm_type_c) {
	    case LIBXL_PSR_CBM_TYPE_UNKNOWN: psr_cbm_type_ocaml = Val_int(0); break;
	    case LIBXL_PSR_CBM_TYPE_L3_CBM: psr_cbm_type_ocaml = Val_int(1); break;
	    case LIBXL_PSR_CBM_TYPE_L3_CBM_CODE: psr_cbm_type_ocaml = Val_int(2); break;
	    case LIBXL_PSR_CBM_TYPE_L3_CBM_DATA: psr_cbm_type_ocaml = Val_int(3); break;
	    case LIBXL_PSR_CBM_TYPE_L2_CBM: psr_cbm_type_ocaml = Val_int(4); break;
	    case LIBXL_PSR_CBM_TYPE_MBA_THRTL: psr_cbm_type_ocaml = Val_int(5); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_psr_cbm_type"); break;
	}
	CAMLreturn(psr_cbm_type_ocaml);
}

/* Convert caml value to psr_cat_info */
static int psr_cat_info_val (libxl_ctx *ctx, libxl_psr_cat_info *c_val, value v)
{
	CAMLparam1(v);

	c_val->id = Int32_val(Field(v, 0));
	c_val->cos_max = Int32_val(Field(v, 1));
	c_val->cbm_len = Int32_val(Field(v, 2));
	c_val->cdp_enabled = Bool_val(Field(v, 3));
	
	CAMLreturn(0);
}

/* Convert psr_cat_info to a caml value */
static value Val_psr_cat_info (libxl_psr_cat_info *psr_cat_info_c)
{
	CAMLparam0();
	CAMLlocal1(psr_cat_info_ocaml);
	{
		CAMLlocal1(psr_cat_info_field);
	
		psr_cat_info_ocaml = caml_alloc_tuple(4);
	
		psr_cat_info_field = caml_copy_int32(psr_cat_info_c->id);
		Store_field(psr_cat_info_ocaml, 0, psr_cat_info_field);
	
		psr_cat_info_field = caml_copy_int32(psr_cat_info_c->cos_max);
		Store_field(psr_cat_info_ocaml, 1, psr_cat_info_field);
	
		psr_cat_info_field = caml_copy_int32(psr_cat_info_c->cbm_len);
		Store_field(psr_cat_info_ocaml, 2, psr_cat_info_field);
	
		psr_cat_info_field = Val_bool(psr_cat_info_c->cdp_enabled);
		Store_field(psr_cat_info_ocaml, 3, psr_cat_info_field);
	}
	CAMLreturn(psr_cat_info_ocaml);
}

/* Get the defaults for psr_cat_info */
value stub_libxl_psr_cat_info_init(value ctx, value unit)
{
	CAMLparam2(ctx, unit);
	CAMLlocal1(val);
	libxl_psr_cat_info c_val;
	libxl_psr_cat_info_init(&c_val);
	val = Val_psr_cat_info(&c_val);
	libxl_psr_cat_info_dispose(&c_val);
	CAMLreturn(val);
}

/* Convert caml value to psr_feat_type */
static int psr_feat_type_val (libxl_ctx *ctx, libxl_psr_feat_type *c_val, value v)
{
	CAMLparam1(v);

	switch(Int_val(v)) {
	    case 0: *c_val = LIBXL_PSR_FEAT_TYPE_CAT; break;
	    case 1: *c_val = LIBXL_PSR_FEAT_TYPE_MBA; break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value to libxl_psr_feat_type"); break;
	}
	CAMLreturn(0);
}

/* Convert psr_feat_type to a caml value */
static value Val_psr_feat_type (libxl_psr_feat_type psr_feat_type_c)
{
	CAMLparam0();
	CAMLlocal1(psr_feat_type_ocaml);
	switch(psr_feat_type_c) {
	    case LIBXL_PSR_FEAT_TYPE_CAT: psr_feat_type_ocaml = Val_int(0); break;
	    case LIBXL_PSR_FEAT_TYPE_MBA: psr_feat_type_ocaml = Val_int(1); break;
	    default: failwith_xl(ERROR_FAIL, "cannot convert value from libxl_psr_feat_type"); break;
	}
	CAMLreturn(psr_feat_type_ocaml);
}

/* Convert psr_hw_info to a caml value */
static value Val_psr_hw_info (libxl_psr_hw_info *psr_hw_info_c)
{
	CAMLparam0();
	CAMLlocal1(psr_hw_info_ocaml);
	{
		CAMLlocal1(psr_hw_info_field);
	
		psr_hw_info_ocaml = caml_alloc_tuple(2);
	
		psr_hw_info_field = caml_copy_int32(psr_hw_info_c->id);
		Store_field(psr_hw_info_ocaml, 0, psr_hw_info_field);
	
		switch(psr_hw_info_c->type) {
		    case LIBXL_PSR_FEAT_TYPE_CAT:
		        /* 0: Block */
		        {
			        CAMLlocal1(tmp);
			        psr_hw_info_field = caml_alloc(1,0);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(3);
			        
			        	anon_field = caml_copy_int32(psr_hw_info_c->u.cat.cos_max);
			        	Store_field(tmp, 0, anon_field);
			        
			        	anon_field = caml_copy_int32(psr_hw_info_c->u.cat.cbm_len);
			        	Store_field(tmp, 1, anon_field);
			        
			        	anon_field = Val_bool(psr_hw_info_c->u.cat.cdp_enabled);
			        	Store_field(tmp, 2, anon_field);
			        }
			        Store_field(psr_hw_info_field, 0, tmp);
		        }
		        break;
		    case LIBXL_PSR_FEAT_TYPE_MBA:
		        /* 1: Block */
		        {
			        CAMLlocal1(tmp);
			        psr_hw_info_field = caml_alloc(1,1);
			        {
			        	CAMLlocal1(anon_field);
			        
			        	tmp = caml_alloc_tuple(3);
			        
			        	anon_field = caml_copy_int32(psr_hw_info_c->u.mba.cos_max);
			        	Store_field(tmp, 0, anon_field);
			        
			        	anon_field = caml_copy_int32(psr_hw_info_c->u.mba.thrtl_max);
			        	Store_field(tmp, 1, anon_field);
			        
			        	anon_field = Val_bool(psr_hw_info_c->u.mba.linear);
			        	Store_field(tmp, 2, anon_field);
			        }
			        Store_field(psr_hw_info_field, 0, tmp);
		        }
		        break;
		    default: failwith_xl(ERROR_FAIL, "cannot convert value from None"); break;
		}
		Store_field(psr_hw_info_ocaml, 1, psr_hw_info_field);
	}
	CAMLreturn(psr_hw_info_ocaml);
}

/* Get the defaults for psr_hw_info */
value stub_libxl_psr_hw_info_init(value ctx, value type, value unit)
{
	CAMLparam3(ctx, type, unit);
	CAMLlocal1(val);
	libxl_psr_hw_info c_val;
	libxl_psr_hw_info_init(&c_val);
	if (type != Val_none) {
		libxl_psr_feat_type c = 0;
		psr_feat_type_val(CTX, &c, Some_val(type));
		libxl_psr_hw_info_init_type(&c_val, c);
	}
	val = Val_psr_hw_info(&c_val);
	libxl_psr_hw_info_dispose(&c_val);
	CAMLreturn(val);
}

