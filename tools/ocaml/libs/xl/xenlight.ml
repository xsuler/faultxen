(*
 * AUTO-GENERATED FILE DO NOT EDIT
 * Generated from xenlight.ml.in and _libxl_types.ml.in
 *)

(*
 * Copyright (C) 2009-2011 Citrix Ltd.
 * Author Vincent Hanquez <vincent.hanquez@eu.citrix.com>
 *
 * This program is free software; you can redistribute it and/or modify
 * it under the terms of the GNU Lesser General Public License as published
 * by the Free Software Foundation; version 2.1 only. with the special
 * exception on linking described in file LICENSE.
 *
 * This program is distributed in the hope that it will be useful,
 * but WITHOUT ANY WARRANTY; without even the implied warranty of
 * MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
 * GNU Lesser General Public License for more details.
 *)

type ctx
type domid = int
type devid = int

(* @@LIBXL_TYPES@@ *)
(* AUTO-GENERATED FILE DO NOT EDIT *)
(* autogenerated by 
   genwrap.py /root/tm/faultxen/tools/ocaml/libs/xl/../../../../tools/libxl/libxl_types.idl _libxl_types.mli.in _libxl_types.ml.in _libxl_types.inc
 *)

(* libxl_error implementation *)
type error = 
	 | ERROR_NONSPECIFIC
	 | ERROR_VERSION
	 | ERROR_FAIL
	 | ERROR_NI
	 | ERROR_NOMEM
	 | ERROR_INVAL
	 | ERROR_BADFAIL
	 | ERROR_GUEST_TIMEDOUT
	 | ERROR_TIMEDOUT
	 | ERROR_NOPARAVIRT
	 | ERROR_NOT_READY
	 | ERROR_OSEVENT_REG_FAIL
	 | ERROR_BUFFERFULL
	 | ERROR_UNKNOWN_CHILD
	 | ERROR_LOCK_FAIL
	 | ERROR_JSON_CONFIG_EMPTY
	 | ERROR_DEVICE_EXISTS
	 | ERROR_CHECKPOINT_DEVOPS_DOES_NOT_MATCH
	 | ERROR_CHECKPOINT_DEVICE_NOT_SUPPORTED
	 | ERROR_VNUMA_CONFIG_INVALID
	 | ERROR_DOMAIN_NOTFOUND
	 | ERROR_ABORTED
	 | ERROR_NOTFOUND
	 | ERROR_DOMAIN_DESTROYED
	 | ERROR_FEATURE_REMOVED
	 | ERROR_PROTOCOL_ERROR_QMP
	 | ERROR_UNKNOWN_QMP_ERROR
	 | ERROR_QMP_GENERIC_ERROR
	 | ERROR_QMP_COMMAND_NOT_FOUND
	 | ERROR_QMP_DEVICE_NOT_ACTIVE
	 | ERROR_QMP_DEVICE_NOT_FOUND
	 | ERROR_QEMU_API

let string_of_error = function
	| ERROR_NONSPECIFIC -> "NONSPECIFIC"
	| ERROR_VERSION -> "VERSION"
	| ERROR_FAIL -> "FAIL"
	| ERROR_NI -> "NI"
	| ERROR_NOMEM -> "NOMEM"
	| ERROR_INVAL -> "INVAL"
	| ERROR_BADFAIL -> "BADFAIL"
	| ERROR_GUEST_TIMEDOUT -> "GUEST_TIMEDOUT"
	| ERROR_TIMEDOUT -> "TIMEDOUT"
	| ERROR_NOPARAVIRT -> "NOPARAVIRT"
	| ERROR_NOT_READY -> "NOT_READY"
	| ERROR_OSEVENT_REG_FAIL -> "OSEVENT_REG_FAIL"
	| ERROR_BUFFERFULL -> "BUFFERFULL"
	| ERROR_UNKNOWN_CHILD -> "UNKNOWN_CHILD"
	| ERROR_LOCK_FAIL -> "LOCK_FAIL"
	| ERROR_JSON_CONFIG_EMPTY -> "JSON_CONFIG_EMPTY"
	| ERROR_DEVICE_EXISTS -> "DEVICE_EXISTS"
	| ERROR_CHECKPOINT_DEVOPS_DOES_NOT_MATCH -> "CHECKPOINT_DEVOPS_DOES_NOT_MATCH"
	| ERROR_CHECKPOINT_DEVICE_NOT_SUPPORTED -> "CHECKPOINT_DEVICE_NOT_SUPPORTED"
	| ERROR_VNUMA_CONFIG_INVALID -> "VNUMA_CONFIG_INVALID"
	| ERROR_DOMAIN_NOTFOUND -> "DOMAIN_NOTFOUND"
	| ERROR_ABORTED -> "ABORTED"
	| ERROR_NOTFOUND -> "NOTFOUND"
	| ERROR_DOMAIN_DESTROYED -> "DOMAIN_DESTROYED"
	| ERROR_FEATURE_REMOVED -> "FEATURE_REMOVED"
	| ERROR_PROTOCOL_ERROR_QMP -> "PROTOCOL_ERROR_QMP"
	| ERROR_UNKNOWN_QMP_ERROR -> "UNKNOWN_QMP_ERROR"
	| ERROR_QMP_GENERIC_ERROR -> "QMP_GENERIC_ERROR"
	| ERROR_QMP_COMMAND_NOT_FOUND -> "QMP_COMMAND_NOT_FOUND"
	| ERROR_QMP_DEVICE_NOT_ACTIVE -> "QMP_DEVICE_NOT_ACTIVE"
	| ERROR_QMP_DEVICE_NOT_FOUND -> "QMP_DEVICE_NOT_FOUND"
	| ERROR_QEMU_API -> "QEMU_API"

(* libxl_domain_type implementation *)
type domain_type = 
	 | DOMAIN_TYPE_INVALID
	 | DOMAIN_TYPE_HVM
	 | DOMAIN_TYPE_PV
	 | DOMAIN_TYPE_PVH

let string_of_domain_type = function
	| DOMAIN_TYPE_INVALID -> "INVALID"
	| DOMAIN_TYPE_HVM -> "HVM"
	| DOMAIN_TYPE_PV -> "PV"
	| DOMAIN_TYPE_PVH -> "PVH"

(* libxl_rdm_reserve_strategy implementation *)
type rdm_reserve_strategy = 
	 | RDM_RESERVE_STRATEGY_IGNORE
	 | RDM_RESERVE_STRATEGY_HOST

let string_of_rdm_reserve_strategy = function
	| RDM_RESERVE_STRATEGY_IGNORE -> "IGNORE"
	| RDM_RESERVE_STRATEGY_HOST -> "HOST"

(* libxl_rdm_reserve_policy implementation *)
type rdm_reserve_policy = 
	 | RDM_RESERVE_POLICY_INVALID
	 | RDM_RESERVE_POLICY_STRICT
	 | RDM_RESERVE_POLICY_RELAXED

let string_of_rdm_reserve_policy = function
	| RDM_RESERVE_POLICY_INVALID -> "INVALID"
	| RDM_RESERVE_POLICY_STRICT -> "STRICT"
	| RDM_RESERVE_POLICY_RELAXED -> "RELAXED"

(* libxl_channel_connection implementation *)
type channel_connection = 
	 | CHANNEL_CONNECTION_UNKNOWN
	 | CHANNEL_CONNECTION_PTY
	 | CHANNEL_CONNECTION_SOCKET

let string_of_channel_connection = function
	| CHANNEL_CONNECTION_UNKNOWN -> "UNKNOWN"
	| CHANNEL_CONNECTION_PTY -> "PTY"
	| CHANNEL_CONNECTION_SOCKET -> "SOCKET"

(* libxl_device_model_version implementation *)
type device_model_version = 
	 | DEVICE_MODEL_VERSION_UNKNOWN
	 | DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL
	 | DEVICE_MODEL_VERSION_QEMU_XEN

let string_of_device_model_version = function
	| DEVICE_MODEL_VERSION_UNKNOWN -> "UNKNOWN"
	| DEVICE_MODEL_VERSION_QEMU_XEN_TRADITIONAL -> "QEMU_XEN_TRADITIONAL"
	| DEVICE_MODEL_VERSION_QEMU_XEN -> "QEMU_XEN"

(* libxl_console_type implementation *)
type console_type = 
	 | CONSOLE_TYPE_UNKNOWN
	 | CONSOLE_TYPE_SERIAL
	 | CONSOLE_TYPE_PV
	 | CONSOLE_TYPE_VUART

let string_of_console_type = function
	| CONSOLE_TYPE_UNKNOWN -> "UNKNOWN"
	| CONSOLE_TYPE_SERIAL -> "SERIAL"
	| CONSOLE_TYPE_PV -> "PV"
	| CONSOLE_TYPE_VUART -> "VUART"

(* libxl_disk_format implementation *)
type disk_format = 
	 | DISK_FORMAT_UNKNOWN
	 | DISK_FORMAT_QCOW
	 | DISK_FORMAT_QCOW2
	 | DISK_FORMAT_VHD
	 | DISK_FORMAT_RAW
	 | DISK_FORMAT_EMPTY
	 | DISK_FORMAT_QED

let string_of_disk_format = function
	| DISK_FORMAT_UNKNOWN -> "UNKNOWN"
	| DISK_FORMAT_QCOW -> "QCOW"
	| DISK_FORMAT_QCOW2 -> "QCOW2"
	| DISK_FORMAT_VHD -> "VHD"
	| DISK_FORMAT_RAW -> "RAW"
	| DISK_FORMAT_EMPTY -> "EMPTY"
	| DISK_FORMAT_QED -> "QED"

(* libxl_disk_backend implementation *)
type disk_backend = 
	 | DISK_BACKEND_UNKNOWN
	 | DISK_BACKEND_PHY
	 | DISK_BACKEND_TAP
	 | DISK_BACKEND_QDISK

let string_of_disk_backend = function
	| DISK_BACKEND_UNKNOWN -> "UNKNOWN"
	| DISK_BACKEND_PHY -> "PHY"
	| DISK_BACKEND_TAP -> "TAP"
	| DISK_BACKEND_QDISK -> "QDISK"

(* libxl_nic_type implementation *)
type nic_type = 
	 | NIC_TYPE_UNKNOWN
	 | NIC_TYPE_VIF_IOEMU
	 | NIC_TYPE_VIF

let string_of_nic_type = function
	| NIC_TYPE_UNKNOWN -> "UNKNOWN"
	| NIC_TYPE_VIF_IOEMU -> "VIF_IOEMU"
	| NIC_TYPE_VIF -> "VIF"

(* libxl_action_on_shutdown implementation *)
type action_on_shutdown = 
	 | ACTION_ON_SHUTDOWN_DESTROY
	 | ACTION_ON_SHUTDOWN_RESTART
	 | ACTION_ON_SHUTDOWN_RESTART_RENAME
	 | ACTION_ON_SHUTDOWN_PRESERVE
	 | ACTION_ON_SHUTDOWN_COREDUMP_DESTROY
	 | ACTION_ON_SHUTDOWN_COREDUMP_RESTART
	 | ACTION_ON_SHUTDOWN_SOFT_RESET

let string_of_action_on_shutdown = function
	| ACTION_ON_SHUTDOWN_DESTROY -> "DESTROY"
	| ACTION_ON_SHUTDOWN_RESTART -> "RESTART"
	| ACTION_ON_SHUTDOWN_RESTART_RENAME -> "RESTART_RENAME"
	| ACTION_ON_SHUTDOWN_PRESERVE -> "PRESERVE"
	| ACTION_ON_SHUTDOWN_COREDUMP_DESTROY -> "COREDUMP_DESTROY"
	| ACTION_ON_SHUTDOWN_COREDUMP_RESTART -> "COREDUMP_RESTART"
	| ACTION_ON_SHUTDOWN_SOFT_RESET -> "SOFT_RESET"

(* libxl_trigger implementation *)
type trigger = 
	 | TRIGGER_UNKNOWN
	 | TRIGGER_POWER
	 | TRIGGER_SLEEP
	 | TRIGGER_NMI
	 | TRIGGER_INIT
	 | TRIGGER_RESET
	 | TRIGGER_S3RESUME

let string_of_trigger = function
	| TRIGGER_UNKNOWN -> "UNKNOWN"
	| TRIGGER_POWER -> "POWER"
	| TRIGGER_SLEEP -> "SLEEP"
	| TRIGGER_NMI -> "NMI"
	| TRIGGER_INIT -> "INIT"
	| TRIGGER_RESET -> "RESET"
	| TRIGGER_S3RESUME -> "S3RESUME"

(* libxl_tsc_mode implementation *)
type tsc_mode = 
	 | TSC_MODE_DEFAULT
	 | TSC_MODE_ALWAYS_EMULATE
	 | TSC_MODE_NATIVE
	 | TSC_MODE_NATIVE_PARAVIRT

let string_of_tsc_mode = function
	| TSC_MODE_DEFAULT -> "DEFAULT"
	| TSC_MODE_ALWAYS_EMULATE -> "ALWAYS_EMULATE"
	| TSC_MODE_NATIVE -> "NATIVE"
	| TSC_MODE_NATIVE_PARAVIRT -> "NATIVE_PARAVIRT"

(* libxl_gfx_passthru_kind implementation *)
type gfx_passthru_kind = 
	 | GFX_PASSTHRU_KIND_DEFAULT
	 | GFX_PASSTHRU_KIND_IGD

let string_of_gfx_passthru_kind = function
	| GFX_PASSTHRU_KIND_DEFAULT -> "DEFAULT"
	| GFX_PASSTHRU_KIND_IGD -> "IGD"

(* libxl_timer_mode implementation *)
type timer_mode = 
	 | TIMER_MODE_UNKNOWN
	 | TIMER_MODE_DELAY_FOR_MISSED_TICKS
	 | TIMER_MODE_NO_DELAY_FOR_MISSED_TICKS
	 | TIMER_MODE_NO_MISSED_TICKS_PENDING
	 | TIMER_MODE_ONE_MISSED_TICK_PENDING

let string_of_timer_mode = function
	| TIMER_MODE_UNKNOWN -> "UNKNOWN"
	| TIMER_MODE_DELAY_FOR_MISSED_TICKS -> "DELAY_FOR_MISSED_TICKS"
	| TIMER_MODE_NO_DELAY_FOR_MISSED_TICKS -> "NO_DELAY_FOR_MISSED_TICKS"
	| TIMER_MODE_NO_MISSED_TICKS_PENDING -> "NO_MISSED_TICKS_PENDING"
	| TIMER_MODE_ONE_MISSED_TICK_PENDING -> "ONE_MISSED_TICK_PENDING"

(* libxl_bios_type implementation *)
type bios_type = 
	 | BIOS_TYPE_UNKNOWN
	 | BIOS_TYPE_ROMBIOS
	 | BIOS_TYPE_SEABIOS
	 | BIOS_TYPE_OVMF

let string_of_bios_type = function
	| BIOS_TYPE_UNKNOWN -> "UNKNOWN"
	| BIOS_TYPE_ROMBIOS -> "ROMBIOS"
	| BIOS_TYPE_SEABIOS -> "SEABIOS"
	| BIOS_TYPE_OVMF -> "OVMF"

(* libxl_scheduler implementation *)
type scheduler = 
	 | SCHEDULER_UNKNOWN
	 | SCHEDULER_SEDF
	 | SCHEDULER_CREDIT
	 | SCHEDULER_CREDIT2
	 | SCHEDULER_ARINC653
	 | SCHEDULER_RTDS
	 | SCHEDULER_NULL

let string_of_scheduler = function
	| SCHEDULER_UNKNOWN -> "UNKNOWN"
	| SCHEDULER_SEDF -> "SEDF"
	| SCHEDULER_CREDIT -> "CREDIT"
	| SCHEDULER_CREDIT2 -> "CREDIT2"
	| SCHEDULER_ARINC653 -> "ARINC653"
	| SCHEDULER_RTDS -> "RTDS"
	| SCHEDULER_NULL -> "NULL"

(* libxl_shutdown_reason implementation *)
type shutdown_reason = 
	 | SHUTDOWN_REASON_UNKNOWN
	 | SHUTDOWN_REASON_POWEROFF
	 | SHUTDOWN_REASON_REBOOT
	 | SHUTDOWN_REASON_SUSPEND
	 | SHUTDOWN_REASON_CRASH
	 | SHUTDOWN_REASON_WATCHDOG
	 | SHUTDOWN_REASON_SOFT_RESET

let string_of_shutdown_reason = function
	| SHUTDOWN_REASON_UNKNOWN -> "UNKNOWN"
	| SHUTDOWN_REASON_POWEROFF -> "POWEROFF"
	| SHUTDOWN_REASON_REBOOT -> "REBOOT"
	| SHUTDOWN_REASON_SUSPEND -> "SUSPEND"
	| SHUTDOWN_REASON_CRASH -> "CRASH"
	| SHUTDOWN_REASON_WATCHDOG -> "WATCHDOG"
	| SHUTDOWN_REASON_SOFT_RESET -> "SOFT_RESET"

(* libxl_vga_interface_type implementation *)
type vga_interface_type = 
	 | VGA_INTERFACE_TYPE_UNKNOWN
	 | VGA_INTERFACE_TYPE_CIRRUS
	 | VGA_INTERFACE_TYPE_STD
	 | VGA_INTERFACE_TYPE_NONE
	 | VGA_INTERFACE_TYPE_QXL

let string_of_vga_interface_type = function
	| VGA_INTERFACE_TYPE_UNKNOWN -> "UNKNOWN"
	| VGA_INTERFACE_TYPE_CIRRUS -> "CIRRUS"
	| VGA_INTERFACE_TYPE_STD -> "STD"
	| VGA_INTERFACE_TYPE_NONE -> "NONE"
	| VGA_INTERFACE_TYPE_QXL -> "QXL"

(* libxl_vendor_device implementation *)
type vendor_device = 
	 | VENDOR_DEVICE_NONE
	 | VENDOR_DEVICE_XENSERVER

let string_of_vendor_device = function
	| VENDOR_DEVICE_NONE -> "NONE"
	| VENDOR_DEVICE_XENSERVER -> "XENSERVER"

(* libxl_viridian_enlightenment implementation *)
type viridian_enlightenment = 
	 | VIRIDIAN_ENLIGHTENMENT_BASE
	 | VIRIDIAN_ENLIGHTENMENT_FREQ
	 | VIRIDIAN_ENLIGHTENMENT_TIME_REF_COUNT
	 | VIRIDIAN_ENLIGHTENMENT_REFERENCE_TSC
	 | VIRIDIAN_ENLIGHTENMENT_HCALL_REMOTE_TLB_FLUSH
	 | VIRIDIAN_ENLIGHTENMENT_APIC_ASSIST
	 | VIRIDIAN_ENLIGHTENMENT_CRASH_CTL
	 | VIRIDIAN_ENLIGHTENMENT_SYNIC
	 | VIRIDIAN_ENLIGHTENMENT_STIMER
	 | VIRIDIAN_ENLIGHTENMENT_HCALL_IPI

let string_of_viridian_enlightenment = function
	| VIRIDIAN_ENLIGHTENMENT_BASE -> "BASE"
	| VIRIDIAN_ENLIGHTENMENT_FREQ -> "FREQ"
	| VIRIDIAN_ENLIGHTENMENT_TIME_REF_COUNT -> "TIME_REF_COUNT"
	| VIRIDIAN_ENLIGHTENMENT_REFERENCE_TSC -> "REFERENCE_TSC"
	| VIRIDIAN_ENLIGHTENMENT_HCALL_REMOTE_TLB_FLUSH -> "HCALL_REMOTE_TLB_FLUSH"
	| VIRIDIAN_ENLIGHTENMENT_APIC_ASSIST -> "APIC_ASSIST"
	| VIRIDIAN_ENLIGHTENMENT_CRASH_CTL -> "CRASH_CTL"
	| VIRIDIAN_ENLIGHTENMENT_SYNIC -> "SYNIC"
	| VIRIDIAN_ENLIGHTENMENT_STIMER -> "STIMER"
	| VIRIDIAN_ENLIGHTENMENT_HCALL_IPI -> "HCALL_IPI"

(* libxl_hdtype implementation *)
type hdtype = 
	 | HDTYPE_IDE
	 | HDTYPE_AHCI

let string_of_hdtype = function
	| HDTYPE_IDE -> "IDE"
	| HDTYPE_AHCI -> "AHCI"

(* libxl_checkpointed_stream implementation *)
type checkpointed_stream = 
	 | CHECKPOINTED_STREAM_NONE
	 | CHECKPOINTED_STREAM_REMUS
	 | CHECKPOINTED_STREAM_COLO

let string_of_checkpointed_stream = function
	| CHECKPOINTED_STREAM_NONE -> "NONE"
	| CHECKPOINTED_STREAM_REMUS -> "REMUS"
	| CHECKPOINTED_STREAM_COLO -> "COLO"

(* libxl_vuart_type implementation *)
type vuart_type = 
	 | VUART_TYPE_UNKNOWN
	 | VUART_TYPE_SBSA_UART

let string_of_vuart_type = function
	| VUART_TYPE_UNKNOWN -> "UNKNOWN"
	| VUART_TYPE_SBSA_UART -> "SBSA_UART"

(* libxl_vkb_backend implementation *)
type vkb_backend = 
	 | VKB_BACKEND_UNKNOWN
	 | VKB_BACKEND_QEMU
	 | VKB_BACKEND_LINUX

let string_of_vkb_backend = function
	| VKB_BACKEND_UNKNOWN -> "UNKNOWN"
	| VKB_BACKEND_QEMU -> "QEMU"
	| VKB_BACKEND_LINUX -> "LINUX"

(* libxl_passthrough implementation *)
type passthrough = 
	 | PASSTHROUGH_DEFAULT
	 | PASSTHROUGH_DISABLED
	 | PASSTHROUGH_ENABLED
	 | PASSTHROUGH_SYNC_PT
	 | PASSTHROUGH_SHARE_PT

let string_of_passthrough = function
	| PASSTHROUGH_DEFAULT -> "DEFAULT"
	| PASSTHROUGH_DISABLED -> "DISABLED"
	| PASSTHROUGH_ENABLED -> "ENABLED"
	| PASSTHROUGH_SYNC_PT -> "SYNC_PT"
	| PASSTHROUGH_SHARE_PT -> "SHARE_PT"

(* libxl_ioport_range implementation *)
module Ioport_range = struct
	type t =
	{
		first : int32;
		number : int32;
	}
	external default : ctx -> unit -> t = "stub_libxl_ioport_range_init"
end

(* libxl_iomem_range implementation *)
module Iomem_range = struct
	type t =
	{
		start : int64;
		number : int64;
		gfn : int64;
	}
	external default : ctx -> unit -> t = "stub_libxl_iomem_range_init"
end

(* libxl_vga_interface_info implementation *)
module Vga_interface_info = struct
	type t =
	{
		kind : vga_interface_type;
	}
	external default : ctx -> unit -> t = "stub_libxl_vga_interface_info_init"
end

(* libxl_vnc_info implementation *)
module Vnc_info = struct
	type t =
	{
		enable : bool option;
		listen : string option;
		passwd : string option;
		display : int;
		findunused : bool option;
	}
	external default : ctx -> unit -> t = "stub_libxl_vnc_info_init"
end

(* libxl_spice_info implementation *)
module Spice_info = struct
	type t =
	{
		enable : bool option;
		port : int;
		tls_port : int;
		host : string option;
		disable_ticketing : bool option;
		passwd : string option;
		agent_mouse : bool option;
		vdagent : bool option;
		clipboard_sharing : bool option;
		usbredirection : int;
		image_compression : string option;
		streaming_video : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_spice_info_init"
end

(* libxl_sdl_info implementation *)
module Sdl_info = struct
	type t =
	{
		enable : bool option;
		opengl : bool option;
		display : string option;
		xauthority : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_sdl_info_init"
end

(* libxl_dominfo implementation *)
module Dominfo = struct
	type t =
	{
		uuid : int array;
		domid : domid;
		ssidref : int32;
		ssid_label : string option;
		running : bool;
		blocked : bool;
		paused : bool;
		shutdown : bool;
		dying : bool;
		never_stop : bool;
		shutdown_reason : shutdown_reason;
		outstanding_memkb : int64;
		current_memkb : int64;
		shared_memkb : int64;
		paged_memkb : int64;
		max_memkb : int64;
		cpu_time : int64;
		vcpu_max_id : int32;
		vcpu_online : int32;
		cpupool : int32;
		domain_type : domain_type;
	}
	external default : ctx -> unit -> t = "stub_libxl_dominfo_init"
	external list : ctx -> t list = "stub_xl_dominfo_list"
	external get : ctx -> domid -> t = "stub_xl_dominfo_get"
end

(* libxl_channelinfo implementation *)
module Channelinfo = struct

	type connection_pty =
	{
			path : string option;
	}
	
	type connection__union = Unknown | Pty of connection_pty | Socket
	
	type t =
	{
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		devid : devid;
		state : int;
		evtch : int;
		rref : int;
		connection : connection__union;
	}
	external default : ctx -> ?connection:channel_connection -> unit -> t = "stub_libxl_channelinfo_init"
end

(* libxl_vminfo implementation *)
module Vminfo = struct
	type t =
	{
		uuid : int array;
		domid : domid;
	}
	external default : ctx -> unit -> t = "stub_libxl_vminfo_init"
end

(* libxl_version_info implementation *)
module Version_info = struct
	type t =
	{
		xen_version_major : int;
		xen_version_minor : int;
		xen_version_extra : string option;
		compiler : string option;
		compile_by : string option;
		compile_domain : string option;
		compile_date : string option;
		capabilities : string option;
		changeset : string option;
		virt_start : int64;
		pagesize : int;
		commandline : string option;
		build_id : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_version_info_init"
end

(* libxl_domain_create_info implementation *)
module Domain_create_info = struct
	type t =
	{
		xl_type : domain_type;
		hap : bool option;
		oos : bool option;
		ssidref : int32;
		ssid_label : string option;
		name : string option;
		uuid : int array;
		xsdata : (string * string) list;
		platformdata : (string * string) list;
		poolid : int32;
		pool_name : string option;
		run_hotplug_scripts : bool option;
		driver_domain : bool option;
		passthrough : passthrough;
	}
	external default : ctx -> unit -> t = "stub_libxl_domain_create_info_init"
end

(* libxl_domain_restore_params implementation *)
module Domain_restore_params = struct
	type t =
	{
		checkpointed_stream : int;
		stream_version : int32;
		colo_proxy_script : string option;
		userspace_colo_proxy : bool option;
	}
	external default : ctx -> unit -> t = "stub_libxl_domain_restore_params_init"
end

(* libxl_sched_params implementation *)
module Sched_params = struct
	type t =
	{
		vcpuid : int;
		weight : int;
		cap : int;
		period : int;
		extratime : int;
		budget : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_sched_params_init"
end

(* libxl_vcpu_sched_params implementation *)
module Vcpu_sched_params = struct
	type t =
	{
		sched : scheduler;
		vcpus : Sched_params.t array;
	}
	external default : ctx -> unit -> t = "stub_libxl_vcpu_sched_params_init"
end

(* libxl_domain_sched_params implementation *)
module Domain_sched_params = struct
	type t =
	{
		sched : scheduler;
		weight : int;
		cap : int;
		period : int;
		budget : int;
		extratime : int;
		slice : int;
		latency : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_domain_sched_params_init"
	external get : ctx -> domid -> t = "stub_xl_domain_sched_params_get"
	external set : ctx -> domid -> t -> unit = "stub_xl_domain_sched_params_set"
end

(* libxl_vnode_info implementation *)
module Vnode_info = struct
	type t =
	{
		memkb : int64;
		distances : int32 array;
		pnode : int32;
		vcpus : bool array;
	}
	external default : ctx -> unit -> t = "stub_libxl_vnode_info_init"
end

(* libxl_gic_version implementation *)
type gic_version = 
	 | GIC_VERSION_DEFAULT
	 | GIC_VERSION_V2
	 | GIC_VERSION_V3

let string_of_gic_version = function
	| GIC_VERSION_DEFAULT -> "DEFAULT"
	| GIC_VERSION_V2 -> "V2"
	| GIC_VERSION_V3 -> "V3"

(* libxl_tee_type implementation *)
type tee_type = 
	 | TEE_TYPE_NONE
	 | TEE_TYPE_OPTEE

let string_of_tee_type = function
	| TEE_TYPE_NONE -> "NONE"
	| TEE_TYPE_OPTEE -> "OPTEE"

(* libxl_rdm_reserve implementation *)
module Rdm_reserve = struct
	type t =
	{
		strategy : rdm_reserve_strategy;
		policy : rdm_reserve_policy;
	}
	external default : ctx -> unit -> t = "stub_libxl_rdm_reserve_init"
end

(* libxl_altp2m_mode implementation *)
type altp2m_mode = 
	 | ALTP2M_MODE_DISABLED
	 | ALTP2M_MODE_MIXED
	 | ALTP2M_MODE_EXTERNAL
	 | ALTP2M_MODE_LIMITED

let string_of_altp2m_mode = function
	| ALTP2M_MODE_DISABLED -> "DISABLED"
	| ALTP2M_MODE_MIXED -> "MIXED"
	| ALTP2M_MODE_EXTERNAL -> "EXTERNAL"
	| ALTP2M_MODE_LIMITED -> "LIMITED"

(* libxl_domain_build_info implementation *)
module Domain_build_info = struct

	type type_hvm =
	{
			firmware : string option;
			bios : bios_type;
			pae : bool option;
			apic : bool option;
			acpi : bool option;
			acpi_s3 : bool option;
			acpi_s4 : bool option;
			acpi_laptop_slate : bool option;
			nx : bool option;
			viridian : bool option;
			viridian_enable : bool array;
			viridian_disable : bool array;
			timeoffset : string option;
			hpet : bool option;
			vpt_align : bool option;
			mmio_hole_memkb : int64;
			timer_mode : timer_mode;
			nested_hvm : bool option;
			altp2m : bool option;
			system_firmware : string option;
			smbios_firmware : string option;
			acpi_firmware : string option;
			hdtype : hdtype;
			nographic : bool option;
			vga : Vga_interface_info.t;
			vnc : Vnc_info.t;
			keymap : string option;
			sdl : Sdl_info.t;
			spice : Spice_info.t;
			gfx_passthru : bool option;
			gfx_passthru_kind : gfx_passthru_kind;
			serial : string option;
			boot : string option;
			usb : bool option;
			usbversion : int;
			usbdevice : string option;
			vkb_device : bool option;
			soundhw : string option;
			xen_platform_pci : bool option;
			usbdevice_list : string list;
			vendor_device : vendor_device;
			ms_vm_genid : int array;
			serial_list : string list;
			rdm : Rdm_reserve.t;
			rdm_mem_boundary_memkb : int64;
			mca_caps : int64;
	}
	
	type type_pv =
	{
			kernel : string option;
			slack_memkb : int64;
			bootloader : string option;
			bootloader_args : string list;
			cmdline : string option;
			ramdisk : string option;
			features : string option;
			e820_host : bool option;
	}
	
	type type_pvh =
	{
			pvshim : bool option;
			pvshim_path : string option;
			pvshim_cmdline : string option;
			pvshim_extra : string option;
	}
	
	type type__union = Hvm of type_hvm | Pv of type_pv | Pvh of type_pvh | Invalid
	
	type arch_arm__anon = {
		gic_version : gic_version;
		vuart : vuart_type;
	}
	
	type t =
	{
		max_vcpus : int;
		avail_vcpus : bool array;
		cpumap : bool array;
		nodemap : bool array;
		vcpu_hard_affinity : bool array array;
		vcpu_soft_affinity : bool array array;
		numa_placement : bool option;
		tsc_mode : tsc_mode;
		max_memkb : int64;
		target_memkb : int64;
		video_memkb : int64;
		shadow_memkb : int64;
		iommu_memkb : int64;
		rtc_timeoffset : int32;
		exec_ssidref : int32;
		exec_ssid_label : string option;
		localtime : bool option;
		disable_migrate : bool option;
		cpuid : unit;
		blkdev_start : string option;
		vnuma_nodes : Vnode_info.t array;
		max_grant_frames : int32;
		max_maptrack_frames : int32;
		device_model_version : device_model_version;
		device_model_stubdomain : bool option;
		device_model : string option;
		device_model_ssidref : int32;
		device_model_ssid_label : string option;
		device_model_user : string option;
		extra : string list;
		extra_pv : string list;
		extra_hvm : string list;
		sched_params : Domain_sched_params.t;
		ioports : Ioport_range.t array;
		irqs : int32 array;
		iomem : Iomem_range.t array;
		claim_mode : bool option;
		event_channels : int32;
		kernel : string option;
		cmdline : string option;
		ramdisk : string option;
		device_tree : string option;
		acpi : bool option;
		bootloader : string option;
		bootloader_args : string list;
		timer_mode : timer_mode;
		nested_hvm : bool option;
		apic : bool option;
		dm_restrict : bool option;
		tee : tee_type;
		xl_type : type__union;
		arch_arm : arch_arm__anon;
		altp2m : altp2m_mode;
	}
	external default : ctx -> ?xl_type:domain_type -> unit -> t = "stub_libxl_domain_build_info_init"
end

(* libxl_device_vfb implementation *)
module Device_vfb = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
		vnc : Vnc_info.t;
		sdl : Sdl_info.t;
		keymap : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_vfb_init"
	external add : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_vfb_add"
	external remove : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_vfb_remove"
	external destroy : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_vfb_destroy"
end

(* libxl_device_vkb implementation *)
module Device_vkb = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
		backend_type : vkb_backend;
		unique_id : string option;
		feature_disable_keyboard : bool;
		feature_disable_pointer : bool;
		feature_abs_pointer : bool;
		feature_raw_pointer : bool;
		feature_multi_touch : bool;
		width : int32;
		height : int32;
		multi_touch_width : int32;
		multi_touch_height : int32;
		multi_touch_num_contacts : int32;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_vkb_init"
	external add : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_vkb_add"
	external remove : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_vkb_remove"
	external destroy : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_vkb_destroy"
end

(* libxl_device_disk implementation *)
module Device_disk = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		pdev_path : string option;
		vdev : string option;
		backend : disk_backend;
		format : disk_format;
		script : string option;
		removable : int;
		readwrite : int;
		is_cdrom : int;
		direct_io_safe : bool;
		discard_enable : bool option;
		colo_enable : bool option;
		colo_restore_enable : bool option;
		colo_host : string option;
		colo_port : int;
		colo_export : string option;
		active_disk : string option;
		hidden_disk : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_disk_init"
	external add : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_disk_add"
	external remove : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_disk_remove"
	external destroy : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_disk_destroy"
	external list : ctx -> domid -> t list = "stub_xl_device_disk_list"
	external insert : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_disk_insert"
	external of_vdev : ctx -> domid -> string -> t = "stub_xl_device_disk_of_vdev"
end

(* libxl_device_nic implementation *)
module Device_nic = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
		mtu : int;
		model : string option;
		mac : int array;
		ip : string option;
		bridge : string option;
		ifname : string option;
		script : string option;
		nictype : nic_type;
		rate_bytes_per_interval : int64;
		rate_interval_usecs : int32;
		gatewaydev : string option;
		coloft_forwarddev : string option;
		colo_sock_mirror_id : string option;
		colo_sock_mirror_ip : string option;
		colo_sock_mirror_port : string option;
		colo_sock_compare_pri_in_id : string option;
		colo_sock_compare_pri_in_ip : string option;
		colo_sock_compare_pri_in_port : string option;
		colo_sock_compare_sec_in_id : string option;
		colo_sock_compare_sec_in_ip : string option;
		colo_sock_compare_sec_in_port : string option;
		colo_sock_compare_notify_id : string option;
		colo_sock_compare_notify_ip : string option;
		colo_sock_compare_notify_port : string option;
		colo_sock_redirector0_id : string option;
		colo_sock_redirector0_ip : string option;
		colo_sock_redirector0_port : string option;
		colo_sock_redirector1_id : string option;
		colo_sock_redirector1_ip : string option;
		colo_sock_redirector1_port : string option;
		colo_sock_redirector2_id : string option;
		colo_sock_redirector2_ip : string option;
		colo_sock_redirector2_port : string option;
		colo_filter_mirror_queue : string option;
		colo_filter_mirror_outdev : string option;
		colo_filter_redirector0_queue : string option;
		colo_filter_redirector0_indev : string option;
		colo_filter_redirector0_outdev : string option;
		colo_filter_redirector1_queue : string option;
		colo_filter_redirector1_indev : string option;
		colo_filter_redirector1_outdev : string option;
		colo_compare_pri_in : string option;
		colo_compare_sec_in : string option;
		colo_compare_out : string option;
		colo_compare_notify_dev : string option;
		colo_sock_sec_redirector0_id : string option;
		colo_sock_sec_redirector0_ip : string option;
		colo_sock_sec_redirector0_port : string option;
		colo_sock_sec_redirector1_id : string option;
		colo_sock_sec_redirector1_ip : string option;
		colo_sock_sec_redirector1_port : string option;
		colo_filter_sec_redirector0_queue : string option;
		colo_filter_sec_redirector0_indev : string option;
		colo_filter_sec_redirector0_outdev : string option;
		colo_filter_sec_redirector1_queue : string option;
		colo_filter_sec_redirector1_indev : string option;
		colo_filter_sec_redirector1_outdev : string option;
		colo_filter_sec_rewriter0_queue : string option;
		colo_checkpoint_host : string option;
		colo_checkpoint_port : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_nic_init"
	external add : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_nic_add"
	external remove : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_nic_remove"
	external destroy : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_nic_destroy"
	external list : ctx -> domid -> t list = "stub_xl_device_nic_list"
	external of_devid : ctx -> domid -> int -> t = "stub_xl_device_nic_of_devid"
end

(* libxl_device_pci implementation *)
module Device_pci = struct
	type t =
	{
		func : int;
		dev : int;
		bus : int;
		domain : int;
		vdevfn : int32;
		vfunc_mask : int32;
		msitranslate : bool;
		power_mgmt : bool;
		permissive : bool;
		seize : bool;
		rdm_policy : rdm_reserve_policy;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_pci_init"
	external add : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_pci_add"
	external remove : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_pci_remove"
	external destroy : ctx -> t -> domid -> ?async:'a -> unit -> unit = "stub_xl_device_pci_destroy"
	external list : ctx -> domid -> t list = "stub_xl_device_pci_list"
	external assignable_add : ctx -> t -> bool -> unit = "stub_xl_device_pci_assignable_add"
	external assignable_remove : ctx -> t -> bool -> unit = "stub_xl_device_pci_assignable_remove"
	external assignable_list : ctx -> t list = "stub_xl_device_pci_assignable_list"
end

(* libxl_device_rdm implementation *)
module Device_rdm = struct
	type t =
	{
		start : int64;
		size : int64;
		policy : rdm_reserve_policy;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_rdm_init"
end

(* libxl_usbctrl_type implementation *)
type usbctrl_type = 
	 | USBCTRL_TYPE_AUTO
	 | USBCTRL_TYPE_PV
	 | USBCTRL_TYPE_DEVICEMODEL
	 | USBCTRL_TYPE_QUSB

let string_of_usbctrl_type = function
	| USBCTRL_TYPE_AUTO -> "AUTO"
	| USBCTRL_TYPE_PV -> "PV"
	| USBCTRL_TYPE_DEVICEMODEL -> "DEVICEMODEL"
	| USBCTRL_TYPE_QUSB -> "QUSB"

(* libxl_usbdev_type implementation *)
type usbdev_type = 
	 | USBDEV_TYPE_HOSTDEV

let string_of_usbdev_type = function
	| USBDEV_TYPE_HOSTDEV -> "HOSTDEV"

(* libxl_device_usbctrl implementation *)
module Device_usbctrl = struct
	type t =
	{
		xl_type : usbctrl_type;
		devid : devid;
		version : int;
		ports : int;
		backend_domid : domid;
		backend_domname : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_usbctrl_init"
end

(* libxl_device_usbdev implementation *)
module Device_usbdev = struct

	type type_hostdev =
	{
			hostbus : int;
			hostaddr : int;
	}
	
	type type__union = Hostdev of type_hostdev
	
	type t =
	{
		ctrl : devid;
		port : int;
		xl_type : type__union;
	}
	external default : ctx -> ?xl_type:usbdev_type -> unit -> t = "stub_libxl_device_usbdev_init"
end

(* libxl_device_dtdev implementation *)
module Device_dtdev = struct
	type t =
	{
		path : string option;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_dtdev_init"
end

(* libxl_device_vtpm implementation *)
module Device_vtpm = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
		uuid : int array;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_vtpm_init"
end

(* libxl_device_p9 implementation *)
module Device_p9 = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		tag : string option;
		path : string option;
		security_model : string option;
		devid : devid;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_p9_init"
end

(* libxl_device_pvcallsif implementation *)
module Device_pvcallsif = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_pvcallsif_init"
end

(* libxl_device_channel implementation *)
module Device_channel = struct

	type connection_socket =
	{
			path : string option;
	}
	
	type connection__union = Unknown | Pty | Socket of connection_socket
	
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
		name : string option;
		connection : connection__union;
	}
	external default : ctx -> ?connection:channel_connection -> unit -> t = "stub_libxl_device_channel_init"
end

(* libxl_connector_param implementation *)
module Connector_param = struct
	type t =
	{
		unique_id : string option;
		width : int32;
		height : int32;
	}
	external default : ctx -> unit -> t = "stub_libxl_connector_param_init"
end

(* libxl_device_vdispl implementation *)
module Device_vdispl = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
		be_alloc : bool;
		connectors : Connector_param.t array;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_vdispl_init"
end

(* libxl_vsnd_pcm_format implementation *)
type vsnd_pcm_format = 
	 | VSND_PCM_FORMAT_S8
	 | VSND_PCM_FORMAT_U8
	 | VSND_PCM_FORMAT_S16_LE
	 | VSND_PCM_FORMAT_S16_BE
	 | VSND_PCM_FORMAT_U16_LE
	 | VSND_PCM_FORMAT_U16_BE
	 | VSND_PCM_FORMAT_S24_LE
	 | VSND_PCM_FORMAT_S24_BE
	 | VSND_PCM_FORMAT_U24_LE
	 | VSND_PCM_FORMAT_U24_BE
	 | VSND_PCM_FORMAT_S32_LE
	 | VSND_PCM_FORMAT_S32_BE
	 | VSND_PCM_FORMAT_U32_LE
	 | VSND_PCM_FORMAT_U32_BE
	 | VSND_PCM_FORMAT_F32_LE
	 | VSND_PCM_FORMAT_F32_BE
	 | VSND_PCM_FORMAT_F64_LE
	 | VSND_PCM_FORMAT_F64_BE
	 | VSND_PCM_FORMAT_IEC958_SUBFRAME_LE
	 | VSND_PCM_FORMAT_IEC958_SUBFRAME_BE
	 | VSND_PCM_FORMAT_MU_LAW
	 | VSND_PCM_FORMAT_A_LAW
	 | VSND_PCM_FORMAT_IMA_ADPCM
	 | VSND_PCM_FORMAT_MPEG
	 | VSND_PCM_FORMAT_GSM

let string_of_vsnd_pcm_format = function
	| VSND_PCM_FORMAT_S8 -> "S8"
	| VSND_PCM_FORMAT_U8 -> "U8"
	| VSND_PCM_FORMAT_S16_LE -> "S16_LE"
	| VSND_PCM_FORMAT_S16_BE -> "S16_BE"
	| VSND_PCM_FORMAT_U16_LE -> "U16_LE"
	| VSND_PCM_FORMAT_U16_BE -> "U16_BE"
	| VSND_PCM_FORMAT_S24_LE -> "S24_LE"
	| VSND_PCM_FORMAT_S24_BE -> "S24_BE"
	| VSND_PCM_FORMAT_U24_LE -> "U24_LE"
	| VSND_PCM_FORMAT_U24_BE -> "U24_BE"
	| VSND_PCM_FORMAT_S32_LE -> "S32_LE"
	| VSND_PCM_FORMAT_S32_BE -> "S32_BE"
	| VSND_PCM_FORMAT_U32_LE -> "U32_LE"
	| VSND_PCM_FORMAT_U32_BE -> "U32_BE"
	| VSND_PCM_FORMAT_F32_LE -> "F32_LE"
	| VSND_PCM_FORMAT_F32_BE -> "F32_BE"
	| VSND_PCM_FORMAT_F64_LE -> "F64_LE"
	| VSND_PCM_FORMAT_F64_BE -> "F64_BE"
	| VSND_PCM_FORMAT_IEC958_SUBFRAME_LE -> "IEC958_SUBFRAME_LE"
	| VSND_PCM_FORMAT_IEC958_SUBFRAME_BE -> "IEC958_SUBFRAME_BE"
	| VSND_PCM_FORMAT_MU_LAW -> "MU_LAW"
	| VSND_PCM_FORMAT_A_LAW -> "A_LAW"
	| VSND_PCM_FORMAT_IMA_ADPCM -> "IMA_ADPCM"
	| VSND_PCM_FORMAT_MPEG -> "MPEG"
	| VSND_PCM_FORMAT_GSM -> "GSM"

(* libxl_vsnd_params implementation *)
module Vsnd_params = struct
	type t =
	{
		sample_rates : int32 array;
		sample_formats : vsnd_pcm_format array;
		channels_min : int32;
		channels_max : int32;
		buffer_size : int32;
	}
	external default : ctx -> unit -> t = "stub_libxl_vsnd_params_init"
end

(* libxl_vsnd_stream_type implementation *)
type vsnd_stream_type = 
	 | VSND_STREAM_TYPE_P
	 | VSND_STREAM_TYPE_C

let string_of_vsnd_stream_type = function
	| VSND_STREAM_TYPE_P -> "P"
	| VSND_STREAM_TYPE_C -> "C"

(* libxl_vsnd_stream implementation *)
module Vsnd_stream = struct
	type t =
	{
		unique_id : string option;
		xl_type : vsnd_stream_type;
		params : Vsnd_params.t;
	}
	external default : ctx -> unit -> t = "stub_libxl_vsnd_stream_init"
end

(* libxl_vsnd_pcm implementation *)
module Vsnd_pcm = struct
	type t =
	{
		name : string option;
		params : Vsnd_params.t;
		streams : Vsnd_stream.t array;
	}
	external default : ctx -> unit -> t = "stub_libxl_vsnd_pcm_init"
end

(* libxl_device_vsnd implementation *)
module Device_vsnd = struct
	type t =
	{
		backend_domid : domid;
		backend_domname : string option;
		devid : devid;
		short_name : string option;
		long_name : string option;
		params : Vsnd_params.t;
		pcms : Vsnd_pcm.t array;
	}
	external default : ctx -> unit -> t = "stub_libxl_device_vsnd_init"
end

(* libxl_domain_config implementation *)
module Domain_config = struct
	type t =
	{
		c_info : Domain_create_info.t;
		b_info : Domain_build_info.t;
		disks : Device_disk.t array;
		nics : Device_nic.t array;
		pcidevs : Device_pci.t array;
		rdms : Device_rdm.t array;
		dtdevs : Device_dtdev.t array;
		vfbs : Device_vfb.t array;
		vkbs : Device_vkb.t array;
		vtpms : Device_vtpm.t array;
		p9s : Device_p9.t array;
		pvcallsifs : Device_pvcallsif.t array;
		vdispls : Device_vdispl.t array;
		vsnds : Device_vsnd.t array;
		channels : Device_channel.t array;
		usbctrls : Device_usbctrl.t array;
		usbdevs : Device_usbdev.t array;
		on_poweroff : action_on_shutdown;
		on_reboot : action_on_shutdown;
		on_watchdog : action_on_shutdown;
		on_crash : action_on_shutdown;
		on_soft_reset : action_on_shutdown;
	}
	external default : ctx -> unit -> t = "stub_libxl_domain_config_init"
end

(* libxl_diskinfo implementation *)
module Diskinfo = struct
	type t =
	{
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		devid : devid;
		state : int;
		evtch : int;
		rref : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_diskinfo_init"
end

(* libxl_nicinfo implementation *)
module Nicinfo = struct
	type t =
	{
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		devid : devid;
		state : int;
		evtch : int;
		rref_tx : int;
		rref_rx : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_nicinfo_init"
end

(* libxl_vtpminfo implementation *)
module Vtpminfo = struct
	type t =
	{
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		devid : devid;
		state : int;
		evtch : int;
		rref : int;
		uuid : int array;
	}
	external default : ctx -> unit -> t = "stub_libxl_vtpminfo_init"
end

(* libxl_usbctrlinfo implementation *)
module Usbctrlinfo = struct
	type t =
	{
		xl_type : usbctrl_type;
		devid : devid;
		version : int;
		ports : int;
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		state : int;
		evtch : int;
		ref_urb : int;
		ref_conn : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_usbctrlinfo_init"
end

(* libxl_physinfo implementation *)
module Physinfo = struct
	type t =
	{
		threads_per_core : int32;
		cores_per_socket : int32;
		max_cpu_id : int32;
		nr_cpus : int32;
		cpu_khz : int32;
		total_pages : int64;
		free_pages : int64;
		scrub_pages : int64;
		outstanding_pages : int64;
		sharing_freed_pages : int64;
		sharing_used_frames : int64;
		max_possible_mfn : int64;
		nr_nodes : int32;
		hw_cap : int32 array;
		cap_hvm : bool;
		cap_pv : bool;
		cap_hvm_directio : bool;
		cap_hap : bool;
		cap_shadow : bool;
		cap_iommu_hap_pt_share : bool;
	}
	external default : ctx -> unit -> t = "stub_libxl_physinfo_init"
	external get : ctx -> t = "stub_xl_physinfo_get"
end

(* libxl_connectorinfo implementation *)
module Connectorinfo = struct
	type t =
	{
		unique_id : string option;
		width : int32;
		height : int32;
		req_evtch : int;
		req_rref : int;
		evt_evtch : int;
		evt_rref : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_connectorinfo_init"
end

(* libxl_vdisplinfo implementation *)
module Vdisplinfo = struct
	type t =
	{
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		devid : devid;
		state : int;
		be_alloc : bool;
		connectors : Connectorinfo.t array;
	}
	external default : ctx -> unit -> t = "stub_libxl_vdisplinfo_init"
end

(* libxl_streaminfo implementation *)
module Streaminfo = struct
	type t =
	{
		req_evtch : int;
		req_rref : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_streaminfo_init"
end

(* libxl_pcminfo implementation *)
module Pcminfo = struct
	type t =
	{
		streams : Streaminfo.t array;
	}
	external default : ctx -> unit -> t = "stub_libxl_pcminfo_init"
end

(* libxl_vsndinfo implementation *)
module Vsndinfo = struct
	type t =
	{
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		devid : devid;
		state : int;
		pcms : Pcminfo.t array;
	}
	external default : ctx -> unit -> t = "stub_libxl_vsndinfo_init"
end

(* libxl_vkbinfo implementation *)
module Vkbinfo = struct
	type t =
	{
		backend : string option;
		backend_id : int32;
		frontend : string option;
		frontend_id : int32;
		devid : devid;
		state : int;
		evtch : int;
		rref : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_vkbinfo_init"
end

(* libxl_numainfo implementation *)
module Numainfo = struct
	type t =
	{
		size : int64;
		free : int64;
		dists : int32 array;
	}
	external default : ctx -> unit -> t = "stub_libxl_numainfo_init"
end

(* libxl_cputopology implementation *)
module Cputopology = struct
	type t =
	{
		core : int32;
		socket : int32;
		node : int32;
	}
	external default : ctx -> unit -> t = "stub_libxl_cputopology_init"
	external get : ctx -> t array = "stub_xl_cputopology_get"
end

(* libxl_pcitopology implementation *)
module Pcitopology = struct
	type t =
	{
		seg : int;
		bus : int;
		devfn : int;
		node : int32;
	}
	external default : ctx -> unit -> t = "stub_libxl_pcitopology_init"
end

(* libxl_sched_credit_params implementation *)
module Sched_credit_params = struct
	type t =
	{
		tslice_ms : int;
		ratelimit_us : int;
		vcpu_migr_delay_us : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_sched_credit_params_init"
end

(* libxl_sched_credit2_params implementation *)
module Sched_credit2_params = struct
	type t =
	{
		ratelimit_us : int;
	}
	external default : ctx -> unit -> t = "stub_libxl_sched_credit2_params_init"
end

(* libxl_domain_remus_info implementation *)
module Domain_remus_info = struct
	type t =
	{
		interval : int;
		allow_unsafe : bool option;
		blackhole : bool option;
		compression : bool option;
		netbuf : bool option;
		netbufscript : string option;
		diskbuf : bool option;
		colo : bool option;
		userspace_colo_proxy : bool option;
	}
	external default : ctx -> unit -> t = "stub_libxl_domain_remus_info_init"
end

(* libxl_event_type implementation *)
type event_type = 
	 | EVENT_TYPE_DOMAIN_SHUTDOWN
	 | EVENT_TYPE_DOMAIN_DEATH
	 | EVENT_TYPE_DISK_EJECT
	 | EVENT_TYPE_OPERATION_COMPLETE
	 | EVENT_TYPE_DOMAIN_CREATE_CONSOLE_AVAILABLE

let string_of_event_type = function
	| EVENT_TYPE_DOMAIN_SHUTDOWN -> "DOMAIN_SHUTDOWN"
	| EVENT_TYPE_DOMAIN_DEATH -> "DOMAIN_DEATH"
	| EVENT_TYPE_DISK_EJECT -> "DISK_EJECT"
	| EVENT_TYPE_OPERATION_COMPLETE -> "OPERATION_COMPLETE"
	| EVENT_TYPE_DOMAIN_CREATE_CONSOLE_AVAILABLE -> "DOMAIN_CREATE_CONSOLE_AVAILABLE"

(* libxl_event implementation *)
module Event = struct

	type type_domain_shutdown =
	{
			shutdown_reason : int;
	}
	
	type type_disk_eject =
	{
			vdev : string option;
			disk : Device_disk.t;
	}
	
	type type_operation_complete =
	{
			rc : int;
	}
	
	type type__union = Domain_shutdown of type_domain_shutdown | Domain_death | Disk_eject of type_disk_eject | Operation_complete of type_operation_complete | Domain_create_console_available
	
	type t =
	{
		domid : domid;
		domuuid : int array;
		for_user : int64;
		xl_type : type__union;
	}
	external default : ctx -> ?xl_type:event_type -> unit -> t = "stub_libxl_event_init"
end

(* libxl_psr_cmt_type implementation *)
type psr_cmt_type = 
	 | PSR_CMT_TYPE_CACHE_OCCUPANCY
	 | PSR_CMT_TYPE_TOTAL_MEM_COUNT
	 | PSR_CMT_TYPE_LOCAL_MEM_COUNT

let string_of_psr_cmt_type = function
	| PSR_CMT_TYPE_CACHE_OCCUPANCY -> "CACHE_OCCUPANCY"
	| PSR_CMT_TYPE_TOTAL_MEM_COUNT -> "TOTAL_MEM_COUNT"
	| PSR_CMT_TYPE_LOCAL_MEM_COUNT -> "LOCAL_MEM_COUNT"

(* libxl_psr_cbm_type implementation *)
type psr_cbm_type = 
	 | PSR_CBM_TYPE_UNKNOWN
	 | PSR_CBM_TYPE_L3_CBM
	 | PSR_CBM_TYPE_L3_CBM_CODE
	 | PSR_CBM_TYPE_L3_CBM_DATA
	 | PSR_CBM_TYPE_L2_CBM
	 | PSR_CBM_TYPE_MBA_THRTL

let string_of_psr_cbm_type = function
	| PSR_CBM_TYPE_UNKNOWN -> "UNKNOWN"
	| PSR_CBM_TYPE_L3_CBM -> "L3_CBM"
	| PSR_CBM_TYPE_L3_CBM_CODE -> "L3_CBM_CODE"
	| PSR_CBM_TYPE_L3_CBM_DATA -> "L3_CBM_DATA"
	| PSR_CBM_TYPE_L2_CBM -> "L2_CBM"
	| PSR_CBM_TYPE_MBA_THRTL -> "MBA_THRTL"

(* libxl_psr_cat_info implementation *)
module Psr_cat_info = struct
	type t =
	{
		id : int32;
		cos_max : int32;
		cbm_len : int32;
		cdp_enabled : bool;
	}
	external default : ctx -> unit -> t = "stub_libxl_psr_cat_info_init"
end

(* libxl_psr_feat_type implementation *)
type psr_feat_type = 
	 | PSR_FEAT_TYPE_CAT
	 | PSR_FEAT_TYPE_MBA

let string_of_psr_feat_type = function
	| PSR_FEAT_TYPE_CAT -> "CAT"
	| PSR_FEAT_TYPE_MBA -> "MBA"

(* libxl_psr_hw_info implementation *)
module Psr_hw_info = struct

	type type_cat =
	{
			cos_max : int32;
			cbm_len : int32;
			cdp_enabled : bool;
	}
	
	type type_mba =
	{
			cos_max : int32;
			thrtl_max : int32;
			linear : bool;
	}
	
	type type__union = Cat of type_cat | Mba of type_mba
	
	type t =
	{
		id : int32;
		xl_type : type__union;
	}
	external default : ctx -> ?xl_type:psr_feat_type -> unit -> t = "stub_libxl_psr_hw_info_init"
end

(* END OF AUTO-GENERATED CODE *)

exception Error of (error * string)

external ctx_alloc: Xentoollog.handle -> ctx = "stub_libxl_ctx_alloc"

external test_raise_exception: unit -> unit = "stub_raise_exception"

type event =
	| POLLIN (* There is data to read *)
	| POLLPRI (* There is urgent data to read *)
	| POLLOUT (* Writing now will not block *)
	| POLLERR (* Error condition (revents only) *)
	| POLLHUP (* Device has been disconnected (revents only) *)
	| POLLNVAL (* Invalid request: fd not open (revents only). *)

module Domain = struct
	external create_new : ctx -> Domain_config.t -> ?async:'a -> unit -> domid = "stub_libxl_domain_create_new"
	external create_restore : ctx -> Domain_config.t -> (Unix.file_descr * Domain_restore_params.t) ->
		?async:'a -> unit -> domid = "stub_libxl_domain_create_restore"
	external shutdown : ctx -> domid -> ?async:'a -> unit -> unit = "stub_libxl_domain_shutdown"
	external reboot : ctx -> domid -> ?async:'a -> unit -> unit = "stub_libxl_domain_reboot"
	external destroy : ctx -> domid -> ?async:'a -> unit -> unit = "stub_libxl_domain_destroy"
	external suspend : ctx -> domid -> Unix.file_descr -> ?async:'a -> unit -> unit = "stub_libxl_domain_suspend"
	external pause : ctx -> domid -> ?async:'a -> unit = "stub_libxl_domain_pause"
	external unpause : ctx -> domid -> ?async:'a -> unit = "stub_libxl_domain_unpause"

	external send_trigger : ctx -> domid -> trigger -> int -> ?async:'a -> unit = "stub_xl_send_trigger"
	external send_sysrq : ctx -> domid -> char -> unit = "stub_xl_send_sysrq"
end

module Host = struct
	type console_reader
	exception End_of_file

	external xen_console_read_start : ctx -> int -> console_reader  = "stub_libxl_xen_console_read_start"
	external xen_console_read_line : ctx -> console_reader -> string = "stub_libxl_xen_console_read_line"
	external xen_console_read_finish : ctx -> console_reader -> unit = "stub_libxl_xen_console_read_finish"

	external send_debug_keys : ctx -> string -> unit = "stub_xl_send_debug_keys"
end

module Async = struct
	type for_libxl
	type event_hooks
	type osevent_hooks

	external osevent_register_hooks' : ctx -> 'a -> osevent_hooks = "stub_libxl_osevent_register_hooks"
	external osevent_occurred_fd : ctx -> for_libxl -> Unix.file_descr -> event list -> event list -> unit = "stub_libxl_osevent_occurred_fd"
	external osevent_occurred_timeout : ctx -> for_libxl -> unit = "stub_libxl_osevent_occurred_timeout"

	let osevent_register_hooks ctx ~user ~fd_register ~fd_modify ~fd_deregister ~timeout_register ~timeout_fire_now =
		Callback.register "libxl_fd_register" fd_register;
		Callback.register "libxl_fd_modify" fd_modify;
		Callback.register "libxl_fd_deregister" fd_deregister;
		Callback.register "libxl_timeout_register" timeout_register;
		Callback.register "libxl_timeout_fire_now" timeout_fire_now;
		osevent_register_hooks' ctx user

	let async_register_callback ~async_callback =
		Callback.register "libxl_async_callback" async_callback

	external evenable_domain_death : ctx -> domid -> int -> unit = "stub_libxl_evenable_domain_death"
	external event_register_callbacks' : ctx -> 'a -> event_hooks = "stub_libxl_event_register_callbacks"

	let event_register_callbacks ctx ~user ~event_occurs_callback ~event_disaster_callback =
		Callback.register "libxl_event_occurs_callback" event_occurs_callback;
		Callback.register "libxl_event_disaster_callback" event_disaster_callback;
		event_register_callbacks' ctx user
end

let register_exceptions () =
	Callback.register_exception "Xenlight.Error" (Error(ERROR_FAIL, ""));
	Callback.register_exception "Xenlight.Host.End_of_file" (Host.End_of_file)

